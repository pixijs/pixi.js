/**
 * @license
 * pixi.js - v3.0.9
 * Compiled 2016-01-27T08:11:01.452Z
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license.php
 *
 *
 * The MIT License
 * 
 * Copyright (c) 2013-2015 Mathew Groves
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 * 
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.PIXI = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
(function () {

    var async = {};
    function noop() {}
    function identity(v) {
        return v;
    }
    function toBool(v) {
        return !!v;
    }
    function notId(v) {
        return !v;
    }

    // global on the server, window in the browser
    var previous_async;

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.
    var root = typeof self === 'object' && self.self === self && self ||
            typeof global === 'object' && global.global === global && global ||
            this;

    if (root != null) {
        previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        return function() {
            if (fn === null) throw new Error("Callback was already called.");
            fn.apply(this, arguments);
            fn = null;
        };
    }

    function _once(fn) {
        return function() {
            if (fn === null) return;
            fn.apply(this, arguments);
            fn = null;
        };
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    // Ported from underscore.js isObject
    var _isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
    };

    function _isArrayLike(arr) {
        return _isArray(arr) || (
            // has a positive integer length property
            typeof arr.length === "number" &&
            arr.length >= 0 &&
            arr.length % 1 === 0
        );
    }

    function _arrayEach(arr, iterator) {
        var index = -1,
            length = arr.length;

        while (++index < length) {
            iterator(arr[index], index, arr);
        }
    }

    function _map(arr, iterator) {
        var index = -1,
            length = arr.length,
            result = Array(length);

        while (++index < length) {
            result[index] = iterator(arr[index], index, arr);
        }
        return result;
    }

    function _range(count) {
        return _map(Array(count), function (v, i) { return i; });
    }

    function _reduce(arr, iterator, memo) {
        _arrayEach(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    }

    function _forEachOf(object, iterator) {
        _arrayEach(_keys(object), function (key) {
            iterator(object[key], key);
        });
    }

    function _indexOf(arr, item) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === item) return i;
        }
        return -1;
    }

    var _keys = Object.keys || function (obj) {
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    function _keyIterator(coll) {
        var i = -1;
        var len;
        var keys;
        if (_isArrayLike(coll)) {
            len = coll.length;
            return function next() {
                i++;
                return i < len ? i : null;
            };
        } else {
            keys = _keys(coll);
            len = keys.length;
            return function next() {
                i++;
                return i < len ? keys[i] : null;
            };
        }
    }

    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
    // This accumulates the arguments passed into an array, after a given index.
    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
    function _restParam(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
            var length = Math.max(arguments.length - startIndex, 0);
            var rest = Array(length);
            for (var index = 0; index < length; index++) {
                rest[index] = arguments[index + startIndex];
            }
            switch (startIndex) {
                case 0: return func.call(this, rest);
                case 1: return func.call(this, arguments[0], rest);
            }
            // Currently unused but handle cases outside of the switch statement:
            // var args = Array(startIndex + 1);
            // for (index = 0; index < startIndex; index++) {
            //     args[index] = arguments[index];
            // }
            // args[startIndex] = rest;
            // return func.apply(this, args);
        };
    }

    function _withoutIndex(iterator) {
        return function (value, index, callback) {
            return iterator(value, callback);
        };
    }

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////

    // capture the global reference to guard against fakeTimer mocks
    var _setImmediate = typeof setImmediate === 'function' && setImmediate;

    var _delay = _setImmediate ? function(fn) {
        // not a direct alias for IE10 compatibility
        _setImmediate(fn);
    } : function(fn) {
        setTimeout(fn, 0);
    };

    if (typeof process === 'object' && typeof process.nextTick === 'function') {
        async.nextTick = process.nextTick;
    } else {
        async.nextTick = _delay;
    }
    async.setImmediate = _setImmediate ? _delay : async.nextTick;


    async.forEach =
    async.each = function (arr, iterator, callback) {
        return async.eachOf(arr, _withoutIndex(iterator), callback);
    };

    async.forEachSeries =
    async.eachSeries = function (arr, iterator, callback) {
        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
    };


    async.forEachLimit =
    async.eachLimit = function (arr, limit, iterator, callback) {
        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
    };

    async.forEachOf =
    async.eachOf = function (object, iterator, callback) {
        callback = _once(callback || noop);
        object = object || [];

        var iter = _keyIterator(object);
        var key, completed = 0;

        while ((key = iter()) != null) {
            completed += 1;
            iterator(object[key], key, only_once(done));
        }

        if (completed === 0) callback(null);

        function done(err) {
            completed--;
            if (err) {
                callback(err);
            }
            // Check key is null in case iterator isn't exhausted
            // and done resolved synchronously.
            else if (key === null && completed <= 0) {
                callback(null);
            }
        }
    };

    async.forEachOfSeries =
    async.eachOfSeries = function (obj, iterator, callback) {
        callback = _once(callback || noop);
        obj = obj || [];
        var nextKey = _keyIterator(obj);
        var key = nextKey();
        function iterate() {
            var sync = true;
            if (key === null) {
                return callback(null);
            }
            iterator(obj[key], key, only_once(function (err) {
                if (err) {
                    callback(err);
                }
                else {
                    key = nextKey();
                    if (key === null) {
                        return callback(null);
                    } else {
                        if (sync) {
                            async.setImmediate(iterate);
                        } else {
                            iterate();
                        }
                    }
                }
            }));
            sync = false;
        }
        iterate();
    };



    async.forEachOfLimit =
    async.eachOfLimit = function (obj, limit, iterator, callback) {
        _eachOfLimit(limit)(obj, iterator, callback);
    };

    function _eachOfLimit(limit) {

        return function (obj, iterator, callback) {
            callback = _once(callback || noop);
            obj = obj || [];
            var nextKey = _keyIterator(obj);
            if (limit <= 0) {
                return callback(null);
            }
            var done = false;
            var running = 0;
            var errored = false;

            (function replenish () {
                if (done && running <= 0) {
                    return callback(null);
                }

                while (running < limit && !errored) {
                    var key = nextKey();
                    if (key === null) {
                        done = true;
                        if (running <= 0) {
                            callback(null);
                        }
                        return;
                    }
                    running += 1;
                    iterator(obj[key], key, only_once(function (err) {
                        running -= 1;
                        if (err) {
                            callback(err);
                            errored = true;
                        }
                        else {
                            replenish();
                        }
                    }));
                }
            })();
        };
    }


    function doParallel(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOf, obj, iterator, callback);
        };
    }
    function doParallelLimit(fn) {
        return function (obj, limit, iterator, callback) {
            return fn(_eachOfLimit(limit), obj, iterator, callback);
        };
    }
    function doSeries(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOfSeries, obj, iterator, callback);
        };
    }

    function _asyncMap(eachfn, arr, iterator, callback) {
        callback = _once(callback || noop);
        arr = arr || [];
        var results = _isArrayLike(arr) ? [] : {};
        eachfn(arr, function (value, index, callback) {
            iterator(value, function (err, v) {
                results[index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    }

    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = doParallelLimit(_asyncMap);

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.inject =
    async.foldl =
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachOfSeries(arr, function (x, i, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };

    async.foldr =
    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, identity).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };

    async.transform = function (arr, memo, iterator, callback) {
        if (arguments.length === 3) {
            callback = iterator;
            iterator = memo;
            memo = _isArray(arr) ? [] : {};
        }

        async.eachOf(arr, function(v, k, cb) {
            iterator(memo, v, k, cb);
        }, function(err) {
            callback(err, memo);
        });
    };

    function _filter(eachfn, arr, iterator, callback) {
        var results = [];
        eachfn(arr, function (x, index, callback) {
            iterator(x, function (v) {
                if (v) {
                    results.push({index: index, value: x});
                }
                callback();
            });
        }, function () {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    }

    async.select =
    async.filter = doParallel(_filter);

    async.selectLimit =
    async.filterLimit = doParallelLimit(_filter);

    async.selectSeries =
    async.filterSeries = doSeries(_filter);

    function _reject(eachfn, arr, iterator, callback) {
        _filter(eachfn, arr, function(value, cb) {
            iterator(value, function(v) {
                cb(!v);
            });
        }, callback);
    }
    async.reject = doParallel(_reject);
    async.rejectLimit = doParallelLimit(_reject);
    async.rejectSeries = doSeries(_reject);

    function _createTester(eachfn, check, getResult) {
        return function(arr, limit, iterator, cb) {
            function done() {
                if (cb) cb(getResult(false, void 0));
            }
            function iteratee(x, _, callback) {
                if (!cb) return callback();
                iterator(x, function (v) {
                    if (cb && check(v)) {
                        cb(getResult(true, x));
                        cb = iterator = false;
                    }
                    callback();
                });
            }
            if (arguments.length > 3) {
                eachfn(arr, limit, iteratee, done);
            } else {
                cb = iterator;
                iterator = limit;
                eachfn(arr, iteratee, done);
            }
        };
    }

    async.any =
    async.some = _createTester(async.eachOf, toBool, identity);

    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);

    async.all =
    async.every = _createTester(async.eachOf, notId, notId);

    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);

    function _findGetResult(v, x) {
        return x;
    }
    async.detect = _createTester(async.eachOf, identity, _findGetResult);
    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                callback(null, _map(results.sort(comparator), function (x) {
                    return x.value;
                }));
            }

        });

        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
    };

    async.auto = function (tasks, concurrency, callback) {
        if (typeof arguments[1] === 'function') {
            // concurrency is optional, shift the args.
            callback = concurrency;
            concurrency = null;
        }
        callback = _once(callback || noop);
        var keys = _keys(tasks);
        var remainingTasks = keys.length;
        if (!remainingTasks) {
            return callback(null);
        }
        if (!concurrency) {
            concurrency = remainingTasks;
        }

        var results = {};
        var runningTasks = 0;

        var hasError = false;

        var listeners = [];
        function addListener(fn) {
            listeners.unshift(fn);
        }
        function removeListener(fn) {
            var idx = _indexOf(listeners, fn);
            if (idx >= 0) listeners.splice(idx, 1);
        }
        function taskComplete() {
            remainingTasks--;
            _arrayEach(listeners.slice(0), function (fn) {
                fn();
            });
        }

        addListener(function () {
            if (!remainingTasks) {
                callback(null, results);
            }
        });

        _arrayEach(keys, function (k) {
            if (hasError) return;
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = _restParam(function(err, args) {
                runningTasks--;
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _forEachOf(results, function(val, rkey) {
                        safeResults[rkey] = val;
                    });
                    safeResults[k] = args;
                    hasError = true;

                    callback(err, safeResults);
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            });
            var requires = task.slice(0, task.length - 1);
            // prevent dead-locks
            var len = requires.length;
            var dep;
            while (len--) {
                if (!(dep = tasks[requires[len]])) {
                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));
                }
                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
                    throw new Error('Has cyclic dependencies');
                }
            }
            function ready() {
                return runningTasks < concurrency && _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            }
            if (ready()) {
                runningTasks++;
                task[task.length - 1](taskCallback, results);
            }
            else {
                addListener(listener);
            }
            function listener() {
                if (ready()) {
                    runningTasks++;
                    removeListener(listener);
                    task[task.length - 1](taskCallback, results);
                }
            }
        });
    };



    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var DEFAULT_INTERVAL = 0;

        var attempts = [];

        var opts = {
            times: DEFAULT_TIMES,
            interval: DEFAULT_INTERVAL
        };

        function parseTimes(acc, t){
            if(typeof t === 'number'){
                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
            } else if(typeof t === 'object'){
                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
            } else {
                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
            }
        }

        var length = arguments.length;
        if (length < 1 || length > 3) {
            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
        } else if (length <= 2 && typeof times === 'function') {
            callback = task;
            task = times;
        }
        if (typeof times !== 'function') {
            parseTimes(opts, times);
        }
        opts.callback = callback;
        opts.task = task;

        function wrappedTask(wrappedCallback, wrappedResults) {
            function retryAttempt(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            }

            function retryInterval(interval){
                return function(seriesCallback){
                    setTimeout(function(){
                        seriesCallback(null);
                    }, interval);
                };
            }

            while (opts.times) {

                var finalAttempt = !(opts.times-=1);
                attempts.push(retryAttempt(opts.task, finalAttempt));
                if(!finalAttempt && opts.interval > 0){
                    attempts.push(retryInterval(opts.interval));
                }
            }

            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || opts.callback)(data.err, data.result);
            });
        }

        // If a callback is passed, run this as a controll flow
        return opts.callback ? wrappedTask() : wrappedTask;
    };

    async.waterfall = function (tasks, callback) {
        callback = _once(callback || noop);
        if (!_isArray(tasks)) {
            var err = new Error('First argument to waterfall must be an array of functions');
            return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        function wrapIterator(iterator) {
            return _restParam(function (err, args) {
                if (err) {
                    callback.apply(null, [err].concat(args));
                }
                else {
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    ensureAsync(iterator).apply(null, args);
                }
            });
        }
        wrapIterator(async.iterator(tasks))();
    };

    function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = _isArrayLike(tasks) ? [] : {};

        eachfn(tasks, function (task, key, callback) {
            task(_restParam(function (err, args) {
                if (args.length <= 1) {
                    args = args[0];
                }
                results[key] = args;
                callback(err);
            }));
        }, function (err) {
            callback(err, results);
        });
    }

    async.parallel = function (tasks, callback) {
        _parallel(async.eachOf, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
    };

    async.series = function(tasks, callback) {
        _parallel(async.eachOfSeries, tasks, callback);
    };

    async.iterator = function (tasks) {
        function makeCallback(index) {
            function fn() {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            }
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        }
        return makeCallback(0);
    };

    async.apply = _restParam(function (fn, args) {
        return _restParam(function (callArgs) {
            return fn.apply(
                null, args.concat(callArgs)
            );
        });
    });

    function _concat(eachfn, arr, fn, callback) {
        var result = [];
        eachfn(arr, function (x, index, cb) {
            fn(x, function (err, y) {
                result = result.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, result);
        });
    }
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        callback = callback || noop;
        if (test()) {
            var next = _restParam(function(err, args) {
                if (err) {
                    callback(err);
                } else if (test.apply(this, args)) {
                    iterator(next);
                } else {
                    callback.apply(null, [null].concat(args));
                }
            });
            iterator(next);
        } else {
            callback(null);
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        var calls = 0;
        return async.whilst(function() {
            return ++calls <= 1 || test.apply(this, arguments);
        }, iterator, callback);
    };

    async.until = function (test, iterator, callback) {
        return async.whilst(function() {
            return !test.apply(this, arguments);
        }, iterator, callback);
    };

    async.doUntil = function (iterator, test, callback) {
        return async.doWhilst(iterator, function() {
            return !test.apply(this, arguments);
        }, callback);
    };

    async.during = function (test, iterator, callback) {
        callback = callback || noop;

        var next = _restParam(function(err, args) {
            if (err) {
                callback(err);
            } else {
                args.push(check);
                test.apply(this, args);
            }
        });

        var check = function(err, truth) {
            if (err) {
                callback(err);
            } else if (truth) {
                iterator(next);
            } else {
                callback(null);
            }
        };

        test(check);
    };

    async.doDuring = function (iterator, test, callback) {
        var calls = 0;
        async.during(function(next) {
            if (calls++ < 1) {
                next(null, true);
            } else {
                test.apply(this, arguments);
            }
        }, iterator, callback);
    };

    function _queue(worker, concurrency, payload) {
        if (concurrency == null) {
            concurrency = 1;
        }
        else if(concurrency === 0) {
            throw new Error('Concurrency must not be zero');
        }
        function _insert(q, data, pos, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    callback: callback || noop
                };

                if (pos) {
                    q.tasks.unshift(item);
                } else {
                    q.tasks.push(item);
                }

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
            });
            async.setImmediate(q.process);
        }
        function _next(q, tasks) {
            return function(){
                workers -= 1;

                var removed = false;
                var args = arguments;
                _arrayEach(tasks, function (task) {
                    _arrayEach(workersList, function (worker, index) {
                        if (worker === task && !removed) {
                            workersList.splice(index, 1);
                            removed = true;
                        }
                    });

                    task.callback.apply(task, args);
                });
                if (q.tasks.length + workers === 0) {
                    q.drain();
                }
                q.process();
            };
        }

        var workers = 0;
        var workersList = [];
        var q = {
            tasks: [],
            concurrency: concurrency,
            payload: payload,
            saturated: noop,
            empty: noop,
            drain: noop,
            started: false,
            paused: false,
            push: function (data, callback) {
                _insert(q, data, false, callback);
            },
            kill: function () {
                q.drain = noop;
                q.tasks = [];
            },
            unshift: function (data, callback) {
                _insert(q, data, true, callback);
            },
            process: function () {
                while(!q.paused && workers < q.concurrency && q.tasks.length){

                    var tasks = q.payload ?
                        q.tasks.splice(0, q.payload) :
                        q.tasks.splice(0, q.tasks.length);

                    var data = _map(tasks, function (task) {
                        return task.data;
                    });

                    if (q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    workersList.push(tasks[0]);
                    var cb = only_once(_next(q, tasks));
                    worker(data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            workersList: function () {
                return workersList;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                var resumeCount = Math.min(q.concurrency, q.tasks.length);
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= resumeCount; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    }

    async.queue = function (worker, concurrency) {
        var q = _queue(function (items, cb) {
            worker(items[0], cb);
        }, concurrency, 1);

        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
            return a.priority - b.priority;
        }

        function _binarySearch(sequence, item, compare) {
            var beg = -1,
                end = sequence.length - 1;
            while (beg < end) {
                var mid = beg + ((end - beg + 1) >>> 1);
                if (compare(item, sequence[mid]) >= 0) {
                    beg = mid;
                } else {
                    end = mid - 1;
                }
            }
            return beg;
        }

        function _insert(q, data, priority, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    priority: priority,
                    callback: typeof callback === 'function' ? callback : noop
                };

                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
                async.setImmediate(q.process);
            });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
            _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        return _queue(worker, 1, payload);
    };

    function _console_fn(name) {
        return _restParam(function (fn, args) {
            fn.apply(null, args.concat([_restParam(function (err, args) {
                if (typeof console === 'object') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _arrayEach(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            })]));
        });
    }
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        var has = Object.prototype.hasOwnProperty;
        hasher = hasher || identity;
        var memoized = _restParam(function memoized(args) {
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (has.call(memo, key)) {   
                async.setImmediate(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (has.call(queues, key)) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([_restParam(function (args) {
                    memo[key] = args;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                        q[i].apply(null, args);
                    }
                })]));
            }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
        return function () {
            return (fn.unmemoized || fn).apply(null, arguments);
        };
    };

    function _times(mapper) {
        return function (count, iterator, callback) {
            mapper(_range(count), iterator, callback);
        };
    }

    async.times = _times(async.map);
    async.timesSeries = _times(async.mapSeries);
    async.timesLimit = function (count, limit, iterator, callback) {
        return async.mapLimit(_range(count), limit, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return _restParam(function (args) {
            var that = this;

            var callback = args[args.length - 1];
            if (typeof callback == 'function') {
                args.pop();
            } else {
                callback = noop;
            }

            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
                    cb(err, nextargs);
                })]));
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        });
    };

    async.compose = function (/* functions... */) {
        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };


    function _applyEach(eachfn) {
        return _restParam(function(fns, args) {
            var go = _restParam(function(args) {
                var that = this;
                var callback = args.pop();
                return eachfn(fns, function (fn, _, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            });
            if (args.length) {
                return go.apply(this, args);
            }
            else {
                return go;
            }
        });
    }

    async.applyEach = _applyEach(async.eachOf);
    async.applyEachSeries = _applyEach(async.eachOfSeries);


    async.forever = function (fn, callback) {
        var done = only_once(callback || noop);
        var task = ensureAsync(fn);
        function next(err) {
            if (err) {
                return done(err);
            }
            task(next);
        }
        next();
    };

    function ensureAsync(fn) {
        return _restParam(function (args) {
            var callback = args.pop();
            args.push(function () {
                var innerArgs = arguments;
                if (sync) {
                    async.setImmediate(function () {
                        callback.apply(null, innerArgs);
                    });
                } else {
                    callback.apply(null, innerArgs);
                }
            });
            var sync = true;
            fn.apply(this, args);
            sync = false;
        });
    }

    async.ensureAsync = ensureAsync;

    async.constant = _restParam(function(values) {
        var args = [null].concat(values);
        return function (callback) {
            return callback.apply(this, args);
        };
    });

    async.wrapSync =
    async.asyncify = function asyncify(func) {
        return _restParam(function (args) {
            var callback = args.pop();
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            // if result is Promise object
            if (_isObject(result) && typeof result.then === "function") {
                result.then(function(value) {
                    callback(null, value);
                })["catch"](function(err) {
                    callback(err.message ? err : new Error(err));
                });
            } else {
                callback(null, result);
            }
        });
    };

    // Node.js
    if (typeof module === 'object' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define === 'function' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":3}],2:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":3}],3:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.0 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],7:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":5,"./encode":6}],8:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":4,"querystring":7}],9:[function(require,module,exports){
'use strict';

module.exports = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var sum = 0,
        i, j, last;

    // calculate original winding order of a polygon ring
    for (i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }

    // link points into circular doubly-linked list in the specified winding order
    if (clockwise === (sum > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        // a self-intersection where edge (v[i-1],v[i]) intersects (v[i+1],v[i+2])
        if (intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hole.x === m.x) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= m.x &&
                pointInTriangle(hy < m.y ? hx : qx, hy, m.x, m.y, hy < m.y ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

},{}],10:[function(require,module,exports){
'use strict';

//
// We store our EE objects in a plain object whose properties are event names.
// If `Object.create(null)` is not supported we prefix the event names with a
// `~` to make sure that the built-in object properties are not overridden or
// used as an attack vector.
// We also assume that `Object.create(null)` is available when the event name
// is an ES6 Symbol.
//
var prefix = typeof Object.create !== 'function' ? '~' : false;

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} once Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Holds the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @param {Boolean} exists We only need to know if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events && this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Functon} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Mixed} context Only remove listeners matching this context.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once && !listeners.once)
        || (context && listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i < length; i++) {
        if (
             listeners[i].fn !== fn
          || (once && !listeners[i].once)
          || (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}

},{}],11:[function(require,module,exports){
/* eslint-disable no-unused-vars */
'use strict';
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],12:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= q.concurrency; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
          return a.priority - b.priority;
        };

        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }

        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };

              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":3}],13:[function(require,module,exports){
var async       = require('async'),
    urlParser   = require('url'),
    Resource    = require('./Resource'),
    EventEmitter = require('eventemitter3');

/**
 * Manages the state and loading of multiple resources to load.
 *
 * @class
 * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.
 * @param [concurrency=10] {number} The number of resources to load concurrently.
 */
function Loader(baseUrl, concurrency) {
    EventEmitter.call(this);

    concurrency = concurrency || 10;

    /**
     * The base url for all resources loaded by this loader.
     *
     * @member {string}
     */
    this.baseUrl = baseUrl || '';

    /**
     * The progress percent of the loader going through the queue.
     *
     * @member {number}
     */
    this.progress = 0;

    /**
     * Loading state of the loader, true if it is currently loading resources.
     *
     * @member {boolean}
     */
    this.loading = false;

    /**
     * The percentage of total progress that a single resource represents.
     *
     * @member {number}
     */
    this._progressChunk = 0;

    /**
     * The middleware to run before loading each resource.
     *
     * @member {function[]}
     */
    this._beforeMiddleware = [];

    /**
     * The middleware to run after loading each resource.
     *
     * @member {function[]}
     */
    this._afterMiddleware = [];

    /**
     * The `_loadResource` function bound with this object context.
     *
     * @private
     * @member {function}
     */
    this._boundLoadResource = this._loadResource.bind(this);

    /**
     * The `_onLoad` function bound with this object context.
     *
     * @private
     * @member {function}
     */
    this._boundOnLoad = this._onLoad.bind(this);

    /**
     * The resource buffer that fills until `load` is called to start loading resources.
     *
     * @private
     * @member {Resource[]}
     */
    this._buffer = [];

    /**
     * Used to track load completion.
     *
     * @private
     * @member {number}
     */
    this._numToLoad = 0;

    /**
     * The resources waiting to be loaded.
     *
     * @private
     * @member {Resource[]}
     */
    this._queue = async.queue(this._boundLoadResource, concurrency);

    /**
     * All the resources for this loader keyed by name.
     *
     * @member {object<string, Resource>}
     */
    this.resources = {};

    /**
     * Emitted once per loaded or errored resource.
     *
     * @event progress
     * @memberof Loader#
     */

    /**
     * Emitted once per errored resource.
     *
     * @event error
     * @memberof Loader#
     */

    /**
     * Emitted once per loaded resource.
     *
     * @event load
     * @memberof Loader#
     */

    /**
     * Emitted when the loader begins to process the queue.
     *
     * @event start
     * @memberof Loader#
     */

    /**
     * Emitted when the queued resources all load.
     *
     * @event complete
     * @memberof Loader#
     */
}

Loader.prototype = Object.create(EventEmitter.prototype);
Loader.prototype.constructor = Loader;
module.exports = Loader;

/**
 * Adds a resource (or multiple resources) to the loader queue.
 *
 * This function can take a wide variety of different parameters. The only thing that is always
 * required the url to load. All the following will work:
 *
 * ```js
 * loader
 *     // normal param syntax
 *     .add('key', 'http://...', function () {})
 *     .add('http://...', function () {})
 *     .add('http://...')
 *
 *     // object syntax
 *     .add({
 *         name: 'key2',
 *         url: 'http://...'
 *     }, function () {})
 *     .add({
 *         url: 'http://...'
 *     }, function () {})
 *     .add({
 *         name: 'key3',
 *         url: 'http://...'
 *         onComplete: function () {}
 *     })
 *     .add({
 *         url: 'https://...',
 *         onComplete: function () {},
 *         crossOrigin: true
 *     })
 *
 *     // you can also pass an array of objects or urls or both
 *     .add([
 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
 *         { url: 'http://...', onComplete: function () {} },
 *         'http://...'
 *     ]);
 * ```
 *
 * @alias enqueue
 * @param [name] {string} The name of the resource to load, if not passed the url is used.
 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
 * @param [options] {object} The options for the load.
 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
 *      loaded be interpreted when using XHR?
 * @param [callback] {function} Function to call when this specific resource completes loading.
 * @return {Loader}
 */
Loader.prototype.add = Loader.prototype.enqueue = function (name, url, options, cb) {
    // special case of an array of objects or urls
    if (Array.isArray(name)) {
        for (var i = 0; i < name.length; ++i) {
            this.add(name[i]);
        }

        return this;
    }

    // if an object is passed instead of params
    if (typeof name === 'object') {
        cb = url || name.callback || name.onComplete;
        options = name;
        url = name.url;
        name = name.name || name.key || name.url;
    }

    // case where no name is passed shift all args over by one.
    if (typeof url !== 'string') {
        cb = options;
        options = url;
        url = name;
    }

    // now that we shifted make sure we have a proper url.
    if (typeof url !== 'string') {
        throw new Error('No url passed to add resource to loader.');
    }

    // options are optional so people might pass a function and no options
    if (typeof options === 'function') {
        cb = options;
        options = null;
    }

    // check if resource already exists.
    if (this.resources[name]) {
        throw new Error('Resource with name "' + name + '" already exists.');
    }

    // add base url if this isn't an absolute url
    url = this._handleBaseUrl(url);

    // create the store the resource
    this.resources[name] = new Resource(name, url, options);

    if (typeof cb === 'function') {
        this.resources[name].once('afterMiddleware', cb);
    }

    this._numToLoad++;

    // if already loading add it to the worker queue
    if (this._queue.started) {
        this._queue.push(this.resources[name]);
        this._progressChunk = (100 - this.progress) / (this._queue.length() + this._queue.running());
    }
    // otherwise buffer it to be added to the queue later
    else {
        this._buffer.push(this.resources[name]);
        this._progressChunk = 100 / this._buffer.length;
    }

    return this;
};

Loader.prototype._handleBaseUrl = function (url) {
    var parsedUrl = urlParser.parse(url);

    // absolute url, just use it as is.
    if (parsedUrl.protocol || parsedUrl.pathname.indexOf('//') === 0) {
        return url;
    }

    // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween
    if (
        this.baseUrl.length &&
        this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 &&
        url.charAt(0) !== '/'
    ) {
        return this.baseUrl + '/' + url;
    }
    else {
        return this.baseUrl + url;
    }
};


/**
 * Sets up a middleware function that will run *before* the
 * resource is loaded.
 *
 * @alias pre
 * @param middleware {function} The middleware function to register.
 * @return {Loader}
 */
Loader.prototype.before = Loader.prototype.pre = function (fn) {
    this._beforeMiddleware.push(fn);

    return this;
};

/**
 * Sets up a middleware function that will run *after* the
 * resource is loaded.
 *
 * @alias use
 * @param middleware {function} The middleware function to register.
 * @return {Loader}
 */
Loader.prototype.after = Loader.prototype.use = function (fn) {
    this._afterMiddleware.push(fn);

    return this;
};

/**
 * Resets the queue of the loader to prepare for a new load.
 *
 * @return {Loader}
 */
Loader.prototype.reset = function () {
    // this.baseUrl = baseUrl || '';

    this.progress = 0;

    this.loading = false;

    this._progressChunk = 0;

    // this._beforeMiddleware.length = 0;
    // this._afterMiddleware.length = 0;

    this._buffer.length = 0;

    this._numToLoad = 0;

    this._queue.kill();
    this._queue.started = false;

    this.resources = {};
};

/**
 * Starts loading the queued resources.
 *
 * @fires start
 * @param [callback] {function} Optional callback that will be bound to the `complete` event.
 * @return {Loader}
 */
Loader.prototype.load = function (cb) {
    // register complete callback if they pass one
    if (typeof cb === 'function') {
        this.once('complete', cb);
    }

    // if the queue has already started we are done here
    if (this._queue.started) {
        return this;
    }

    // notify of start
    this.emit('start', this);

    // start the internal queue
    for (var i = 0; i < this._buffer.length; ++i) {
        this._queue.push(this._buffer[i]);
    }

    // empty the buffer
    this._buffer.length = 0;

    return this;
};

/**
 * Loads a single resource.
 *
 * @fires progress
 * @private
 */
Loader.prototype._loadResource = function (resource, dequeue) {
    var self = this;

    resource._dequeue = dequeue;

    this._runMiddleware(resource, this._beforeMiddleware, function () {
        // resource.on('progress', self.emit.bind(self, 'progress'));

        resource.load(self._boundOnLoad);
    });
};

/**
 * Called once each resource has loaded.
 *
 * @fires complete
 * @private
 */
Loader.prototype._onComplete = function () {
    this.emit('complete', this, this.resources);
};

/**
 * Called each time a resources is loaded.
 *
 * @fires progress
 * @fires error
 * @fires load
 * @private
 */
Loader.prototype._onLoad = function (resource) {
    this.progress += this._progressChunk;

    this.emit('progress', this, resource);

    // run middleware, this *must* happen before dequeue so sub-assets get added properly
    this._runMiddleware(resource, this._afterMiddleware, function () {
        resource.emit('afterMiddleware', resource);

        this._numToLoad--;

        // do completion check
        if (this._numToLoad === 0) {
            this.progress = 100;
            this._onComplete();
        }
        
        if (resource.error) {
            this.emit('error', resource.error, this, resource);
        }
        else {
            this.emit('load', this, resource);
        }
    });
    


    // remove this resource from the async queue
    resource._dequeue();
};

/**
 * Run middleware functions on a resource.
 *
 * @private
 */
Loader.prototype._runMiddleware = function (resource, fns, cb) {
    var self = this;

    async.eachSeries(fns, function (fn, next) {
        fn.call(self, resource, next);
    }, cb.bind(this, resource));
};

Loader.LOAD_TYPE = Resource.LOAD_TYPE;
Loader.XHR_READY_STATE = Resource.XHR_READY_STATE;
Loader.XHR_RESPONSE_TYPE = Resource.XHR_RESPONSE_TYPE;

},{"./Resource":14,"async":12,"eventemitter3":10,"url":8}],14:[function(require,module,exports){
var EventEmitter = require('eventemitter3'),
    _url = require('url'),
    // tests is CORS is supported in XHR, if not we need to use XDR
    useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest()))),
    tempAnchor = null;

/**
 * Manages the state and loading of a single resource represented by
 * a single URL.
 *
 * @class
 * @param name {string} The name of the resource to load.
 * @param url {string|string[]} The url for this resource, for audio/video loads you can pass an array of sources.
 * @param [options] {object} The options for the load.
 * @param [options.crossOrigin] {string|boolean} Is this request cross-origin? Default is to determine automatically.
 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.LOAD_TYPE} How should this resource be loaded?
 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
 *      loaded be interpreted when using XHR?
 * @param [options.metadata] {object} Extra info for middleware.
 */
function Resource(name, url, options) {
    EventEmitter.call(this);

    options = options || {};

    if (typeof name !== 'string' || typeof url !== 'string') {
        throw new Error('Both name and url are required for constructing a resource.');
    }

    /**
     * The name of this resource.
     *
     * @member {string}
     * @readonly
     */
    this.name = name;

    /**
     * The url used to load this resource.
     *
     * @member {string}
     * @readonly
     */
    this.url = url;

    /**
     * Stores whether or not this url is a data url.
     *
     * @member {boolean}
     * @readonly
     */
    this.isDataUrl = this.url.indexOf('data:') === 0;

    /**
     * The data that was loaded by the resource.
     *
     * @member {any}
     */
    this.data = null;

    /**
     * Is this request cross-origin? If unset, determined automatically.
     *
     * @member {string}
     */
    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;

    /**
     * The method of loading to use for this resource.
     *
     * @member {Resource.LOAD_TYPE}
     */
    this.loadType = options.loadType || this._determineLoadType();

    /**
     * The type used to load the resource via XHR. If unset, determined automatically.
     *
     * @member {string}
     */
    this.xhrType = options.xhrType;

    /**
     * Extra info for middleware
     *
     * @member {object}
     */
    this.metadata = options.metadata || {};

    /**
     * The error that occurred while loading (if any).
     *
     * @member {Error}
     * @readonly
     */
    this.error = null;

    /**
     * The XHR object that was used to load this resource. This is only set
     * when `loadType` is `Resource.LOAD_TYPE.XHR`.
     *
     * @member {XMLHttpRequest}
     */
    this.xhr = null;

    /**
     * Describes if this resource was loaded as json. Only valid after the resource
     * has completely loaded.
     *
     * @member {boolean}
     */
    this.isJson = false;

    /**
     * Describes if this resource was loaded as xml. Only valid after the resource
     * has completely loaded.
     *
     * @member {boolean}
     */
    this.isXml = false;

    /**
     * Describes if this resource was loaded as an image tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {boolean}
     */
    this.isImage = false;

    /**
     * Describes if this resource was loaded as an audio tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {boolean}
     */
    this.isAudio = false;

    /**
     * Describes if this resource was loaded as a video tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {boolean}
     */
    this.isVideo = false;

    /**
     * The `dequeue` method that will be used a storage place for the async queue dequeue method
     * used privately by the loader.
     *
     * @member {function}
     * @private
     */
    this._dequeue = null;

    /**
     * The `complete` function bound to this resource's context.
     *
     * @member {function}
     * @private
     */
    this._boundComplete = this.complete.bind(this);

    /**
     * The `_onError` function bound to this resource's context.
     *
     * @member {function}
     * @private
     */
    this._boundOnError = this._onError.bind(this);

    /**
     * The `_onProgress` function bound to this resource's context.
     *
     * @member {function}
     * @private
     */
    this._boundOnProgress = this._onProgress.bind(this);

    // xhr callbacks
    this._boundXhrOnError = this._xhrOnError.bind(this);
    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
    this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);

    /**
     * Emitted when the resource beings to load.
     *
     * @event start
     * @memberof Resource#
     */

    /**
     * Emitted each time progress of this resource load updates.
     * Not all resources types and loader systems can support this event
     * so sometimes it may not be available. If the resource
     * is being loaded on a modern browser, using XHR, and the remote server
     * properly sets Content-Length headers, then this will be available.
     *
     * @event progress
     * @memberof Resource#
     */

    /**
     * Emitted once this resource has loaded, if there was an error it will
     * be in the `error` property.
     *
     * @event complete
     * @memberof Resource#
     */
}

Resource.prototype = Object.create(EventEmitter.prototype);
Resource.prototype.constructor = Resource;
module.exports = Resource;

/**
 * Marks the resource as complete.
 *
 * @fires complete
 */
Resource.prototype.complete = function () {
    // TODO: Clean this up in a wrapper or something...gross....
    if (this.data && this.data.removeEventListener) {
        this.data.removeEventListener('error', this._boundOnError);
        this.data.removeEventListener('load', this._boundComplete);
        this.data.removeEventListener('progress', this._boundOnProgress);
        this.data.removeEventListener('canplaythrough', this._boundComplete);
    }

    if (this.xhr) {
        if (this.xhr.removeEventListener) {
            this.xhr.removeEventListener('error', this._boundXhrOnError);
            this.xhr.removeEventListener('abort', this._boundXhrOnAbort);
            this.xhr.removeEventListener('progress', this._boundOnProgress);
            this.xhr.removeEventListener('load', this._boundXhrOnLoad);
        }
        else {
            this.xhr.onerror = null;
            this.xhr.ontimeout = null;
            this.xhr.onprogress = null;
            this.xhr.onload = null;
        }
    }

    this.emit('complete', this);
};

/**
 * Kicks off loading of this resource.
 *
 * @fires start
 * @param [callback] {function} Optional callback to call once the resource is loaded.
 */
Resource.prototype.load = function (cb) {
    this.emit('start', this);

    // if a callback is set, listen for complete event
    if (cb) {
        this.once('complete', cb);
    }

    // if unset, determine the value
    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {
        this.crossOrigin = this._determineCrossOrigin(this.url);
    }

    switch(this.loadType) {
        case Resource.LOAD_TYPE.IMAGE:
            this._loadImage();
            break;

        case Resource.LOAD_TYPE.AUDIO:
            this._loadElement('audio');
            break;

        case Resource.LOAD_TYPE.VIDEO:
            this._loadElement('video');
            break;

        case Resource.LOAD_TYPE.XHR:
            /* falls through */
        default:
            if (useXdr && this.crossOrigin) {
                this._loadXdr();
            }
            else {
                this._loadXhr();
            }
            break;
    }
};

/**
 * Loads this resources using an Image object.
 *
 * @private
 */
Resource.prototype._loadImage = function () {
    this.data = new Image();

    if (this.crossOrigin) {
        this.data.crossOrigin = this.crossOrigin;
    }

    this.data.src = this.url;

    this.isImage = true;

    this.data.addEventListener('error', this._boundOnError, false);
    this.data.addEventListener('load', this._boundComplete, false);
    this.data.addEventListener('progress', this._boundOnProgress, false);
};

/**
 * Loads this resources using an HTMLAudioElement or HTMLVideoElement.
 *
 * @private
 */
Resource.prototype._loadElement = function (type) {
    if (type === 'audio' && typeof Audio !== 'undefined') {
        this.data = new Audio();
    }
    else {
        this.data = document.createElement(type);
    }

    if (this.data === null) {
        this.error = new Error('Unsupported element ' + type);
        this.complete();
        return;
    }

    // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
    if (navigator.isCocoonJS) {
        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
    }
    else {
        if (Array.isArray(this.url)) {
            for (var i = 0; i < this.url.length; ++i) {
                this.data.appendChild(this._createSource(type, this.url[i]));
            }
        }
        else {
            this.data.appendChild(this._createSource(type, this.url));
        }
    }

    this['is' + type[0].toUpperCase() + type.substring(1)] = true;

    this.data.addEventListener('error', this._boundOnError, false);
    this.data.addEventListener('load', this._boundComplete, false);
    this.data.addEventListener('progress', this._boundOnProgress, false);
    this.data.addEventListener('canplaythrough', this._boundComplete, false);

    this.data.load();
};

/**
 * Loads this resources using an XMLHttpRequest.
 *
 * @private
 */
Resource.prototype._loadXhr = function () {
    // if unset, determine the value
    if (typeof this.xhrType !== 'string') {
        this.xhrType = this._determineXhrType();
    }

    var xhr = this.xhr = new XMLHttpRequest();

    // set the request type and url
    xhr.open('GET', this.url, true);

    // load json as text and parse it ourselves. We do this because some browsers
    // *cough* safari *cough* can't deal with it.
    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
        xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;
    }
    else {
        xhr.responseType = this.xhrType;
    }

    xhr.addEventListener('error', this._boundXhrOnError, false);
    xhr.addEventListener('abort', this._boundXhrOnAbort, false);
    xhr.addEventListener('progress', this._boundOnProgress, false);
    xhr.addEventListener('load', this._boundXhrOnLoad, false);

    xhr.send();
};

/**
 * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
 *
 * @private
 */
Resource.prototype._loadXdr = function () {
    // if unset, determine the value
    if (typeof this.xhrType !== 'string') {
        this.xhrType = this._determineXhrType();
    }

    var xdr = this.xhr = new XDomainRequest();

    // XDomainRequest has a few quirks. Occasionally it will abort requests
    // A way to avoid this is to make sure ALL callbacks are set even if not used
    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
    xdr.timeout = 5000;

    xdr.onerror = this._boundXhrOnError;
    xdr.ontimeout = this._boundXdrOnTimeout;
    xdr.onprogress = this._boundOnProgress;
    xdr.onload = this._boundXhrOnLoad;

    xdr.open('GET', this.url, true);

    //  Note: The xdr.send() call is wrapped in a timeout to prevent an issue with the interface where some requests are lost
    //  if multiple XDomainRequests are being sent at the same time.
    // Some info here: https://github.com/photonstorm/phaser/issues/1248
    setTimeout(function () {
        xdr.send();
    }, 0);
};

/**
 * Creates a source used in loading via an element.
 *
 * @param type {string} The element type (video or audio).
 * @param url {string} The source URL to load from.
 * @param [mime] {string} The mime type of the video
 * @private
 */
Resource.prototype._createSource = function (type, url, mime) {
    if (!mime) {
        mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);
    }

    var source = document.createElement('source');

    source.src = url;
    source.type = mime;

    return source;
};

/**
 * Called if a load errors out.
 *
 * @param event {Event} The error event from the element that emits it.
 * @private
 */
Resource.prototype._onError = function (event) {
    this.error = new Error('Failed to load element using ' + event.target.nodeName);
    this.complete();
};

/**
 * Called if a load progress event fires for xhr/xdr.
 *
 * @fires progress
 * @param event {XMLHttpRequestProgressEvent|Event}
 * @private
 */
Resource.prototype._onProgress =  function (event) {
    if (event && event.lengthComputable) {
        this.emit('progress', this, event.loaded / event.total);
    }
};

/**
 * Called if an error event fires for xhr/xdr.
 *
 * @param event {XMLHttpRequestErrorEvent|Event}
 * @private
 */
Resource.prototype._xhrOnError = function () {
    this.error = new Error(
        reqType(this.xhr) + ' Request failed. ' +
        'Status: ' + this.xhr.status + ', text: "' + this.xhr.statusText + '"'
    );

    this.complete();
};

/**
 * Called if an abort event fires for xhr.
 *
 * @param event {XMLHttpRequestAbortEvent}
 * @private
 */
Resource.prototype._xhrOnAbort = function () {
    this.error = new Error(reqType(this.xhr) + ' Request was aborted by the user.');
    this.complete();
};

/**
 * Called if a timeout event fires for xdr.
 *
 * @param event {Event}
 * @private
 */
Resource.prototype._xdrOnTimeout = function () {
    this.error = new Error(reqType(this.xhr) + ' Request timed out.');
    this.complete();
};

/**
 * Called when data successfully loads from an xhr/xdr request.
 *
 * @param event {XMLHttpRequestLoadEvent|Event}
 * @private
 */
Resource.prototype._xhrOnLoad = function () {
    var xhr = this.xhr,
        status = xhr.status !== undefined ? xhr.status : 200; //XDR has no `.status`, assume 200.

    // status can be 0 when using the file:// protocol, also check if a response was found
    if (status === 200 || status === 204 || (status === 0 && xhr.responseText.length > 0)) {
        // if text, just return it
        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {
            this.data = xhr.responseText;
        }
        // if json, parse into json object
        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {
            try {
                this.data = JSON.parse(xhr.responseText);
                this.isJson = true;
            } catch(e) {
                this.error = new Error('Error trying to parse loaded json:', e);
            }
        }
        // if xml, parse into an xml document or div element
        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
            try {
                if (window.DOMParser) {
                    var domparser = new DOMParser();
                    this.data = domparser.parseFromString(xhr.responseText, 'text/xml');
                }
                else {
                    var div = document.createElement('div');
                    div.innerHTML = xhr.responseText;
                    this.data = div;
                }
                this.isXml = true;
            } catch (e) {
                this.error = new Error('Error trying to parse loaded xml:', e);
            }
        }
        // other types just return the response
        else {
            this.data = xhr.response || xhr.responseText;
        }
    }
    else {
        this.error = new Error('[' + xhr.status + ']' + xhr.statusText + ':' + xhr.responseURL);
    }

    this.complete();
};

function reqType(xhr) {
    return xhr.toString().replace('object ', '');
}

/**
 * Sets the `crossOrigin` property for this resource based on if the url
 * for this resource is cross-origin. If crossOrigin was manually set, this
 * function does nothing.
 *
 * @private
 * @param url {string} The url to test.
 * @param [location=window.location] {object} The location object to test against.
 * @return {string} The crossOrigin value to use (or empty string for none).
 */
Resource.prototype._determineCrossOrigin = function (url, loc) {
    // data: and javascript: urls are considered same-origin
    if (url.indexOf('data:') === 0) {
        return '';
    }

    // default is window.location
    loc = loc || window.location;

    if (!tempAnchor) {
        tempAnchor = document.createElement('a');
    }

    // let the browser determine the full href for the url of this resource and then
    // parse with the node url lib, we can't use the properties of the anchor element
    // because they don't work in IE9 :(
    tempAnchor.href = url;
    url = _url.parse(tempAnchor.href);

    var samePort = (!url.port && loc.port === '') || (url.port === loc.port);

    // if cross origin
    if (url.hostname !== loc.hostname || !samePort || url.protocol !== loc.protocol) {
        return 'anonymous';
    }

    return '';
};

/**
 * Determines the responseType of an XHR request based on the extension of the
 * resource being loaded.
 *
 * @private
 * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
 */
Resource.prototype._determineXhrType = function () {
    return Resource._xhrTypeMap[this._getExtension()] || Resource.XHR_RESPONSE_TYPE.TEXT;
};

Resource.prototype._determineLoadType = function () {
    return Resource._loadTypeMap[this._getExtension()] || Resource.LOAD_TYPE.XHR;
};

Resource.prototype._getExtension = function () {
    var url = this.url,
        ext;

    if (this.isDataUrl) {
        var slashIndex = url.indexOf('/');
        ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
    }
    else {
        var queryStart = url.indexOf('?');
        if (queryStart !== -1) {
            url = url.substring(0, queryStart);
        }

        ext = url.substring(url.lastIndexOf('.') + 1);
    }

    return ext;
};

/**
 * Determines the mime type of an XHR request based on the responseType of
 * resource being loaded.
 *
 * @private
 * @return {string} The mime type to use.
 */
Resource.prototype._getMimeFromXhrType = function (type) {
    switch(type) {
        case Resource.XHR_RESPONSE_TYPE.BUFFER:
            return 'application/octet-binary';

        case Resource.XHR_RESPONSE_TYPE.BLOB:
            return 'application/blob';

        case Resource.XHR_RESPONSE_TYPE.DOCUMENT:
            return 'application/xml';

        case Resource.XHR_RESPONSE_TYPE.JSON:
            return 'application/json';

        case Resource.XHR_RESPONSE_TYPE.DEFAULT:
        case Resource.XHR_RESPONSE_TYPE.TEXT:
            /* falls through */
        default:
            return 'text/plain';

    }
};

/**
 * The types of loading a resource can use.
 *
 * @static
 * @constant
 * @property {object} LOAD_TYPE
 * @property {number} LOAD_TYPE.XHR - Uses XMLHttpRequest to load the resource.
 * @property {number} LOAD_TYPE.IMAGE - Uses an `Image` object to load the resource.
 * @property {number} LOAD_TYPE.AUDIO - Uses an `Audio` object to load the resource.
 * @property {number} LOAD_TYPE.VIDEO - Uses a `Video` object to load the resource.
 */
Resource.LOAD_TYPE = {
    XHR:    1,
    IMAGE:  2,
    AUDIO:  3,
    VIDEO:  4
};

/**
 * The XHR ready states, used internally.
 *
 * @static
 * @constant
 * @property {object} XHR_READY_STATE
 * @property {number} XHR_READY_STATE.UNSENT - open()has not been called yet.
 * @property {number} XHR_READY_STATE.OPENED - send()has not been called yet.
 * @property {number} XHR_READY_STATE.HEADERS_RECEIVED - send() has been called, and headers and status are available.
 * @property {number} XHR_READY_STATE.LOADING - Downloading; responseText holds partial data.
 * @property {number} XHR_READY_STATE.DONE - The operation is complete.
 */
Resource.XHR_READY_STATE = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
};

/**
 * The XHR ready states, used internally.
 *
 * @static
 * @constant
 * @property {object} XHR_RESPONSE_TYPE
 * @property {string} XHR_RESPONSE_TYPE.DEFAULT - defaults to text
 * @property {string} XHR_RESPONSE_TYPE.BUFFER - ArrayBuffer
 * @property {string} XHR_RESPONSE_TYPE.BLOB - Blob
 * @property {string} XHR_RESPONSE_TYPE.DOCUMENT - Document
 * @property {string} XHR_RESPONSE_TYPE.JSON - Object
 * @property {string} XHR_RESPONSE_TYPE.TEXT - String
 */
Resource.XHR_RESPONSE_TYPE = {
    DEFAULT:    'text',
    BUFFER:     'arraybuffer',
    BLOB:       'blob',
    DOCUMENT:   'document',
    JSON:       'json',
    TEXT:       'text'
};

Resource._loadTypeMap = {
    'gif':      Resource.LOAD_TYPE.IMAGE,
    'png':      Resource.LOAD_TYPE.IMAGE,
    'bmp':      Resource.LOAD_TYPE.IMAGE,
    'jpg':      Resource.LOAD_TYPE.IMAGE,
    'jpeg':     Resource.LOAD_TYPE.IMAGE,
    'tif':      Resource.LOAD_TYPE.IMAGE,
    'tiff':     Resource.LOAD_TYPE.IMAGE,
    'webp':     Resource.LOAD_TYPE.IMAGE,
    'tga':      Resource.LOAD_TYPE.IMAGE
};

Resource._xhrTypeMap = {
    // xml
    'xhtml':    Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'html':     Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'htm':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'xml':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'tmx':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'tsx':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'svg':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,

    // images
    'gif':      Resource.XHR_RESPONSE_TYPE.BLOB,
    'png':      Resource.XHR_RESPONSE_TYPE.BLOB,
    'bmp':      Resource.XHR_RESPONSE_TYPE.BLOB,
    'jpg':      Resource.XHR_RESPONSE_TYPE.BLOB,
    'jpeg':     Resource.XHR_RESPONSE_TYPE.BLOB,
    'tif':      Resource.XHR_RESPONSE_TYPE.BLOB,
    'tiff':     Resource.XHR_RESPONSE_TYPE.BLOB,
    'webp':     Resource.XHR_RESPONSE_TYPE.BLOB,
    'tga':      Resource.XHR_RESPONSE_TYPE.BLOB,

    // json
    'json':     Resource.XHR_RESPONSE_TYPE.JSON,

    // text
    'text':     Resource.XHR_RESPONSE_TYPE.TEXT,
    'txt':      Resource.XHR_RESPONSE_TYPE.TEXT
};

/**
 * Sets the load type to be used for a specific extension.
 *
 * @static
 * @param extname {string} The extension to set the type for, e.g. "png" or "fnt"
 * @param loadType {Resource.LOAD_TYPE} The load type to set it to.
 */
Resource.setExtensionLoadType = function (extname, loadType) {
    setExtMap(Resource._loadTypeMap, extname, loadType);
};

/**
 * Sets the load type to be used for a specific extension.
 *
 * @static
 * @param extname {string} The extension to set the type for, e.g. "png" or "fnt"
 * @param xhrType {Resource.XHR_RESPONSE_TYPE} The xhr type to set it to.
 */
Resource.setExtensionXhrType = function (extname, xhrType) {
    setExtMap(Resource._xhrTypeMap, extname, xhrType);
};

function setExtMap(map, extname, val) {
    if (extname && extname.indexOf('.') === 0) {
        extname = extname.substring(1);
    }

    if (!extname) {
        return;
    }

    map[extname] = val;
}

},{"eventemitter3":10,"url":8}],15:[function(require,module,exports){
module.exports = {

    // private property
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    encodeBinary: function (input) {
        var output = "";
        var bytebuffer;
        var encodedCharIndexes = new Array(4);
        var inx = 0;
        var jnx = 0;
        var paddingBytes = 0;

        while (inx < input.length) {
            // Fill byte buffer array
            bytebuffer = new Array(3);
            for (jnx = 0; jnx < bytebuffer.length; jnx++) {
                if (inx < input.length) {
                    // throw away high-order byte, as documented at:
                    // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
                    bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;
                }
                else {
                    bytebuffer[jnx] = 0;
                }
            }

            // Get each encoded character, 6 bits at a time
            // index 1: first 6 bits
            encodedCharIndexes[0] = bytebuffer[0] >> 2;
            // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)
            encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);
            // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)
            encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);
            // index 3: forth 6 bits (6 least significant bits from input byte 3)
            encodedCharIndexes[3] = bytebuffer[2] & 0x3f;

            // Determine whether padding happened, and adjust accordingly
            paddingBytes = inx - (input.length - 1);
            switch (paddingBytes) {
                case 2:
                    // Set last 2 characters to padding char
                    encodedCharIndexes[3] = 64;
                    encodedCharIndexes[2] = 64;
                    break;

                case 1:
                    // Set last character to padding char
                    encodedCharIndexes[3] = 64;
                    break;

                default:
                    break; // No padding - proceed
            }

            // Now we will grab each appropriate character out of our keystring
            // based on our index array and append it to the output string
            for (jnx = 0; jnx < encodedCharIndexes.length; jnx++) {
                output += this._keyStr.charAt(encodedCharIndexes[jnx]);
            }
        }
        return output;
    }
};

},{}],16:[function(require,module,exports){
module.exports = require('./Loader');

module.exports.Resource = require('./Resource');

module.exports.middleware = {
    caching: {
        memory: require('./middlewares/caching/memory')
    },
    parsing: {
        blob: require('./middlewares/parsing/blob')
    }
};

},{"./Loader":13,"./Resource":14,"./middlewares/caching/memory":17,"./middlewares/parsing/blob":18}],17:[function(require,module,exports){
// a simple in-memory cache for resources
var cache = {};

module.exports = function () {
    return function (resource, next) {
        // if cached, then set data and complete the resource
        if (cache[resource.url]) {
            resource.data = cache[resource.url];
            resource.complete();
        }
        // if not cached, wait for complete and store it in the cache.
        else {
            resource.once('complete', function () {
               cache[this.url] = this.data;
            });
        }
        
        next();
    };
};

},{}],18:[function(require,module,exports){
var Resource = require('../../Resource'),
    b64 = require('../../b64');

window.URL = window.URL || window.webkitURL;

// a middleware for transforming XHR loaded Blobs into more useful objects

module.exports = function () {
    return function (resource, next) {
        if (!resource.data) {
            return next();
        }

        // if this was an XHR load of a blob
        if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {
            // if there is no blob support we probably got a binary string back
            if (!window.Blob || typeof resource.data === 'string') {
                var type = resource.xhr.getResponseHeader('content-type');

                // this is an image, convert the binary string into a data url
                if (type && type.indexOf('image') === 0) {
                    resource.data = new Image();
                    resource.data.src = 'data:' + type + ';base64,' + b64.encodeBinary(resource.xhr.responseText);

                    resource.isImage = true;

                    // wait until the image loads and then callback
                    resource.data.onload = function () {
                        resource.data.onload = null;

                        next();
                    };
                }
            }
            // if content type says this is an image, then we should transform the blob into an Image object
            else if (resource.data.type.indexOf('image') === 0) {
                var src = URL.createObjectURL(resource.data);

                resource.blob = resource.data;
                resource.data = new Image();
                resource.data.src = src;

                resource.isImage = true;

                // cleanup the no longer used blob after the image loads
                resource.data.onload = function () {
                    URL.revokeObjectURL(src);
                    resource.data.onload = null;

                    next();
                };
            }
        }
        else {
            next();
        }
    };
};

},{"../../Resource":14,"../../b64":15}],19:[function(require,module,exports){
module.exports={
  "name": "pixi.js",
  "version": "3.0.9",
  "description": "Pixi.js is a fast lightweight 2D library that works across all devices.",
  "author": "Mat Groves",
  "contributors": [
    "Chad Engler <chad@pantherdev.com>",
    "Richard Davey <rdavey@gmail.com>"
  ],
  "main": "./src/index.js",
  "homepage": "http://goodboydigital.com/",
  "bugs": "https://github.com/pixijs/pixi.js/issues",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/pixijs/pixi.js.git"
  },
  "scripts": {
    "start": "gulp && gulp watch",
    "test": "gulp && testem ci",
    "build": "gulp",
    "docs": "jsdoc -c ./gulp/util/jsdoc.conf.json -R README.md"
  },
  "files": [
    "bin/",
    "src/",
    "CONTRIBUTING.md",
    "LICENSE",
    "package.json",
    "README.md"
  ],
  "dependencies": {
    "async": "^1.5.0",
    "brfs": "^1.4.1",
    "earcut": "^2.0.7",
    "eventemitter3": "^1.1.1",
    "object-assign": "^4.0.1",
    "resource-loader": "^1.6.4"
  },
  "devDependencies": {
    "browserify": "^11.1.0",
    "chai": "^3.2.0",
    "del": "^2.0.2",
    "gulp": "^3.9.0",
    "gulp-cached": "^1.1.0",
    "gulp-concat": "^2.6.0",
    "gulp-debug": "^2.1.0",
    "gulp-header": "^1.7.1",
    "gulp-jshint": "^1.11.2",
    "gulp-mirror": "^0.4.0",
    "gulp-plumber": "^1.0.1",
    "gulp-rename": "^1.2.2",
    "gulp-sourcemaps": "^1.5.2",
    "gulp-uglify": "^1.4.1",
    "gulp-util": "^3.0.6",
    "jaguarjs-jsdoc": "git+https://github.com/davidshimjs/jaguarjs-jsdoc.git",
    "jsdoc": "^3.3.2",
    "jshint-summary": "^0.4.0",
    "minimist": "^1.2.0",
    "mocha": "^2.3.2",
    "require-dir": "^0.3.0",
    "run-sequence": "^1.1.2",
    "testem": "^0.9.4",
    "vinyl-buffer": "^1.0.0",
    "vinyl-source-stream": "^1.1.0",
    "watchify": "^3.4.0"
  },
  "browserify": {
    "transform": [
      "brfs"
    ]
  }
}

},{}],20:[function(require,module,exports){
var core = require('../core');

// add some extra variables to the container..
Object.assign(
    core.DisplayObject.prototype,
    require('./accessibleTarget')
);


/**
 * The Accessibility manager reacreates the ability to tab and and have content read by screen readers. This is very important as it can possibly help people with disabilities access pixi content.
 * Much like interaction any DisplayObject can be made accessible. This manager will map the events as if the mouse was being used, minimizing the efferot required to implement.
 *
 * @class
 * @memberof PIXI
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} A reference to the current renderer
 */
function AccessibilityManager(renderer)
{
	// first we create a div that will sit over the pixi element. This is where the div overlays will go.
    var div = document.createElement('div');
    
    div.style.width = 100 + 'px';
    div.style.height = 100 + 'px';
    div.style.position = 'absolute';
    div.style.top = 0;
    div.style.left = 0;
   //
    div.style.zIndex = 2;
   	
   	/**
   	 * This is the dom element that will sit over the pixi element. This is where the div overlays will go.
   	 * 
   	 * @type {HTMLElement}
   	 * @private
   	 */
   	this.div = div;

   	/**
   	 * A simple pool for storing divs.
   	 * 
   	 * @type {Array}
   	 * @private
   	 */
 	this.pool = [];

 	/**
 	 * This is a tick used to check if an object is no longer being rendered.
 	 * 
 	 * @type {Number}
 	 * @private
 	 */
   	this.renderId = 0;

   	/**
   	 * Setting this to true will visually show the divs
   	 * 
   	 * @type {Boolean}
   	 */
   	this.debug = false;

  	/**
     * The renderer this accessibility manager works for.
     *
     * @member {PIXI.SystemRenderer}
     */
   	this.renderer = renderer;

   	/**
     * The array of currently active accessible items.
     *
     * @member {Array}
     * @private
     */
   	this.children = [];
   	
   	/**
     * pre bind the functions..
     */
   	this._onKeyDown = this._onKeyDown.bind(this);
   	this._onMouseMove = this._onMouseMove.bind(this);
   	
   	/**
     * stores the state of the manager. If there are no accessible objects or the mouse is moving the will be false.
     *
     * @member {Array}
     * @private
     */
   	this.isActive = false;


   	// let listen for tab.. once pressed we can fire up and show the accessibility layer
   	window.addEventListener('keydown', this._onKeyDown, false);
}


AccessibilityManager.prototype.constructor = AccessibilityManager;
module.exports = AccessibilityManager;

/**
 * Activating will cause the Accessibility layer to be shown. This is called when a user preses the tab key
 * @private
 */
AccessibilityManager.prototype.activate = function()
{
	if(this.isActive)
	{
		return;
	}

	this.isActive = true;

	window.document.addEventListener('mousemove', this._onMouseMove, true);
	window.removeEventListener('keydown', this._onKeyDown, false);

	this.renderer.on('postrender', this.update, this);

	this.renderer.view.parentNode.appendChild(this.div);	
};

/**
 * Deactivating will cause the Accessibility layer to be hidden. This is called when a user moves the mouse
 * @private
 */
AccessibilityManager.prototype.deactivate = function()
{
	if(!this.isActive)
	{
		return;
	}

	this.isActive = false;

	window.document.removeEventListener('mousemove', this._onMouseMove);
	window.addEventListener('keydown', this._onKeyDown, false);

	this.renderer.off('postrender', this.update);

	this.div.parentNode.removeChild(this.div);

};

/**
 * This recursive function will run throught he scene graph and add any new accessible objects to the DOM layer.
 * @param element {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} the DisplayObject to check.
 * @private
 */
AccessibilityManager.prototype.updateAccessibleObjects = function(displayObject)
{
	if(!displayObject.visible)
	{
		return;
	}

	if(displayObject.accessible && displayObject.interactive)
	{
		if(!displayObject._accessibleActive)
		{
			this.addChild(displayObject);
		}
	   	
	   	displayObject.renderId = this.renderId;
	}

	var children = displayObject.children;

	for (var i = children.length - 1; i >= 0; i--) {
		
		this.updateAccessibleObjects(children[i]);
	}
};


/**
 * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects
 * @private
 */
AccessibilityManager.prototype.update = function()
{

	// update children...
	this.updateAccessibleObjects(this.renderer._lastObjectRendered);

	var rect = this.renderer.view.getBoundingClientRect();
	var sx = rect.width  / this.renderer.width;
	var sy = rect.height / this.renderer.height;

	var div = this.div;

	div.style.left = rect.left + 'px';
	div.style.top = rect.top + 'px';
	div.style.width = this.renderer.width + 'px';
	div.style.height = this.renderer.height + 'px';

	for (var i = 0; i < this.children.length; i++)
	{

		var child = this.children[i];

		if(child.renderId !== this.renderId)
		{
			child._accessibleActive = false;

            core.utils.removeItems(this.children, i, 1);
			this.div.removeChild( child._accessibleDiv );
			this.pool.push(child._accessibleDiv);
			child._accessibleDiv = null;

			i--;

			if(this.children.length === 0)
			{
				this.deactivate();
			}
		}
		else
		{
			// map div to display..
			div = child._accessibleDiv;
			var hitArea = child.hitArea;
			var wt = child.worldTransform;

			if(child.hitArea)
			{
				div.style.left = ((wt.tx + (hitArea.x * wt.a)) * sx) + 'px';
				div.style.top =  ((wt.ty + (hitArea.y * wt.d)) * sy) +  'px';

				div.style.width = (hitArea.width * wt.a * sx) + 'px';
				div.style.height = (hitArea.height * wt.d * sy) + 'px';
			
			}
			else
			{
				hitArea = child.getBounds();

				this.capHitArea(hitArea);

				div.style.left = (hitArea.x * sx) + 'px';
				div.style.top =  (hitArea.y * sy) +  'px';

				div.style.width = (hitArea.width * sx) + 'px';
				div.style.height = (hitArea.height * sy) + 'px';
			}		
		}
	}

	// increment the render id..
	this.renderId++;
};

AccessibilityManager.prototype.capHitArea = function (hitArea)
{
    if (hitArea.x < 0)
    {
        hitArea.width += hitArea.x;
        hitArea.x = 0;
    }

    if (hitArea.y < 0)
    {
        hitArea.height += hitArea.y;
        hitArea.y = 0;
    }

    if ( hitArea.x + hitArea.width > this.renderer.width )
    {
        hitArea.width = this.renderer.width - hitArea.x;
    }

    if ( hitArea.y + hitArea.height > this.renderer.height )
    {
        hitArea.height = this.renderer.height - hitArea.y;
    }
};


/**
 * Adds a DisplayObject to the accessibility manager
 * @private
 */
AccessibilityManager.prototype.addChild = function(displayObject)
{
//	this.activate();
	
	var div = this.pool.pop();

	if(!div)
	{
		div = document.createElement('button'); 

	    div.style.width = 100 + 'px';
	    div.style.height = 100 + 'px';
	    div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';
	    div.style.position = 'absolute';
	    div.style.zIndex = 2;
	    div.style.borderStyle = 'none';

	    
	    div.addEventListener('click', this._onClick.bind(this));
	    div.addEventListener('focus', this._onFocus.bind(this));
	    div.addEventListener('focusout', this._onFocusOut.bind(this));
	}
	   	



	div.title = displayObject.accessibleTitle || 'displayObject ' + this.tabIndex;

	//
	
	displayObject._accessibleActive = true;
	displayObject._accessibleDiv = div;
	div.displayObject = displayObject;


	this.children.push(displayObject);
	this.div.appendChild( displayObject._accessibleDiv );
	displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
};


/**
 * Maps the div button press to pixi's InteractionManager (click)
 * @private
 */
AccessibilityManager.prototype._onClick = function(e)
{
	var interactionManager = this.renderer.plugins.interaction;
	interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData);
};

/**
 * Maps the div focus events to pixis InteractionManager (mouseover)
 * @private
 */
AccessibilityManager.prototype._onFocus = function(e)
{
	var interactionManager = this.renderer.plugins.interaction;
	interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData);
};

/**
 * Maps the div focus events to pixis InteractionManager (mouseout)
 * @private
 */
AccessibilityManager.prototype._onFocusOut = function(e)
{
	var interactionManager = this.renderer.plugins.interaction;
	interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData);
};

/**
 * Is called when a key is pressed
 *
 * @private
 */
AccessibilityManager.prototype._onKeyDown = function(e)
{
	if(e.keyCode !== 9)
	{
		return;
	}

	this.activate();
};

/**
 * Is called when the mouse moves across the renderer element
 *
 * @private
 */
AccessibilityManager.prototype._onMouseMove = function()
{
	this.deactivate();
};


/**
 * Destroys the accessibility manager
 *
 */
AccessibilityManager.prototype.destroy = function () 
{
	this.div = null;

	for (var i = 0; i < this.children.length; i++)
	{
		this.children[i].div = null;
	}

	
	window.document.removeEventListener('mousemove', this._onMouseMove);
	window.removeEventListener('keydown', this._onKeyDown);
		
	this.pool = null;
	this.children = null;
	this.renderer = null;

};

core.WebGLRenderer.registerPlugin('accessibility', AccessibilityManager);
core.CanvasRenderer.registerPlugin('accessibility', AccessibilityManager);


},{"../core":30,"./accessibleTarget":21}],21:[function(require,module,exports){
/**
 * Default property values of accessible objects
 * used by {@link PIXI.accessibility.AccessibilityManager}.
 *
 * @mixin
 * @memberof PIXI
 * @example
 *      function MyObject() {}
 *
 *      Object.assign(
 *          MyObject.prototype,
 *          PIXI.accessibility.accessibleTarget
 *      );
 */
var accessibleTarget = {
    
    /**
     * @todo Needs docs.
     */
    accessible:false,

    /**
     * @todo Needs docs.
     */
    accessibleTitle:null,

    /**
     * @todo Needs docs.
     */
    tabIndex:0,

    /**
     * @todo Needs docs.
     */
    _accessibleActive:false,

    /**
     * @todo Needs docs.
     */
    _accessibleDiv:false

};

module.exports = accessibleTarget;

},{}],22:[function(require,module,exports){
/**
 * @file        Main export of the PIXI accessibility library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.interaction
 */
module.exports = {
    accessibleTarget:     require('./accessibleTarget'),
    AccessibilityManager: require('./AccessibilityManager')
};

},{"./AccessibilityManager":20,"./accessibleTarget":21}],23:[function(require,module,exports){
/**
 * Constant values used in pixi
 *
 * @lends PIXI
 */
var CONST = {
    /**
     * String of the current PIXI version
     *
     * @static
     * @constant
     * @property {string} VERSION
     */
    VERSION: require('../../package.json').version,

    /**
     * @property {number} PI_2 - Two Pi
     * @constant
     * @static
     */
    PI_2: Math.PI * 2,

    /**
     * @property {number} RAD_TO_DEG - Constant conversion factor for converting radians to degrees
     * @constant
     * @static
     */
    RAD_TO_DEG: 180 / Math.PI,

    /**
     * @property {Number} DEG_TO_RAD - Constant conversion factor for converting degrees to radians
     * @constant
     * @static
     */
    DEG_TO_RAD: Math.PI / 180,

    /**
     * Target frames per millisecond.
     *
     * @static
     * @constant
     * @property {number} TARGET_FPMS=0.06
     */
    TARGET_FPMS: 0.06,

    /**
     * Constant to identify the Renderer Type.
     *
     * @static
     * @constant
     * @property {object} RENDERER_TYPE
     * @property {number} RENDERER_TYPE.UNKNOWN
     * @property {number} RENDERER_TYPE.WEBGL
     * @property {number} RENDERER_TYPE.CANVAS
     */
    RENDERER_TYPE: {
        UNKNOWN:    0,
        WEBGL:      1,
        CANVAS:     2
    },

    /**
     * Various blend modes supported by PIXI. IMPORTANT - The WebGL renderer only supports
     * the NORMAL, ADD, MULTIPLY and SCREEN blend modes. Anything else will silently act like
     * NORMAL.
     *
     * @static
     * @constant
     * @property {object} BLEND_MODES
     * @property {number} BLEND_MODES.NORMAL
     * @property {number} BLEND_MODES.ADD
     * @property {number} BLEND_MODES.MULTIPLY
     * @property {number} BLEND_MODES.SCREEN
     * @property {number} BLEND_MODES.OVERLAY
     * @property {number} BLEND_MODES.DARKEN
     * @property {number} BLEND_MODES.LIGHTEN
     * @property {number} BLEND_MODES.COLOR_DODGE
     * @property {number} BLEND_MODES.COLOR_BURN
     * @property {number} BLEND_MODES.HARD_LIGHT
     * @property {number} BLEND_MODES.SOFT_LIGHT
     * @property {number} BLEND_MODES.DIFFERENCE
     * @property {number} BLEND_MODES.EXCLUSION
     * @property {number} BLEND_MODES.HUE
     * @property {number} BLEND_MODES.SATURATION
     * @property {number} BLEND_MODES.COLOR
     * @property {number} BLEND_MODES.LUMINOSITY
     */
    BLEND_MODES: {
        NORMAL:         0,
        ADD:            1,
        MULTIPLY:       2,
        SCREEN:         3,
        OVERLAY:        4,
        DARKEN:         5,
        LIGHTEN:        6,
        COLOR_DODGE:    7,
        COLOR_BURN:     8,
        HARD_LIGHT:     9,
        SOFT_LIGHT:     10,
        DIFFERENCE:     11,
        EXCLUSION:      12,
        HUE:            13,
        SATURATION:     14,
        COLOR:          15,
        LUMINOSITY:     16
    },

    /**
     * Various webgl draw modes. These can be used to specify which GL drawMode to use
     * under certain situations and renderers.
     *
     * @static
     * @constant
     * @property {object} DRAW_MODES
     * @property {number} DRAW_MODES.POINTS
     * @property {number} DRAW_MODES.LINES
     * @property {number} DRAW_MODES.LINE_LOOP
     * @property {number} DRAW_MODES.LINE_STRIP
     * @property {number} DRAW_MODES.TRIANGLES
     * @property {number} DRAW_MODES.TRIANGLE_STRIP
     * @property {number} DRAW_MODES.TRIANGLE_FAN
     */
    DRAW_MODES: {
        POINTS:         0,
        LINES:          1,
        LINE_LOOP:      2,
        LINE_STRIP:     3,
        TRIANGLES:      4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN:   6
    },

    /**
     * The scale modes that are supported by pixi.
     *
     * The DEFAULT scale mode affects the default scaling mode of future operations.
     * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
     *
     * @static
     * @constant
     * @property {object} SCALE_MODES
     * @property {number} SCALE_MODES.DEFAULT=LINEAR
     * @property {number} SCALE_MODES.LINEAR Smooth scaling
     * @property {number} SCALE_MODES.NEAREST Pixelating scaling
     */
    SCALE_MODES: {
        DEFAULT:    0,
        LINEAR:     0,
        NEAREST:    1
    },

    /**
     * The prefix that denotes a URL is for a retina asset
     *
     * @static
     * @constant
     * @property {string} RETINA_PREFIX
     */
    //example: '@2x',
    RETINA_PREFIX: /@(.+)x/,

    RESOLUTION:1,

    FILTER_RESOLUTION:1,

    /**
     * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
     * or {@link PIXI.CanvasRenderer}.
     *
     * @static
     * @constant
     * @property {object} DEFAULT_RENDER_OPTIONS
     * @property {HTMLCanvasElement} DEFAULT_RENDER_OPTIONS.view=null
     * @property {boolean} DEFAULT_RENDER_OPTIONS.transparent=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.antialias=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.forceFXAA=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.preserveDrawingBuffer=false
     * @property {number} DEFAULT_RENDER_OPTIONS.resolution=1
     * @property {number} DEFAULT_RENDER_OPTIONS.backgroundColor=0x000000
     * @property {boolean} DEFAULT_RENDER_OPTIONS.clearBeforeRender=true
     * @property {boolean} DEFAULT_RENDER_OPTIONS.autoResize=false
     */
    DEFAULT_RENDER_OPTIONS: {
        view: null,
        resolution: 1,
        antialias: false,
        forceFXAA: false,
        autoResize: false,
        transparent: false,
        backgroundColor: 0x000000,
        clearBeforeRender: true,
        preserveDrawingBuffer: false,
        roundPixels: false
    },

    /**
     * Constants that identify shapes, mainly to prevent `instanceof` calls.
     *
     * @static
     * @constant
     * @property {object} SHAPES
     * @property {object} SHAPES.POLY=0
     * @property {object} SHAPES.RECT=1
     * @property {object} SHAPES.CIRC=2
     * @property {object} SHAPES.ELIP=3
     * @property {object} SHAPES.RREC=4
     */
    SHAPES: {
        POLY: 0,
        RECT: 1,
        CIRC: 2,
        ELIP: 3,
        RREC: 4
    },

    // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
    // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
    SPRITE_BATCH_SIZE: 2000 //nice balance between mobile and desktop machines
};

module.exports = CONST;

},{"../../package.json":19}],24:[function(require,module,exports){
var math = require('../math'),
    utils = require('../utils'),
    DisplayObject = require('./DisplayObject'),
    RenderTexture = require('../textures/RenderTexture'),
    _tempMatrix = new math.Matrix();

/**
 * A Container represents a collection of display objects.
 * It is the base class of all display objects that act as a container for other objects.
 *
 *```js
 * var container = new PIXI.Container();
 * container.addChild(sprite);
 * ```
 * @class
 * @extends PIXI.DisplayObject
 * @memberof PIXI
 */
function Container()
{
    DisplayObject.call(this);

    /**
     * The array of children of this container.
     *
     * @member {PIXI.DisplayObject[]}
     * @readonly
     */
    this.children = [];
}

// constructor
Container.prototype = Object.create(DisplayObject.prototype);
Container.prototype.constructor = Container;
module.exports = Container;

Object.defineProperties(Container.prototype, {
    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Container#
     */
    width: {
        get: function ()
        {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function (value)
        {

            var width = this.getLocalBounds().width;

            if (width !== 0)
            {
                this.scale.x = value / width;
            }
            else
            {
                this.scale.x = 1;
            }


            this._width = value;
        }
    },

    /**
     * The height of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Container#
     */
    height: {
        get: function ()
        {
            return  this.scale.y * this.getLocalBounds().height;
        },
        set: function (value)
        {

            var height = this.getLocalBounds().height;

            if (height !== 0)
            {
                this.scale.y = value / height ;
            }
            else
            {
                this.scale.y = 1;
            }

            this._height = value;
        }
    }
});

/**
 * Overridable method that can be used by Container subclasses whenever the children array is modified
 *
 * @private
 */
Container.prototype.onChildrenChange = function () {};

/**
 * Adds a child to the container.
 * 
 * You can also add multple items like so: myContainer.addChild(thinkOne, thingTwo, thingThree)
 * @param child {PIXI.DisplayObject} The DisplayObject to add to the container
 * @return {PIXI.DisplayObject} The child that was added.
 */
Container.prototype.addChild = function (child)
{ 
    var argumentsLength = arguments.length;

    // if there is only one argument we can bypass looping through the them
    if(argumentsLength > 1)
    {
        // loop through the arguments property and add all children
        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
        for (var i = 0; i < argumentsLength; i++)
        {
            this.addChild( arguments[i] );
        }
    }     
    else
    {
        // if the child has a parent then lets remove it as Pixi objects can only exist in one place
        if (child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;
        
        this.children.push(child);

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(this.children.length-1);
        child.emit('added', this);
    }

    return child;
};

/**
 * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
 *
 * @param child {PIXI.DisplayObject} The child to add
 * @param index {number} The index to place the child in
 * @return {PIXI.DisplayObject} The child that was added.
 */
Container.prototype.addChildAt = function (child, index)
{
    if (index >= 0 && index <= this.children.length)
    {
        if (child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('added', this);

        return child;
    }
    else
    {
        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);
    }
};

/**
 * Swaps the position of 2 Display Objects within this container.
 *
 * @param child {PIXI.DisplayObject}
 * @param child2 {PIXI.DisplayObject}
 */
Container.prototype.swapChildren = function (child, child2)
{
    if (child === child2)
    {
        return;
    }

    var index1 = this.getChildIndex(child);
    var index2 = this.getChildIndex(child2);

    if (index1 < 0 || index2 < 0)
    {
        throw new Error('swapChildren: Both the supplied DisplayObjects must be children of the caller.');
    }

    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
};

/**
 * Returns the index position of a child DisplayObject instance
 *
 * @param child {PIXI.DisplayObject} The DisplayObject instance to identify
 * @return {number} The index position of the child display object to identify
 */
Container.prototype.getChildIndex = function (child)
{
    var index = this.children.indexOf(child);

    if (index === -1)
    {
        throw new Error('The supplied DisplayObject must be a child of the caller');
    }

    return index;
};

/**
 * Changes the position of an existing child in the display object container
 *
 * @param child {PIXI.DisplayObject} The child DisplayObject instance for which you want to change the index number
 * @param index {number} The resulting index number for the child display object
 */
Container.prototype.setChildIndex = function (child, index)
{
    if (index < 0 || index >= this.children.length)
    {
        throw new Error('The supplied index is out of bounds');
    }

    var currentIndex = this.getChildIndex(child);

    utils.removeItems(this.children, currentIndex, 1); // remove from old position
    this.children.splice(index, 0, child); //add at new position
    this.onChildrenChange(index);
};

/**
 * Returns the child at the specified index
 *
 * @param index {number} The index to get the child at
 * @return {PIXI.DisplayObject} The child at the given index, if any.
 */
Container.prototype.getChildAt = function (index)
{
    if (index < 0 || index >= this.children.length)
    {
        throw new Error('getChildAt: Supplied index ' + index + ' does not exist in the child list, or the supplied DisplayObject is not a child of the caller');
    }

    return this.children[index];
};

/**
 * Removes a child from the container.
 *
 * @param child {PIXI.DisplayObject} The DisplayObject to remove
 * @return {PIXI.DisplayObject} The child that was removed.
 */
Container.prototype.removeChild = function (child)
{
    var argumentsLength = arguments.length;

    // if there is only one argument we can bypass looping through the them
    if(argumentsLength > 1)
    {
        // loop through the arguments property and add all children
        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
        for (var i = 0; i < argumentsLength; i++)
        {
            this.removeChild( arguments[i] );
        }
    }     
    else
    {   
        var index = this.children.indexOf(child);

        if (index === -1)
        {
            return;
        }

        child.parent = null;
        utils.removeItems(this.children, index, 1);

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('removed', this);
    }

    return child;
};

/**
 * Removes a child from the specified index position.
 *
 * @param index {number} The index to get the child from
 * @return {PIXI.DisplayObject} The child that was removed.
 */
Container.prototype.removeChildAt = function (index)
{
    var child = this.getChildAt(index);

    child.parent = null;
    utils.removeItems(this.children, index, 1);

    // TODO - lets either do all callbacks or all events.. not both!
    this.onChildrenChange(index);
    child.emit('removed', this);

    return child;
};

/**
 * Removes all children from this container that are within the begin and end indexes.
 *
 * @param beginIndex {number} The beginning position. Default value is 0.
 * @param endIndex {number} The ending position. Default value is size of the container.
 */
Container.prototype.removeChildren = function (beginIndex, endIndex)
{
    var begin = beginIndex || 0;
    var end = typeof endIndex === 'number' ? endIndex : this.children.length;
    var range = end - begin;
    var removed, i;

    if (range > 0 && range <= end)
    {
        removed = this.children.splice(begin, range);

        for (i = 0; i < removed.length; ++i)
        {
            removed[i].parent = null;
        }

        this.onChildrenChange(beginIndex);

        for (i = 0; i < removed.length; ++i)
        {
            removed[i].emit('removed', this);
        }

        return removed;
    }
    else if (range === 0 && this.children.length === 0)
    {
        return [];
    }
    else
    {
        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    }
};

/**
 * Useful function that returns a texture of the display object that can then be used to create sprites
 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
 *
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used to generate the texture.
 * @param resolution {number} The resolution of the texture being generated
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} a texture of the display object
 */
Container.prototype.generateTexture = function (renderer, resolution, scaleMode)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);

    _tempMatrix.tx = -bounds.x;
    _tempMatrix.ty = -bounds.y;

    renderTexture.render(this, _tempMatrix);

    return renderTexture;
};

/*
 * Updates the transform on all children of this container for rendering
 *
 * @private
 */
Container.prototype.updateTransform = function ()
{
    if (!this.visible)
    {
        return;
    }

    this.displayObjectUpdateTransform();

    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].updateTransform();
    }
};

// performance increase to avoid using call.. (10x faster)
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

/**
 * Retrieves the bounds of the Container as a rectangle. The bounds calculation takes all visible children into consideration.
 *
 * @return {PIXI.Rectangle} The rectangular bounding area
 */
Container.prototype.getBounds = function ()
{
    if(!this._currentBounds)
    {

        if (this.children.length === 0)
        {
            return math.Rectangle.EMPTY;
        }

        // TODO the bounds have already been calculated this render session so return what we have

        var minX = Infinity;
        var minY = Infinity;

        var maxX = -Infinity;
        var maxY = -Infinity;

        var childBounds;
        var childMaxX;
        var childMaxY;

        var childVisible = false;

        for (var i = 0, j = this.children.length; i < j; ++i)
        {
            var child = this.children[i];

            if (!child.visible)
            {
                continue;
            }

            childVisible = true;

            childBounds = this.children[i].getBounds();

            minX = minX < childBounds.x ? minX : childBounds.x;
            minY = minY < childBounds.y ? minY : childBounds.y;

            childMaxX = childBounds.width + childBounds.x;
            childMaxY = childBounds.height + childBounds.y;

            maxX = maxX > childMaxX ? maxX : childMaxX;
            maxY = maxY > childMaxY ? maxY : childMaxY;
        }

        if (!childVisible)
        {
            return math.Rectangle.EMPTY;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.y = minY;
        bounds.width = maxX - minX;
        bounds.height = maxY - minY;

        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

Container.prototype.containerGetBounds = Container.prototype.getBounds;

/**
 * Retrieves the non-global local bounds of the Container as a rectangle.
 * The calculation takes all visible children into consideration.
 *
 * @return {PIXI.Rectangle} The rectangular bounding area
 */
Container.prototype.getLocalBounds = function ()
{
    var matrixCache = this.worldTransform;

    this.worldTransform = math.Matrix.IDENTITY;

    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].updateTransform();
    }

    this.worldTransform = matrixCache;

    this._currentBounds = null;

    return this.getBounds( math.Matrix.IDENTITY );
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer
 */
Container.prototype.renderWebGL = function (renderer)
{

    // if the object is not visible or the alpha is 0 then no need to render this element
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
    {
        return;
    }

    var i, j;

    // do a quick check to see if this element has a mask or a filter.
    if (this._mask || this._filters)
    {
        renderer.currentRenderer.flush();

        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (this._filters && this._filters.length)
        {
            renderer.filterManager.pushFilter(this, this._filters);
        }

        if (this._mask)
        {
            renderer.maskManager.pushMask(this, this._mask);
        }

        renderer.currentRenderer.start();

        // add this object to the batch, only rendered if it has a texture.
        this._renderWebGL(renderer);

        // now loop through the children and make sure they get rendered
        for (i = 0, j = this.children.length; i < j; i++)
        {
            this.children[i].renderWebGL(renderer);
        }

        renderer.currentRenderer.flush();

        if (this._mask)
        {
            renderer.maskManager.popMask(this, this._mask);
        }

        if (this._filters)
        {
            renderer.filterManager.popFilter();

        }
        renderer.currentRenderer.start();
    }
    else
    {
        this._renderWebGL(renderer);

        // simple render children!
        for (i = 0, j = this.children.length; i < j; ++i)
        {
            this.children[i].renderWebGL(renderer);
        }
    }
};

/**
 * To be overridden by the subclass
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer
 * @private
 */
Container.prototype._renderWebGL = function (renderer) // jshint unused:false
{
    // this is where content itself gets rendered...
};

/**
 * To be overridden by the subclass
 *
 * @param renderer {PIXI.CanvasRenderer} The renderer
 * @private
 */
Container.prototype._renderCanvas = function (renderer) // jshint unused:false
{
    // this is where content itself gets rendered...
};


/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer} The renderer
 */
Container.prototype.renderCanvas = function (renderer)
{
    // if not visible or the alpha is 0 then no need to render this
    if (!this.visible || this.alpha <= 0 || !this.renderable)
    {
        return;
    }

    if (this._mask)
    {
        renderer.maskManager.pushMask(this._mask, renderer);
    }

    this._renderCanvas(renderer);
    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].renderCanvas(renderer);
    }

    if (this._mask)
    {
        renderer.maskManager.popMask(renderer);
    }
};

/**
 * Destroys the container
 * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well
 */
Container.prototype.destroy = function (destroyChildren)
{
    DisplayObject.prototype.destroy.call(this);

    if (destroyChildren)
    {
        for (var i = 0, j = this.children.length; i < j; ++i)
        {
            this.children[i].destroy(destroyChildren);
        }
    }

    this.removeChildren();

    this.children = null;
};

},{"../math":33,"../textures/RenderTexture":71,"../utils":77,"./DisplayObject":25}],25:[function(require,module,exports){
var math = require('../math'),
    RenderTexture = require('../textures/RenderTexture'),
    EventEmitter = require('eventemitter3'),
    CONST = require('../const'),
    _tempMatrix = new math.Matrix(),
    _tempDisplayObjectParent = {worldTransform:new math.Matrix(), worldAlpha:1, children:[]};


/**
 * The base class for all objects that are rendered on the screen.
 * This is an abstract class and should not be used on its own rather it should be extended.
 *
 * @class
 * @extends EventEmitter
 * @memberof PIXI
 */
function DisplayObject()
{
    EventEmitter.call(this);

    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     *
     * @member {PIXI.Point}
     */
    this.position = new math.Point();

    /**
     * The scale factor of the object.
     *
     * @member {PIXI.Point}
     */
    this.scale = new math.Point(1, 1);

    /**
     * The pivot point of the displayObject that it rotates around
     *
     * @member {PIXI.Point}
     */
    this.pivot = new math.Point(0, 0);


    /**
     * The skew factor for the object in radians.
     *
     * @member {PIXI.Point}
     */
    this.skew = new math.Point(0, 0);

    /**
     * The rotation of the object in radians.
     *
     * @member {number}
     */
    this.rotation = 0;

    /**
     * The opacity of the object.
     *
     * @member {number}
     */
    this.alpha = 1;

    /**
     * The visibility of the object. If false the object will not be drawn, and
     * the updateTransform function will not be called.
     *
     * @member {boolean}
     */
    this.visible = true;

    /**
     * Can this object be rendered, if false the object will not be drawn but the updateTransform
     * methods will still be called.
     *
     * @member {boolean}
     */
    this.renderable = true;

    /**
     * The display object container that contains this display object.
     *
     * @member {PIXI.Container}
     * @readOnly
     */
    this.parent = null;

    /**
     * The multiplied alpha of the displayObject
     *
     * @member {number}
     * @readOnly
     */
    this.worldAlpha = 1;

    /**
     * Current transform of the object based on world (parent) factors
     *
     * @member {PIXI.Matrix}
     * @readOnly
     */
    this.worldTransform = new math.Matrix();

    /**
     * The area the filter is applied to. This is used as more of an optimisation
     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
     *
     * @member {PIXI.Rectangle}
     */
    this.filterArea = null;

    /**
     * cached sin rotation
     *
     * @member {number}
     * @private
     */
    this._sr = 0;

    /**
     * cached cos rotation
     *
     * @member {number}
     * @private
     */
    this._cr = 1;

    /**
     * The original, cached bounds of the object
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._bounds = new math.Rectangle(0, 0, 1, 1);

    /**
     * The most up-to-date bounds of the object
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._currentBounds = null;

    /**
     * The original, cached mask of the object
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._mask = null;
}

// constructor
DisplayObject.prototype = Object.create(EventEmitter.prototype);
DisplayObject.prototype.constructor = DisplayObject;
module.exports = DisplayObject;

Object.defineProperties(DisplayObject.prototype, {
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     * @memberof PIXI.DisplayObject#
     */
    x: {
        get: function ()
        {
            return this.position.x;
        },
        set: function (value)
        {
            this.position.x = value;
        }
    },

    /**
     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
     *
     * @member {number}
     * @memberof PIXI.DisplayObject#
     */
    y: {
        get: function ()
        {
            return this.position.y;
        },
        set: function (value)
        {
            this.position.y = value;
        }
    },

    /**
     * Indicates if the sprite is globally visible.
     *
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     * @readonly
     */
    worldVisible: {
        get: function ()
        {
            var item = this;

            do {
                if (!item.visible)
                {
                    return false;
                }

                item = item.parent;
            } while (item);

            return true;
        }
    },

    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.
     * In PIXI a regular mask must be a PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it utilises shape clipping.
     * To remove a mask, set this property to null.
     *
     * @member {PIXI.Graphics|PIXI.Sprite}
     * @memberof PIXI.DisplayObject#
     */
    mask: {
        get: function ()
        {
            return this._mask;
        },
        set: function (value)
        {
            if (this._mask)
            {
                this._mask.renderable = true;
            }

            this._mask = value;

            if (this._mask)
            {
                this._mask.renderable = false;
            }
        }
    },

    /**
     * Sets the filters for the displayObject.
     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
     * To remove filters simply set this property to 'null'
     *
     * @member {PIXI.AbstractFilter[]}
     * @memberof PIXI.DisplayObject#
     */
    filters: {
        get: function ()
        {
            return this._filters && this._filters.slice();
        },
        set: function (value)
        {
            this._filters = value && value.slice();
        }
    }

});

/*
 * Updates the object transform for rendering
 *
 * TODO - Optimization pass!
 */
DisplayObject.prototype.updateTransform = function ()
{
    // create some matrix refs for easy access
    var pt = this.parent.worldTransform;
    var wt = this.worldTransform;

    // temporary matrix variables
    var a, b, c, d, tx, ty;

    // looks like we are skewing
    if(this.skew.x || this.skew.y)
    {
        // I'm assuming that skewing is not going to be very common
        // With that in mind, we can do a full setTransform using the temp matrix
        _tempMatrix.setTransform(
            this.position.x,
            this.position.y,
            this.pivot.x,
            this.pivot.y,
            this.scale.x,
            this.scale.y,
            this.rotation,
            this.skew.x,
            this.skew.y
        );

        // now concat the matrix (inlined so that we can avoid using copy)
        wt.a  = _tempMatrix.a  * pt.a + _tempMatrix.b  * pt.c;
        wt.b  = _tempMatrix.a  * pt.b + _tempMatrix.b  * pt.d;
        wt.c  = _tempMatrix.c  * pt.a + _tempMatrix.d  * pt.c;
        wt.d  = _tempMatrix.c  * pt.b + _tempMatrix.d  * pt.d;
        wt.tx = _tempMatrix.tx * pt.a + _tempMatrix.ty * pt.c + pt.tx;
        wt.ty = _tempMatrix.tx * pt.b + _tempMatrix.ty * pt.d + pt.ty;
    }
    else
    {
        // so if rotation is between 0 then we can simplify the multiplication process...
        if (this.rotation % CONST.PI_2)
        {
            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
            if (this.rotation !== this.rotationCache)
            {
                this.rotationCache = this.rotation;
                this._sr = Math.sin(this.rotation);
                this._cr = Math.cos(this.rotation);
            }

            // get the matrix values of the displayobject based on its transform properties..
            a  =  this._cr * this.scale.x;
            b  =  this._sr * this.scale.x;
            c  = -this._sr * this.scale.y;
            d  =  this._cr * this.scale.y;
            tx =  this.position.x;
            ty =  this.position.y;

            // check for pivot.. not often used so geared towards that fact!
            if (this.pivot.x || this.pivot.y)
            {
                tx -= this.pivot.x * a + this.pivot.y * c;
                ty -= this.pivot.x * b + this.pivot.y * d;
            }

            // concat the parent matrix with the objects transform.
            wt.a  = a  * pt.a + b  * pt.c;
            wt.b  = a  * pt.b + b  * pt.d;
            wt.c  = c  * pt.a + d  * pt.c;
            wt.d  = c  * pt.b + d  * pt.d;
            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        }
        else
        {
            // lets do the fast version as we know there is no rotation..
            a  = this.scale.x;
            d  = this.scale.y;

            tx = this.position.x - this.pivot.x * a;
            ty = this.position.y - this.pivot.y * d;

            wt.a  = a  * pt.a;
            wt.b  = a  * pt.b;
            wt.c  = d  * pt.c;
            wt.d  = d  * pt.d;
            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        }
    }

    // multiply the alphas..
    this.worldAlpha = this.alpha * this.parent.worldAlpha;

    // reset the bounds each time this is called!
    this._currentBounds = null;
};

// performance increase to avoid using call.. (10x faster)
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

/**
 *
 *
 * Retrieves the bounds of the displayObject as a rectangle object
 *
 * @param matrix {PIXI.Matrix}
 * @return {PIXI.Rectangle} the rectangular bounding area
 */
DisplayObject.prototype.getBounds = function (matrix) // jshint unused:false
{
    return math.Rectangle.EMPTY;
};

/**
 * Retrieves the local bounds of the displayObject as a rectangle object
 *
 * @return {PIXI.Rectangle} the rectangular bounding area
 */
DisplayObject.prototype.getLocalBounds = function ()
{
    return this.getBounds(math.Matrix.IDENTITY);
};

/**
 * Calculates the global position of the display object
 *
 * @param position {PIXI.Point} The world origin to calculate from
 * @return {PIXI.Point} A point object representing the position of this object
 */
DisplayObject.prototype.toGlobal = function (position)
{
    // this parent check is for just in case the item is a root object.
    // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
    // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
    if(!this.parent)
    {
        this.parent = _tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
    }
    else
    {
        this.displayObjectUpdateTransform();
    }

    // don't need to update the lot
    return this.worldTransform.apply(position);
};

/**
 * Calculates the local position of the display object relative to another point
 *
 * @param position {PIXI.Point} The world origin to calculate from
 * @param [from] {PIXI.DisplayObject} The DisplayObject to calculate the global position from
 * @param [point] {PIXI.Point} A Point object in which to store the value, optional (otherwise will create a new Point)
 * @return {PIXI.Point} A point object representing the position of this object
 */
DisplayObject.prototype.toLocal = function (position, from, point)
{
    if (from)
    {
        position = from.toGlobal(position);
    }

    // this parent check is for just in case the item is a root object.
    // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
    // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
    if(!this.parent)
    {
        this.parent = _tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
    }
    else
    {
        this.displayObjectUpdateTransform();
    }

    // simply apply the matrix..
    return this.worldTransform.applyInverse(position, point);
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer
 * @private
 */
DisplayObject.prototype.renderWebGL = function (renderer) // jshint unused:false
{
    // OVERWRITE;
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer} The renderer
 * @private
 */
DisplayObject.prototype.renderCanvas = function (renderer) // jshint unused:false
{
    // OVERWRITE;
};
/**
 * Useful function that returns a texture of the display object that can then be used to create sprites
 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
 *
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used to generate the texture.
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @param resolution {number} The resolution of the texture being generated
 * @return {PIXI.Texture} a texture of the display object
 */
DisplayObject.prototype.generateTexture = function (renderer, scaleMode, resolution)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);

    _tempMatrix.tx = -bounds.x;
    _tempMatrix.ty = -bounds.y;

    renderTexture.render(this, _tempMatrix);

    return renderTexture;
};

/**
 * Set the parent Container of this DisplayObject
 *
 * @param container {Container} The Container to add this DisplayObject to
 * @return {Container} The Container that this DisplayObject was added to
 */
DisplayObject.prototype.setParent = function (container)
{
    if (!container || !container.addChild)
    {
        throw new Error('setParent: Argument must be a Container');
    }

    container.addChild(this);
    return container;
};

/**
 * Convenience function to set the postion, scale, skew and pivot at once.
 *
 * @param [x=0] {number} The X position
 * @param [y=0] {number} The Y position
 * @param [scaleX=1] {number} The X scale value
 * @param [scaleY=1] {number} The Y scale value
 * @param [rotation=0] {number} The rotation
 * @param [skewX=0] {number} The X skew value
 * @param [skewY=0] {number} The Y skew value
 * @param [pivotX=0] {number} The X pivot value
 * @param [pivotY=0] {number} The Y pivot value
 * @return {PIXI.DisplayObject}
 */
DisplayObject.prototype.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) //jshint ignore:line
{
    this.position.x = x || 0;
    this.position.y = y || 0;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation || 0;
    this.skew.x = skewX || 0;
    this.skew.y = skewY || 0;
    this.pivot.x = pivotX || 0;
    this.pivot.y = pivotY || 0;
    return this;
};

/**
 * Base destroy method for generic display objects
 *
 */
DisplayObject.prototype.destroy = function ()
{

    this.position = null;
    this.scale = null;
    this.pivot = null;
    this.skew = null;

    this.parent = null;

    this._bounds = null;
    this._currentBounds = null;
    this._mask = null;

    this.worldTransform = null;
    this.filterArea = null;
};

},{"../const":23,"../math":33,"../textures/RenderTexture":71,"eventemitter3":10}],26:[function(require,module,exports){
var Container = require('../display/Container'),
    Texture = require('../textures/Texture'),
    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),
    CanvasGraphics = require('../renderers/canvas/utils/CanvasGraphics'),
    GraphicsData = require('./GraphicsData'),
    math = require('../math'),
    CONST = require('../const'),
    tempPoint = new math.Point();

/**
 * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
 * rectangles to the display, and to color and fill them.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 */
function Graphics()
{
    Container.call(this);

    /**
     * The alpha value used when filling the Graphics object.
     *
     * @member {number}
     * @default 1
     */
    this.fillAlpha = 1;

    /**
     * The width (thickness) of any lines drawn.
     *
     * @member {number}
     * @default 0
     */
    this.lineWidth = 0;

    /**
     * The color of any lines drawn.
     *
     * @member {string}
     * @default 0
     */
    this.lineColor = 0;

    /**
     * Graphics data
     *
     * @member {PIXI.GraphicsData[]}
     * @private
     */
    this.graphicsData = [];

    /**
     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;

    /**
     * The previous tint applied to the graphic shape. Used to compare to the current tint and check if theres change.
     *
     * @member {number}
     * @private
     * @default 0xFFFFFF
     */
    this._prevTint = 0xFFFFFF;

    /**
     * The blend mode to be applied to the graphic shape. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    this.blendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * Current path
     *
     * @member {PIXI.GraphicsData}
     * @private
     */
    this.currentPath = null;

    /**
     * Array containing some WebGL-related properties used by the WebGL renderer.
     *
     * @member {object<number, object>}
     * @private
     */
    // TODO - _webgl should use a prototype object, not a random undocumented object...
    this._webGL = {};

    /**
     * Whether this shape is being used as a mask.
     *
     * @member {boolean}
     */
    this.isMask = false;

    /**
     * The bounds' padding used for bounds calculation.
     *
     * @member {number}
     */
    this.boundsPadding = 0;

    /**
     * A cache of the local bounds to prevent recalculation.
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._localBounds = new math.Rectangle(0,0,1,1);

    /**
     * Used to detect if the graphics object has changed. If this is set to true then the graphics
     * object will be recalculated.
     *
     * @member {boolean}
     * @private
     */
    this.dirty = true;

    /**
     * Used to detect if the WebGL graphics object has changed. If this is set to true then the
     * graphics object will be recalculated.
     *
     * @member {boolean}
     * @private
     */
    this.glDirty = false;

    this.boundsDirty = true;

    /**
     * Used to detect if the cached sprite object needs to be updated.
     *
     * @member {boolean}
     * @private
     */
    this.cachedSpriteDirty = false;

    /**
     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
     * This is useful if your graphics element does not change often, as it will speed up the rendering
     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
     * you are constantly redrawing the graphics element.
     *
     * @name cacheAsBitmap
     * @member {boolean}
     * @memberof PIXI.Graphics#
     * @default false
     */
}

// constructor
Graphics.prototype = Object.create(Container.prototype);
Graphics.prototype.constructor = Graphics;
module.exports = Graphics;

/**
 * Creates a new Graphics object with the same values as this one.
 * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
 *
 * @return {PIXI.Graphics}
 */
Graphics.prototype.clone = function ()
{
    var clone = new Graphics();

    clone.renderable    = this.renderable;
    clone.fillAlpha     = this.fillAlpha;
    clone.lineWidth     = this.lineWidth;
    clone.lineColor     = this.lineColor;
    clone.tint          = this.tint;
    clone.blendMode     = this.blendMode;
    clone.isMask        = this.isMask;
    clone.boundsPadding = this.boundsPadding;
    clone.dirty         = true;
    clone.glDirty       = true;
    clone.cachedSpriteDirty = this.cachedSpriteDirty;

    // copy graphics data
    for (var i = 0; i < this.graphicsData.length; ++i)
    {
        clone.graphicsData.push(this.graphicsData[i].clone());
    }

    clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];

    clone.updateLocalBounds();

    return clone;
};

/**
 * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.
 *
 * @param lineWidth {number} width of the line to draw, will update the objects stored style
 * @param color {number} color of the line to draw, will update the objects stored style
 * @param alpha {number} alpha of the line to draw, will update the objects stored style
 * @return {PIXI.Graphics}
 */
Graphics.prototype.lineStyle = function (lineWidth, color, alpha)
{
    this.lineWidth = lineWidth || 0;
    this.lineColor = color || 0;
    this.lineAlpha = (alpha === undefined) ? 1 : alpha;

    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length)
        {
            // halfway through a line? start a new one!
            var shape = new math.Polygon(this.currentPath.shape.points.slice(-2));
            shape.closed = false;
            this.drawShape(shape);
        }
        else
        {
            // otherwise its empty so lets just set the line properties
            this.currentPath.lineWidth = this.lineWidth;
            this.currentPath.lineColor = this.lineColor;
            this.currentPath.lineAlpha = this.lineAlpha;
        }
    }

    return this;
};

/**
 * Moves the current drawing position to x, y.
 *
 * @param x {number} the X coordinate to move to
 * @param y {number} the Y coordinate to move to
 * @return {PIXI.Graphics}
  */
Graphics.prototype.moveTo = function (x, y)
{
    var shape = new math.Polygon([x,y]);
    shape.closed = false;
    this.drawShape(shape);

    return this;
};

/**
 * Draws a line using the current line style from the current drawing position to (x, y);
 * The current drawing position is then set to (x, y).
 *
 * @param x {number} the X coordinate to draw to
 * @param y {number} the Y coordinate to draw to
 * @return {PIXI.Graphics}
 */
Graphics.prototype.lineTo = function (x, y)
{
    this.currentPath.shape.points.push(x, y);
    this.dirty = true;

    return this;
};

/**
 * Calculate the points for a quadratic bezier curve and then draws it.
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @param cpX {number} Control point x
 * @param cpY {number} Control point y
 * @param toX {number} Destination point x
 * @param toY {number} Destination point y
 * @return {PIXI.Graphics}
 */
Graphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY)
{
    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length === 0)
        {
            this.currentPath.shape.points = [0, 0];
        }
    }
    else
    {
        this.moveTo(0,0);
    }

    var xa,
        ya,
        n = 20,
        points = this.currentPath.shape.points;

    if (points.length === 0)
    {
        this.moveTo(0, 0);
    }

    var fromX = points[points.length-2];
    var fromY = points[points.length-1];

    var j = 0;
    for (var i = 1; i <= n; ++i)
    {
        j = i / n;

        xa = fromX + ( (cpX - fromX) * j );
        ya = fromY + ( (cpY - fromY) * j );

        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),
                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );
    }

    this.dirty = this.boundsDirty = true;

    return this;
};

/**
 * Calculate the points for a bezier curve and then draws it.
 *
 * @param cpX {number} Control point x
 * @param cpY {number} Control point y
 * @param cpX2 {number} Second Control point x
 * @param cpY2 {number} Second Control point y
 * @param toX {number} Destination point x
 * @param toY {number} Destination point y
 * @return {PIXI.Graphics}
 */
Graphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY)
{
    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length === 0)
        {
            this.currentPath.shape.points = [0, 0];
        }
    }
    else
    {
        this.moveTo(0,0);
    }

    var n = 20,
        dt,
        dt2,
        dt3,
        t2,
        t3,
        points = this.currentPath.shape.points;

    var fromX = points[points.length-2];
    var fromY = points[points.length-1];

    var j = 0;

    for (var i = 1; i <= n; ++i)
    {
        j = i / n;

        dt = (1 - j);
        dt2 = dt * dt;
        dt3 = dt2 * dt;

        t2 = j * j;
        t3 = t2 * j;

        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,
                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }

    this.dirty = this.boundsDirty = true;

    return this;
};

/**
 * The arcTo() method creates an arc/curve between two tangents on the canvas.
 *
 * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
 *
 * @param x1 {number} The x-coordinate of the beginning of the arc
 * @param y1 {number} The y-coordinate of the beginning of the arc
 * @param x2 {number} The x-coordinate of the end of the arc
 * @param y2 {number} The y-coordinate of the end of the arc
 * @param radius {number} The radius of the arc
 * @return {PIXI.Graphics}
 */
Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius)
{
    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length === 0)
        {
            this.currentPath.shape.points.push(x1, y1);
        }
    }
    else
    {
        this.moveTo(x1, y1);
    }

    var points = this.currentPath.shape.points,
        fromX = points[points.length-2],
        fromY = points[points.length-1],
        a1 = fromY - y1,
        b1 = fromX - x1,
        a2 = y2   - y1,
        b2 = x2   - x1,
        mm = Math.abs(a1 * b2 - b1 * a2);

    if (mm < 1.0e-8 || radius === 0)
    {
        if (points[points.length-2] !== x1 || points[points.length-1] !== y1)
        {
            points.push(x1, y1);
        }
    }
    else
    {
        var dd = a1 * a1 + b1 * b1,
            cc = a2 * a2 + b2 * b2,
            tt = a1 * a2 + b1 * b2,
            k1 = radius * Math.sqrt(dd) / mm,
            k2 = radius * Math.sqrt(cc) / mm,
            j1 = k1 * tt / dd,
            j2 = k2 * tt / cc,
            cx = k1 * b2 + k2 * b1,
            cy = k1 * a2 + k2 * a1,
            px = b1 * (k2 + j1),
            py = a1 * (k2 + j1),
            qx = b2 * (k1 + j2),
            qy = a2 * (k1 + j2),
            startAngle = Math.atan2(py - cy, px - cx),
            endAngle   = Math.atan2(qy - cy, qx - cx);

        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
    }

    this.dirty = this.boundsDirty = true;

    return this;
};

/**
 * The arc method creates an arc/curve (used to create circles, or parts of circles).
 *
 * @param cx {number} The x-coordinate of the center of the circle
 * @param cy {number} The y-coordinate of the center of the circle
 * @param radius {number} The radius of the circle
 * @param startAngle {number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)
 * @param endAngle {number} The ending angle, in radians
 * @param anticlockwise {boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.
 * @return {PIXI.Graphics}
 */
Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise)
{
    anticlockwise = anticlockwise || false;

    if (startAngle === endAngle)
    {
        return this;
    }

    if( !anticlockwise && endAngle <= startAngle )
    {
        endAngle += Math.PI * 2;
    }
    else if( anticlockwise && startAngle <= endAngle )
    {
        startAngle += Math.PI * 2;
    }

    var sweep = anticlockwise ? (startAngle - endAngle) * -1 : (endAngle - startAngle);
    var segs =  Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;

    if(sweep === 0)
    {
        return this;
    }

    var startX = cx + Math.cos(startAngle) * radius;
    var startY = cy + Math.sin(startAngle) * radius;

    if (this.currentPath)
    {
        this.currentPath.shape.points.push(startX, startY);
    }
    else
    {
        this.moveTo(startX, startY);
    }

    var points = this.currentPath.shape.points;

    var theta = sweep/(segs*2);
    var theta2 = theta*2;

    var cTheta = Math.cos(theta);
    var sTheta = Math.sin(theta);

    var segMinus = segs - 1;

    var remainder = ( segMinus % 1 ) / segMinus;

    for(var i=0; i<=segMinus; i++)
    {
        var real =  i + remainder * i;


        var angle = ((theta) + startAngle + (theta2 * real));

        var c = Math.cos(angle);
        var s = -Math.sin(angle);

        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,
                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);
    }

    this.dirty = this.boundsDirty = true;

    return this;
};

/**
 * Specifies a simple one-color fill that subsequent calls to other Graphics methods
 * (such as lineTo() or drawCircle()) use when drawing.
 *
 * @param color {number} the color of the fill
 * @param alpha {number} the alpha of the fill
 * @return {PIXI.Graphics}
 */
Graphics.prototype.beginFill = function (color, alpha)
{
    this.filling = true;
    this.fillColor = color || 0;
    this.fillAlpha = (alpha === undefined) ? 1 : alpha;

    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length <= 2)
        {
            this.currentPath.fill = this.filling;
            this.currentPath.fillColor = this.fillColor;
            this.currentPath.fillAlpha = this.fillAlpha;
        }
    }
    return this;
};

/**
 * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
 *
 * @return {Graphics}
 */
Graphics.prototype.endFill = function ()
{
    this.filling = false;
    this.fillColor = null;
    this.fillAlpha = 1;

    return this;
};

/**
 *
 * @param x {number} The X coord of the top-left of the rectangle
 * @param y {number} The Y coord of the top-left of the rectangle
 * @param width {number} The width of the rectangle
 * @param height {number} The height of the rectangle
 * @return {PIXI.Graphics}
 */
Graphics.prototype.drawRect = function ( x, y, width, height )
{
    this.drawShape(new math.Rectangle(x,y, width, height));

    return this;
};

/**
 *
 * @param x {number} The X coord of the top-left of the rectangle
 * @param y {number} The Y coord of the top-left of the rectangle
 * @param width {number} The width of the rectangle
 * @param height {number} The height of the rectangle
 * @param radius {number} Radius of the rectangle corners
 * @return {PIXI.Graphics}
 */
Graphics.prototype.drawRoundedRect = function ( x, y, width, height, radius )
{
    this.drawShape(new math.RoundedRectangle(x, y, width, height, radius));

    return this;
};

/**
 * Draws a circle.
 *
 * @param x {number} The X coordinate of the center of the circle
 * @param y {number} The Y coordinate of the center of the circle
 * @param radius {number} The radius of the circle
 * @return {PIXI.Graphics}
 */
Graphics.prototype.drawCircle = function (x, y, radius)
{
    this.drawShape(new math.Circle(x,y, radius));

    return this;
};

/**
 * Draws an ellipse.
 *
 * @param x {number} The X coordinate of the center of the ellipse
 * @param y {number} The Y coordinate of the center of the ellipse
 * @param width {number} The half width of the ellipse
 * @param height {number} The half height of the ellipse
 * @return {PIXI.Graphics}
 */
Graphics.prototype.drawEllipse = function (x, y, width, height)
{
    this.drawShape(new math.Ellipse(x, y, width, height));

    return this;
};

/**
 * Draws a polygon using the given path.
 *
 * @param path {number[]|PIXI.Point[]} The path data used to construct the polygon.
 * @return {PIXI.Graphics}
 */
Graphics.prototype.drawPolygon = function (path)
{
    // prevents an argument assignment deopt
    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
    var points = path;

    var closed = true;

    if (points instanceof math.Polygon)
    {
        closed = points.closed;
        points = points.points;
    }

    if (!Array.isArray(points))
    {
        // prevents an argument leak deopt
        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        points = new Array(arguments.length);

        for (var i = 0; i < points.length; ++i)
        {
            points[i] = arguments[i];
        }
    }

    var shape = new math.Polygon(points);
    shape.closed = closed;

    this.drawShape(shape);

    return this;
};

/**
 * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
 *
 * @return {PIXI.Graphics}
 */
Graphics.prototype.clear = function ()
{
    this.lineWidth = 0;
    this.filling = false;

    this.dirty = true;
    this.clearDirty = true;
    this.graphicsData = [];

    return this;
};

/**
 * Useful function that returns a texture of the graphics object that can then be used to create sprites
 * This can be quite useful if your geometry is complicated and needs to be reused multiple times.
 *
 * @param resolution {number} The resolution of the texture being generated
 * @param scaleMode {number} Should be one of the scaleMode consts
 * @return {PIXI.Texture} a texture of the graphics object
 */
Graphics.prototype.generateTexture = function (renderer, resolution, scaleMode)
{

    resolution = resolution || 1;

    var bounds = this.getLocalBounds();

    var canvasBuffer = new CanvasBuffer(bounds.width * resolution, bounds.height * resolution);

    var texture = Texture.fromCanvas(canvasBuffer.canvas, scaleMode);
    texture.baseTexture.resolution = resolution;

    canvasBuffer.context.scale(resolution, resolution);

    canvasBuffer.context.translate(-bounds.x,-bounds.y);

    CanvasGraphics.renderGraphics(this, canvasBuffer.context);

    return texture;
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer}
 * @private
 */
Graphics.prototype._renderWebGL = function (renderer)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element

    // this code may still be needed so leaving for now..
    //
    /*
    if (this._cacheAsBitmap)
    {
        if (this.dirty || this.cachedSpriteDirty)
        {
            this._generateCachedSprite();

            // we will also need to update the texture on the gpu too!
            this.updateCachedSpriteTexture();

            this.cachedSpriteDirty = false;
            this.dirty = false;
        }

        this._cachedSprite.worldAlpha = this.worldAlpha;

        Sprite.prototype.renderWebGL.call(this._cachedSprite, renderer);

        return;
    }

    */

    if (this.glDirty)
    {
        this.dirty = true;
        this.glDirty = false;
    }

    renderer.setObjectRenderer(renderer.plugins.graphics);
    renderer.plugins.graphics.render(this);

};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer}
 * @private
 */
Graphics.prototype._renderCanvas = function (renderer)
{
    if (this.isMask === true)
    {
        return;
    }

    // if the tint has changed, set the graphics object to dirty.
    if (this._prevTint !== this.tint) {
        this.dirty = true;
    }

    // this code may still be needed so leaving for now..
    //
    /*
    if (this._cacheAsBitmap)
    {
        if (this.dirty || this.cachedSpriteDirty)
        {
            this._generateCachedSprite();

            // we will also need to update the texture
            this.updateCachedSpriteTexture();

            this.cachedSpriteDirty = false;
            this.dirty = false;
        }

        this._cachedSprite.alpha = this.alpha;

        Sprite.prototype._renderCanvas.call(this._cachedSprite, renderer);

        return;
    }
    */
    var context = renderer.context;
    var transform = this.worldTransform;

    var compositeOperation = renderer.blendModes[this.blendMode];
    if (compositeOperation !== context.globalCompositeOperation)
    {
        context.globalCompositeOperation = compositeOperation;
    }

    var resolution = renderer.resolution;
    context.setTransform(
        transform.a * resolution,
        transform.b * resolution,
        transform.c * resolution,
        transform.d * resolution,
        transform.tx * resolution,
        transform.ty * resolution
    );

    CanvasGraphics.renderGraphics(this, context);
};

/**
 * Retrieves the bounds of the graphic shape as a rectangle object
 *
 * @param [matrix] {PIXI.Matrix} The world transform matrix to use, defaults to this
 *  object's worldTransform.
 * @return {PIXI.Rectangle} the rectangular bounding area
 */
Graphics.prototype.getBounds = function (matrix)
{
    if(!this._currentBounds)
    {

        // return an empty object if the item is a mask!
        if (!this.renderable)
        {
            return math.Rectangle.EMPTY;
        }

        if (this.boundsDirty)
        {
            this.updateLocalBounds();

            this.glDirty = true;
            this.cachedSpriteDirty = true;
            this.boundsDirty = false;
        }

        var bounds = this._localBounds;

        var w0 = bounds.x;
        var w1 = bounds.width + bounds.x;

        var h0 = bounds.y;
        var h1 = bounds.height + bounds.y;

        var worldTransform = matrix || this.worldTransform;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;

        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;

        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;

        var x4 =  a * w1 + c * h0 + tx;
        var y4 =  d * h0 + b * w1 + ty;

        var maxX = x1;
        var maxY = y1;

        var minX = x1;
        var minY = y1;

        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;

        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;

        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;

        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;

        this._bounds.x = minX;
        this._bounds.width = maxX - minX;

        this._bounds.y = minY;
        this._bounds.height = maxY - minY;

        this._currentBounds = this._bounds;
    }

    return this._currentBounds;
};

/**
* Tests if a point is inside this graphics object
*
* @param point {PIXI.Point} the point to test
* @return {boolean} the result of the test
*/
Graphics.prototype.containsPoint = function( point )
{
    this.worldTransform.applyInverse(point,  tempPoint);

    var graphicsData = this.graphicsData;

    for (var i = 0; i < graphicsData.length; i++)
    {
        var data = graphicsData[i];

        if (!data.fill)
        {
            continue;
        }

        // only deal with fills..
        if (data.shape)
        {
            if ( data.shape.contains( tempPoint.x, tempPoint.y ) )
            {
                return true;
            }
        }
    }

    return false;
};

/**
 * Update the bounds of the object
 *
 */
Graphics.prototype.updateLocalBounds = function ()
{
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    if (this.graphicsData.length)
    {
        var shape, points, x, y, w, h;

        for (var i = 0; i < this.graphicsData.length; i++)
        {
            var data = this.graphicsData[i];
            var type = data.type;
            var lineWidth = data.lineWidth;
            shape = data.shape;

            if (type === CONST.SHAPES.RECT || type === CONST.SHAPES.RREC)
            {
                x = shape.x - lineWidth/2;
                y = shape.y - lineWidth/2;
                w = shape.width + lineWidth;
                h = shape.height + lineWidth;

                minX = x < minX ? x : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y < minY ? y : minY;
                maxY = y + h > maxY ? y + h : maxY;
            }
            else if (type === CONST.SHAPES.CIRC)
            {
                x = shape.x;
                y = shape.y;
                w = shape.radius + lineWidth/2;
                h = shape.radius + lineWidth/2;

                minX = x - w < minX ? x - w : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y - h < minY ? y - h : minY;
                maxY = y + h > maxY ? y + h : maxY;
            }
            else if (type === CONST.SHAPES.ELIP)
            {
                x = shape.x;
                y = shape.y;
                w = shape.width + lineWidth/2;
                h = shape.height + lineWidth/2;

                minX = x - w < minX ? x - w : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y - h < minY ? y - h : minY;
                maxY = y + h > maxY ? y + h : maxY;
            }
            else
            {
                // POLY
                points = shape.points;

                for (var j = 0; j < points.length; j += 2)
                {
                    x = points[j];
                    y = points[j+1];

                    minX = x-lineWidth < minX ? x-lineWidth : minX;
                    maxX = x+lineWidth > maxX ? x+lineWidth : maxX;

                    minY = y-lineWidth < minY ? y-lineWidth : minY;
                    maxY = y+lineWidth > maxY ? y+lineWidth : maxY;
                }
            }
        }
    }
    else
    {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
    }

    var padding = this.boundsPadding;

    this._localBounds.x = minX - padding;
    this._localBounds.width = (maxX - minX) + padding * 2;

    this._localBounds.y = minY - padding;
    this._localBounds.height = (maxY - minY) + padding * 2;
};

/**
 * Generates the cached sprite when the sprite has cacheAsBitmap = true
 *
 * @private
 */
/*
Graphics.prototype._generateCachedSprite = function ()
{
    var bounds = this.getLocalBounds();

    if (!this._cachedSprite)
    {
        var canvasBuffer = new CanvasBuffer(bounds.width, bounds.height);
        var texture = Texture.fromCanvas(canvasBuffer.canvas);

        this._cachedSprite = new Sprite(texture);
        this._cachedSprite.buffer = canvasBuffer;

        this._cachedSprite.worldTransform = this.worldTransform;
    }
    else
    {
        this._cachedSprite.buffer.resize(bounds.width, bounds.height);
    }

    // leverage the anchor to account for the offset of the element
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

    // this._cachedSprite.buffer.context.save();
    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);

    // make sure we set the alpha of the graphics to 1 for the render..
    this.worldAlpha = 1;

    // now render the graphic..
    CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);

    this._cachedSprite.alpha = this.alpha;
};
*/
/**
 * Updates texture size based on canvas size
 *
 * @private
 */
/*
Graphics.prototype.updateCachedSpriteTexture = function ()
{
    var cachedSprite = this._cachedSprite;
    var texture = cachedSprite.texture;
    var canvas = cachedSprite.buffer.canvas;

    texture.baseTexture.width = canvas.width;
    texture.baseTexture.height = canvas.height;
    texture.crop.width = texture.frame.width = canvas.width;
    texture.crop.height = texture.frame.height = canvas.height;

    cachedSprite._width = canvas.width;
    cachedSprite._height = canvas.height;

    // update the dirty base textures
    texture.baseTexture.dirty();
};*/

/**
 * Destroys a previous cached sprite.
 *
 */
/*
Graphics.prototype.destroyCachedSprite = function ()
{
    this._cachedSprite.texture.destroy(true);

    // let the gc collect the unused sprite
    // TODO could be object pooled!
    this._cachedSprite = null;
};*/

/**
 * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
 *
 * @param shape {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Line|PIXI.Polygon} The shape object to draw.
 * @return {PIXI.GraphicsData} The generated GraphicsData object.
 */
Graphics.prototype.drawShape = function (shape)
{
    if (this.currentPath)
    {
        // check current path!
        if (this.currentPath.shape.points.length <= 2)
        {
            this.graphicsData.pop();
        }
    }

    this.currentPath = null;

    var data = new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);

    this.graphicsData.push(data);

    if (data.type === CONST.SHAPES.POLY)
    {
        data.shape.closed = data.shape.closed || this.filling;
        this.currentPath = data;
    }

    this.dirty = this.boundsDirty = true;

    return data;
};

/**
 * Destroys the Graphics object.
 */
Graphics.prototype.destroy = function () {
    Container.prototype.destroy.apply(this, arguments);

    // destroy each of the GraphicsData objects
    for (var i = 0; i < this.graphicsData.length; ++i) {
        this.graphicsData[i].destroy();
    }

    // for each webgl data entry, destroy the WebGLGraphicsData
    for (var id in this._webgl) {
        for (var j = 0; j < this._webgl[id].data.length; ++j) {
            this._webgl[id].data[j].destroy();
        }
    }

    this.graphicsData = null;

    this.currentPath = null;
    this._webgl = null;
    this._localBounds = null;
};

},{"../const":23,"../display/Container":24,"../math":33,"../renderers/canvas/utils/CanvasBuffer":45,"../renderers/canvas/utils/CanvasGraphics":46,"../textures/Texture":72,"./GraphicsData":27}],27:[function(require,module,exports){
/**
 * A GraphicsData object.
 *
 * @class
 * @memberof PIXI
 * @param lineWidth {number} the width of the line to draw
 * @param lineColor {number} the color of the line to draw
 * @param lineAlpha {number} the alpha of the line to draw
 * @param fillColor {number} the color of the fill
 * @param fillAlpha {number} the alpha of the fill
 * @param fill      {boolean} whether or not the shape is filled with a colour
 * @param shape     {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.
 */
function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape)
{
    /*
     * @member {number} the width of the line to draw
     */
    this.lineWidth = lineWidth;

    /*
     * @member {number} the color of the line to draw
     */
    this.lineColor = lineColor;
    /*
     * @member {number} the alpha of the line to draw
     */
    this.lineAlpha = lineAlpha;
    /*
     * @member {number} cached tint of the line to draw
     */
    this._lineTint = lineColor;

    /*
     * @member {number} the color of the fill
     */
    this.fillColor = fillColor;

    /*
     * @member {number} the alpha of the fill
     */
    this.fillAlpha = fillAlpha;

    /*
     * @member {number} cached tint of the fill
     */
    this._fillTint = fillColor;

    /*
     * @member {boolean} whether or not the shape is filled with a colour
     */
    this.fill = fill;

    /*
     * @member {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Line|PIXI.Polygon} The shape object to draw.
     */
    this.shape = shape;

    /*
     * @member {number} The type of the shape, see the Const.Shapes file for all the existing types,
     */
    this.type = shape.type;
}

GraphicsData.prototype.constructor = GraphicsData;
module.exports = GraphicsData;

/**
 * Creates a new GraphicsData object with the same values as this one.
 *
 * @return {PIXI.GraphicsData}
 */
GraphicsData.prototype.clone = function ()
{
    return new GraphicsData(
        this.lineWidth,
        this.lineColor,
        this.lineAlpha,
        this.fillColor,
        this.fillAlpha,
        this.fill,
        this.shape
    );
};

/**
 * Destroys the Graphics data.
 */
GraphicsData.prototype.destroy = function () {
    this.shape = null;
};

},{}],28:[function(require,module,exports){
var utils = require('../../utils'),
    math = require('../../math'),
    CONST = require('../../const'),
    ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
    WebGLGraphicsData = require('./WebGLGraphicsData'),
    earcut = require('earcut');

/**
 * Renders the graphics object.
 *
 * @class
 * @private
 * @memberof PIXI
 * @extends PIXI.ObjectRenderer
 * @param renderer {PIXI.WebGLRenderer} The renderer this object renderer works for.
 */
function GraphicsRenderer(renderer)
{
    ObjectRenderer.call(this, renderer);

    this.graphicsDataPool = [];

    this.primitiveShader = null;
    this.complexPrimitiveShader = null;

    /**
     * This is the maximum number of points a poly can contain before it is rendered as a complex polygon (using the stencil buffer)
     * @type {Number}
     */
    this.maximumSimplePolySize = 200;
}

GraphicsRenderer.prototype = Object.create(ObjectRenderer.prototype);
GraphicsRenderer.prototype.constructor = GraphicsRenderer;
module.exports = GraphicsRenderer;

WebGLRenderer.registerPlugin('graphics', GraphicsRenderer);

/**
 * Called when there is a WebGL context change
 *
 * @private
 *
 */
GraphicsRenderer.prototype.onContextChange = function()
{

};

/**
 * Destroys this renderer.
 *
 */
GraphicsRenderer.prototype.destroy = function () {
    ObjectRenderer.prototype.destroy.call(this);

    for (var i = 0; i < this.graphicsDataPool.length; ++i) {
        this.graphicsDataPool[i].destroy();
    }

    this.graphicsDataPool = null;
};

/**
 * Renders a graphics object.
 *
 * @param graphics {PIXI.Graphics} The graphics object to render.
 */
GraphicsRenderer.prototype.render = function(graphics)
{
    var renderer = this.renderer;
    var gl = renderer.gl;

    var shader = renderer.shaderManager.plugins.primitiveShader,
        webGLData;

    if (graphics.dirty || !graphics._webGL[gl.id])
    {
        this.updateGraphics(graphics);
    }

    var webGL = graphics._webGL[gl.id];

    // This  could be speeded up for sure!

    renderer.blendModeManager.setBlendMode( graphics.blendMode );

//    var matrix =  graphics.worldTransform.clone();
//    var matrix =  renderer.currentRenderTarget.projectionMatrix.clone();
//    matrix.append(graphics.worldTransform);

    for (var i = 0, n = webGL.data.length; i < n; i++)
    {
        webGLData = webGL.data[i];

        if (webGL.data[i].mode === 1)
        {

            renderer.stencilManager.pushStencil(graphics, webGLData);

            gl.uniform1f(renderer.shaderManager.complexPrimitiveShader.uniforms.alpha._location, graphics.worldAlpha * webGLData.alpha);

            // render quad..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );

            renderer.stencilManager.popStencil(graphics, webGLData);
        }
        else
        {

            shader = renderer.shaderManager.primitiveShader;

            renderer.shaderManager.setShader( shader );//activatePrimitiveShader();

            gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));

            gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, renderer.currentRenderTarget.projectionMatrix.toArray(true));

            gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));

            gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);


            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
            gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false,4 * 6, 2 * 4);

            // set the index buffer!
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );
        }

        renderer.drawCount++;
    }
};

/**
 * Updates the graphics object
 *
 * @private
 * @param graphics {PIXI.Graphics} The graphics object to update
 */
GraphicsRenderer.prototype.updateGraphics = function(graphics)
{
    var gl = this.renderer.gl;

     // get the contexts graphics object
    var webGL = graphics._webGL[gl.id];

    // if the graphics object does not exist in the webGL context time to create it!
    if (!webGL)
    {
        webGL = graphics._webGL[gl.id] = {lastIndex:0, data:[], gl:gl};
    }

    // flag the graphics as not dirty as we are about to update it...
    graphics.dirty = false;

    var i;

    // if the user cleared the graphics object we will need to clear every object
    if (graphics.clearDirty)
    {
        graphics.clearDirty = false;

        // loop through and return all the webGLDatas to the object pool so than can be reused later on
        for (i = 0; i < webGL.data.length; i++)
        {
            var graphicsData = webGL.data[i];
            graphicsData.reset();
            this.graphicsDataPool.push( graphicsData );
        }

        // clear the array and reset the index..
        webGL.data = [];
        webGL.lastIndex = 0;
    }

    var webGLData;

    // loop through the graphics datas and construct each one..
    // if the object is a complex fill then the new stencil buffer technique will be used
    // other wise graphics objects will be pushed into a batch..
    for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];

        if (data.type === CONST.SHAPES.POLY)
        {
            // need to add the points the the graphics object..
            data.points = data.shape.points.slice();
            if (data.shape.closed)
            {
                // close the poly if the value is true!
                if (data.points[0] !== data.points[data.points.length-2] || data.points[1] !== data.points[data.points.length-1])
                {
                    data.points.push(data.points[0], data.points[1]);
                }
            }

            // MAKE SURE WE HAVE THE CORRECT TYPE..
            if (data.fill)
            {
                if (data.points.length >= 6)
                {
                    if (data.points.length < this.maximumSimplePolySize * 2)
                    {
                        webGLData = this.switchMode(webGL, 0);

                        var canDrawUsingSimple = this.buildPoly(data, webGLData);

                        if (!canDrawUsingSimple)
                        {
                            webGLData = this.switchMode(webGL, 1);
                            this.buildComplexPoly(data, webGLData);
                        }

                    }
                    else
                    {
                        webGLData = this.switchMode(webGL, 1);
                        this.buildComplexPoly(data, webGLData);
                    }
                }
            }

            if (data.lineWidth > 0)
            {
                webGLData = this.switchMode(webGL, 0);
                this.buildLine(data, webGLData);
            }
        }
        else
        {
            webGLData = this.switchMode(webGL, 0);

            if (data.type === CONST.SHAPES.RECT)
            {
                this.buildRectangle(data, webGLData);
            }
            else if (data.type === CONST.SHAPES.CIRC || data.type === CONST.SHAPES.ELIP)
            {
                this.buildCircle(data, webGLData);
            }
            else if (data.type === CONST.SHAPES.RREC)
            {
                this.buildRoundedRectangle(data, webGLData);
            }
        }

        webGL.lastIndex++;
    }

    // upload all the dirty data...
    for (i = 0; i < webGL.data.length; i++)
    {
        webGLData = webGL.data[i];

        if (webGLData.dirty)
        {
            webGLData.upload();
        }
    }
};

/**
 *
 *
 * @private
 * @param webGL {WebGLRenderingContext} the current WebGL drawing context
 * @param type {number} TODO @Alvin
 */
GraphicsRenderer.prototype.switchMode = function (webGL, type)
{
    var webGLData;

    if (!webGL.data.length)
    {
        webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);
        webGLData.mode = type;
        webGL.data.push(webGLData);
    }
    else
    {
        webGLData = webGL.data[webGL.data.length-1];

        if ((webGLData.points.length > 320000) || webGLData.mode !== type || type === 1)
        {
            webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);
            webGLData.mode = type;
            webGL.data.push(webGLData);
        }
    }

    webGLData.dirty = true;

    return webGLData;
};

/**
 * Builds a rectangle to draw
 *
 * @private
 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildRectangle = function (graphicsData, webGLData)
{
    // --- //
    // need to convert points to a nice regular data
    //
    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y = rectData.y;
    var width = rectData.width;
    var height = rectData.height;

    if (graphicsData.fill)
    {
        var color = utils.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vertPos = verts.length/6;

        // start
        verts.push(x, y);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y);
        verts.push(r, g, b, alpha);

        verts.push(x , y + height);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y + height);
        verts.push(r, g, b, alpha);

        // insert 2 dead triangles..
        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);
    }

    if (graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [x, y,
                  x + width, y,
                  x + width, y + height,
                  x, y + height,
                  x, y];


        this.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a rounded rectangle to draw
 *
 * @private
 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildRoundedRectangle = function (graphicsData, webGLData)
{
    var rrectData = graphicsData.shape;
    var x = rrectData.x;
    var y = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;

    var radius = rrectData.radius;

    var recPoints = [];
    recPoints.push(x, y + radius);
    this.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);
    this.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);
    this.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);
    this.quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);

    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
    // TODO - fix this properly, this is not very elegant.. but it works for now.

    if (graphicsData.fill)
    {
        var color = utils.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        var triangles = earcut(recPoints, null, 2);

        var i = 0;
        for (i = 0; i < triangles.length; i+=3)
        {
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i+1] + vecPos);
            indices.push(triangles[i+2] + vecPos);
            indices.push(triangles[i+2] + vecPos);
        }

        for (i = 0; i < recPoints.length; i++)
        {
            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = recPoints;

        this.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @private
 * @param fromX {number} Origin point x
 * @param fromY {number} Origin point x
 * @param cpX {number} Control point x
 * @param cpY {number} Control point y
 * @param toX {number} Destination point x
 * @param toY {number} Destination point y
 * @param [out] {number[]} The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
GraphicsRenderer.prototype.quadraticBezierCurve = function (fromX, fromY, cpX, cpY, toX, toY, out)
{
    var xa,
        ya,
        xb,
        yb,
        x,
        y,
        n = 20,
        points = out || [];

    function getPt(n1 , n2, perc) {
        var diff = n2 - n1;

        return n1 + ( diff * perc );
    }

    var j = 0;
    for (var i = 0; i <= n; i++ ) {
        j = i / n;

        // The Green Line
        xa = getPt( fromX , cpX , j );
        ya = getPt( fromY , cpY , j );
        xb = getPt( cpX , toX , j );
        yb = getPt( cpY , toY , j );

        // The Black Dot
        x = getPt( xa , xb , j );
        y = getPt( ya , yb , j );

        points.push(x, y);
    }

    return points;
};

/**
 * Builds a circle to draw
 *
 * @private
 * @param graphicsData {PIXI.Graphics} The graphics object to draw
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildCircle = function (graphicsData, webGLData)
{
    // need to convert points to a nice regular data
    var circleData = graphicsData.shape;
    var x = circleData.x;
    var y = circleData.y;
    var width;
    var height;

    // TODO - bit hacky??
    if (graphicsData.type === CONST.SHAPES.CIRC)
    {
        width = circleData.radius;
        height = circleData.radius;
    }
    else
    {
        width = circleData.width;
        height = circleData.height;
    }

    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));
    var seg = (Math.PI * 2) / totalSegs ;

    var i = 0;

    if (graphicsData.fill)
    {
        var color = utils.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        indices.push(vecPos);

        for (i = 0; i < totalSegs + 1 ; i++)
        {
            verts.push(x,y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width,
                       y + Math.cos(seg * i) * height,
                       r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
        }

        indices.push(vecPos-1);
    }

    if (graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [];

        for (i = 0; i < totalSegs + 1; i++)
        {
            graphicsData.points.push(x + Math.sin(seg * i) * width,
                                     y + Math.cos(seg * i) * height);
        }

        this.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a line to draw
 *
 * @private
 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildLine = function (graphicsData, webGLData)
{
    // TODO OPTIMISE!
    var i = 0;
    var points = graphicsData.points;

    if (points.length === 0)
    {
        return;
    }
    // if the line width is an odd number add 0.5 to align to a whole pixel
    // commenting this out fixes #711 and #1620
    // if (graphicsData.lineWidth%2)
    // {
    //     for (i = 0; i < points.length; i++)
    //     {
    //         points[i] += 0.5;
    //     }
    // }

    // get first and last point.. figure out the middle!
    var firstPoint = new math.Point(points[0], points[1]);
    var lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);

    // if the first point is the last point - gonna have issues :)
    if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)
    {
        // need to clone as we are going to slightly modify the shape..
        points = points.slice();

        points.pop();
        points.pop();

        lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);

        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;
        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = webGLData.points;
    var indices = webGLData.indices;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length/6;

    // DRAW the Line
    var width = graphicsData.lineWidth / 2;

    // sort color
    var color = utils.hex2rgb(graphicsData.lineColor);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
    var a1, b1, c1, a2, b2, c2;
    var denom, pdist, dist;

    p1x = points[0];
    p1y = points[1];

    p2x = points[2];
    p2y = points[3];

    perpx = -(p1y - p2y);
    perpy =  p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    // start
    verts.push(p1x - perpx , p1y - perpy,
                r, g, b, alpha);

    verts.push(p1x + perpx , p1y + perpy,
                r, g, b, alpha);

    for (i = 1; i < length-1; i++)
    {
        p1x = points[(i-1)*2];
        p1y = points[(i-1)*2 + 1];

        p2x = points[(i)*2];
        p2y = points[(i)*2 + 1];

        p3x = points[(i+1)*2];
        p3y = points[(i+1)*2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx*perpx + perpy*perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        a1 = (-perpy + p1y) - (-perpy + p2y);
        b1 = (-perpx + p2x) - (-perpx + p1x);
        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
        a2 = (-perp2y + p3y) - (-perp2y + p2y);
        b2 = (-perp2x + p2x) - (-perp2x + p3x);
        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

        denom = a1*b2 - a2*b1;

        if (Math.abs(denom) < 0.1 )
        {

            denom+=10.1;
            verts.push(p2x - perpx , p2y - perpy,
                r, g, b, alpha);

            verts.push(p2x + perpx , p2y + perpy,
                r, g, b, alpha);

            continue;
        }

        px = (b1*c2 - b2*c1)/denom;
        py = (a2*c1 - a1*c2)/denom;


        pdist = (px -p2x) * (px -p2x) + (py -p2y) * (py -p2y);


        if (pdist > 140 * 140)
        {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x, p2y +perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            indexCount++;
        }
        else
        {

            verts.push(px , py);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px-p2x), p2y - (py - p2y));
            verts.push(r, g, b, alpha);
        }
    }

    p1x = points[(length-2)*2];
    p1y = points[(length-2)*2 + 1];

    p2x = points[(length-1)*2];
    p2y = points[(length-1)*2 + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - perpx , p2y - perpy);
    verts.push(r, g, b, alpha);

    verts.push(p2x + perpx , p2y + perpy);
    verts.push(r, g, b, alpha);

    indices.push(indexStart);

    for (i = 0; i < indexCount; i++)
    {
        indices.push(indexStart++);
    }

    indices.push(indexStart-1);
};

/**
 * Builds a complex polygon to draw
 *
 * @private
 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildComplexPoly = function (graphicsData, webGLData)
{
    //TODO - no need to copy this as it gets turned into a FLoat32Array anyways..
    var points = graphicsData.points.slice();

    if (points.length < 6)
    {
        return;
    }

    // get first and last point.. figure out the middle!
    var indices = webGLData.indices;
    webGLData.points = points;
    webGLData.alpha = graphicsData.fillAlpha;
    webGLData.color = utils.hex2rgb(graphicsData.fillColor);

    // calclate the bounds..
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    var x,y;

    // get size..
    for (var i = 0; i < points.length; i+=2)
    {
        x = points[i];
        y = points[i+1];

        minX = x < minX ? x : minX;
        maxX = x > maxX ? x : maxX;

        minY = y < minY ? y : minY;
        maxY = y > maxY ? y : maxY;
    }

    // add a quad to the end cos there is no point making another buffer!
    points.push(minX, minY,
                maxX, minY,
                maxX, maxY,
                minX, maxY);

    // push a quad onto the end..

    //TODO - this aint needed!
    var length = points.length / 2;
    for (i = 0; i < length; i++)
    {
        indices.push( i );
    }

};

/**
 * Builds a polygon to draw
 *
 * @private
 * @param graphicsData {PIXI.WebGLGraphicsData} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildPoly = function (graphicsData, webGLData)
{
    var points = graphicsData.points;

    if (points.length < 6)
    {
        return;
    }

    // get first and last point.. figure out the middle!
    var verts = webGLData.points;
    var indices = webGLData.indices;

    var length = points.length / 2;

    // sort color
    var color = utils.hex2rgb(graphicsData.fillColor);
    var alpha = graphicsData.fillAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var triangles = earcut(points, null, 2);

    if (!triangles) {
        return false;
    }

    var vertPos = verts.length / 6;

    var i = 0;

    for (i = 0; i < triangles.length; i+=3)
    {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i+1] + vertPos);
        indices.push(triangles[i+2] +vertPos);
        indices.push(triangles[i+2] + vertPos);
    }

    for (i = 0; i < length; i++)
    {
        verts.push(points[i * 2], points[i * 2 + 1],
                   r, g, b, alpha);
    }

    return true;
};

},{"../../const":23,"../../math":33,"../../renderers/webgl/WebGLRenderer":49,"../../renderers/webgl/utils/ObjectRenderer":63,"../../utils":77,"./WebGLGraphicsData":29,"earcut":9}],29:[function(require,module,exports){
/**
 * An object containing WebGL specific properties to be used by the WebGL renderer
 *
 * @class
 * @memberof PIXI
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 * @private
 */
function WebGLGraphicsData(gl) {

    /**
     * The current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    //TODO does this need to be split before uploding??
    /**
     * An array of color components (r,g,b)
     * @member {number[]}
     */
    this.color = [0,0,0]; // color split!

    /**
     * An array of points to draw
     * @member {PIXI.Point[]}
     */
    this.points = [];

    /**
     * The indices of the vertices
     * @member {number[]}
     */
    this.indices = [];
    /**
     * The main buffer
     * @member {WebGLBuffer}
     */
    this.buffer = gl.createBuffer();

    /**
     * The index buffer
     * @member {WebGLBuffer}
     */
    this.indexBuffer = gl.createBuffer();

    /**
     * todo @alvin
     * @member {number}
     */
    this.mode = 1;

    /**
     * The alpha of the graphics
     * @member {number}
     */
    this.alpha = 1;

    /**
     * Whether this graphics is dirty or not
     * @member {boolean}
     */
    this.dirty = true;

    this.glPoints = null;
    this.glIndices = null;
}

WebGLGraphicsData.prototype.constructor = WebGLGraphicsData;
module.exports = WebGLGraphicsData;

/**
 * Resets the vertices and the indices
 */
WebGLGraphicsData.prototype.reset = function () {
    this.points.length = 0;
    this.indices.length = 0;
};

/**
 * Binds the buffers and uploads the data
 */
WebGLGraphicsData.prototype.upload = function () {
    var gl = this.gl;

//    this.lastIndex = graphics.graphicsData.length;
    this.glPoints = new Float32Array(this.points);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);

    this.glIndices = new Uint16Array(this.indices);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndices, gl.STATIC_DRAW);

    this.dirty = false;
};

WebGLGraphicsData.prototype.destroy = function () {
    this.color = null;
    this.points = null;
    this.indices = null;

    this.gl.deleteBuffer(this.buffer);
    this.gl.deleteBuffer(this.indexBuffer);
    
    this.gl = null;

    this.buffer = null;
    this.indexBuffer = null;

    this.glPoints = null;
    this.glIndices = null;
};

},{}],30:[function(require,module,exports){
/**
 * @file        Main export of the PIXI core library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI
 */
// export core and const. We assign core to const so that the non-reference types in const remain in-tact
var core = module.exports = Object.assign(require('./const'), require('./math'), {
    // utils
    utils: require('./utils'),
    ticker: require('./ticker'),

    // display
    DisplayObject:          require('./display/DisplayObject'),
    Container:              require('./display/Container'),

    // sprites
    Sprite:                 require('./sprites/Sprite'),
    ParticleContainer:      require('./particles/ParticleContainer'),
    SpriteRenderer:         require('./sprites/webgl/SpriteRenderer'),
    ParticleRenderer:       require('./particles/webgl/ParticleRenderer'),

    // text
    Text:                   require('./text/Text'),

    // primitives
    Graphics:               require('./graphics/Graphics'),
    GraphicsData:           require('./graphics/GraphicsData'),
    GraphicsRenderer:       require('./graphics/webgl/GraphicsRenderer'),

    // textures
    Texture:                require('./textures/Texture'),
    BaseTexture:            require('./textures/BaseTexture'),
    RenderTexture:          require('./textures/RenderTexture'),
    VideoBaseTexture:       require('./textures/VideoBaseTexture'),
    TextureUvs:             require('./textures/TextureUvs'),

    // renderers - canvas
    CanvasRenderer:         require('./renderers/canvas/CanvasRenderer'),
    CanvasGraphics:         require('./renderers/canvas/utils/CanvasGraphics'),
    CanvasBuffer:           require('./renderers/canvas/utils/CanvasBuffer'),

    // renderers - webgl
    WebGLRenderer:          require('./renderers/webgl/WebGLRenderer'),
    WebGLManager:          require('./renderers/webgl/managers/WebGLManager'),
    ShaderManager:          require('./renderers/webgl/managers/ShaderManager'),
    Shader:                 require('./renderers/webgl/shaders/Shader'),
    ObjectRenderer:         require('./renderers/webgl/utils/ObjectRenderer'),
    RenderTarget:           require('./renderers/webgl/utils/RenderTarget'),

    // filters - webgl
    AbstractFilter:         require('./renderers/webgl/filters/AbstractFilter'),
    FXAAFilter:             require('./renderers/webgl/filters/FXAAFilter'),
    SpriteMaskFilter:       require('./renderers/webgl/filters/SpriteMaskFilter'),

    /**
     * This helper function will automatically detect which renderer you should be using.
     * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
     * the browser then this function will return a canvas renderer
     *
     * @memberof PIXI
     * @param width=800 {number} the width of the renderers view
     * @param height=600 {number} the height of the renderers view
     * @param [options] {object} The optional renderer parameters
     * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
     * @param [options.transparent=false] {boolean} If the render view is transparent, default false
     * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
     * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if you
     *      need to call toDataUrl on the webgl context
     * @param [options.resolution=1] {number} the resolution of the renderer, retina would be 2
     * @param [noWebGL=false] {boolean} prevents selection of WebGL renderer, even if such is present
     *
     * @return {WebGLRenderer|CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
     */
    autoDetectRenderer: function (width, height, options, noWebGL)
    {
        width = width || 800;
        height = height || 600;

        if (!noWebGL && core.utils.isWebGLSupported())
        {
            return new core.WebGLRenderer(width, height, options);
        }

        return new core.CanvasRenderer(width, height, options);
    }
});

},{"./const":23,"./display/Container":24,"./display/DisplayObject":25,"./graphics/Graphics":26,"./graphics/GraphicsData":27,"./graphics/webgl/GraphicsRenderer":28,"./math":33,"./particles/ParticleContainer":39,"./particles/webgl/ParticleRenderer":41,"./renderers/canvas/CanvasRenderer":44,"./renderers/canvas/utils/CanvasBuffer":45,"./renderers/canvas/utils/CanvasGraphics":46,"./renderers/webgl/WebGLRenderer":49,"./renderers/webgl/filters/AbstractFilter":50,"./renderers/webgl/filters/FXAAFilter":51,"./renderers/webgl/filters/SpriteMaskFilter":52,"./renderers/webgl/managers/ShaderManager":56,"./renderers/webgl/managers/WebGLManager":58,"./renderers/webgl/shaders/Shader":61,"./renderers/webgl/utils/ObjectRenderer":63,"./renderers/webgl/utils/RenderTarget":65,"./sprites/Sprite":67,"./sprites/webgl/SpriteRenderer":68,"./text/Text":69,"./textures/BaseTexture":70,"./textures/RenderTexture":71,"./textures/Texture":72,"./textures/TextureUvs":73,"./textures/VideoBaseTexture":74,"./ticker":76,"./utils":77}],31:[function(require,module,exports){
// @todo - ignore the too many parameters warning for now
// should either fix it or change the jshint config
// jshint -W072

var Point = require('./Point');

/**
 * The pixi Matrix class as an object, which makes it a lot faster,
 * here is a representation of it :
 * | a | b | tx|
 * | c | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class
 * @memberof PIXI
 */
function Matrix()
{
    /**
     * @member {number}
     * @default 1
     */
    this.a = 1;

    /**
     * @member {number}
     * @default 0
     */
    this.b = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.c = 0;

    /**
     * @member {number}
     * @default 1
     */
    this.d = 1;

    /**
     * @member {number}
     * @default 0
     */
    this.tx = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.ty = 0;
}

Matrix.prototype.constructor = Matrix;
module.exports = Matrix;

/**
 * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
 *
 * a = array[0]
 * b = array[1]
 * c = array[3]
 * d = array[4]
 * tx = array[2]
 * ty = array[5]
 *
 * @param array {number[]} The array that the matrix will be populated from.
 */
Matrix.prototype.fromArray = function (array)
{
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
};


/**
 * sets the matrix properties
 *
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @param {number} tx
 * @param {number} ty
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.set = function (a, b, c, d, tx, ty)
{
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;

    return this;
};


/**
 * Creates an array from the current Matrix object.
 *
 * @param transpose {boolean} Whether we need to transpose the matrix or not
 * @param [out] {Array} If provided the array will be assigned to out
 * @return {number[]} the newly created array which contains the matrix
 */
Matrix.prototype.toArray = function (transpose, out)
{
    if (!this.array)
    {
        this.array = new Float32Array(9);
    }

    var array = out || this.array;

    if (transpose)
    {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = 0;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
    }
    else
    {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = this.tx;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
    }

    return array;
};

/**
 * Get a new position with the current transformation applied.
 * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
 *
 * @param pos {PIXI.Point} The origin
 * @param [newPos] {PIXI.Point} The point that the new position is assigned to (allowed to be same as input)
 * @return {PIXI.Point} The new point, transformed through this matrix
 */
Matrix.prototype.apply = function (pos, newPos)
{
    newPos = newPos || new Point();

    var x = pos.x;
    var y = pos.y;

    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;

    return newPos;
};

/**
 * Get a new position with the inverse of the current transformation applied.
 * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
 *
 * @param pos {PIXI.Point} The origin
 * @param [newPos] {PIXI.Point} The point that the new position is assigned to (allowed to be same as input)
 * @return {PIXI.Point} The new point, inverse-transformed through this matrix
 */
Matrix.prototype.applyInverse = function (pos, newPos)
{
    newPos = newPos || new Point();

    var id = 1 / (this.a * this.d + this.c * -this.b);

    var x = pos.x;
    var y = pos.y;

    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;

    return newPos;
};

/**
 * Translates the matrix on the x and y.
 *
 * @param {number} x
 * @param {number} y
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.translate = function (x, y)
{
    this.tx += x;
    this.ty += y;

    return this;
};

/**
 * Applies a scale transformation to the matrix.
 *
 * @param {number} x The amount to scale horizontally
 * @param {number} y The amount to scale vertically
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.scale = function (x, y)
{
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;

    return this;
};


/**
 * Applies a rotation transformation to the matrix.
 *
 * @param {number} angle - The angle in radians.
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.rotate = function (angle)
{
    var cos = Math.cos( angle );
    var sin = Math.sin( angle );

    var a1 = this.a;
    var c1 = this.c;
    var tx1 = this.tx;

    this.a = a1 * cos-this.b * sin;
    this.b = a1 * sin+this.b * cos;
    this.c = c1 * cos-this.d * sin;
    this.d = c1 * sin+this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;

    return this;
};

/**
 * Appends the given Matrix to this Matrix.
 *
 * @param {PIXI.Matrix} matrix
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.append = function (matrix)
{
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;

    this.a  = matrix.a * a1 + matrix.b * c1;
    this.b  = matrix.a * b1 + matrix.b * d1;
    this.c  = matrix.c * a1 + matrix.d * c1;
    this.d  = matrix.c * b1 + matrix.d * d1;

    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;

    return this;
};

/**
 * Sets the matrix based on all the available properties
 *
 * @param {number} x
 * @param {number} y
 * @param {number} pivotX
 * @param {number} pivotY
 * @param {number} scaleX
 * @param {number} scaleY
 * @param {number} rotation
 * @param {number} skewX
 * @param {number} skewY
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.setTransform = function (x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY)
{
    var a, b, c, d, sr, cr, cy, sy, nsx, cx;

    sr  = Math.sin(rotation);
    cr  = Math.cos(rotation);
    cy  = Math.cos(skewY);
    sy  = Math.sin(skewY);
    nsx = -Math.sin(skewX);
    cx  =  Math.cos(skewX);

    a  =  cr * scaleX;
    b  =  sr * scaleX;
    c  = -sr * scaleY;
    d  =  cr * scaleY;

    this.a  = cy * a + sy * c;
    this.b  = cy * b + sy * d;
    this.c  = nsx * a + cx * c;
    this.d  = nsx * b + cx * d;

    this.tx = x + ( pivotX * a + pivotY * c );
    this.ty = y + ( pivotX * b + pivotY * d );

    return this;
};

/**
 * Prepends the given Matrix to this Matrix.
 *
 * @param {PIXI.Matrix} matrix
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.prepend = function(matrix)
{
    var tx1 = this.tx;

    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)
    {
        var a1 = this.a;
        var c1 = this.c;
        this.a  = a1*matrix.a+this.b*matrix.c;
        this.b  = a1*matrix.b+this.b*matrix.d;
        this.c  = c1*matrix.a+this.d*matrix.c;
        this.d  = c1*matrix.b+this.d*matrix.d;
    }

    this.tx = tx1*matrix.a+this.ty*matrix.c+matrix.tx;
    this.ty = tx1*matrix.b+this.ty*matrix.d+matrix.ty;

    return this;
};

/**
 * Inverts this matrix
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.invert = function()
{
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    var tx1 = this.tx;
    var n = a1*d1-b1*c1;

    this.a = d1/n;
    this.b = -b1/n;
    this.c = -c1/n;
    this.d = a1/n;
    this.tx = (c1*this.ty-d1*tx1)/n;
    this.ty = -(a1*this.ty-b1*tx1)/n;

    return this;
};


/**
 * Resets this Matix to an identity (default) matrix.
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.identity = function ()
{
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;

    return this;
};

/**
 * Creates a new Matrix object with the same values as this one.
 *
 * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
 */
Matrix.prototype.clone = function ()
{
    var matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;

    return matrix;
};

/**
 * Changes the values of the given matrix to be the same as the ones in this matrix
 *
 * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
 */
Matrix.prototype.copy = function (matrix)
{
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;

    return matrix;
};

/**
 * A default (identity) matrix
 *
 * @static
 * @const
 */
Matrix.IDENTITY = new Matrix();

/**
 * A temp matrix
 *
 * @static
 * @const
 */
Matrix.TEMP_MATRIX = new Matrix();

},{"./Point":32}],32:[function(require,module,exports){
/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @memberof PIXI
 * @param [x=0] {number} position of the point on the x axis
 * @param [y=0] {number} position of the point on the y axis
 */
function Point(x, y)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;
}

Point.prototype.constructor = Point;
module.exports = Point;

/**
 * Creates a clone of this point
 *
 * @return {PIXI.Point} a copy of the point
 */
Point.prototype.clone = function ()
{
    return new Point(this.x, this.y);
};

/**
 * Copies x and y from the given point
 *
 * @param p {PIXI.Point}
 */
Point.prototype.copy = function (p) {
    this.set(p.x, p.y);
};

/**
 * Returns true if the given point is equal to this point
 *
 * @param p {PIXI.Point}
 * @returns {boolean}
 */
Point.prototype.equals = function (p) {
    return (p.x === this.x) && (p.y === this.y);
};

/**
 * Sets the point to a new x and y position.
 * If y is omitted, both x and y will be set to x.
 *
 * @param [x=0] {number} position of the point on the x axis
 * @param [y=0] {number} position of the point on the y axis
 */
Point.prototype.set = function (x, y)
{
    this.x = x || 0;
    this.y = y || ( (y !== 0) ? this.x : 0 ) ;
};

},{}],33:[function(require,module,exports){
/**
 * Math classes and utilities mixed into PIXI namespace.
 *
 * @lends PIXI
 */
module.exports = {
    // These will be mixed to be made publicly available,
    // while this module is used internally in core
    // to avoid circular dependencies and cut down on
    // internal module requires.

    Point:      require('./Point'),
    Matrix:     require('./Matrix'),

    Circle:     require('./shapes/Circle'),
    Ellipse:    require('./shapes/Ellipse'),
    Polygon:    require('./shapes/Polygon'),
    Rectangle:  require('./shapes/Rectangle'),
    RoundedRectangle: require('./shapes/RoundedRectangle')
};

},{"./Matrix":31,"./Point":32,"./shapes/Circle":34,"./shapes/Ellipse":35,"./shapes/Polygon":36,"./shapes/Rectangle":37,"./shapes/RoundedRectangle":38}],34:[function(require,module,exports){
var Rectangle = require('./Rectangle'),
    CONST = require('../../const');

/**
 * The Circle object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the center of this circle
 * @param y {number} The Y coordinate of the center of this circle
 * @param radius {number} The radius of the circle
 */
function Circle(x, y, radius)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.radius = radius || 0;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.CIRC;
}

Circle.prototype.constructor = Circle;
module.exports = Circle;

/**
 * Creates a clone of this Circle instance
 *
 * @return {PIXI.Circle} a copy of the Circle
 */
Circle.prototype.clone = function ()
{
    return new Circle(this.x, this.y, this.radius);
};

/**
 * Checks whether the x and y coordinates given are contained within this circle
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Circle
 */
Circle.prototype.contains = function (x, y)
{
    if (this.radius <= 0)
    {
        return false;
    }

    var dx = (this.x - x),
        dy = (this.y - y),
        r2 = this.radius * this.radius;

    dx *= dx;
    dy *= dy;

    return (dx + dy <= r2);
};

/**
* Returns the framing rectangle of the circle as a Rectangle object
*
* @return {PIXI.Rectangle} the framing rectangle
*/
Circle.prototype.getBounds = function ()
{
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
};

},{"../../const":23,"./Rectangle":37}],35:[function(require,module,exports){
var Rectangle = require('./Rectangle'),
    CONST = require('../../const');

/**
 * The Ellipse object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the center of the ellipse
 * @param y {number} The Y coordinate of the center of the ellipse
 * @param width {number} The half width of this ellipse
 * @param height {number} The half height of this ellipse
 */
function Ellipse(x, y, width, height)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height || 0;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.ELIP;
}

Ellipse.prototype.constructor = Ellipse;
module.exports = Ellipse;

/**
 * Creates a clone of this Ellipse instance
 *
 * @return {PIXI.Ellipse} a copy of the ellipse
 */
Ellipse.prototype.clone = function ()
{
    return new Ellipse(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates given are contained within this ellipse
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coords are within this ellipse
 */
Ellipse.prototype.contains = function (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    //normalize the coords to an ellipse with center 0,0
    var normx = ((x - this.x) / this.width),
        normy = ((y - this.y) / this.height);

    normx *= normx;
    normy *= normy;

    return (normx + normy <= 1);
};

/**
 * Returns the framing rectangle of the ellipse as a Rectangle object
 *
 * @return {PIXI.Rectangle} the framing rectangle
 */
Ellipse.prototype.getBounds = function ()
{
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
};

},{"../../const":23,"./Rectangle":37}],36:[function(require,module,exports){
var Point = require('../Point'),
    CONST = require('../../const');

/**
 * @class
 * @memberof PIXI
 * @param points {PIXI.Point[]|number[]|...PIXI.Point|...number} This can be an array of Points that form the polygon,
 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
 *      arguments passed can be flat x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
 *      Numbers.
 */
function Polygon(points_)
{
    // prevents an argument assignment deopt
    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
    var points = points_;

    //if points isn't an array, use arguments as the array
    if (!Array.isArray(points))
    {
        // prevents an argument leak deopt
        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        points = new Array(arguments.length);

        for (var a = 0; a < points.length; ++a) {
            points[a] = arguments[a];
        }
    }

    // if this is an array of points, convert it to a flat array of numbers
    if (points[0] instanceof Point)
    {
        var p = [];
        for (var i = 0, il = points.length; i < il; i++)
        {
            p.push(points[i].x, points[i].y);
        }

        points = p;
    }

    this.closed = true;

    /**
     * An array of the points of this polygon
     *
     * @member {number[]}
     */
    this.points = points;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.POLY;
}

Polygon.prototype.constructor = Polygon;
module.exports = Polygon;

/**
 * Creates a clone of this polygon
 *
 * @return {PIXI.Polygon} a copy of the polygon
 */
Polygon.prototype.clone = function ()
{
    return new Polygon(this.points.slice());
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this polygon
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this polygon
 */
Polygon.prototype.contains = function (x, y)
{
    var inside = false;

    // use some raycasting to test hits
    // https://github.com/substack/point-in-polygon/blob/master/index.js
    var length = this.points.length / 2;

    for (var i = 0, j = length - 1; i < length; j = i++)
    {
        var xi = this.points[i * 2], yi = this.points[i * 2 + 1],
            xj = this.points[j * 2], yj = this.points[j * 2 + 1],
            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if (intersect)
        {
            inside = !inside;
        }
    }

    return inside;
};

},{"../../const":23,"../Point":32}],37:[function(require,module,exports){
var CONST = require('../../const');

/**
 * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the upper-left corner of the rectangle
 * @param y {number} The Y coordinate of the upper-left corner of the rectangle
 * @param width {number} The overall width of this rectangle
 * @param height {number} The overall height of this rectangle
 */
function Rectangle(x, y, width, height)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height || 0;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.RECT;
}

Rectangle.prototype.constructor = Rectangle;
module.exports = Rectangle;

/**
 * A constant empty rectangle.
 *
 * @static
 * @constant
 */
Rectangle.EMPTY = new Rectangle(0, 0, 0, 0);


/**
 * Creates a clone of this Rectangle
 *
 * @return {PIXI.Rectangle} a copy of the rectangle
 */
Rectangle.prototype.clone = function ()
{
    return new Rectangle(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates given are contained within this Rectangle
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Rectangle
 */
Rectangle.prototype.contains = function (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    if (x >= this.x && x < this.x + this.width)
    {
        if (y >= this.y && y < this.y + this.height)
        {
            return true;
        }
    }

    return false;
};

},{"../../const":23}],38:[function(require,module,exports){
var CONST = require('../../const');

/**
 * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its top-left corner point (x, y) and by its width and its height and its radius.
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the upper-left corner of the rounded rectangle
 * @param y {number} The Y coordinate of the upper-left corner of the rounded rectangle
 * @param width {number} The overall width of this rounded rectangle
 * @param height {number} The overall height of this rounded rectangle
 * @param radius {number} Controls the radius of the rounded corners
 */
function RoundedRectangle(x, y, width, height, radius)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height || 0;

    /**
     * @member {number}
     * @default 20
     */
    this.radius = radius || 20;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.RREC;
}

RoundedRectangle.prototype.constructor = RoundedRectangle;
module.exports = RoundedRectangle;

/**
 * Creates a clone of this Rounded Rectangle
 *
 * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
 */
RoundedRectangle.prototype.clone = function ()
{
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
};

/**
 * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
 */
RoundedRectangle.prototype.contains = function (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    if (x >= this.x && x <= this.x + this.width)
    {
        if (y >= this.y && y <= this.y + this.height)
        {
            return true;
        }
    }

    return false;
};

},{"../../const":23}],39:[function(require,module,exports){
var Container = require('../display/Container'),
    CONST = require('../const');

/**
 * The ParticleContainer class is a really fast version of the Container built solely for speed,
 * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that advanced
 * functionality will not work. ParticleContainer implements only the basic object transform (position, scale, rotation).
 * Any other functionality like tinting, masking, etc will not work on sprites in this batch.
 *
 * It's extremely easy to use :
 *
 * ```js
 * var container = new ParticleContainer();
 *
 * for (var i = 0; i < 100; ++i)
 * {
 *     var sprite = new PIXI.Sprite.fromImage("myImage.png");
 *     container.addChild(sprite);
 * }
 * ```
 *
 * And here you have a hundred sprites that will be renderer at the speed of light.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 * @param [maxSize=15000] {number} The maximum number of particles that can be renderer by the container.
 * @param [properties] {object} The properties of children that should be uploaded to the gpu and applied.
 * @param [properties.scale=false] {boolean} When true, scale be uploaded and applied.
 * @param [properties.position=true] {boolean} When true, position be uploaded and applied.
 * @param [properties.rotation=false] {boolean} When true, rotation be uploaded and applied.
 * @param [properties.uvs=false] {boolean} When true, uvs be uploaded and applied.
 * @param [properties.alpha=false] {boolean} When true, alpha be uploaded and applied.
 * @param [batchSize=15000] {number} Number of particles per batch.
 */
function ParticleContainer(maxSize, properties, batchSize)
{
    Container.call(this);

    batchSize = batchSize || 15000; //CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop
    maxSize = maxSize || 15000;

    // Making sure the batch size is valid
    // 65535 is max vertex index in the index buffer (see ParticleRenderer)
    // so max number of particles is 65536 / 4 = 16384
    var maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
        batchSize = maxBatchSize;
    }

    if (batchSize > maxSize) {
        batchSize = maxSize;
    }

    /**
     * Set properties to be dynamic (true) / static (false)
     *
     * @member {boolean[]}
     * @private
     */
    this._properties = [false, true, false, false, false];

    /**
     * @member {number}
     * @private
     */
    this._maxSize = maxSize;

    /**
     * @member {number}
     * @private
     */
    this._batchSize = batchSize;

    /**
     * @member {WebGLBuffer}
     * @private
     */
    this._buffers = null;

    /**
     * @member {number}
     * @private
     */
    this._bufferToUpdate = 0;

    /**
     * @member {boolean}
     *
     */
    this.interactiveChildren = false;

    /**
     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    this.blendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * Used for canvas renderering. If true then the elements will be positioned at the nearest pixel. This provides a nice speed boost.
     *
     * @member {boolean}
     * @default true;
     */
    this.roundPixels = true;

    this.setProperties(properties);
}

ParticleContainer.prototype = Object.create(Container.prototype);
ParticleContainer.prototype.constructor = ParticleContainer;
module.exports = ParticleContainer;

/**
 * Sets the private properties array to dynamic / static based on the passed properties object
 *
 * @param properties {object} The properties to be uploaded
 */
ParticleContainer.prototype.setProperties = function(properties)
{
    if ( properties ) {
        this._properties[0] = 'scale' in properties ? !!properties.scale : this._properties[0];
        this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
        this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
        this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
        this._properties[4] = 'alpha' in properties ? !!properties.alpha : this._properties[4];
    }
};

/**
 * Updates the object transform for rendering
 *
 * @private
 */
ParticleContainer.prototype.updateTransform = function ()
{

    // TODO don't need to!
    this.displayObjectUpdateTransform();
    //  PIXI.Container.prototype.updateTransform.call( this );
};

/**
 * Renders the container using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer} The webgl renderer
 * @private
 */
ParticleContainer.prototype.renderWebGL = function (renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)
    {
        return;
    }

    renderer.setObjectRenderer( renderer.plugins.particle );
    renderer.plugins.particle.render( this );
};

/**
 * Set the flag that static data should be updated to true
 *
 * @private
 */
ParticleContainer.prototype.onChildrenChange = function (smallestChildIndex)
{
    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    if (bufferIndex < this._bufferToUpdate) {
        this._bufferToUpdate = bufferIndex;
    }
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer} The canvas renderer
 * @private
 */
ParticleContainer.prototype.renderCanvas = function (renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)
    {
        return;
    }

    var context = renderer.context;
    var transform = this.worldTransform;
    var isRotated = true;

    var positionX = 0;
    var positionY = 0;

    var finalWidth = 0;
    var finalHeight = 0;

    var compositeOperation = renderer.blendModes[this.blendMode];
    if (compositeOperation !== context.globalCompositeOperation)
    {
        context.globalCompositeOperation = compositeOperation;
    }

    context.globalAlpha = this.worldAlpha;

    this.displayObjectUpdateTransform();

    for (var i = 0; i < this.children.length; ++i)
    {
        var child = this.children[i];

        if (!child.visible)
        {
            continue;
        }

        var frame = child.texture.frame;

        context.globalAlpha = this.worldAlpha * child.alpha;

        if (child.rotation % (Math.PI * 2) === 0)
        {
            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call
            if (isRotated)
            {
                context.setTransform(
                    transform.a,
                    transform.b,
                    transform.c,
                    transform.d,
                    transform.tx,
                    transform.ty
                );

                isRotated = false;
            }

            positionX = ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5);
            positionY = ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5);

            finalWidth = frame.width * child.scale.x;
            finalHeight = frame.height * child.scale.y;

        }
        else
        {
            if (!isRotated)
            {
                isRotated = true;
            }

            child.displayObjectUpdateTransform();

            var childTransform = child.worldTransform;

            if (renderer.roundPixels)
            {
                context.setTransform(
                    childTransform.a,
                    childTransform.b,
                    childTransform.c,
                    childTransform.d,
                    childTransform.tx | 0,
                    childTransform.ty | 0
                );
            }
            else
            {
                context.setTransform(
                    childTransform.a,
                    childTransform.b,
                    childTransform.c,
                    childTransform.d,
                    childTransform.tx,
                    childTransform.ty
                );
            }

            positionX = ((child.anchor.x) * (-frame.width) + 0.5);
            positionY = ((child.anchor.y) * (-frame.height) + 0.5);

            finalWidth = frame.width;
            finalHeight = frame.height;
        }

        context.drawImage(
            child.texture.baseTexture.source,
            frame.x,
            frame.y,
            frame.width,
            frame.height,
            positionX,
            positionY,
            finalWidth,
            finalHeight
        );
    }
};

/**
 * Destroys the container
 *
 * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well
 */
ParticleContainer.prototype.destroy = function () {
    Container.prototype.destroy.apply(this, arguments);

    if (this._buffers) {
        for (var i = 0; i < this._buffers.length; ++i) {
            this._buffers[i].destroy();
        }
    }

    this._properties = null;
    this._buffers = null;
};

},{"../const":23,"../display/Container":24}],40:[function(require,module,exports){

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's ParticleBuffer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java
 */

/**
 * The particle buffer manages the static and dynamic buffers for a particle container.
 *
 * @class
 * @private
 * @memberof PIXI
 */
function ParticleBuffer(gl, properties, dynamicPropertyFlags, size)
{
    /**
     * The current WebGL drawing context.
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * Size of a single vertex.
     *
     * @member {number}
     */
    this.vertSize = 2;

    /**
     * Size of a single vertex in bytes.
     *
     * @member {number}
     */
    this.vertByteSize = this.vertSize * 4;

    /**
     * The number of particles the buffer can hold
     *
     * @member {number}
     */
    this.size = size;

    /**
     * A list of the properties that are dynamic.
     *
     * @member {object[]}
     */
    this.dynamicProperties = [];

    /**
     * A list of the properties that are static.
     *
     * @member {object[]}
     */
    this.staticProperties = [];

    for (var i = 0; i < properties.length; i++)
    {
        var property = properties[i];

        if(dynamicPropertyFlags[i])
        {
            this.dynamicProperties.push(property);
        }
        else
        {
            this.staticProperties.push(property);
        }
    }

    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;

    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;

    this.initBuffers();

}

ParticleBuffer.prototype.constructor = ParticleBuffer;
module.exports = ParticleBuffer;

/**
 * Sets up the renderer context and necessary buffers.
 *
 * @private
 */
ParticleBuffer.prototype.initBuffers = function ()
{
    var gl = this.gl;
    var i;
    var property;

    var dynamicOffset = 0;
    this.dynamicStride = 0;

    for (i = 0; i < this.dynamicProperties.length; i++)
    {
        property = this.dynamicProperties[i];

        property.offset = dynamicOffset;
        dynamicOffset += property.size;
        this.dynamicStride += property.size;
    }

    this.dynamicData = new Float32Array( this.size * this.dynamicStride * 4);
    this.dynamicBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.dynamicData, gl.DYNAMIC_DRAW);


    // static //
    var staticOffset = 0;
    this.staticStride = 0;

    for (i = 0; i < this.staticProperties.length; i++)
    {
        property = this.staticProperties[i];

        property.offset = staticOffset;
        staticOffset += property.size;
        this.staticStride += property.size;
    }

    this.staticData = new Float32Array( this.size * this.staticStride * 4);
    this.staticBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.staticData, gl.DYNAMIC_DRAW);
};

/**
 * Uploads the dynamic properties.
 *
 */
ParticleBuffer.prototype.uploadDynamic = function(children, startIndex, amount)
{
    var gl = this.gl;

    for (var i = 0; i < this.dynamicProperties.length; i++)
    {
        var property = this.dynamicProperties[i];
        property.uploadFunction(children, startIndex, amount, this.dynamicData, this.dynamicStride, property.offset);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.dynamicData);
};

/**
 * Uploads the static properties.
 *
 */
ParticleBuffer.prototype.uploadStatic = function(children, startIndex, amount)
{
    var gl = this.gl;

    for (var i = 0; i < this.staticProperties.length; i++)
    {
        var property = this.staticProperties[i];
        property.uploadFunction(children, startIndex, amount, this.staticData, this.staticStride, property.offset);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.staticData);
};

/**
 * Binds the buffers to the GPU
 *
 */
ParticleBuffer.prototype.bind = function ()
{
    var gl = this.gl;
    var i, property;

    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);

    for (i = 0; i < this.dynamicProperties.length; i++)
    {
        property = this.dynamicProperties[i];
        gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.dynamicStride * 4, property.offset * 4);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);

    for (i = 0; i < this.staticProperties.length; i++)
    {
        property = this.staticProperties[i];
        gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.staticStride * 4, property.offset * 4);
    }
};

/**
 * Destroys the ParticleBuffer.
 *
 */
ParticleBuffer.prototype.destroy = function ()
{
    this.dynamicProperties = null;
    this.dynamicData = null;
    this.gl.deleteBuffer(this.dynamicBuffer);

    this.staticProperties = null;
    this.staticData = null;
    this.gl.deleteBuffer(this.staticBuffer);
};

},{}],41:[function(require,module,exports){
var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
    ParticleShader = require('./ParticleShader'),
    ParticleBuffer = require('./ParticleBuffer'),
    math            = require('../../math');

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's ParticleRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java
 */

/**
 *
 * @class
 * @private
 * @memberof PIXI
 * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.
 */
function ParticleRenderer(renderer)
{
    ObjectRenderer.call(this, renderer);

    // 65535 is max vertex index in the index buffer (see ParticleRenderer)
    // so max number of particles is 65536 / 4 = 16384
    // and max number of element in the index buffer is 16384 * 6 = 98304
    // Creating a full index buffer, overhead is 98304 * 2 = 196Ko
    var numIndices = 98304;

    /**
     * Holds the indices
     *
     * @member {Uint16Array}
     */
    this.indices = new Uint16Array(numIndices);

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    /**
     * The default shader that is used if a sprite doesn't have a more specific one.
     *
     * @member {PIXI.Shader}
     */
    this.shader = null;

    this.indexBuffer = null;

    this.properties = null;

    this.tempMatrix = new math.Matrix();
}

ParticleRenderer.prototype = Object.create(ObjectRenderer.prototype);
ParticleRenderer.prototype.constructor = ParticleRenderer;
module.exports = ParticleRenderer;

WebGLRenderer.registerPlugin('particle', ParticleRenderer);

/**
 * When there is a WebGL context change
 *
 * @private
 */
ParticleRenderer.prototype.onContextChange = function ()
{
    var gl = this.renderer.gl;

    // setup default shader
    this.shader = new ParticleShader(this.renderer.shaderManager);

    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.

    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    this.properties = [
        // verticesData
        {
            attribute:this.shader.attributes.aVertexPosition,
            size:2,
            uploadFunction:this.uploadVertices,
            offset:0
        },
        // positionData
        {
            attribute:this.shader.attributes.aPositionCoord,
            size:2,
            uploadFunction:this.uploadPosition,
            offset:0
        },
        // rotationData
        {
            attribute:this.shader.attributes.aRotation,
            size:1,
            uploadFunction:this.uploadRotation,
            offset:0
        },
        // uvsData
        {
            attribute:this.shader.attributes.aTextureCoord,
            size:2,
            uploadFunction:this.uploadUvs,
            offset:0
        },
        // alphaData
        {
            attribute:this.shader.attributes.aColor,
            size:1,
            uploadFunction:this.uploadAlpha,
            offset:0
        }
    ];
};

/**
 * Starts a new particle batch.
 *
 */
ParticleRenderer.prototype.start = function ()
{
    var gl = this.renderer.gl;

    // bind the main texture
    gl.activeTexture(gl.TEXTURE0);

    // bind the buffers

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    var shader = this.shader;

    this.renderer.shaderManager.setShader(shader);
};


/**
 * Renders the particle container object.
 *
 * @param container {PIXI.ParticleContainer} The container to render using this ParticleRenderer
 */
ParticleRenderer.prototype.render = function (container)
{
    var children = container.children,
        totalChildren = children.length,
        maxSize = container._maxSize,
        batchSize = container._batchSize;

    if(totalChildren === 0)
    {
        return;
    }
    else if(totalChildren > maxSize)
    {
        totalChildren = maxSize;
    }

    if(!container._buffers)
    {
        container._buffers = this.generateBuffers( container );
    }

    // if the uvs have not updated then no point rendering just yet!
    this.renderer.blendModeManager.setBlendMode(container.blendMode);

    var gl = this.renderer.gl;

    var m =  container.worldTransform.copy( this.tempMatrix );
    m.prepend( this.renderer.currentRenderTarget.projectionMatrix );
    gl.uniformMatrix3fv(this.shader.uniforms.projectionMatrix._location, false, m.toArray(true));
    gl.uniform1f(this.shader.uniforms.uAlpha._location, container.worldAlpha);


    // make sure the texture is bound..
    var baseTexture = children[0]._texture.baseTexture;

    if (!baseTexture._glTextures[gl.id])
    {
        // if the texture has not updated then lets not upload any static properties
        if(!this.renderer.updateTexture(baseTexture))
        {
            return;
        }

        if(!container._properties[0] || !container._properties[3])
        {
            container._bufferToUpdate = 0;
        }
    }
    else
    {
        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);
    }

    // now lets upload and render the buffers..
    for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)
    {
        var amount = ( totalChildren - i);
        if(amount > batchSize)
        {
            amount = batchSize;
        }

        var buffer = container._buffers[j];

        // we always upload the dynamic
        buffer.uploadDynamic(children, i, amount);

        // we only upload the static content when we have to!
        if(container._bufferToUpdate === j)
        {
            buffer.uploadStatic(children, i, amount);
            container._bufferToUpdate = j + 1;
        }

        // bind the buffer
        buffer.bind( this.shader );

         // now draw those suckas!
        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        this.renderer.drawCount++;
    }
};

/**
 * Creates one particle buffer for each child in the container we want to render and updates internal properties
 *
 * @param container {PIXI.ParticleContainer} The container to render using this ParticleRenderer
 */
ParticleRenderer.prototype.generateBuffers = function (container)
{
    var gl = this.renderer.gl,
        buffers = [],
        size = container._maxSize,
        batchSize = container._batchSize,
        dynamicPropertyFlags = container._properties,
        i;

    for (i = 0; i < size; i += batchSize)
    {
        buffers.push(new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize));
    }

    return buffers;
};

/**
 * Uploads the verticies.
 *
 * @param children {PIXI.DisplayObject[]} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their vertices uploaded
 * @param array {number[]}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadVertices = function (children, startIndex, amount, array, stride, offset)
{
    var sprite,
        texture,
        trim,
        sx,
        sy,
        w0, w1, h0, h1;

    for (var i = 0; i < amount; i++) {

        sprite = children[startIndex + i];
        texture = sprite._texture;
        sx = sprite.scale.x;
        sy = sprite.scale.y;

        if (texture.trim)
        {
            // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
            trim = texture.trim;

            w1 = trim.x - sprite.anchor.x * trim.width;
            w0 = w1 + texture.crop.width;

            h1 = trim.y - sprite.anchor.y * trim.height;
            h0 = h1 + texture.crop.height;
        }
        else
        {
            w0 = (texture._frame.width ) * (1-sprite.anchor.x);
            w1 = (texture._frame.width ) * -sprite.anchor.x;

            h0 = texture._frame.height * (1-sprite.anchor.y);
            h1 = texture._frame.height * -sprite.anchor.y;
        }

        array[offset] = w1 * sx;
        array[offset + 1] = h1 * sy;

        array[offset + stride] = w0 * sx;
        array[offset + stride + 1] = h1 * sy;

        array[offset + stride * 2] = w0 * sx;
        array[offset + stride * 2 + 1] = h0 * sy;

        array[offset + stride * 3] = w1 * sx;
        array[offset + stride * 3 + 1] = h0 * sy;

        offset += stride * 4;
    }

};

/**
 *
 * @param children {PIXI.DisplayObject[]} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their positions uploaded
 * @param array {number[]}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadPosition = function (children,startIndex, amount, array, stride, offset)
{
    for (var i = 0; i < amount; i++)
    {
        var spritePosition = children[startIndex + i].position;

        array[offset] = spritePosition.x;
        array[offset + 1] = spritePosition.y;

        array[offset + stride] = spritePosition.x;
        array[offset + stride + 1] = spritePosition.y;

        array[offset + stride * 2] = spritePosition.x;
        array[offset + stride * 2 + 1] = spritePosition.y;

        array[offset + stride * 3] = spritePosition.x;
        array[offset + stride * 3 + 1] = spritePosition.y;

        offset += stride * 4;
    }

};

/**
 *
 * @param children {PIXI.DisplayObject[]} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their rotation uploaded
 * @param array {number[]}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadRotation = function (children,startIndex, amount, array, stride, offset)
{
    for (var i = 0; i < amount; i++)
    {
        var spriteRotation = children[startIndex + i].rotation;


        array[offset] = spriteRotation;
        array[offset + stride] = spriteRotation;
        array[offset + stride * 2] = spriteRotation;
        array[offset + stride * 3] = spriteRotation;

        offset += stride * 4;
    }
};

/**
 *
 * @param children {PIXI.DisplayObject[]} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their Uvs uploaded
 * @param array {number[]}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadUvs = function (children,startIndex, amount, array, stride, offset)
{
    for (var i = 0; i < amount; i++)
    {
        var textureUvs = children[startIndex + i]._texture._uvs;

        if (textureUvs)
        {
            array[offset] = textureUvs.x0;
            array[offset + 1] = textureUvs.y0;

            array[offset + stride] = textureUvs.x1;
            array[offset + stride + 1] = textureUvs.y1;

            array[offset + stride * 2] = textureUvs.x2;
            array[offset + stride * 2 + 1] = textureUvs.y2;

            array[offset + stride * 3] = textureUvs.x3;
            array[offset + stride * 3 + 1] = textureUvs.y3;

            offset += stride * 4;
        }
        else
        {
            //TODO you know this can be easier!
            array[offset] = 0;
            array[offset + 1] = 0;

            array[offset + stride] = 0;
            array[offset + stride + 1] = 0;

            array[offset + stride * 2] = 0;
            array[offset + stride * 2 + 1] = 0;

            array[offset + stride * 3] = 0;
            array[offset + stride * 3 + 1] = 0;

            offset += stride * 4;
        }
    }
};

/**
 *
 * @param children {PIXI.DisplayObject[]} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their alpha uploaded
 * @param array {number[]}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadAlpha = function (children,startIndex, amount, array, stride, offset)
{
     for (var i = 0; i < amount; i++)
     {
        var spriteAlpha = children[startIndex + i].alpha;

        array[offset] = spriteAlpha;
        array[offset + stride] = spriteAlpha;
        array[offset + stride * 2] = spriteAlpha;
        array[offset + stride * 3] = spriteAlpha;

        offset += stride * 4;
    }
};


/**
 * Destroys the ParticleRenderer.
 *
 */
ParticleRenderer.prototype.destroy = function ()
{
    if (this.renderer.gl) {
        this.renderer.gl.deleteBuffer(this.indexBuffer);
    }

    ObjectRenderer.prototype.destroy.apply(this, arguments);

    this.shader.destroy();

    this.indices = null;
    this.tempMatrix = null;
};

},{"../../math":33,"../../renderers/webgl/WebGLRenderer":49,"../../renderers/webgl/utils/ObjectRenderer":63,"./ParticleBuffer":40,"./ParticleShader":42}],42:[function(require,module,exports){
var TextureShader = require('../../renderers/webgl/shaders/TextureShader');

/**
 * @class
 * @extends PIXI.TextureShader
 * @memberof PIXI
 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
 */
function ParticleShader(shaderManager)
{
    TextureShader.call(this,
        shaderManager,
        // vertex shader
        [
            'attribute vec2 aVertexPosition;',
            'attribute vec2 aTextureCoord;',
            'attribute float aColor;',

            'attribute vec2 aPositionCoord;',
            'attribute vec2 aScale;',
            'attribute float aRotation;',

            'uniform mat3 projectionMatrix;',

            'varying vec2 vTextureCoord;',
            'varying float vColor;',

            'void main(void){',
            '   vec2 v = aVertexPosition;',

            '   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);',
            '   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);',
            '   v = v + aPositionCoord;',

            '   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);',

            '   vTextureCoord = aTextureCoord;',
            '   vColor = aColor;',
            '}'
        ].join('\n'),
        // hello
         [
            'precision lowp float;',

            'varying vec2 vTextureCoord;',
            'varying float vColor;',

            'uniform sampler2D uSampler;',
            'uniform float uAlpha;',

            'void main(void){',
            '  vec4 color = texture2D(uSampler, vTextureCoord) * vColor * uAlpha;',
            '  if (color.a == 0.0) discard;',
            '  gl_FragColor = color;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            uAlpha:  { type: '1f', value: 1 }
        },
        // custom attributes
        {
            aPositionCoord: 0,
           // aScale:         0,
            aRotation:      0
        }
    );

    // TEMP HACK

}

ParticleShader.prototype = Object.create(TextureShader.prototype);
ParticleShader.prototype.constructor = ParticleShader;

module.exports = ParticleShader;

},{"../../renderers/webgl/shaders/TextureShader":62}],43:[function(require,module,exports){
var utils = require('../utils'),
    math = require('../math'),
    CONST = require('../const'),
    EventEmitter = require('eventemitter3');

/**
 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @param system {string} The name of the system this renderer is for.
 * @param [width=800] {number} the width of the canvas view
 * @param [height=600] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass.
 * @param [options.backgroundColor=0x000000] {number} The background color of the rendered area (shown if not transparent).
 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
 */
function SystemRenderer(system, width, height, options)
{
    EventEmitter.call(this);

    utils.sayHello(system);

    // prepare options
    if (options)
    {
        for (var i in CONST.DEFAULT_RENDER_OPTIONS)
        {
            if (typeof options[i] === 'undefined')
            {
                options[i] = CONST.DEFAULT_RENDER_OPTIONS[i];
            }
        }
    }
    else
    {
        options = CONST.DEFAULT_RENDER_OPTIONS;
    }

    /**
     * The type of the renderer.
     *
     * @member {number}
     * @default PIXI.RENDERER_TYPE.UNKNOWN
     * @see PIXI.RENDERER_TYPE
     */
    this.type = CONST.RENDERER_TYPE.UNKNOWN;

    /**
     * The width of the canvas view
     *
     * @member {number}
     * @default 800
     */
    this.width = width || 800;

    /**
     * The height of the canvas view
     *
     * @member {number}
     * @default 600
     */
    this.height = height || 600;

    /**
     * The canvas element that everything is drawn to
     *
     * @member {HTMLCanvasElement}
     */
    this.view = options.view || document.createElement('canvas');

    /**
     * The resolution of the renderer
     *
     * @member {number}
     * @default 1
     */
    this.resolution = options.resolution;

    /**
     * Whether the render view is transparent
     *
     * @member {boolean}
     */
    this.transparent = options.transparent;

    /**
     * Whether the render view should be resized automatically
     *
     * @member {boolean}
     */
    this.autoResize = options.autoResize || false;

    /**
     * Tracks the blend modes useful for this renderer.
     *
     * @member {object<string, mixed>}
     */
    this.blendModes = null;

    /**
     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
     *
     * @member {boolean}
     */
    this.preserveDrawingBuffer = options.preserveDrawingBuffer;

    /**
     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
     * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
     * If the scene is transparent Pixi will use clearRect to clear the canvas every frame.
     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
     *
     * @member {boolean}
     * @default
     */
    this.clearBeforeRender = options.clearBeforeRender;

    /**
     * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Handy for crisp pixel art and speed on legacy devices.
     *
     * @member {boolean}
     */
    this.roundPixels = options.roundPixels;

    /**
     * The background color as a number.
     *
     * @member {number}
     * @private
     */
    this._backgroundColor = 0x000000;

    /**
     * The background color as an [R, G, B] array.
     *
     * @member {number[]}
     * @private
     */
    this._backgroundColorRgb = [0, 0, 0];

    /**
     * The background color as a string.
     *
     * @member {string}
     * @private
     */
    this._backgroundColorString = '#000000';

    this.backgroundColor = options.backgroundColor || this._backgroundColor; // run bg color setter

    /**
     * This temporary display object used as the parent of the currently being rendered item
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    this._tempDisplayObjectParent = {worldTransform:new math.Matrix(), worldAlpha:1, children:[]};

    /**
     * The last root object that the renderer tried to render.
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    this._lastObjectRendered = this._tempDisplayObjectParent;
}

// constructor
SystemRenderer.prototype = Object.create(EventEmitter.prototype);
SystemRenderer.prototype.constructor = SystemRenderer;
module.exports = SystemRenderer;

Object.defineProperties(SystemRenderer.prototype, {
    /**
     * The background color to fill if not transparent
     *
     * @member {number}
     * @memberof PIXI.SystemRenderer#
     */
    backgroundColor:
    {
        get: function ()
        {
            return this._backgroundColor;
        },
        set: function (val)
        {
            this._backgroundColor = val;
            this._backgroundColorString = utils.hex2string(val);
            utils.hex2rgb(val, this._backgroundColorRgb);
        }
    }
});

/**
 * Resizes the canvas view to the specified width and height
 *
 * @param width {number} the new width of the canvas view
 * @param height {number} the new height of the canvas view
 */
SystemRenderer.prototype.resize = function (width, height) {
    this.width = width * this.resolution;
    this.height = height * this.resolution;

    this.view.width = this.width;
    this.view.height = this.height;

    if (this.autoResize)
    {
        this.view.style.width = this.width / this.resolution + 'px';
        this.view.style.height = this.height / this.resolution + 'px';
    }
};

/**
 * Removes everything from the renderer and optionally removes the Canvas DOM element.
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
SystemRenderer.prototype.destroy = function (removeView) {
    if (removeView && this.view.parentNode)
    {
        this.view.parentNode.removeChild(this.view);
    }

    this.type = CONST.RENDERER_TYPE.UNKNOWN;

    this.width = 0;
    this.height = 0;

    this.view = null;

    this.resolution = 0;

    this.transparent = false;

    this.autoResize = false;

    this.blendModes = null;

    this.preserveDrawingBuffer = false;
    this.clearBeforeRender = false;

    this.roundPixels = false;

    this._backgroundColor = 0;
    this._backgroundColorRgb = null;
    this._backgroundColorString = null;
};

},{"../const":23,"../math":33,"../utils":77,"eventemitter3":10}],44:[function(require,module,exports){
var SystemRenderer = require('../SystemRenderer'),
    CanvasMaskManager = require('./utils/CanvasMaskManager'),
    utils = require('../../utils'),
    math = require('../../math'),
    CONST = require('../../const');

/**
 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.SystemRenderer
 * @param [width=800] {number} the width of the canvas view
 * @param [height=600] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass.
 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
 */
function CanvasRenderer(width, height, options)
{
    options = options || {};

    SystemRenderer.call(this, 'Canvas', width, height, options);

    this.type = CONST.RENDERER_TYPE.CANVAS;

    /**
     * The canvas 2d context that everything is drawn with.
     *
     * @member {CanvasRenderingContext2D}
     */
    this.context = this.view.getContext('2d', { alpha: this.transparent });

    /**
     * Boolean flag controlling canvas refresh.
     *
     * @member {boolean}
     */
    this.refresh = true;

    /**
     * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
     *
     * @member {PIXI.CanvasMaskManager}
     */
    this.maskManager = new CanvasMaskManager();

    /**
     * The canvas property used to set the canvas smoothing property.
     *
     * @member {string}
     */
    this.smoothProperty = 'imageSmoothingEnabled';

    if (!this.context.imageSmoothingEnabled)
    {
        if (this.context.webkitImageSmoothingEnabled)
        {
            this.smoothProperty = 'webkitImageSmoothingEnabled';
        }
        else if (this.context.mozImageSmoothingEnabled)
        {
            this.smoothProperty = 'mozImageSmoothingEnabled';
        }
        else if (this.context.oImageSmoothingEnabled)
        {
            this.smoothProperty = 'oImageSmoothingEnabled';
        }
        else if (this.context.msImageSmoothingEnabled)
        {
            this.smoothProperty = 'msImageSmoothingEnabled';
        }
    }

    this.initPlugins();

    this._mapBlendModes();

    /**
     * This temporary display object used as the parent of the currently being rendered item
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    this._tempDisplayObjectParent = {
        worldTransform: new math.Matrix(),
        worldAlpha: 1
    };


    this.resize(width, height);
}

// constructor
CanvasRenderer.prototype = Object.create(SystemRenderer.prototype);
CanvasRenderer.prototype.constructor = CanvasRenderer;
module.exports = CanvasRenderer;
utils.pluginTarget.mixin(CanvasRenderer);

/**
 * Renders the object to this canvas view
 *
 * @param object {PIXI.DisplayObject} the object to be rendered
 */
CanvasRenderer.prototype.render = function (object)
{
    this.emit('prerender');

    var cacheParent = object.parent;

    this._lastObjectRendered = object;

    object.parent = this._tempDisplayObjectParent;

    // update the scene graph
    object.updateTransform();

    object.parent = cacheParent;

    this.context.setTransform(1, 0, 0, 1, 0, 0);

    this.context.globalAlpha = 1;

    this.context.globalCompositeOperation = this.blendModes[CONST.BLEND_MODES.NORMAL];

    if (navigator.isCocoonJS && this.view.screencanvas)
    {
        this.context.fillStyle = 'black';
        this.context.clear();
    }

    if (this.clearBeforeRender)
    {
        if (this.transparent)
        {
            this.context.clearRect(0, 0, this.width, this.height);
        }
        else
        {
            this.context.fillStyle = this._backgroundColorString;
            this.context.fillRect(0, 0, this.width , this.height);
        }
    }

    this.renderDisplayObject(object, this.context);

    this.emit('postrender');
};

/**
 * Removes everything from the renderer and optionally removes the Canvas DOM element.
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
CanvasRenderer.prototype.destroy = function (removeView)
{
    this.destroyPlugins();

    // call the base destroy
    SystemRenderer.prototype.destroy.call(this, removeView);

    this.context = null;

    this.refresh = true;

    this.maskManager.destroy();
    this.maskManager = null;

    this.smoothProperty = null;
};

/**
 * Renders a display object
 *
 * @param displayObject {PIXI.DisplayObject} The displayObject to render
 * @private
 */
CanvasRenderer.prototype.renderDisplayObject = function (displayObject, context)
{
    var tempContext = this.context;

    this.context = context;
    displayObject.renderCanvas(this);
    this.context = tempContext;
};

/**
 * @extends PIXI.SystemRenderer#resize
 *
 * @param {number} w
 * @param {number} h
 */
CanvasRenderer.prototype.resize = function (w, h)
{
    SystemRenderer.prototype.resize.call(this, w, h);

    //reset the scale mode.. oddly this seems to be reset when the canvas is resized.
    //surely a browser bug?? Let pixi fix that for you..
    if(this.smoothProperty)
    {
        this.context[this.smoothProperty] = (CONST.SCALE_MODES.DEFAULT === CONST.SCALE_MODES.LINEAR);
    }

};

/**
 * Maps Pixi blend modes to canvas blend modes.
 *
 * @private
 */
CanvasRenderer.prototype._mapBlendModes = function ()
{
    if (!this.blendModes)
    {
        this.blendModes = {};

        if (utils.canUseNewCanvasBlendModes())
        {
            this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???
            this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'multiply';
            this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'screen';
            this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'overlay';
            this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'darken';
            this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'lighten';
            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'color-dodge';
            this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'color-burn';
            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'hard-light';
            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'soft-light';
            this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'difference';
            this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'exclusion';
            this.blendModes[CONST.BLEND_MODES.HUE]           = 'hue';
            this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'saturate';
            this.blendModes[CONST.BLEND_MODES.COLOR]         = 'color';
            this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'luminosity';
        }
        else
        {
            // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'
            this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???
            this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'source-over';
            this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'source-over';
            this.blendModes[CONST.BLEND_MODES.HUE]           = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR]         = 'source-over';
            this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'source-over';
        }
    }
};

},{"../../const":23,"../../math":33,"../../utils":77,"../SystemRenderer":43,"./utils/CanvasMaskManager":47}],45:[function(require,module,exports){
/**
 * Creates a Canvas element of the given size.
 *
 * @class
 * @memberof PIXI
 * @param width {number} the width for the newly created canvas
 * @param height {number} the height for the newly created canvas
 */
function CanvasBuffer(width, height)
{
    /**
     * The Canvas object that belongs to this CanvasBuffer.
     *
     * @member {HTMLCanvasElement}
     */
    this.canvas = document.createElement('canvas');

    /**
     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
     *
     * @member {CanvasRenderingContext2D}
     */
    this.context = this.canvas.getContext('2d');

    this.canvas.width = width;
    this.canvas.height = height;
}

CanvasBuffer.prototype.constructor = CanvasBuffer;
module.exports = CanvasBuffer;

Object.defineProperties(CanvasBuffer.prototype, {
    /**
     * The width of the canvas buffer in pixels.
     *
     * @member {number}
     * @memberof PIXI.CanvasBuffer#
     */
    width: {
        get: function ()
        {
            return this.canvas.width;
        },
        set: function (val)
        {
            this.canvas.width = val;
        }
    },
    /**
     * The height of the canvas buffer in pixels.
     *
     * @member {number}
     * @memberof PIXI.CanvasBuffer#
     */
    height: {
        get: function ()
        {
            return this.canvas.height;
        },
        set: function (val)
        {
            this.canvas.height = val;
        }
    }
});

/**
 * Clears the canvas that was created by the CanvasBuffer class.
 *
 * @private
 */
CanvasBuffer.prototype.clear = function ()
{
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0,0, this.canvas.width, this.canvas.height);
};

/**
 * Resizes the canvas to the specified width and height.
 *
 * @param width {number} the new width of the canvas
 * @param height {number} the new height of the canvas
 */
CanvasBuffer.prototype.resize = function (width, height)
{
    this.canvas.width = width;
    this.canvas.height = height;
};

/**
 * Destroys this canvas.
 *
 */
CanvasBuffer.prototype.destroy = function ()
{
    this.context = null;
    this.canvas = null;
};

},{}],46:[function(require,module,exports){
var CONST = require('../../../const');

/**
 * A set of functions used by the canvas renderer to draw the primitive graphics data.
 * @static
 * @class
 * @memberof PIXI
 */
var CanvasGraphics = {};
module.exports = CanvasGraphics;

/*
 * Renders a Graphics object to a canvas.
 *
 * @param graphics {PIXI.Graphics} the actual graphics object to render
 * @param context {CanvasRenderingContext2D} the 2d drawing method of the canvas
 */
CanvasGraphics.renderGraphics = function (graphics, context)
{
    var worldAlpha = graphics.worldAlpha;

    if (graphics.dirty)
    {
        this.updateGraphicsTint(graphics);
        graphics.dirty = false;
    }

    for (var i = 0; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];
        var shape = data.shape;

        var fillColor = data._fillTint;
        var lineColor = data._lineTint;

        context.lineWidth = data.lineWidth;

        if (data.type === CONST.SHAPES.POLY)
        {
            context.beginPath();

            var points = shape.points;

            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            if (shape.closed)
            {
                context.lineTo(points[0], points[1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

            if (data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
        else if (data.type === CONST.SHAPES.RECT)
        {

            if (data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fillRect(shape.x, shape.y, shape.width, shape.height);

            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.strokeRect(shape.x, shape.y, shape.width, shape.height);
            }
        }
        else if (data.type === CONST.SHAPES.CIRC)
        {
            // TODO - need to be Undefined!
            context.beginPath();
            context.arc(shape.x, shape.y, shape.radius,0,2*Math.PI);
            context.closePath();

            if (data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
        else if (data.type === CONST.SHAPES.ELIP)
        {
            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

            var w = shape.width * 2;
            var h = shape.height * 2;

            var x = shape.x - w/2;
            var y = shape.y - h/2;

            context.beginPath();

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

            context.closePath();

            if (data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
        else if (data.type === CONST.SHAPES.RREC)
        {
            var rx = shape.x;
            var ry = shape.y;
            var width = shape.width;
            var height = shape.height;
            var radius = shape.radius;

            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;

            context.beginPath();
            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();

            if (data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();

            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
    }
};

/*
 * Renders a graphics mask
 *
 * @private
 * @param graphics {PIXI.Graphics} the graphics which will be used as a mask
 * @param context {CanvasRenderingContext2D} the context 2d method of the canvas
 */
CanvasGraphics.renderGraphicsMask = function (graphics, context)
{
    var len = graphics.graphicsData.length;

    if (len === 0)
    {
        return;
    }

    context.beginPath();

    for (var i = 0; i < len; i++)
    {
        var data = graphics.graphicsData[i];
        var shape = data.shape;

        if (data.type === CONST.SHAPES.POLY)
        {

            var points = shape.points;

            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

        }
        else if (data.type === CONST.SHAPES.RECT)
        {
            context.rect(shape.x, shape.y, shape.width, shape.height);
            context.closePath();
        }
        else if (data.type === CONST.SHAPES.CIRC)
        {
            // TODO - need to be Undefined!
            context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
            context.closePath();
        }
        else if (data.type === CONST.SHAPES.ELIP)
        {

            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

            var w = shape.width * 2;
            var h = shape.height * 2;

            var x = shape.x - w/2;
            var y = shape.y - h/2;

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            context.closePath();
        }
        else if (data.type === CONST.SHAPES.RREC)
        {

            var rx = shape.x;
            var ry = shape.y;
            var width = shape.width;
            var height = shape.height;
            var radius = shape.radius;

            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;

            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();
        }
    }
};

/*
 * Updates the tint of a graphics object
 *
 * @private
 * @param graphics {PIXI.Graphics} the graphics that will have its tint updated
 *
 */
CanvasGraphics.updateGraphicsTint = function (graphics)
{
    if (graphics.tint === 0xFFFFFF && graphics._prevTint === graphics.tint)
    {
        return;
    }
    graphics._prevTint = graphics.tint;

    var tintR = (graphics.tint >> 16 & 0xFF) / 255;
    var tintG = (graphics.tint >> 8 & 0xFF) / 255;
    var tintB = (graphics.tint & 0xFF)/ 255;

    for (var i = 0; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];

        var fillColor = data.fillColor | 0;
        var lineColor = data.lineColor | 0;

        /*
        var colorR = (fillColor >> 16 & 0xFF) / 255;
        var colorG = (fillColor >> 8 & 0xFF) / 255;
        var colorB = (fillColor & 0xFF) / 255;

        colorR *= tintR;
        colorG *= tintG;
        colorB *= tintB;

        fillColor = ((colorR*255 << 16) + (colorG*255 << 8) + colorB*255);

        colorR = (lineColor >> 16 & 0xFF) / 255;
        colorG = (lineColor >> 8 & 0xFF) / 255;
        colorB = (lineColor & 0xFF) / 255;

        colorR *= tintR;
        colorG *= tintG;
        colorB *= tintB;

        lineColor = ((colorR*255 << 16) + (colorG*255 << 8) + colorB*255);
        */

        // super inline cos im an optimization NAZI :)
        data._fillTint = (((fillColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (fillColor & 0xFF) / 255 * tintB*255);
        data._lineTint = (((lineColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (lineColor & 0xFF) / 255 * tintB*255);

    }
};


},{"../../../const":23}],47:[function(require,module,exports){
var CanvasGraphics = require('./CanvasGraphics');

/**
 * A set of functions used to handle masking.
 *
 * @class
 * @memberof PIXI
 */
function CanvasMaskManager()
{}

CanvasMaskManager.prototype.constructor = CanvasMaskManager;
module.exports = CanvasMaskManager;

/**
 * This method adds it to the current stack of masks.
 *
 * @param maskData {object} the maskData that will be pushed
 * @param renderer {PIXI.WebGLRenderer|PIXI.CanvasRenderer} The renderer context to use.
 */
CanvasMaskManager.prototype.pushMask = function (maskData, renderer)
{

    renderer.context.save();

    var cacheAlpha = maskData.alpha;
    var transform = maskData.worldTransform;
    var resolution = renderer.resolution;

    renderer.context.setTransform(
        transform.a * resolution,
        transform.b * resolution,
        transform.c * resolution,
        transform.d * resolution,
        transform.tx * resolution,
        transform.ty * resolution
    );

    //TODO suport sprite alpha masks??
    //lots of effort required. If demand is great enough..
    if(!maskData.texture)
    {
        CanvasGraphics.renderGraphicsMask(maskData, renderer.context);
        renderer.context.clip();
    }

    maskData.worldAlpha = cacheAlpha;
};

/**
 * Restores the current drawing context to the state it was before the mask was applied.
 *
 * @param renderer {PIXI.WebGLRenderer|PIXI.CanvasRenderer} The renderer context to use.
 */
CanvasMaskManager.prototype.popMask = function (renderer)
{
    renderer.context.restore();
};

CanvasMaskManager.prototype.destroy = function () {};

},{"./CanvasGraphics":46}],48:[function(require,module,exports){
var utils = require('../../../utils');

/**
 * Utility methods for Sprite/Texture tinting.
 * @static
 * @class
 * @memberof PIXI
 */
var CanvasTinter = {};
module.exports = CanvasTinter;

/**
 * Basically this method just needs a sprite and a color and tints the sprite with the given color.
 *
 * @param sprite {PIXI.Sprite} the sprite to tint
 * @param color {number} the color to use to tint the sprite with
 * @return {HTMLCanvasElement} The tinted canvas
 */
CanvasTinter.getTintedTexture = function (sprite, color)
{
    var texture = sprite.texture;

    color = CanvasTinter.roundColor(color);

    var stringColor = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);

    texture.tintCache = texture.tintCache || {};

    if (texture.tintCache[stringColor])
    {
        return texture.tintCache[stringColor];
    }

     // clone texture..
    var canvas = CanvasTinter.canvas || document.createElement('canvas');

    //CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);
    CanvasTinter.tintMethod(texture, color, canvas);

    if (CanvasTinter.convertTintToImage)
    {
        // is this better?
        var tintImage = new Image();
        tintImage.src = canvas.toDataURL();

        texture.tintCache[stringColor] = tintImage;
    }
    else
    {
        texture.tintCache[stringColor] = canvas;
        // if we are not converting the texture to an image then we need to lose the reference to the canvas
        CanvasTinter.canvas = null;
    }

    return canvas;
};

/**
 * Tint a texture using the 'multiply' operation.
 *
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithMultiply = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var resolution = texture.baseTexture.resolution;

    var crop = texture.crop.clone();
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);

    context.fillRect(0, 0, crop.width, crop.height);

    context.globalCompositeOperation = 'multiply';

    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    context.globalCompositeOperation = 'destination-atop';

    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );
};

/**
 * Tint a texture using the 'overlay' operation.
 *
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithOverlay = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var resolution = texture.baseTexture.resolution;

    var crop = texture.crop.clone();
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.globalCompositeOperation = 'copy';
    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);
    context.fillRect(0, 0, crop.width, crop.height);

    context.globalCompositeOperation = 'destination-atop';
    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    // context.globalCompositeOperation = 'copy';
};

/**
 * Tint a texture pixel per pixel.
 *
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithPerPixel = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var resolution = texture.baseTexture.resolution;

    var crop = texture.crop.clone();
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.globalCompositeOperation = 'copy';
    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    var rgbValues = utils.hex2rgb(color);
    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];

    var pixelData = context.getImageData(0, 0, crop.width, crop.height);

    var pixels = pixelData.data;

    for (var i = 0; i < pixels.length; i += 4)
    {
        pixels[i+0] *= r;
        pixels[i+1] *= g;
        pixels[i+2] *= b;
    }

    context.putImageData(pixelData, 0, 0);
};

/**
 * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
 *
 * @param color {number} the color to round, should be a hex color
 */
CanvasTinter.roundColor = function (color)
{
    var step = CanvasTinter.cacheStepsPerColorChannel;

    var rgbValues = utils.hex2rgb(color);

    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);
    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);
    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);

    return utils.rgb2hex(rgbValues);
};

/**
 * Number of steps which will be used as a cap when rounding colors.
 *
 * @member
 */
CanvasTinter.cacheStepsPerColorChannel = 8;

/**
 * Tint cache boolean flag.
 *
 * @member
 */
CanvasTinter.convertTintToImage = false;

/**
 * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
 *
 * @member
 */
CanvasTinter.canUseMultiply = utils.canUseNewCanvasBlendModes();

/**
 * The tinting method that will be used.
 *
 */
CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply :  CanvasTinter.tintWithPerPixel;

},{"../../../utils":77}],49:[function(require,module,exports){
var SystemRenderer = require('../SystemRenderer'),
    ShaderManager = require('./managers/ShaderManager'),
    MaskManager = require('./managers/MaskManager'),
    StencilManager = require('./managers/StencilManager'),
    FilterManager = require('./managers/FilterManager'),
    BlendModeManager = require('./managers/BlendModeManager'),
    RenderTarget = require('./utils/RenderTarget'),
    ObjectRenderer = require('./utils/ObjectRenderer'),
    FXAAFilter = require('./filters/FXAAFilter'),
    utils = require('../../utils'),
    CONST = require('../../const');

/**
 * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
 * So no need for Sprite Batches or Sprite Clouds.
 * Don't forget to add the view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.SystemRenderer
 * @param [width=0] {number} the width of the canvas view
 * @param [height=0] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used
 * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always look as great
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass. If you wish to set this to false, you *must* set preserveDrawingBuffer to `true`.
 * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if
 *      you need to call toDataUrl on the webgl context.
 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
 */
function WebGLRenderer(width, height, options)
{
    options = options || {};

    SystemRenderer.call(this, 'WebGL', width, height, options);

    /**
     * The type of this renderer as a standardised const
     *
     * @member {number}
     *
     */
    this.type = CONST.RENDERER_TYPE.WEBGL;

    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);

    this.view.addEventListener('webglcontextlost', this.handleContextLost, false);
    this.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);

    //TODO possibility to force FXAA as it may offer better performance?
    /**
     * Does it use FXAA ?
     *
     * @member {boolean}
     * @private
     */
    this._useFXAA = !!options.forceFXAA && options.antialias;

    /**
     * The fxaa filter
     *
     * @member {PIXI.FXAAFilter}
     * @private
     */
    this._FXAAFilter = null;

    /**
     * The options passed in to create a new webgl context.
     *
     * @member {object}
     * @private
     */
    this._contextOptions = {
        alpha: this.transparent,
        antialias: options.antialias,
        premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer
    };

    /**
     * Counter for the number of draws made each frame
     *
     * @member {number}
     */
    this.drawCount = 0;

    /**
     * Deals with managing the shader programs and their attribs.
     *
     * @member {PIXI.ShaderManager}
     */
    this.shaderManager = new ShaderManager(this);

    /**
     * Manages the masks using the stencil buffer.
     *
     * @member {PIXI.MaskManager}
     */
    this.maskManager = new MaskManager(this);

    /**
     * Manages the stencil buffer.
     *
     * @member {PIXI.StencilManager}
     */
    this.stencilManager = new StencilManager(this);

    /**
     * Manages the filters.
     *
     * @member {PIXI.FilterManager}
     */
    this.filterManager = new FilterManager(this);


    /**
     * Manages the blendModes
     *
     * @member {PIXI.BlendModeManager}
     */
    this.blendModeManager = new BlendModeManager(this);

    /**
     * Holds the current render target
     *
     * @member {PIXI.RenderTarget}
     */
    this.currentRenderTarget = null;

    /**
     * The currently active ObjectRenderer.
     *
     * @member {PIXI.ObjectRenderer}
     */
    this.currentRenderer = new ObjectRenderer(this);

    this.initPlugins();

    // initialize the context so it is ready for the managers.
    this._createContext();
    this._initContext();

    // map some webGL blend modes..
    this._mapGlModes();

    // track textures in the renderer so we can no longer listen to them on destruction.
    this._managedTextures = [];

    /**
     * An array of render targets
     * @member {PIXI.RenderTarget[]}
     * @private
     */
    this._renderTargetStack = [];
}

// constructor
WebGLRenderer.prototype = Object.create(SystemRenderer.prototype);
WebGLRenderer.prototype.constructor = WebGLRenderer;
module.exports = WebGLRenderer;
utils.pluginTarget.mixin(WebGLRenderer);

WebGLRenderer.glContextId = 0;

/**
 * Creates the gl context.
 *
 * @private
 */
WebGLRenderer.prototype._createContext = function () {
    var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions);
    this.gl = gl;

    if (!gl)
    {
        // fail, not able to get a context
        throw new Error('This browser does not support webGL. Try using the canvas renderer');
    }

    this.glContextId = WebGLRenderer.glContextId++;
    gl.id = this.glContextId;
    gl.renderer = this;
};

/**
 * Creates the WebGL context
 *
 * @private
 */
WebGLRenderer.prototype._initContext = function ()
{
    var gl = this.gl;

    // set up the default pixi settings..
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.BLEND);

    this.renderTarget = new RenderTarget(gl, this.width, this.height, null, this.resolution, true);

    this.setRenderTarget(this.renderTarget);

    this.emit('context', gl);

    // setup the width/height properties and gl viewport
    this.resize(this.width, this.height);

    if(!this._useFXAA)
    {
        this._useFXAA = (this._contextOptions.antialias && ! gl.getContextAttributes().antialias);
    }


    if(this._useFXAA)
    {
        window.console.warn('FXAA antialiasing being used instead of native antialiasing');
        this._FXAAFilter = [new FXAAFilter()];
    }
};

/**
 * Renders the object to its webGL view
 *
 * @param object {PIXI.DisplayObject} the object to be rendered
 */
WebGLRenderer.prototype.render = function (object)
{

    this.emit('prerender');

    // no point rendering if our context has been blown up!
    if (this.gl.isContextLost())
    {
        return;
    }

    this.drawCount = 0;

    this._lastObjectRendered = object;

    if(this._useFXAA)
    {
        this._FXAAFilter[0].uniforms.resolution.value.x = this.width;
        this._FXAAFilter[0].uniforms.resolution.value.y = this.height;
        object.filterArea = this.renderTarget.size;
        object.filters = this._FXAAFilter;
    }

    var cacheParent = object.parent;
    object.parent = this._tempDisplayObjectParent;

    // update the scene graph
    object.updateTransform();

    object.parent = cacheParent;

    var gl = this.gl;

    // make sure we are bound to the main frame buffer
    this.setRenderTarget(this.renderTarget);

    if (this.clearBeforeRender)
    {
        if (this.transparent)
        {
            gl.clearColor(0, 0, 0, 0);
        }
        else
        {
            gl.clearColor(this._backgroundColorRgb[0], this._backgroundColorRgb[1], this._backgroundColorRgb[2], 1);
        }

        gl.clear(gl.COLOR_BUFFER_BIT);
    }

    this.renderDisplayObject(object, this.renderTarget);//this.projection);

    this.emit('postrender');
};

/**
 * Renders a Display Object.
 *
 * @param displayObject {PIXI.DisplayObject} The DisplayObject to render
 * @param renderTarget {PIXI.RenderTarget} The render target to use to render this display object
 *
 */
WebGLRenderer.prototype.renderDisplayObject = function (displayObject, renderTarget, clear)//projection, buffer)
{
    // TODO is this needed...
    //this.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);
    this.setRenderTarget(renderTarget);

    if(clear)
    {
        renderTarget.clear();
    }

    // start the filter manager
    this.filterManager.setFilterStack( renderTarget.filterStack );

    // render the scene!
    displayObject.renderWebGL(this);

    // finish the current renderer..
    this.currentRenderer.flush();
};

/**
 * Changes the current renderer to the one given in parameter
 *
 * @param objectRenderer {PIXI.ObjectRenderer} The object renderer to use.
 */
WebGLRenderer.prototype.setObjectRenderer = function (objectRenderer)
{
    if (this.currentRenderer === objectRenderer)
    {
        return;
    }

    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
};

/**
 * Changes the current render target to the one given in parameter
 *
 * @param renderTarget {PIXI.RenderTarget} the new render target
 */
WebGLRenderer.prototype.setRenderTarget = function (renderTarget)
{
    if( this.currentRenderTarget === renderTarget)
    {
        return;
    }
    // TODO - maybe down the line this should be a push pos thing? Leaving for now though.
    this.currentRenderTarget = renderTarget;
    this.currentRenderTarget.activate();
    this.stencilManager.setMaskStack( renderTarget.stencilMaskStack );
};


/**
 * Resizes the webGL view to the specified width and height.
 *
 * @param width {number} the new width of the webGL view
 * @param height {number} the new height of the webGL view
 */
WebGLRenderer.prototype.resize = function (width, height)
{
    SystemRenderer.prototype.resize.call(this, width, height);

    this.filterManager.resize(width, height);
    this.renderTarget.resize(width, height);

    if(this.currentRenderTarget === this.renderTarget)
    {
        this.renderTarget.activate();
        this.gl.viewport(0, 0, this.width, this.height);
    }
};

/**
 * Updates and/or Creates a WebGL texture for the renderer's context.
 *
 * @param texture {PIXI.BaseTexture|PIXI.Texture} the texture to update
 */
WebGLRenderer.prototype.updateTexture = function (texture)
{
    texture = texture.baseTexture || texture;

    if (!texture.hasLoaded)
    {
        return;
    }

    var gl = this.gl;

    if (!texture._glTextures[gl.id])
    {
        texture._glTextures[gl.id] = gl.createTexture();
        texture.on('update', this.updateTexture, this);
        texture.on('dispose', this.destroyTexture, this);
        this._managedTextures.push(texture);
    }


    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);

    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);


    if (texture.mipmap && texture.isPowerOfTwo)
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
    }
    else
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }

    if (!texture.isPowerOfTwo)
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    else
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    }

    return  texture._glTextures[gl.id];
};

/**
 * Deletes the texture from WebGL
 *
 * @param texture {PIXI.BaseTexture|PIXI.Texture} the texture to destroy
 */
WebGLRenderer.prototype.destroyTexture = function (texture, _skipRemove)
{
    texture = texture.baseTexture || texture;

    if (!texture.hasLoaded)
    {
        return;
    }

    if (texture._glTextures[this.gl.id])
    {
        this.gl.deleteTexture(texture._glTextures[this.gl.id]);
        delete texture._glTextures[this.gl.id];

        if (!_skipRemove)
        {
            var i = this._managedTextures.indexOf(texture);
            if (i !== -1) {
                utils.removeItems(this._managedTextures, i, 1);
            }
        }
    }
};

/**
 * Handles a lost webgl context
 *
 * @private
 */
WebGLRenderer.prototype.handleContextLost = function (event)
{
    event.preventDefault();
};

/**
 * Handles a restored webgl context
 *
 * @private
 */
WebGLRenderer.prototype.handleContextRestored = function ()
{
    this._initContext();

    // empty all the old gl textures as they are useless now
    for (var i = 0; i < this._managedTextures.length; ++i)
    {
        var texture = this._managedTextures[i];
        if (texture._glTextures[this.gl.id])
        {
            delete texture._glTextures[this.gl.id];
        }
    }
};

/**
 * Removes everything from the renderer (event listeners, spritebatch, etc...)
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
WebGLRenderer.prototype.destroy = function (removeView)
{
    this.destroyPlugins();

    // remove listeners
    this.view.removeEventListener('webglcontextlost', this.handleContextLost);
    this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);

    // destroy managed textures
    for (var i = 0; i < this._managedTextures.length; ++i)
    {
        var texture = this._managedTextures[i];
        this.destroyTexture(texture, true);
        texture.off('update', this.updateTexture, this);
        texture.off('dispose', this.destroyTexture, this);
    }

    // call base destroy
    SystemRenderer.prototype.destroy.call(this, removeView);

    this.uid = 0;

    // destroy the managers
    this.shaderManager.destroy();
    this.maskManager.destroy();
    this.stencilManager.destroy();
    this.filterManager.destroy();
    this.blendModeManager.destroy();

    this.shaderManager = null;
    this.maskManager = null;
    this.filterManager = null;
    this.blendModeManager = null;
    this.currentRenderer = null;

    this.handleContextLost = null;
    this.handleContextRestored = null;

    this._contextOptions = null;

    this._managedTextures = null;

    this.drawCount = 0;

    this.gl.useProgram(null);

    this.gl = null;
};

/**
 * Maps Pixi blend modes to WebGL blend modes.
 *
 * @private
 */
WebGLRenderer.prototype._mapGlModes = function ()
{
    var gl = this.gl;

    if (!this.blendModes)
    {
        this.blendModes = {};

        this.blendModes[CONST.BLEND_MODES.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];
        this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];
        this.blendModes[CONST.BLEND_MODES.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
    }

    if (!this.drawModes)
    {
        this.drawModes = {};

        this.drawModes[CONST.DRAW_MODES.POINTS]         = gl.POINTS;
        this.drawModes[CONST.DRAW_MODES.LINES]          = gl.LINES;
        this.drawModes[CONST.DRAW_MODES.LINE_LOOP]      = gl.LINE_LOOP;
        this.drawModes[CONST.DRAW_MODES.LINE_STRIP]     = gl.LINE_STRIP;
        this.drawModes[CONST.DRAW_MODES.TRIANGLES]      = gl.TRIANGLES;
        this.drawModes[CONST.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;
        this.drawModes[CONST.DRAW_MODES.TRIANGLE_FAN]   = gl.TRIANGLE_FAN;
    }
};

},{"../../const":23,"../../utils":77,"../SystemRenderer":43,"./filters/FXAAFilter":51,"./managers/BlendModeManager":53,"./managers/FilterManager":54,"./managers/MaskManager":55,"./managers/ShaderManager":56,"./managers/StencilManager":57,"./utils/ObjectRenderer":63,"./utils/RenderTarget":65}],50:[function(require,module,exports){
var DefaultShader = require('../shaders/TextureShader');

/**
 * This is the base class for creating a PIXI filter. Currently only WebGL supports filters.
 * If you want to make a custom filter this should be your base class.
 *
 * @class
 * @memberof PIXI
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param uniforms {object} An object containing the uniforms for this filter.
 */
function AbstractFilter(vertexSrc, fragmentSrc, uniforms)
{

    /**
     * An array of shaders
     * @member {PIXI.Shader[]}
     * @private
     */
    this.shaders = [];

    /**
     * The extra padding that the filter might need
     * @member {number}
     */
    this.padding = 0;

    /**
     * The uniforms as an object
     * @member {object}
     */
    this.uniforms = uniforms || {};


    /**
     * The code of the vertex shader
     * @member {string[]}
     * @private
     */
    this.vertexSrc = vertexSrc || DefaultShader.defaultVertexSrc;

    /**
     * The code of the frament shader
     * @member {string[]}
     * @private
     */
    this.fragmentSrc = fragmentSrc || DefaultShader.defaultFragmentSrc;

    //TODO a reminder - would be cool to have lower res filters as this would give better performance.

    //typeof fragmentSrc === 'string' ? fragmentSrc.split('') : (fragmentSrc || []);

}

AbstractFilter.prototype.constructor = AbstractFilter;
module.exports = AbstractFilter;

/**
 * Grabs a shader from the current renderer
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the shader from
 */
AbstractFilter.prototype.getShader = function (renderer)
{
    var gl = renderer.gl;

    var shader = this.shaders[gl.id];

    if (!shader)
    {
        shader = new DefaultShader(renderer.shaderManager,
            this.vertexSrc,
            this.fragmentSrc,
            this.uniforms,
            this.attributes
        );

        this.shaders[gl.id] = shader;
    }

    return shader;
};

/**
 * Applies the filter
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from
 * @param input {PIXI.RenderTarget}
 * @param output {PIXI.RenderTarget}
 * @param clear {boolean} Whether or not we want to clear the outputTarget
 */
AbstractFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    renderer.filterManager.applyFilter(shader, input, output, clear);
};

/**
 * Syncs a uniform between the class object and the shaders.
 *
 */
AbstractFilter.prototype.syncUniform = function (uniform)
{
    for (var i = 0, j = this.shaders.length; i < j; ++i)
    {
        this.shaders[i].syncUniform(uniform);
    }
};

},{"../shaders/TextureShader":62}],51:[function(require,module,exports){
var AbstractFilter = require('./AbstractFilter');
// @see https://github.com/substack/brfs/issues/25


/**
 *
 * Basic FXAA implementation based on the code on geeks3d.com with the
 * modification that the texture2DLod stuff was removed since it's
 * unsupported by WebGL.
 *
 * --
 * From:
 * https://github.com/mitsuhiko/webgl-meincraft
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI
 *
 */
function FXAAFilter()
{
    AbstractFilter.call(this,
        // vertex shader
        "\r\nprecision mediump float;\r\n\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform vec2 resolution;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nvarying vec2 vResolution;\r\n\r\n//texcoords computed in vertex step\r\n//to avoid dependent texture reads\r\nvarying vec2 v_rgbNW;\r\nvarying vec2 v_rgbNE;\r\nvarying vec2 v_rgbSW;\r\nvarying vec2 v_rgbSE;\r\nvarying vec2 v_rgbM;\r\n\r\n\r\nvoid texcoords(vec2 fragCoord, vec2 resolution,\r\n            out vec2 v_rgbNW, out vec2 v_rgbNE,\r\n            out vec2 v_rgbSW, out vec2 v_rgbSE,\r\n            out vec2 v_rgbM) {\r\n    vec2 inverseVP = 1.0 / resolution.xy;\r\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\r\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\r\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\r\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\r\n    v_rgbM = vec2(fragCoord * inverseVP);\r\n}\r\n\r\nvoid main(void){\r\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n   vTextureCoord = aTextureCoord;\r\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\r\n   vResolution = resolution;\r\n\r\n   //compute the texture coords and send them to varyings\r\n   texcoords(aTextureCoord * resolution, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\r\n}\r\n",
        // fragment shader
        "precision lowp float;\r\n\r\n\r\n/**\r\nBasic FXAA implementation based on the code on geeks3d.com with the\r\nmodification that the texture2DLod stuff was removed since it's\r\nunsupported by WebGL.\r\n\r\n--\r\n\r\nFrom:\r\nhttps://github.com/mitsuhiko/webgl-meincraft\r\n\r\nCopyright (c) 2011 by Armin Ronacher.\r\n\r\nSome rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without\r\nmodification, are permitted provided that the following conditions are\r\nmet:\r\n\r\n    * Redistributions of source code must retain the above copyright\r\n      notice, this list of conditions and the following disclaimer.\r\n\r\n    * Redistributions in binary form must reproduce the above\r\n      copyright notice, this list of conditions and the following\r\n      disclaimer in the documentation and/or other materials provided\r\n      with the distribution.\r\n\r\n    * The names of the contributors may not be used to endorse or\r\n      promote products derived from this software without specific\r\n      prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\n#ifndef FXAA_REDUCE_MIN\r\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\r\n#endif\r\n#ifndef FXAA_REDUCE_MUL\r\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\r\n#endif\r\n#ifndef FXAA_SPAN_MAX\r\n    #define FXAA_SPAN_MAX     8.0\r\n#endif\r\n\r\n//optimized version for mobile, where dependent\r\n//texture reads can be a bottleneck\r\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\r\n            vec2 v_rgbNW, vec2 v_rgbNE,\r\n            vec2 v_rgbSW, vec2 v_rgbSE,\r\n            vec2 v_rgbM) {\r\n    vec4 color;\r\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\r\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\r\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\r\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\r\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\r\n    vec4 texColor = texture2D(tex, v_rgbM);\r\n    vec3 rgbM  = texColor.xyz;\r\n    vec3 luma = vec3(0.299, 0.587, 0.114);\r\n    float lumaNW = dot(rgbNW, luma);\r\n    float lumaNE = dot(rgbNE, luma);\r\n    float lumaSW = dot(rgbSW, luma);\r\n    float lumaSE = dot(rgbSE, luma);\r\n    float lumaM  = dot(rgbM,  luma);\r\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\r\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\r\n\r\n    mediump vec2 dir;\r\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\r\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\r\n\r\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\r\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\r\n\r\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\r\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\r\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\r\n              dir * rcpDirMin)) * inverseVP;\r\n\r\n    vec3 rgbA = 0.5 * (\r\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\r\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\r\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\r\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\r\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\r\n\r\n    float lumaB = dot(rgbB, luma);\r\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\r\n        color = vec4(rgbA, texColor.a);\r\n    else\r\n        color = vec4(rgbB, texColor.a);\r\n    return color;\r\n}\r\n\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying vec2 vResolution;\r\n\r\n//texcoords computed in vertex step\r\n//to avoid dependent texture reads\r\nvarying vec2 v_rgbNW;\r\nvarying vec2 v_rgbNE;\r\nvarying vec2 v_rgbSW;\r\nvarying vec2 v_rgbSE;\r\nvarying vec2 v_rgbM;\r\n\r\nuniform sampler2D uSampler;\r\n\r\n\r\nvoid main(void){\r\n\r\n    gl_FragColor = fxaa(uSampler, vTextureCoord * vResolution, vResolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\r\n\r\n}\r\n",
        // uniforms
        {
            resolution: { type: 'v2', value: { x: 1, y: 1 } }
        }
    );

}

FXAAFilter.prototype = Object.create(AbstractFilter.prototype);
FXAAFilter.prototype.constructor = FXAAFilter;
module.exports = FXAAFilter;

/**
 * Applies the filter
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from
 * @param input {PIXI.RenderTarget}
 * @param output {PIXI.RenderTarget}
 */
FXAAFilter.prototype.applyFilter = function (renderer, input, output)
{
    var filterManager = renderer.filterManager;

    var shader = this.getShader( renderer );
     // draw the filter...
    filterManager.applyFilter(shader, input, output);
};

},{"./AbstractFilter":50}],52:[function(require,module,exports){
var AbstractFilter = require('./AbstractFilter'),
    math =  require('../../../math');

// @see https://github.com/substack/brfs/issues/25


/**
 * The SpriteMaskFilter class
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI
 * @param sprite {PIXI.Sprite} the target sprite
 */
function SpriteMaskFilter(sprite)
{
    var maskMatrix = new math.Matrix();

    AbstractFilter.call(this,
        "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 otherMatrix;\r\n\r\nvarying vec2 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\r\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\r\n}\r\n",
        "precision lowp float;\r\n\r\nvarying vec2 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\nuniform float alpha;\r\nuniform sampler2D mask;\r\n\r\nvoid main(void)\r\n{\r\n    // check clip! this will stop the mask bleeding out from the edges\r\n    vec2 text = abs( vMaskCoord - 0.5 );\r\n    text = step(0.5, text);\r\n    float clip = 1.0 - max(text.y, text.x);\r\n    vec4 original = texture2D(uSampler, vTextureCoord);\r\n    vec4 masky = texture2D(mask, vMaskCoord);\r\n    original *= (masky.r * masky.a * alpha * clip);\r\n    gl_FragColor = original;\r\n}\r\n",
        {
            mask:           { type: 'sampler2D', value: sprite._texture },
            alpha:          { type: 'f', value: 1},
            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) }
        }
    );

    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;
}

SpriteMaskFilter.prototype = Object.create(AbstractFilter.prototype);
SpriteMaskFilter.prototype.constructor = SpriteMaskFilter;
module.exports = SpriteMaskFilter;

/**
 * Applies the filter
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from
 * @param input {PIXI.RenderTarget}
 * @param output {PIXI.RenderTarget}
 */
SpriteMaskFilter.prototype.applyFilter = function (renderer, input, output)
{
    var filterManager = renderer.filterManager;

    this.uniforms.mask.value = this.maskSprite._texture;

    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);

    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);
    this.uniforms.alpha.value = this.maskSprite.worldAlpha;

    var shader = this.getShader(renderer);
     // draw the filter...
    filterManager.applyFilter(shader, input, output);
};


Object.defineProperties(SpriteMaskFilter.prototype, {
    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {PIXI.Texture}
     * @memberof PIXI.SpriteMaskFilter#
     */
    map: {
        get: function ()
        {
            return this.uniforms.mask.value;
        },
        set: function (value)
        {
            this.uniforms.mask.value = value;
        }
    },

    /**
     * The offset used to move the displacement map.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.SpriteMaskFilter#
     */
    offset: {
        get: function()
        {
            return this.uniforms.offset.value;
        },
        set: function(value)
        {
            this.uniforms.offset.value = value;
        }
    }
});

},{"../../../math":33,"./AbstractFilter":50}],53:[function(require,module,exports){
var WebGLManager = require('./WebGLManager');

/**
 * @class
 * @memberof PIXI
 * @extends PIXI.WebGlManager
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function BlendModeManager(renderer)
{
    WebGLManager.call(this, renderer);

    /**
     * @member {number}
     */
    this.currentBlendMode = 99999;
}

BlendModeManager.prototype = Object.create(WebGLManager.prototype);
BlendModeManager.prototype.constructor = BlendModeManager;
module.exports = BlendModeManager;

/**
 * Sets-up the given blendMode from WebGL's point of view.
 *
 * @param blendMode {number} the blendMode, should be a Pixi const, such as `PIXI.BLEND_MODES.ADD`. See
 *  {@link PIXI.BLEND_MODES} for possible values.
 */
BlendModeManager.prototype.setBlendMode = function (blendMode)
{
    if (this.currentBlendMode === blendMode)
    {
        return false;
    }

    this.currentBlendMode = blendMode;

    var mode = this.renderer.blendModes[this.currentBlendMode];
    this.renderer.gl.blendFunc(mode[0], mode[1]);

    return true;
};

},{"./WebGLManager":58}],54:[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    RenderTarget = require('../utils/RenderTarget'),
    CONST = require('../../../const'),
    Quad = require('../utils/Quad'),
    math =  require('../../../math');

/**
 * @class
 * @memberof PIXI
 * @extends PIXI.WebGLManager
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function FilterManager(renderer)
{
    WebGLManager.call(this, renderer);

    /**
     * @member {object[]}
     */
    this.filterStack = [];

    this.filterStack.push({
        renderTarget:renderer.currentRenderTarget,
        filter:[],
        bounds:null
    });

    /**
     * @member {PIXI.RenderTarget[]}
     */
    this.texturePool = [];

    /**
     * The size of the texture
     *
     * @member {PIXI.Rectangle}
     */
    // listen for context and update necessary buffers
    //TODO make this dynamic!
    //TODO test this out by forces power of two?
    this.textureSize = new math.Rectangle(0, 0, renderer.width, renderer.height);

    /**
     * The current frame
     *
     * @member {PIXI.Rectangle}
     */
    this.currentFrame = null;
}

FilterManager.prototype = Object.create(WebGLManager.prototype);
FilterManager.prototype.constructor = FilterManager;
module.exports = FilterManager;


/**
 * Called when there is a WebGL context change.
 *
 */
FilterManager.prototype.onContextChange = function ()
{
    this.texturePool.length = 0;

    var gl = this.renderer.gl;
    this.quad = new Quad(gl);
};

/**
 * @param renderer {PIXI.WebGLRenderer}
 * @param buffer {ArrayBuffer}
 */
FilterManager.prototype.setFilterStack = function ( filterStack )
{
    this.filterStack = filterStack;
};

/**
 * Applies the filter and adds it to the current filter stack.
 *
 * @param target {PIXI.DisplayObject}
 * @param filters {PIXI.AbstractFiler[]} the filters that will be pushed to the current filter stack
 */
FilterManager.prototype.pushFilter = function (target, filters)
{
    // get the bounds of the object..
    // TODO replace clone with a copy to save object creation
    var bounds = target.filterArea ? target.filterArea.clone() : target.getBounds();

    //bounds = bounds.clone();

    // round off the rectangle to get a nice smoooooooth filter :)
    bounds.x = bounds.x | 0;
    bounds.y = bounds.y | 0;
    bounds.width = bounds.width | 0;
    bounds.height = bounds.height | 0;


    // padding!
    var padding = filters[0].padding | 0;
    bounds.x -= padding;
    bounds.y -= padding;
    bounds.width += padding * 2;
    bounds.height += padding * 2;


    if(this.renderer.currentRenderTarget.transform)
    {
        //TODO this will break if the renderTexture transform is anything other than a translation.
        //Will need to take the full matrix transform into acount..
        var transform = this.renderer.currentRenderTarget.transform;

        bounds.x += transform.tx;
        bounds.y += transform.ty;

        this.capFilterArea( bounds );

        bounds.x -= transform.tx;
        bounds.y -= transform.ty;
    }
    else
    {
         this.capFilterArea( bounds );
    }

    if(bounds.width > 0 && bounds.height > 0)
    {
        this.currentFrame = bounds;

        var texture = this.getRenderTarget();

        this.renderer.setRenderTarget(texture);

        // clear the texture..
        texture.clear();

        // TODO get rid of object creation!
        this.filterStack.push({
            renderTarget: texture,
            filter: filters
        });

    }
    else
    {
        // push somthing on to the stack that is empty
        this.filterStack.push({
            renderTarget: null,
            filter: filters
        });
    }
};


/**
 * Removes the last filter from the filter stack and returns it.
 *
 */
FilterManager.prototype.popFilter = function ()
{
    var filterData = this.filterStack.pop();
    var previousFilterData = this.filterStack[this.filterStack.length-1];

    var input = filterData.renderTarget;

    // if the renderTarget is null then we don't apply the filter as its offscreen
    if(!filterData.renderTarget)
    {
        return;
    }

    var output = previousFilterData.renderTarget;

    // use program
    var gl = this.renderer.gl;


    this.currentFrame = input.frame;

    this.quad.map(this.textureSize, input.frame);


    // TODO.. this probably only needs to be done once!
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quad.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.quad.indexBuffer);

    var filters = filterData.filter;

    // assuming all filters follow the correct format??
    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);

    // restore the normal blendmode!
    this.renderer.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);

    if (filters.length === 1)
    {
        // TODO (cengler) - There has to be a better way then setting this each time?
        if (filters[0].uniforms.dimensions)
        {
            filters[0].uniforms.dimensions.value[0] = this.renderer.width;
            filters[0].uniforms.dimensions.value[1] = this.renderer.height;
            filters[0].uniforms.dimensions.value[2] = this.quad.vertices[0];
            filters[0].uniforms.dimensions.value[3] = this.quad.vertices[5];
        }

        filters[0].applyFilter( this.renderer, input, output );
        this.returnRenderTarget( input );

    }
    else
    {
        var flipTexture = input;
        var flopTexture = this.getRenderTarget(true);

        for (var i = 0; i < filters.length-1; i++)
        {
            var filter = filters[i];

            // TODO (cengler) - There has to be a better way then setting this each time?
            if (filter.uniforms.dimensions)
            {
                filter.uniforms.dimensions.value[0] = this.renderer.width;
                filter.uniforms.dimensions.value[1] = this.renderer.height;
                filter.uniforms.dimensions.value[2] = this.quad.vertices[0];
                filter.uniforms.dimensions.value[3] = this.quad.vertices[5];
            }

            filter.applyFilter( this.renderer, flipTexture, flopTexture );

            var temp = flipTexture;
            flipTexture = flopTexture;
            flopTexture = temp;
        }

        filters[filters.length-1].applyFilter( this.renderer, flipTexture, output );

        this.returnRenderTarget( flipTexture );
        this.returnRenderTarget( flopTexture );
    }

    return filterData.filter;
};

/**
 * Grabs an render target from the internal pool
 *
 * @param clear {boolean} Whether or not we need to clear the RenderTarget
 * @return {RenderTarget}
 */
FilterManager.prototype.getRenderTarget = function ( clear )
{
    var renderTarget = this.texturePool.pop() || new RenderTarget(this.renderer.gl, this.textureSize.width, this.textureSize.height, CONST.SCALE_MODES.LINEAR, this.renderer.resolution * CONST.FILTER_RESOLUTION);
    renderTarget.frame = this.currentFrame;

    if (clear)
    {
        renderTarget.clear(true);
    }

    return renderTarget;
};

/*
 * Returns a RenderTarget to the internal pool
 * @param renderTarget {RenderTarget} The RenderTarget we want to return to the pool
 */
FilterManager.prototype.returnRenderTarget = function (renderTarget)
{
    this.texturePool.push( renderTarget );
};

/*
 * Applies the filter
 * @param shader {Shader} The shader to upload
 * @param inputTarget {RenderTarget}
 * @param outputTarget {RenderTarget}
 * @param clear {boolean} Whether or not we want to clear the outputTarget
 */
FilterManager.prototype.applyFilter = function (shader, inputTarget, outputTarget, clear)
{
    var gl = this.renderer.gl;

    this.renderer.setRenderTarget(outputTarget);

    if (clear)
    {
        outputTarget.clear();
    }

    // set the shader
    this.renderer.shaderManager.setShader(shader);

    // TODO (cengler) - Can this be cached and not `toArray`ed each frame?
    shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);

    //TODO can this be optimised?
    shader.syncUniforms();
/*
    gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
    gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);
*/

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);

    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
    this.renderer.drawCount++;
};

/*
 * Calculates the mapped matrix
 * @param filterArea {Rectangle} The filter area
 * @param sprite {Sprite} the target sprite
 * @param outputMatrix {Matrix} @alvin
 */
// TODO playing around here.. this is temporary - (will end up in the shader)
FilterManager.prototype.calculateMappedMatrix = function (filterArea, sprite, outputMatrix)
{
    var worldTransform = sprite.worldTransform.copy(math.Matrix.TEMP_MATRIX),
    texture = sprite._texture.baseTexture;

    var mappedMatrix = outputMatrix.identity();

    // scale..
    var ratio = this.textureSize.height / this.textureSize.width;

    mappedMatrix.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height );

    mappedMatrix.scale(1 , ratio);

    var translateScaleX = (this.textureSize.width / texture.width);
    var translateScaleY = (this.textureSize.height / texture.height);

    worldTransform.tx /= texture.width * translateScaleX;
    worldTransform.ty /= texture.width * translateScaleX;

    worldTransform.invert();

    mappedMatrix.prepend(worldTransform);

    // apply inverse scale..
    mappedMatrix.scale(1 , 1/ratio);

    mappedMatrix.scale( translateScaleX , translateScaleY );

    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);

    return mappedMatrix;

    // Keeping the orginal as a reminder to me on how this works!
    //
    // var m = new math.Matrix();

    // // scale..
    // var ratio = this.textureSize.height / this.textureSize.width;

    // m.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height);


    // m.scale(1 , ratio);


    // var transform = wt.clone();

    // var translateScaleX = (this.textureSize.width / 620);
    // var translateScaleY = (this.textureSize.height / 380);

    // transform.tx /= 620 * translateScaleX;
    // transform.ty /= 620 * translateScaleX;

    // transform.invert();

    // transform.append(m);

    // // apply inverse scale..
    // transform.scale(1 , 1/ratio);

    // transform.scale( translateScaleX , translateScaleY );

    // return transform;
};

/*
 * Constrains the filter area to the texture size
 * @param filterArea {Rectangle} The filter area we want to cap
 */
FilterManager.prototype.capFilterArea = function (filterArea)
{
    if (filterArea.x < 0)
    {
        filterArea.width += filterArea.x;
        filterArea.x = 0;
    }

    if (filterArea.y < 0)
    {
        filterArea.height += filterArea.y;
        filterArea.y = 0;
    }

    if ( filterArea.x + filterArea.width > this.textureSize.width )
    {
        filterArea.width = this.textureSize.width - filterArea.x;
    }

    if ( filterArea.y + filterArea.height > this.textureSize.height )
    {
        filterArea.height = this.textureSize.height - filterArea.y;
    }
};

/*
 * Resizes all the render targets in the pool
 * @param width {number} the new width
 * @param height {number} the new height
 */
FilterManager.prototype.resize = function ( width, height )
{
    this.textureSize.width = width;
    this.textureSize.height = height;

    for (var i = 0; i < this.texturePool.length; i++)
    {
        this.texturePool[i].resize( width, height );
    }
};

/**
 * Destroys the filter and removes it from the filter stack.
 *
 */
FilterManager.prototype.destroy = function ()
{
    this.quad.destroy();
    
    WebGLManager.prototype.destroy.call(this);
    
    this.filterStack = null;
    this.offsetY = 0;

    // destroy textures
    for (var i = 0; i < this.texturePool.length; i++)
    {
        this.texturePool[i].destroy();
    }

    this.texturePool = null;
};

},{"../../../const":23,"../../../math":33,"../utils/Quad":64,"../utils/RenderTarget":65,"./WebGLManager":58}],55:[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    AlphaMaskFilter = require('../filters/SpriteMaskFilter');

/**
 * @class
 * @memberof PIXI
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function MaskManager(renderer)
{
    WebGLManager.call(this, renderer);

    this.stencilStack = [];
    this.reverse = true;
    this.count = 0;

    this.alphaMaskPool = [];
}

MaskManager.prototype = Object.create(WebGLManager.prototype);
MaskManager.prototype.constructor = MaskManager;
module.exports = MaskManager;

/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param graphics {PIXI.Graphics}
 * @param webGLData {any[]}
 */
MaskManager.prototype.pushMask = function (target, maskData)
{
    if (maskData.texture)
    {
        this.pushSpriteMask(target, maskData);
    }
    else
    {
        this.pushStencilMask(target, maskData);
    }

};

/**
 * Removes the last mask from the mask stack and doesn't return it.
 *
 * @param target {PIXI.RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.popMask = function (target, maskData)
{
    if (maskData.texture)
    {
        this.popSpriteMask(target, maskData);
    }
    else
    {
        this.popStencilMask(target, maskData);
    }
};

/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param target {PIXI.RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.pushSpriteMask = function (target, maskData)
{
    var alphaMaskFilter = this.alphaMaskPool.pop();

    if (!alphaMaskFilter)
    {
        alphaMaskFilter = [new AlphaMaskFilter(maskData)];
    }

    alphaMaskFilter[0].maskSprite = maskData;
    this.renderer.filterManager.pushFilter(target, alphaMaskFilter);
};

/**
 * Removes the last filter from the filter stack and doesn't return it.
 *
 */
MaskManager.prototype.popSpriteMask = function ()
{
    var filters = this.renderer.filterManager.popFilter();

    this.alphaMaskPool.push(filters);
};


/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param target {PIXI.RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.pushStencilMask = function (target, maskData)
{
    this.renderer.stencilManager.pushMask(maskData);
};

/**
 * Removes the last filter from the filter stack and doesn't return it.
 *
 * @param target {PIXI.RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.popStencilMask = function (target, maskData)
{
    this.renderer.stencilManager.popMask(maskData);
};


},{"../filters/SpriteMaskFilter":52,"./WebGLManager":58}],56:[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    TextureShader = require('../shaders/TextureShader'),
    ComplexPrimitiveShader = require('../shaders/ComplexPrimitiveShader'),
    PrimitiveShader = require('../shaders/PrimitiveShader'),
    utils = require('../../../utils');

/**
 * @class
 * @memberof PIXI
 * @extends PIXI.WebGLManager
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function ShaderManager(renderer)
{
    WebGLManager.call(this, renderer);

    /**
     * @member {number}
     */
    this.maxAttibs = 10;

    /**
     * @member {any[]}
     */
    this.attribState = [];

    /**
     * @member {any[]}
     */
    this.tempAttribState = [];

    for (var i = 0; i < this.maxAttibs; i++)
    {
        this.attribState[i] = false;
    }

    /**
     * @member {any[]}
     */
    this.stack = [];

    /**
     * @member {number}
     * @private
     */
    this._currentId = -1;

    /**
     * @member {PIXI.Shader}
     * @private
     */
    this.currentShader = null;

//    this.initPlugins();
}

ShaderManager.prototype = Object.create(WebGLManager.prototype);
ShaderManager.prototype.constructor = ShaderManager;
utils.pluginTarget.mixin(ShaderManager);

module.exports = ShaderManager;

/**
 * Called when there is a WebGL context change.
 *
 */
ShaderManager.prototype.onContextChange = function ()
{
    this.initPlugins();

    var gl = this.renderer.gl;

    // get the maximum number of attribute correctly as this tends to vary
    this.maxAttibs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

    this.attribState = [];

    for (var i = 0; i < this.maxAttibs; i++)
    {
        this.attribState[i] = false;
    }

    // TODO - Why are these not plugins? We can't decouple primitives unless they are....
    this.defaultShader = new TextureShader(this);
    this.primitiveShader = new PrimitiveShader(this);
    this.complexPrimitiveShader = new ComplexPrimitiveShader(this);
};

/**
 * Takes the attributes given in parameters and uploads them.
 *
 * @param attribs {any[]} attribs
 */
ShaderManager.prototype.setAttribs = function (attribs)
{
    // reset temp state
    var i;

    for (i = 0; i < this.tempAttribState.length; i++)
    {
        this.tempAttribState[i] = false;
    }

    // set the new attribs
    for (var a in attribs)
    {
        this.tempAttribState[attribs[a]] = true;
    }

    var gl = this.renderer.gl;

    for (i = 0; i < this.attribState.length; i++)
    {
        if (this.attribState[i] !== this.tempAttribState[i])
        {
            this.attribState[i] = this.tempAttribState[i];

            if (this.attribState[i])
            {
                gl.enableVertexAttribArray(i);
            }
            else
            {
                gl.disableVertexAttribArray(i);
            }
        }
    }
};

/**
 * Sets the current shader.
 *
 * @param shader {PIXI.Shader} the shader to upload
 */
ShaderManager.prototype.setShader = function (shader)
{
    if (this._currentId === shader.uid)
    {
        return false;
    }

    this._currentId = shader.uid;

    this.currentShader = shader;

    this.renderer.gl.useProgram(shader.program);
    this.setAttribs(shader.attributes);

    return true;
};

/**
 * Destroys this object.
 *
 */
ShaderManager.prototype.destroy = function ()
{
    this.primitiveShader.destroy();
    this.complexPrimitiveShader.destroy();
    WebGLManager.prototype.destroy.call(this);

    this.destroyPlugins();

    this.attribState = null;

    this.tempAttribState = null;
};

},{"../../../utils":77,"../shaders/ComplexPrimitiveShader":59,"../shaders/PrimitiveShader":60,"../shaders/TextureShader":62,"./WebGLManager":58}],57:[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    utils = require('../../../utils');

/**
 * @class
 * @memberof PIXI
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function WebGLMaskManager(renderer)
{
    WebGLManager.call(this, renderer);
    this.stencilMaskStack = null;
}

WebGLMaskManager.prototype = Object.create(WebGLManager.prototype);
WebGLMaskManager.prototype.constructor = WebGLMaskManager;
module.exports = WebGLMaskManager;

/**
 * Changes the mask stack that is used by this manager.
 *
 * @param stencilMaskStack {PIXI.StencilMaskStack} The mask stack
 */
WebGLMaskManager.prototype.setMaskStack = function ( stencilMaskStack )
{
    this.stencilMaskStack = stencilMaskStack;

    var gl = this.renderer.gl;

    if (stencilMaskStack.stencilStack.length === 0)
    {
        gl.disable(gl.STENCIL_TEST);
    }
    else
    {
        gl.enable(gl.STENCIL_TEST);
    }
};

/**
 * Applies the Mask and adds it to the current filter stack. @alvin
 *
 * @param graphics {PIXI.Graphics}
 * @param webGLData {any[]}
 */
WebGLMaskManager.prototype.pushStencil = function (graphics, webGLData)
{
    this.renderer.currentRenderTarget.attachStencilBuffer();

    var gl = this.renderer.gl,
        sms = this.stencilMaskStack;

    this.bindGraphics(graphics, webGLData);

    if (sms.stencilStack.length === 0)
    {
        gl.enable(gl.STENCIL_TEST);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        sms.reverse = true;
        sms.count = 0;
    }

    sms.stencilStack.push(webGLData);

    var level = sms.count;

    gl.colorMask(false, false, false, false);

    gl.stencilFunc(gl.ALWAYS,0,0xFF);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

    // draw the triangle strip!

    if (webGLData.mode === 1)
    {
        gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );

        if (sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        // draw a quad to increment..
        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );

        if (sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }

        sms.reverse = !sms.reverse;
    }
    else
    {
        if (!sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

        if (!sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }
    }

    gl.colorMask(true, true, true, true);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);

    sms.count++;
};

/**
 * TODO this does not belong here!
 *
 * @param graphics {PIXI.Graphics}
 * @param webGLData {any[]}
 */
WebGLMaskManager.prototype.bindGraphics = function (graphics, webGLData)
{
    //if (this._currentGraphics === graphics)return;
    var gl = this.renderer.gl;

     // bind the graphics object..
    var shader;// = this.renderer.shaderManager.plugins.primitiveShader;

    if (webGLData.mode === 1)
    {
        shader = this.renderer.shaderManager.complexPrimitiveShader;

        this.renderer.shaderManager.setShader(shader);

        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));

        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));

        gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));

        gl.uniform3fv(shader.uniforms.color._location, webGLData.color);

        gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);

        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);


        // now do the rest..
        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
    else
    {
        //this.renderer.shaderManager.activatePrimitiveShader();
        shader = this.renderer.shaderManager.primitiveShader;

        this.renderer.shaderManager.setShader(shader);

        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));

        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));

        gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));

        gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);

        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
        gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false,4 * 6, 2 * 4);

        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
};

/**
 * TODO @alvin
 * @param graphics {PIXI.Graphics}
 * @param webGLData {any[]}
 */
WebGLMaskManager.prototype.popStencil = function (graphics, webGLData)
{
    var gl = this.renderer.gl,
        sms = this.stencilMaskStack;

    sms.stencilStack.pop();

    sms.count--;

    if (sms.stencilStack.length === 0)
    {
        // the stack is empty!
        gl.disable(gl.STENCIL_TEST);

    }
    else
    {

        var level = sms.count;

        this.bindGraphics(graphics, webGLData);

        gl.colorMask(false, false, false, false);

        if (webGLData.mode === 1)
        {
            sms.reverse = !sms.reverse;

            if (sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            // draw a quad to increment..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );

            gl.stencilFunc(gl.ALWAYS,0,0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

            // draw the triangle strip!
            gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );

            this.renderer.drawCount += 2;

            if (!sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }

        }
        else
        {
          //  console.log("<<>>")
            if (!sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

            this.renderer.drawCount++;

            if (!sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }
        }

        gl.colorMask(true, true, true, true);
        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);


    }
};

/**
 * Destroys the mask stack.
 *
 */
WebGLMaskManager.prototype.destroy = function ()
{
    WebGLManager.prototype.destroy.call(this);

    this.stencilMaskStack.stencilStack = null;
};

/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param maskData {any[]} The mask data structure to use
 */
WebGLMaskManager.prototype.pushMask = function (maskData)
{


    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

    if (maskData.dirty)
    {
        this.renderer.plugins.graphics.updateGraphics(maskData, this.renderer.gl);
    }

    if (!maskData._webGL[this.renderer.gl.id].data.length)
    {
        return;
    }

    this.pushStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0]);
};

/**
 * Removes the last filter from the filter stack and doesn't return it.
 *
 * @param maskData {any[]}
 */
WebGLMaskManager.prototype.popMask = function (maskData)
{
    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

    this.popStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0]);
};


},{"../../../utils":77,"./WebGLManager":58}],58:[function(require,module,exports){
/**
 * @class
 * @memberof PIXI
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function WebGLManager(renderer)
{
    /**
     * The renderer this manager works for.
     *
     * @member {PIXI.WebGLRenderer}
     */
    this.renderer = renderer;

    this.renderer.on('context', this.onContextChange, this);
}

WebGLManager.prototype.constructor = WebGLManager;
module.exports = WebGLManager;

/**
 * Generic method called when there is a WebGL context change.
 *
 */
WebGLManager.prototype.onContextChange = function ()
{
	// do some codes init!
};

/**
 * Generic destroy methods to be overridden by the subclass
 *
 */
WebGLManager.prototype.destroy = function ()
{
    this.renderer.off('context', this.onContextChange, this);

    this.renderer = null;
};

},{}],59:[function(require,module,exports){
var Shader = require('./Shader');

/**
 * This shader is used to draw complex primitive shapes for {@link PIXI.Graphics}.
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.
 */
function ComplexPrimitiveShader(shaderManager)
{
    Shader.call(this,
        shaderManager,
        // vertex shader
        [
            'attribute vec2 aVertexPosition;',

            'uniform mat3 translationMatrix;',
            'uniform mat3 projectionMatrix;',

            'uniform vec3 tint;',
            'uniform float alpha;',
            'uniform vec3 color;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
            '   vColor = vec4(color * alpha * tint, alpha);',//" * vec4(tint * alpha, alpha);',
            '}'
        ].join('\n'),
        // fragment shader
        [
            'precision mediump float;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_FragColor = vColor;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            tint:   { type: '3f', value: [0, 0, 0] },
            alpha:  { type: '1f', value: 0 },
            color:  { type: '3f', value: [0,0,0] },
            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
        },
        // attributes
        {
            aVertexPosition:0
        }
    );
}

ComplexPrimitiveShader.prototype = Object.create(Shader.prototype);
ComplexPrimitiveShader.prototype.constructor = ComplexPrimitiveShader;
module.exports = ComplexPrimitiveShader;

},{"./Shader":61}],60:[function(require,module,exports){
var Shader = require('./Shader');

/**
 * This shader is used to draw simple primitive shapes for {@link PIXI.Graphics}.
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
 */
function PrimitiveShader(shaderManager)
{
    Shader.call(this,
        shaderManager,
        // vertex shader
        [
            'attribute vec2 aVertexPosition;',
            'attribute vec4 aColor;',

            'uniform mat3 translationMatrix;',
            'uniform mat3 projectionMatrix;',

            'uniform float alpha;',
            'uniform float flipY;',
            'uniform vec3 tint;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
            '   vColor = aColor * vec4(tint * alpha, alpha);',
            '}'
        ].join('\n'),
        // fragment shader
        [
            'precision mediump float;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_FragColor = vColor;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            tint:   { type: '3f', value: [0, 0, 0] },
            alpha:  { type: '1f', value: 0 },
            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
        },
        // custom attributes
        {
            aVertexPosition:0,
            aColor:0
        }
    );
}

PrimitiveShader.prototype = Object.create(Shader.prototype);
PrimitiveShader.prototype.constructor = PrimitiveShader;
module.exports = PrimitiveShader;

},{"./Shader":61}],61:[function(require,module,exports){
/*global console */
var utils = require('../../../utils');

/**
 * Base shader class for PIXI managed shaders.
 *
 * @class
 * @memberof PIXI
 * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.
 * @param [vertexSrc] {string} The source of the vertex shader.
 * @param [fragmentSrc] {string} The source of the fragment shader.
 * @param [uniforms] {object} Uniforms for this shader.
 * @param [attributes] {object} Attributes for this shader.
 */
function Shader(shaderManager, vertexSrc, fragmentSrc, uniforms, attributes)
{
    if (!vertexSrc || !fragmentSrc)
    {
         throw new Error('Pixi.js Error. Shader requires vertexSrc and fragmentSrc');
    }

    /**
     * A unique id
     * @member {number}
     * @readonly
     */
    this.uid = utils.uid();

    /**
     * The current WebGL drawing context
     * @member {WebGLRenderingContext}
     * @readonly
     */
    this.gl = shaderManager.renderer.gl;

    //TODO maybe we should pass renderer rather than shader manger?? food for thought..
    this.shaderManager = shaderManager;

    /**
     * The WebGL program.
     *
     * @member {WebGLProgram}
     * @readonly
     */
    this.program = null;

    /**
     * The uniforms as an object
     * @member {object}
     * @private
     */
    this.uniforms = uniforms || {};

    /**
     * The attributes as an object
     * @member {object}
     * @private
     */
    this.attributes = attributes || {};

    /**
     * Internal texture counter
     * @member {number}
     * @private
     */
    this.textureCount = 1;

    /**
     * The vertex shader as an array of strings
     *
     * @member {string}
     */
    this.vertexSrc = vertexSrc;

    /**
     * The fragment shader as an array of strings
     *
     * @member {string}
     */
    this.fragmentSrc = fragmentSrc;

    this.init();
}

Shader.prototype.constructor = Shader;
module.exports = Shader;

/**
 * Creates the shader and uses it
 *
 */
Shader.prototype.init = function ()
{
    this.compile();

    this.gl.useProgram(this.program);

    this.cacheUniformLocations(Object.keys(this.uniforms));
    this.cacheAttributeLocations(Object.keys(this.attributes));
};

/**
 * Caches the locations of the uniform for reuse.
 *
 * @param keys {string} the uniforms to cache
 */
Shader.prototype.cacheUniformLocations = function (keys)
{
    for (var i = 0; i < keys.length; ++i)
    {
        this.uniforms[keys[i]]._location = this.gl.getUniformLocation(this.program, keys[i]);
    }
};

/**
 * Caches the locations of the attribute for reuse.
 *
 * @param keys {string} the attributes to cache
 */
Shader.prototype.cacheAttributeLocations = function (keys)
{
    for (var i = 0; i < keys.length; ++i)
    {
        this.attributes[keys[i]] = this.gl.getAttribLocation(this.program, keys[i]);
    }

    // TODO: Check if this is needed anymore...

    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its something to do with the current state of the gl context.
    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    // if (this.attributes.aColor === -1){
    //     this.attributes.aColor = 2;
    // }

    // End worst hack eva //
};

/**
 * Attaches the shaders and creates the program.
 *
 * @return {WebGLProgram}
 */
Shader.prototype.compile = function ()
{
    var gl = this.gl;

    var glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexSrc);
    var glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentSrc);

    var program = gl.createProgram();

    gl.attachShader(program, glVertShader);
    gl.attachShader(program, glFragShader);
    gl.linkProgram(program);

    // if linking fails, then log and cleanup
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Pixi.js Error: Could not initialize shader.');
        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error('gl.getError()', gl.getError());

        // if there is a program info log, log it
        if (gl.getProgramInfoLog(program) !== '')
        {
            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
        }

        gl.deleteProgram(program);
        program = null;
    }

    // clean up some shaders
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);

    return (this.program = program);
};

/*
Shader.prototype.buildSync = function ()
{
   // var str = ""

   // str =  "Shader.prototype.syncUniforms = function()";
   // str += "{\n";

    for (var key in this.uniforms)
    {
        var uniform = this.uniforms[key];

        Object.defineProperty(this, key, {

            get: function ()
            {
                return uniform.value
            },
            set: function (value)
            {
                this.setUniform(uniform, value);
            }
        });

        console.log( makePropSetter( key, " bloop", uniform.type )  )
  //      Object.def
        //    location = uniform._location,
          //  value = uniform.value,
            //i, il;

    //    str += "gl.uniform1i(this.uniforms."+ key +"._location, this.uniforms." + key + ".value );\n"

    }

}*/

/**
* Adds a new uniform
*
* @param uniform {object} the new uniform to attach
*/
Shader.prototype.syncUniform = function (uniform)
{
    var location = uniform._location,
        value = uniform.value,
        gl = this.gl,
        i, il;

    switch (uniform.type)
    {
        case 'b':
        case 'bool':
        case 'boolean':
            gl.uniform1i(location, value ? 1 : 0);
            break;

        // single int value
        case 'i':
        case '1i':
            gl.uniform1i(location, value);
            break;

        // single float value
        case 'f':
        case '1f':
            gl.uniform1f(location, value);
            break;

        // Float32Array(2) or JS Arrray
        case '2f':
            gl.uniform2f(location, value[0], value[1]);
            break;

        // Float32Array(3) or JS Arrray
        case '3f':
            gl.uniform3f(location, value[0], value[1], value[2]);
            break;

        // Float32Array(4) or JS Arrray
        case '4f':
            gl.uniform4f(location, value[0], value[1], value[2], value[3]);
            break;

        // a 2D Point object
        case 'v2':
            gl.uniform2f(location, value.x, value.y);
            break;

        // a 3D Point object
        case 'v3':
            gl.uniform3f(location, value.x, value.y, value.z);
            break;

        // a 4D Point object
        case 'v4':
            gl.uniform4f(location, value.x, value.y, value.z, value.w);
            break;

        // Int32Array or JS Array
        case '1iv':
            gl.uniform1iv(location, value);
            break;

        // Int32Array or JS Array
        case '2iv':
            gl.uniform2iv(location, value);
            break;

        // Int32Array or JS Array
        case '3iv':
            gl.uniform3iv(location, value);
            break;

        // Int32Array or JS Array
        case '4iv':
            gl.uniform4iv(location, value);
            break;

        // Float32Array or JS Array
        case '1fv':
            gl.uniform1fv(location, value);
            break;

        // Float32Array or JS Array
        case '2fv':
            gl.uniform2fv(location, value);
            break;

        // Float32Array or JS Array
        case '3fv':
            gl.uniform3fv(location, value);
            break;

        // Float32Array or JS Array
        case '4fv':
            gl.uniform4fv(location, value);
            break;

        // Float32Array or JS Array
        case 'm2':
        case 'mat2':
        case 'Matrix2fv':
            gl.uniformMatrix2fv(location, uniform.transpose, value);
            break;

        // Float32Array or JS Array
        case 'm3':
        case 'mat3':
        case 'Matrix3fv':

            gl.uniformMatrix3fv(location, uniform.transpose, value);
            break;

        // Float32Array or JS Array
        case 'm4':
        case 'mat4':
        case 'Matrix4fv':
            gl.uniformMatrix4fv(location, uniform.transpose, value);
            break;

        // a Color Value
        case 'c':
            if (typeof value === 'number')
            {
                value = utils.hex2rgb(value);
            }

            gl.uniform3f(location, value[0], value[1], value[2]);
            break;

        // flat array of integers (JS or typed array)
        case 'iv1':
            gl.uniform1iv(location, value);
            break;

        // flat array of integers with 3 x N size (JS or typed array)
        case 'iv':
            gl.uniform3iv(location, value);
            break;

        // flat array of floats (JS or typed array)
        case 'fv1':
            gl.uniform1fv(location, value);
            break;

        // flat array of floats with 3 x N size (JS or typed array)
        case 'fv':
            gl.uniform3fv(location, value);
            break;

        // array of 2D Point objects
        case 'v2v':
            if (!uniform._array)
            {
                uniform._array = new Float32Array(2 * value.length);
            }

            for (i = 0, il = value.length; i < il; ++i)
            {
                uniform._array[i * 2]       = value[i].x;
                uniform._array[i * 2 + 1]   = value[i].y;
            }

            gl.uniform2fv(location, uniform._array);
            break;

        // array of 3D Point objects
        case 'v3v':
            if (!uniform._array)
            {
                uniform._array = new Float32Array(3 * value.length);
            }

            for (i = 0, il = value.length; i < il; ++i)
            {
                uniform._array[i * 3]       = value[i].x;
                uniform._array[i * 3 + 1]   = value[i].y;
                uniform._array[i * 3 + 2]   = value[i].z;

            }

            gl.uniform3fv(location, uniform._array);
            break;

        // array of 4D Point objects
        case 'v4v':
            if (!uniform._array)
            {
                uniform._array = new Float32Array(4 * value.length);
            }

            for (i = 0, il = value.length; i < il; ++i)
            {
                uniform._array[i * 4]       = value[i].x;
                uniform._array[i * 4 + 1]   = value[i].y;
                uniform._array[i * 4 + 2]   = value[i].z;
                uniform._array[i * 4 + 3]   = value[i].w;

            }

            gl.uniform4fv(location, uniform._array);
            break;

        // PIXI.Texture
        case 't':
        case 'sampler2D':

            if (!uniform.value || !uniform.value.baseTexture.hasLoaded)
            {
                break;
            }

            // activate this texture
            gl.activeTexture(gl['TEXTURE' + this.textureCount]);

            var texture = uniform.value.baseTexture._glTextures[gl.id];

            if (!texture)
            {
                this.initSampler2D(uniform);

                // set the textur to the newly created one..
                texture = uniform.value.baseTexture._glTextures[gl.id];
            }

            // bind the texture
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // set uniform to texture index
            gl.uniform1i(uniform._location, this.textureCount);

            // increment next texture id
            this.textureCount++;

            break;

        default:
            console.warn('Pixi.js Shader Warning: Unknown uniform type: ' + uniform.type);
    }
};

/**
 * Updates the shader uniform values.
 *
 */
Shader.prototype.syncUniforms = function ()
{
    this.textureCount = 1;

    for (var key in this.uniforms)
    {
        this.syncUniform(this.uniforms[key]);
    }
};


/**
 * Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)
 *
 */
Shader.prototype.initSampler2D = function (uniform)
{
    var gl = this.gl;

    var texture = uniform.value.baseTexture;

    if(!texture.hasLoaded)
    {
        return;
    }



    if (uniform.textureData)
    {

        //TODO move this...
        var data = uniform.textureData;

        texture._glTextures[gl.id] = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);
        // GLTextureLinear = mag/min linear, wrap clamp
        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat
        // GLTextureNearest = mag/min nearest, wrap clamp
        // AudioTexture = whatever + luminance + width 512, height 2, border 0
        // KeyTexture = whatever + luminance + width 256, height 2, border 0

        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST
        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT

        gl.texImage2D(gl.TEXTURE_2D, 0, data.luminance ? gl.LUMINANCE : gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, data.magFilter ? data.magFilter : gl.LINEAR );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE );

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE);
    }
    else
    {
        this.shaderManager.renderer.updateTexture(texture);
    }
};

/**
 * Destroys the shader.
 *
 */
Shader.prototype.destroy = function ()
{
    this.gl.deleteProgram(this.program);

    this.gl = null;
    this.uniforms = null;
    this.attributes = null;

    this.vertexSrc = null;
    this.fragmentSrc = null;
};

Shader.prototype._glCompile = function (type, src)
{
    var shader = this.gl.createShader(type);

    this.gl.shaderSource(shader, src);
    this.gl.compileShader(shader);

    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS))
    {
        console.log(this.gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

},{"../../../utils":77}],62:[function(require,module,exports){
var Shader = require('./Shader');

/**
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.
 * @param [vertexSrc] {string} The source of the vertex shader.
 * @param [fragmentSrc] {string} The source of the fragment shader.
 * @param [customUniforms] {object} Custom uniforms to use to augment the built-in ones.
 * @param [fragmentSrc] {string} The source of the fragment shader.
 */
function TextureShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes)
{
    var uniforms = {

        uSampler:           { type: 'sampler2D', value: 0 },
        projectionMatrix:   { type: 'mat3', value: new Float32Array([1, 0, 0,
                                                                     0, 1, 0,
                                                                     0, 0, 1]) }
    };

    if (customUniforms)
    {
        for (var u in customUniforms)
        {
            uniforms[u] = customUniforms[u];
        }
    }


    var attributes = {
        aVertexPosition:    0,
        aTextureCoord:      0,
        aColor:             0
    };

    if (customAttributes)
    {
        for (var a in customAttributes)
        {
            attributes[a] = customAttributes[a];
        }
    }

    /**
     * The vertex shader.
     *
     * @member {string}
     */
    vertexSrc = vertexSrc || TextureShader.defaultVertexSrc;

    /**
     * The fragment shader.
     *
     * @member {string}
     */
    fragmentSrc = fragmentSrc || TextureShader.defaultFragmentSrc;

    Shader.call(this, shaderManager, vertexSrc, fragmentSrc, uniforms, attributes);
}

// constructor
TextureShader.prototype = Object.create(Shader.prototype);
TextureShader.prototype.constructor = TextureShader;
module.exports = TextureShader;

/**
 * The default vertex shader source
 *
 * @static
 * @constant
 */
TextureShader.defaultVertexSrc = [
    'precision lowp float;',
    'attribute vec2 aVertexPosition;',
    'attribute vec2 aTextureCoord;',
    'attribute vec4 aColor;',

    'uniform mat3 projectionMatrix;',

    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',

    'void main(void){',
    '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
    '   vTextureCoord = aTextureCoord;',
    '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',
    '}'
].join('\n');

/**
 * The default fragment shader source
 *
 * @static
 * @constant
 */
TextureShader.defaultFragmentSrc = [
    'precision lowp float;',

    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',

    'uniform sampler2D uSampler;',

    'void main(void){',
    '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
    '}'
].join('\n');

},{"./Shader":61}],63:[function(require,module,exports){
var WebGLManager = require('../managers/WebGLManager');

/**
 * Base for a common object renderer that can be used as a system renderer plugin.
 *
 * @class
 * @extends PIXI.WebGLManager
 * @memberof PIXI
 * @param renderer {PIXI.WebGLRenderer} The renderer this object renderer works for.
 */
function ObjectRenderer(renderer)
{
    WebGLManager.call(this, renderer);
}


ObjectRenderer.prototype = Object.create(WebGLManager.prototype);
ObjectRenderer.prototype.constructor = ObjectRenderer;
module.exports = ObjectRenderer;

/**
 * Starts the renderer and sets the shader
 *
 */
ObjectRenderer.prototype.start = function ()
{
    // set the shader..
};

/**
 * Stops the renderer
 *
 */
ObjectRenderer.prototype.stop = function ()
{
    this.flush();
};

/**
 * flushes
 *
 */
ObjectRenderer.prototype.flush = function ()
{
    // flush!
};

/**
 * Renders an object
 *
 * @param object {PIXI.DisplayObject} The object to render.
 */
ObjectRenderer.prototype.render = function (object) // jshint unused:false
{
    // render the object
};

},{"../managers/WebGLManager":58}],64:[function(require,module,exports){
/**
 * Helper class to create a quad
 *
 * @class
 * @memberof PIXI
 * @param gl {WebGLRenderingContext} The gl context for this quad to use.
 */
function Quad(gl)
{
    /*
     * the current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

//    this.textures = new TextureUvs();

    /**
     * An array of vertices
     *
     * @member {Float32Array}
     */
    this.vertices = new Float32Array([
        0,0,
        200,0,
        200,200,
        0,200
    ]);

    /**
     * The Uvs of the quad
     *
     * @member {Float32Array}
     */
    this.uvs = new Float32Array([
        0,0,
        1,0,
        1,1,
        0,1
    ]);

//    var white = (0xFFFFFF >> 16) + (0xFFFFFF & 0xff00) + ((0xFFFFFF & 0xff) << 16) + (1 * 255 << 24);
    //TODO convert this to a 32 unsigned int array
    /**
     * The color components of the triangles
     *
     * @member {Float32Array}
     */
    this.colors = new Float32Array([
        1,1,1,1,
        1,1,1,1,
        1,1,1,1,
        1,1,1,1
    ]);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    this.indices = new Uint16Array([
        0, 1, 2, 0, 3, 2
    ]);

    /*
     * @member {WebGLBuffer} The vertex buffer
     */
    this.vertexBuffer = gl.createBuffer();

    /*
     * @member {WebGLBuffer} The index buffer
     */
    this.indexBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    this.upload();
}

Quad.prototype.constructor = Quad;

/**
 * Maps two Rectangle to the quad
 * @param rect {PIXI.Rectangle} the first rectangle
 * @param rect2 {PIXI.Rectangle} the second rectangle
 */
Quad.prototype.map = function(rect, rect2)
{
    var x = 0; //rect2.x / rect.width;
    var y = 0; //rect2.y / rect.height;

    this.uvs[0] = x;
    this.uvs[1] = y;

    this.uvs[2] = x + rect2.width / rect.width;
    this.uvs[3] = y;

    this.uvs[4] = x + rect2.width / rect.width;
    this.uvs[5] = y + rect2.height / rect.height;

    this.uvs[6] = x;
    this.uvs[7] = y + rect2.height / rect.height;

    /// -----
    x = rect2.x;
    y = rect2.y;

    this.vertices[0] = x;
    this.vertices[1] = y;

    this.vertices[2] = x + rect2.width;
    this.vertices[3] = y;

    this.vertices[4] = x + rect2.width;
    this.vertices[5] = y + rect2.height;

    this.vertices[6] = x;
    this.vertices[7] = y + rect2.height;

    this.upload();
};

/**
 * Binds the buffer and uploads the data
 */
Quad.prototype.upload = function()
{
    var gl = this.gl;

    // TODO could probably be pushed into one upload!
    gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);

    gl.bufferSubData(gl.ARRAY_BUFFER, 8 * 4, this.uvs);

    gl.bufferSubData(gl.ARRAY_BUFFER, (8 + 8) * 4, this.colors);
};

Quad.prototype.destroy = function()
{
    var gl = this.gl;
    
     gl.deleteBuffer(this.vertexBuffer);
     gl.deleteBuffer(this.indexBuffer);
};

module.exports = Quad;



},{}],65:[function(require,module,exports){
var math = require('../../../math'),
    utils = require('../../../utils'),
    CONST = require('../../../const'),
    //StencilManager = require('../managers/StencilManager'),
    StencilMaskStack = require('./StencilMaskStack');

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * @class
 * @memberof PIXI
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 * @param width {number} the horizontal range of the filter
 * @param height {number} the vertical range of the filter
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @param resolution {number} the current resolution
 * @param root {boolean} Whether this object is the root element or not
 */
var RenderTarget = function(gl, width, height, scaleMode, resolution, root)
{
    //TODO Resolution could go here ( eg low res blurs )

    /**
     * The current WebGL drawing context.
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    // next time to create a frame buffer and texture

    /**
     * A frame buffer
     *
     * @member {WebGLFrameBuffer}
     */
    this.frameBuffer = null;

    /**
     * The texture
     *
     * @member {PIXI.Texture}
     */
    this.texture = null;

    /**
     * The size of the object as a rectangle
     *
     * @member {PIXI.Rectangle}
     */
    this.size = new math.Rectangle(0, 0, 1, 1);

    /**
     * The current resolution
     *
     * @member {number}
     */
    this.resolution = resolution || CONST.RESOLUTION;

    /**
     * The projection matrix
     *
     * @member {PIXI.Matrix}
     */
    this.projectionMatrix = new math.Matrix();

    /**
     * The object's transform
     *
     * @member {PIXI.Matrix}
     */
    this.transform = null;

    /**
     * The frame.
     *
     * @member {PIXI.Rectangle}
     */
    this.frame = null;

    /**
     * The stencil buffer stores masking data for the render target
     *
     * @member {WebGLRenderBuffer}
     */
    this.stencilBuffer = null;

    /**
     * The data structure for the stencil masks
     *
     * @member {PIXI.StencilMaskStack}
     */
    this.stencilMaskStack = new StencilMaskStack();

    /**
     * Stores filter data for the render target
     *
     * @member {object[]}
     */
    this.filterStack = [
        {
            renderTarget:this,
            filter:[],
            bounds:this.size
        }
    ];


    /**
     * The scale mode.
     *
     * @member {number}
     * @default PIXI.SCALE_MODES.DEFAULT
     * @see PIXI.SCALE_MODES
     */
    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;

    /**
     * Whether this object is the root element or not
     *
     * @member {boolean}
     */
    this.root = root;

    if (!this.root)
    {
       // this.flipY = true;
        this.frameBuffer = gl.createFramebuffer();

        /*
            A frame buffer needs a target to render to..
            create a texture and bind it attach it to the framebuffer..
         */

        this.texture = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D,  this.texture);

        // set the scale properties of the texture..
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);

        // check to see if the texture is a power of two!
        var isPowerOfTwo = utils.isPowerOfTwo(width, height);

        //TODO for 99% of use cases if a texture is power of two we should tile the texture...
         if (!isPowerOfTwo)
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        else
        {

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    }

    this.resize(width, height);
};

RenderTarget.prototype.constructor = RenderTarget;
module.exports = RenderTarget;

/**
 * Clears the filter texture.
 *
 * @param [bind=false] {boolean} Should we bind our framebuffer before clearing?
 */
RenderTarget.prototype.clear = function(bind)
{
    var gl = this.gl;
    if(bind)
    {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
    }

    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/**
 * Binds the stencil buffer.
 *
 */
RenderTarget.prototype.attachStencilBuffer = function()
{

    if (this.stencilBuffer)
    {
        return;
    }

    /**
     * The stencil buffer is used for masking in pixi
     * lets create one and then add attach it to the framebuffer..
     */
    if (!this.root)
    {
        var gl = this.gl;

        this.stencilBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencilBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  this.size.width * this.resolution  , this.size.height * this.resolution );
    }
};

/**
 * Binds the buffers and initialises the viewport.
 *
 */
RenderTarget.prototype.activate = function()
{
    //TOOD refactor usage of frame..
    var gl = this.gl;

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

    var projectionFrame = this.frame || this.size;

    // TODO add a dirty flag to this of a setter for the frame?
    this.calculateProjection( projectionFrame );

    if(this.transform)
    {
        this.projectionMatrix.append(this.transform);
    }

    gl.viewport(0,0, projectionFrame.width * this.resolution, projectionFrame.height * this.resolution);
};

/**
 * Updates the projection matrix based on a projection frame (which is a rectangle)
 *
 */
RenderTarget.prototype.calculateProjection = function (projectionFrame)
{
    var pm = this.projectionMatrix;

    pm.identity();

    if (!this.root)
    {
        pm.a = 1 / projectionFrame.width*2;
        pm.d = 1 / projectionFrame.height*2;

        pm.tx = -1 - projectionFrame.x * pm.a;
        pm.ty = -1 - projectionFrame.y * pm.d;
    }
    else
    {
        pm.a = 1 / projectionFrame.width*2;
        pm.d = -1 / projectionFrame.height*2;

        pm.tx = -1 - projectionFrame.x * pm.a;
        pm.ty = 1 - projectionFrame.y * pm.d;
    }
};


/**
 * Resizes the texture to the specified width and height
 *
 * @param width {Number} the new width of the texture
 * @param height {Number} the new height of the texture
 */
RenderTarget.prototype.resize = function (width, height)
{
    width = width | 0;
    height = height | 0;

    if (this.size.width === width && this.size.height === height) {
        return;
    }

    this.size.width = width;
    this.size.height = height;

    if (!this.root)
    {
        var gl = this.gl;

        gl.bindTexture(gl.TEXTURE_2D,  this.texture);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width * this.resolution, height * this.resolution , 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        if (this.stencilBuffer )
        {
            // update the stencil buffer width and height
            gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  width * this.resolution, height * this.resolution );
        }
    }

    var projectionFrame = this.frame || this.size;

    this.calculateProjection( projectionFrame );
};

/**
 * Destroys the render target.
 *
 */
RenderTarget.prototype.destroy = function ()
{
    var gl = this.gl;
    gl.deleteRenderbuffer( this.stencilBuffer );
    gl.deleteFramebuffer( this.frameBuffer );
    gl.deleteTexture( this.texture );

    this.frameBuffer = null;
    this.texture = null;
};

},{"../../../const":23,"../../../math":33,"../../../utils":77,"./StencilMaskStack":66}],66:[function(require,module,exports){
/**
 * Generic Mask Stack data structure
 * @class
 * @memberof PIXI
 */
function StencilMaskStack()
{
	/**
     * The actual stack
     *
     * @member {any[]}
     */
    this.stencilStack = [];

    /**
     * TODO @alvin
     *
     * @member {boolean}
     */
    this.reverse = true;

    /**
     * Internal count
     *
     * @member {number}
     */
    this.count = 0;
}

StencilMaskStack.prototype.constructor = StencilMaskStack;
module.exports = StencilMaskStack;

},{}],67:[function(require,module,exports){
var math = require('../math'),
    Texture = require('../textures/Texture'),
    Container = require('../display/Container'),
    CanvasTinter = require('../renderers/canvas/utils/CanvasTinter'),
    utils = require('../utils'),
    CONST = require('../const'),
    tempPoint = new math.Point();

/**
 * The Sprite object is the base for all textured objects that are rendered to the screen
 *
 * A sprite can be created directly from an image like this:
 *
 * ```js
 * var sprite = new PIXI.Sprite.fromImage('assets/image.png');
 * ```
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 * @param texture {PIXI.Texture} The texture for this sprite
 */
function Sprite(texture)
{
    Container.call(this);

    /**
     * The anchor sets the origin point of the texture.
     * The default is 0,0 this means the texture's origin is the top left
     * Setting the anchor to 0.5,0.5 means the texture's origin is centered
     * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
     *
     * @member {PIXI.Point}
     */
    this.anchor = new math.Point();

    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     * @private
     */
    this._texture = null;

    /**
     * The width of the sprite (this is initially set by the texture)
     *
     * @member {number}
     * @private
     */
    this._width = 0;

    /**
     * The height of the sprite (this is initially set by the texture)
     *
     * @member {number}
     * @private
     */
    this._height = 0;

    /**
     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;

    /**
     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    this.blendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * The shader that will be used to render the sprite. Set to null to remove a current shader.
     *
     * @member {PIXI.AbstractFilter|PIXI.Shader}
     */
    this.shader = null;

    /**
     * An internal cached value of the tint.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    this.cachedTint = 0xFFFFFF;

    // call texture setter
    this.texture = texture || Texture.EMPTY;
}

// constructor
Sprite.prototype = Object.create(Container.prototype);
Sprite.prototype.constructor = Sprite;
module.exports = Sprite;

Object.defineProperties(Sprite.prototype, {
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Sprite#
     */
    width: {
        get: function ()
        {
            return Math.abs(this.scale.x) * this.texture._frame.width;
        },
        set: function (value)
        {
            var sign = utils.sign(this.scale.x) || 1;
            this.scale.x = sign * value / this.texture._frame.width;
            this._width = value;
        }
    },

    /**
     * The height of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Sprite#
     */
    height: {
        get: function ()
        {
            return  Math.abs(this.scale.y) * this.texture._frame.height;
        },
        set: function (value)
        {
            var sign = utils.sign(this.scale.y) || 1;
            this.scale.y = sign * value / this.texture._frame.height;
            this._height = value;
        }
    },

    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     * @memberof PIXI.Sprite#
     */
    texture: {
        get: function ()
        {
            return  this._texture;
        },
        set: function (value)
        {
            if (this._texture === value)
            {
                return;
            }

            this._texture = value;
            this.cachedTint = 0xFFFFFF;

            if (value)
            {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded)
                {
                    this._onTextureUpdate();
                }
                else
                {
                    value.once('update', this._onTextureUpdate, this);
                }
            }
        }
    }
});

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @private
 */
Sprite.prototype._onTextureUpdate = function ()
{
    // so if _width is 0 then width was not set..
    if (this._width)
    {
        this.scale.x = utils.sign(this.scale.x) * this._width / this.texture.frame.width;
    }

    if (this._height)
    {
        this.scale.y = utils.sign(this.scale.y) * this._height / this.texture.frame.height;
    }
};

/**
*
* Renders the object using the WebGL renderer
*
* @param renderer {PIXI.WebGLRenderer}
* @private
*/
Sprite.prototype._renderWebGL = function (renderer)
{
    renderer.setObjectRenderer(renderer.plugins.sprite);
    renderer.plugins.sprite.render(this);
};

/**
 * Returns the bounds of the Sprite as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {PIXI.Matrix} the transformation matrix of the sprite
 * @return {PIXI.Rectangle} the framing rectangle
 */
Sprite.prototype.getBounds = function (matrix)
{
    if(!this._currentBounds)
    {

        var width = this._texture._frame.width;
        var height = this._texture._frame.height;

        var w0 = width * (1-this.anchor.x);
        var w1 = width * -this.anchor.x;

        var h0 = height * (1-this.anchor.y);
        var h1 = height * -this.anchor.y;

        var worldTransform = matrix || this.worldTransform ;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var minX,
            maxX,
            minY,
            maxY;

        //TODO - I am SURE this can be optimised, but the below is not accurate enough..
        /*
        if (b === 0 && c === 0)
        {
            // scale may be negative!
            if (a < 0)
            {
                a *= -1;
            }

            if (d < 0)
            {
                d *= -1;
            }

            // this means there is no rotation going on right? RIGHT?
            // if thats the case then we can avoid checking the bound values! yay
            minX = a * w1 + tx;
            maxX = a * w0 + tx;
            minY = d * h1 + ty;
            maxY = d * h0 + ty;
        }
        else
        {
        */
       
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;

        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;

        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;

        var x4 =  a * w1 + c * h0 + tx;
        var y4 =  d * h0 + b * w1 + ty;

        minX = x1;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;

        minY = y1;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;

        maxX = x1;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;

        maxY = y1;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;

        //}

        // check for children
        if(this.children.length)
        {
            var childBounds = this.containerGetBounds();

            w0 = childBounds.x;
            w1 = childBounds.x + childBounds.width;
            h0 = childBounds.y;
            h1 = childBounds.y + childBounds.height;

            minX = (minX < w0) ? minX : w0;
            minY = (minY < h0) ? minY : h0;

            maxX = (maxX > w1) ? maxX : w1;
            maxY = (maxY > h1) ? maxY : h1;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.width = maxX - minX;

        bounds.y = minY;
        bounds.height = maxY - minY;

        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

/**
 * Gets the local bounds of the sprite object.
 *
 */
Sprite.prototype.getLocalBounds = function ()
{
    this._bounds.x = -this._texture._frame.width * this.anchor.x;
    this._bounds.y = -this._texture._frame.height * this.anchor.y;
    this._bounds.width = this._texture._frame.width;
    this._bounds.height = this._texture._frame.height;
    return this._bounds;
};

/**
* Tests if a point is inside this sprite
*
* @param point {PIXI.Point} the point to test
* @return {boolean} the result of the test
*/
Sprite.prototype.containsPoint = function( point )
{
    this.worldTransform.applyInverse(point,  tempPoint);

    var width = this._texture._frame.width;
    var height = this._texture._frame.height;
    var x1 = -width * this.anchor.x;
    var y1;

    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )
    {
        y1 = -height * this.anchor.y;

        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )
        {
            return true;
        }
    }

    return false;
};

/**
* Renders the object using the Canvas renderer
*
* @param renderer {PIXI.CanvasRenderer} The renderer
* @private
*/
Sprite.prototype._renderCanvas = function (renderer)
{
    if (this.texture.crop.width <= 0 || this.texture.crop.height <= 0)
    {
        return;
    }

    var compositeOperation = renderer.blendModes[this.blendMode];
    if (compositeOperation !== renderer.context.globalCompositeOperation)
    {
        renderer.context.globalCompositeOperation = compositeOperation;
    }

    //  Ignore null sources
    if (this.texture.valid)
    {
        var texture = this._texture,
            wt = this.worldTransform,
            dx,
            dy,
            width,
            height;

        renderer.context.globalAlpha = this.worldAlpha;

        // If smoothingEnabled is supported and we need to change the smoothing property for this texture
        var smoothingEnabled = texture.baseTexture.scaleMode === CONST.SCALE_MODES.LINEAR;
        if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled)
        {
            renderer.context[renderer.smoothProperty] = smoothingEnabled;
        }

        // If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions

        if(texture.rotate)
        {
            width = texture.crop.height;
            height = texture.crop.width;

            dx = (texture.trim) ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;
            dy = (texture.trim) ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;
       
            dx += width;

            wt.tx = dy * wt.a + dx * wt.c + wt.tx;
            wt.ty = dy * wt.b + dx * wt.d + wt.ty;

            var temp = wt.a;
            wt.a  = -wt.c;
            wt.c  =  temp;

            temp = wt.b;
            wt.b  = -wt.d;
            wt.d  =  temp;

            // the anchor has already been applied above, so lets set it to zero
            dx = 0;
            dy = 0;

        }
        else
        {
            width = texture.crop.width;
            height = texture.crop.height;

            dx = (texture.trim) ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;
            dy = (texture.trim) ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;
        }



        // Allow for pixel rounding
        if (renderer.roundPixels)
        {
            renderer.context.setTransform(
                wt.a,
                wt.b,
                wt.c,
                wt.d,
                (wt.tx * renderer.resolution) | 0,
                (wt.ty * renderer.resolution) | 0
            );

            dx = dx | 0;
            dy = dy | 0;
        }
        else
        {

            renderer.context.setTransform(
                wt.a,
                wt.b,
                wt.c,
                wt.d,
                wt.tx * renderer.resolution,
                wt.ty * renderer.resolution
            );


        }

        var resolution = texture.baseTexture.resolution;

        if (this.tint !== 0xFFFFFF)
        {
            if (this.cachedTint !== this.tint)
            {
                this.cachedTint = this.tint;

                // TODO clean up caching - how to clean up the caches?
                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);
            }

            renderer.context.drawImage(
                this.tintedTexture,
                0,
                0,
                width * resolution,
                height * resolution,
                dx * renderer.resolution,
                dy * renderer.resolution,
                width * renderer.resolution,
                height * renderer.resolution
            );
        }
        else
        {
            renderer.context.drawImage(
                texture.baseTexture.source,
                texture.crop.x * resolution,
                texture.crop.y * resolution,
                width * resolution,
                height * resolution,
                dx  * renderer.resolution,
                dy  * renderer.resolution,
                width * renderer.resolution,
                height * renderer.resolution
            );
        }
    }
};

/**
 * Destroys this sprite and optionally its texture
 *
 * @param [destroyTexture=false] {boolean} Should it destroy the current texture of the sprite as well
 * @param [destroyBaseTexture=false] {boolean} Should it destroy the base texture of the sprite as well
 */
Sprite.prototype.destroy = function (destroyTexture, destroyBaseTexture)
{
    Container.prototype.destroy.call(this);

    this.anchor = null;

    if (destroyTexture)
    {
        this._texture.destroy(destroyBaseTexture);
    }

    this._texture = null;
    this.shader = null;
};

// some helper functions..

/**
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {string} The frame Id of the texture in the cache
 * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} if you want to specify the scale mode, see {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the frameId
 */
Sprite.fromFrame = function (frameId)
{
    var texture = utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
    }

    return new Sprite(texture);
};

/**
 * Helper function that creates a sprite that will contain a texture based on an image url
 * If the image is not in the texture cache it will be loaded
 *
 * @static
 * @param imageId {string} The image url of the texture
 * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the image id
 */
Sprite.fromImage = function (imageId, crossorigin, scaleMode)
{
    return new Sprite(Texture.fromImage(imageId, crossorigin, scaleMode));
};

},{"../const":23,"../display/Container":24,"../math":33,"../renderers/canvas/utils/CanvasTinter":48,"../textures/Texture":72,"../utils":77}],68:[function(require,module,exports){
var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
    CONST = require('../../const');

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's SpriteRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteRenderer.java
 */

/**
 * Renderer dedicated to drawing and batching sprites.
 *
 * @class
 * @private
 * @memberof PIXI
 * @extends PIXI.ObjectRenderer
 * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.
 */
function SpriteRenderer(renderer)
{
    ObjectRenderer.call(this, renderer);

    /**
     * Number of values sent in the vertex buffer.
     * positionX, positionY, colorR, colorG, colorB = 5
     *
     * @member {number}
     */
    this.vertSize = 5;

    /**
     * The size of the vertex information in bytes.
     *
     * @member {number}
     */
    this.vertByteSize = this.vertSize * 4;

    /**
     * The number of images in the SpriteBatch before it flushes.
     *
     * @member {number}
     */
    this.size = CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop

    // the total number of bytes in our batch
    var numVerts = (this.size * 4) * this.vertByteSize;

    // the total number of indices in our batch, there are 6 points per quad.
    var numIndices = this.size * 6;

    /**
     * Holds the vertex data that will be sent to the vertex shader.
     *
     * @member {ArrayBuffer}
     */
    this.vertices = new ArrayBuffer(numVerts);

    /**
     * View on the vertices as a Float32Array for positions
     *
     * @member {Float32Array}
     */
    this.positions = new Float32Array(this.vertices);

    /**
     * View on the vertices as a Uint32Array for colors
     *
     * @member {Uint32Array}
     */
    this.colors = new Uint32Array(this.vertices);

    /**
     * Holds the indices of the geometry (quads) to draw
     *
     * @member {Uint16Array}
     */
    this.indices = new Uint16Array(numIndices);

    // fill the indices with the quads to draw
    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    /**
     * The current size of the batch, each render() call adds to this number.
     *
     * @member {number}
     */
    this.currentBatchSize = 0;

    /**
     * The current sprites in the batch.
     *
     * @member {PIXI.Sprite[]}
     */
    this.sprites = [];

    /**
     * The default shader that is used if a sprite doesn't have a more specific one.
     *
     * @member {PIXI.Shader}
     */
    this.shader = null;
}

SpriteRenderer.prototype = Object.create(ObjectRenderer.prototype);
SpriteRenderer.prototype.constructor = SpriteRenderer;
module.exports = SpriteRenderer;

WebGLRenderer.registerPlugin('sprite', SpriteRenderer);

/**
 * Sets up the renderer context and necessary buffers.
 *
 * @private
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 */
SpriteRenderer.prototype.onContextChange = function ()
{
    var gl = this.renderer.gl;

    // setup default shader
    this.shader = this.renderer.shaderManager.defaultShader;

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);

    this.currentBlendMode = 99999;
};

/**
 * Renders the sprite object.
 *
 * @param sprite {PIXI.Sprite} the sprite to render when using this spritebatch
 */
SpriteRenderer.prototype.render = function (sprite)
{
    var texture = sprite._texture;

    //TODO set blend modes..
    // check texture..
    if (this.currentBatchSize >= this.size)
    {
        this.flush();
    }

    // get the uvs for the texture
    var uvs = texture._uvs;

    // if the uvs have not updated then no point rendering just yet!
    if (!uvs)
    {
        return;
    }

    // TODO trim??
    var aX = sprite.anchor.x;
    var aY = sprite.anchor.y;

    var w0, w1, h0, h1;

    if (texture.trim && sprite.tileScale === undefined)
    {
        // if the sprite is trimmed and is not a tilingsprite then we need to add the extra space before transforming the sprite coords..
        var trim = texture.trim;

        w1 = trim.x - aX * trim.width;
        w0 = w1 + texture.crop.width;

        h1 = trim.y - aY * trim.height;
        h0 = h1 + texture.crop.height;

    }
    else
    {
        w0 = (texture._frame.width ) * (1-aX);
        w1 = (texture._frame.width ) * -aX;

        h0 = texture._frame.height * (1-aY);
        h1 = texture._frame.height * -aY;
    }

    var index = this.currentBatchSize * this.vertByteSize;

    var worldTransform = sprite.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.b;
    var c = worldTransform.c;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var colors = this.colors;
    var positions = this.positions;

    if (this.renderer.roundPixels)
    {
        var resolution = this.renderer.resolution;

        // xy
        positions[index] = (((a * w1 + c * h1 + tx) * resolution) | 0) / resolution;
        positions[index+1] = (((d * h1 + b * w1 + ty) * resolution) | 0) / resolution;

        // xy
        positions[index+5] = (((a * w0 + c * h1 + tx) * resolution) | 0) / resolution;
        positions[index+6] = (((d * h1 + b * w0 + ty) * resolution) | 0) / resolution;

         // xy
        positions[index+10] = (((a * w0 + c * h0 + tx) * resolution) | 0) / resolution;
        positions[index+11] = (((d * h0 + b * w0 + ty) * resolution) | 0) / resolution;

        // xy
        positions[index+15] = (((a * w1 + c * h0 + tx) * resolution) | 0) / resolution;
        positions[index+16] = (((d * h0 + b * w1 + ty) * resolution) | 0) / resolution;
    }
    else
    {

        // xy
        positions[index] = a * w1 + c * h1 + tx;
        positions[index+1] = d * h1 + b * w1 + ty;

        // xy
        positions[index+5] = a * w0 + c * h1 + tx;
        positions[index+6] = d * h1 + b * w0 + ty;

         // xy
        positions[index+10] = a * w0 + c * h0 + tx;
        positions[index+11] = d * h0 + b * w0 + ty;

        // xy
        positions[index+15] = a * w1 + c * h0 + tx;
        positions[index+16] = d * h0 + b * w1 + ty;
    }

    // uv
    positions[index+2] = uvs.x0;
    positions[index+3] = uvs.y0;

    // uv
    positions[index+7] = uvs.x1;
    positions[index+8] = uvs.y1;

     // uv
    positions[index+12] = uvs.x2;
    positions[index+13] = uvs.y2;

    // uv
    positions[index+17] = uvs.x3;
    positions[index+18] = uvs.y3;

    // color and alpha
    var tint = sprite.tint;
    colors[index+4] = colors[index+9] = colors[index+14] = colors[index+19] = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);

    // increment the batchsize
    this.sprites[this.currentBatchSize++] = sprite;
};

/**
 * Renders the content and empties the current batch.
 *
 */
SpriteRenderer.prototype.flush = function ()
{
    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize === 0)
    {
        return;
    }

    var gl = this.renderer.gl;
    var shader;

    // upload the verts to the buffer
    if (this.currentBatchSize > ( this.size * 0.5 ) )
    {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    }
    else
    {
        var view = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }

    var nextTexture, nextBlendMode, nextShader;
    var batchSize = 0;
    var start = 0;

    var currentBaseTexture = null;
    var currentBlendMode = this.renderer.blendModeManager.currentBlendMode;
    var currentShader = null;

    var blendSwap = false;
    var shaderSwap = false;
    var sprite;

    for (var i = 0, j = this.currentBatchSize; i < j; i++)
    {

        sprite = this.sprites[i];

        nextTexture = sprite._texture.baseTexture;
        nextBlendMode = sprite.blendMode;
        nextShader = sprite.shader || this.shader;

        blendSwap = currentBlendMode !== nextBlendMode;
        shaderSwap = currentShader !== nextShader; // should I use uidS???

        if (currentBaseTexture !== nextTexture || blendSwap || shaderSwap)
        {
            this.renderBatch(currentBaseTexture, batchSize, start);

            start = i;
            batchSize = 0;
            currentBaseTexture = nextTexture;

            if (blendSwap)
            {
                currentBlendMode = nextBlendMode;
                this.renderer.blendModeManager.setBlendMode( currentBlendMode );
            }

            if (shaderSwap)
            {
                currentShader = nextShader;



                shader = currentShader.shaders ? currentShader.shaders[gl.id] : currentShader;

                if (!shader)
                {
                    shader = currentShader.getShader(this.renderer);

                }

                // set shader function???
                this.renderer.shaderManager.setShader(shader);

                //TODO - i KNOW this can be optimised! Once v3 is stable il look at this next...
                shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);
                //Make this a little more dynamic / intelligent!
                shader.syncUniforms();

                //TODO investigate some kind of texture state managment??
                // need to make sure this texture is the active one for all the batch swaps..
                gl.activeTexture(gl.TEXTURE0);

                // both thease only need to be set if they are changing..
                // set the projection
                //gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));


            }
        }

        batchSize++;
    }

    this.renderBatch(currentBaseTexture, batchSize, start);

    // then reset the batch!
    this.currentBatchSize = 0;
};

/**
 * Draws the currently batches sprites.
 *
 * @private
 * @param texture {PIXI.Texture}
 * @param size {number}
 * @param startIndex {number}
 */
SpriteRenderer.prototype.renderBatch = function (texture, size, startIndex)
{
    if (size === 0)
    {
        return;
    }

    var gl = this.renderer.gl;

    if (!texture._glTextures[gl.id])
    {
        this.renderer.updateTexture(texture);
    }
    else
    {
        // bind the current texture
        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
    }

    // now draw those suckas!
    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);

    // increment the draw count
    this.renderer.drawCount++;
};

/**
 * Starts a new sprite batch.
 *
 */
SpriteRenderer.prototype.start = function ()
{
    var gl = this.renderer.gl;

    // bind the main texture


    // bind the buffers
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // this is the same for each shader?
    var stride =  this.vertByteSize;
    gl.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(this.shader.attributes.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);

    // color attributes will be interpreted as unsigned bytes and normalized
    gl.vertexAttribPointer(this.shader.attributes.aColor, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4);
};

/**
 * Destroys the SpriteBatch.
 *
 */
SpriteRenderer.prototype.destroy = function ()
{
    this.renderer.gl.deleteBuffer(this.vertexBuffer);
    this.renderer.gl.deleteBuffer(this.indexBuffer);

    ObjectRenderer.prototype.destroy.call(this);

    this.shader.destroy();

    this.renderer = null;

    this.vertices = null;
    this.positions = null;
    this.colors = null;
    this.indices = null;

    this.vertexBuffer = null;
    this.indexBuffer = null;

    this.sprites = null;
    this.shader = null;
};

},{"../../const":23,"../../renderers/webgl/WebGLRenderer":49,"../../renderers/webgl/utils/ObjectRenderer":63}],69:[function(require,module,exports){
var Sprite = require('../sprites/Sprite'),
    Texture = require('../textures/Texture'),
    math = require('../math'),
    utils = require('../utils'),
    CONST = require('../const');

/**
 * A Text Object will create a line or multiple lines of text. To split a line you can use '\n' in your text string,
 * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.
 *
 * A Text can be created directly from a string and a style object
 *
 * ```js
 * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});
 * ```
 *
 * @class
 * @extends PIXI.Sprite
 * @memberof PIXI
 * @param text {string} The copy that you would like the text to display
 * @param [style] {object} The style parameters
 * @param [style.font] {string} default 'bold 20px Arial' The style and size of the font
 * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
 * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
 * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
 * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used
 * @param [style.wordWrapWidth=100] {number} The width at which text will wrap, it needs wordWrap to be set to true
 * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses
 * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text
 * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
 * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow
 * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow
 * @param [style.dropShadowBlur=0] {number} Set a shadow blur radius
 * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will
 *      prevent this from happening by adding padding to the top and bottom of text height.
 * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.
 * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve
 *      spiked text issues. Default is 'miter' (creates a sharp corner).
 * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
 *      or increase the spikiness of rendered text.
 */
function Text(text, style, resolution)
{
    /**
     * The canvas element that everything is drawn to
     *
     * @member {HTMLCanvasElement}
     */
    this.canvas = document.createElement('canvas');

    /**
     * The canvas 2d context that everything is drawn with
     * @member {HTMLCanvasElement}
     */
    this.context = this.canvas.getContext('2d');

    /**
     * The resolution of the canvas.
     * @member {number}
     */
    this.resolution = resolution || CONST.RESOLUTION;

    /**
     * Private tracker for the current text.
     *
     * @member {string}
     * @private
     */
    this._text = null;

    /**
     * Private tracker for the current style.
     *
     * @member {object}
     * @private
     */
    this._style = null;

    var texture = Texture.fromCanvas(this.canvas);
    texture.trim = new math.Rectangle();
    Sprite.call(this, texture);

    this.text = text;
    this.style = style;
}

// constructor
Text.prototype = Object.create(Sprite.prototype);
Text.prototype.constructor = Text;
module.exports = Text;

Text.fontPropertiesCache = {};
Text.fontPropertiesCanvas = document.createElement('canvas');
Text.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');

Object.defineProperties(Text.prototype, {
    /**
     * The width of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Text#
     */
    width: {
        get: function ()
        {
            if (this.dirty)
            {
                this.updateText();
            }

            return this.scale.x * this._texture._frame.width;
        },
        set: function (value)
        {
            this.scale.x = value / this._texture._frame.width;
            this._width = value;
        }
    },

    /**
     * The height of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Text#
     */
    height: {
        get: function ()
        {
            if (this.dirty)
            {
                this.updateText();
            }

            return  this.scale.y * this._texture._frame.height;
        },
        set: function (value)
        {
            this.scale.y = value / this._texture._frame.height;
            this._height = value;
        }
    },

    /**
     * Set the style of the text
     *
     * @param [style] {object} The style parameters
     * @param [style.font='bold 20pt Arial'] {string} The style and size of the font
     * @param [style.fill='black'] {string|number} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'
     * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
     * @param [style.stroke='black'] {string|number} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'
     * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
     * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used
     * @param [style.wordWrapWidth=100] {number} The width at which text will wrap
     * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses
     * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text
     * @param [style.dropShadowColor='#000000'] {string|number} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     * @param [style.dropShadowAngle=Math.PI/6] {number} Set a angle of the drop shadow
     * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow
     * @param [style.dropShadowBlur=0] {number} Set a shadow blur radius
     * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will
     *      prevent this from happening by adding padding to the top and bottom of text height.
     * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.
     * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve
     *      spiked text issues. Default is 'miter' (creates a sharp corner).
     * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
     *      or increase the spikiness of rendered text.
     * @memberof PIXI.Text#
     */
    style: {
        get: function ()
        {
            return this._style;
        },
        set: function (style)
        {
            style = style || {};

            if (typeof style.fill === 'number') {
                style.fill = utils.hex2string(style.fill);
            }

            if (typeof style.stroke === 'number') {
                style.stroke = utils.hex2string(style.stroke);
            }

            if (typeof style.dropShadowColor === 'number') {
                style.dropShadowColor = utils.hex2string(style.dropShadowColor);
            }

            style.font = style.font || 'bold 20pt Arial';
            style.fill = style.fill || 'black';
            style.align = style.align || 'left';
            style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/pixijs/pixi.js/issues/136
            style.strokeThickness = style.strokeThickness || 0;
            style.wordWrap = style.wordWrap || false;
            style.wordWrapWidth = style.wordWrapWidth || 100;

            style.dropShadow = style.dropShadow || false;
            style.dropShadowColor = style.dropShadowColor || '#000000';
            style.dropShadowAngle = style.dropShadowAngle !== undefined ? style.dropShadowAngle : Math.PI / 6;
            style.dropShadowDistance = style.dropShadowDistance !== undefined ? style.dropShadowDistance : 5;
            style.dropShadowBlur = style.dropShadowBlur !== undefined ? style.dropShadowBlur : 0; //shadowBlur is '0' by default according to HTML

            style.padding = style.padding || 0;

            style.textBaseline = style.textBaseline || 'alphabetic';

            style.lineJoin = style.lineJoin || 'miter';
            style.miterLimit = style.miterLimit || 10;

            this._style = style;
            this.dirty = true;
        }
    },

    /**
     * Set the copy for the text object. To split a line you can use '\n'.
     *
     * @param text {string} The copy that you would like the text to display
     * @memberof PIXI.Text#
     */
    text: {
        get: function()
        {
            return this._text;
        },
        set: function (text){
            text = text.toString() || ' ';
            if (this._text === text)
            {
                return;
            }
            this._text = text;
            this.dirty = true;
        }
    }
});

/**
 * Renders text and updates it when needed
 *
 * @private
 */
Text.prototype.updateText = function ()
{
    var style = this._style;
    this.context.font = style.font;

    // word wrap
    // preserve original text
    var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;

    // split text into lines
    var lines = outputText.split(/(?:\r\n|\r|\n)/);

    // calculate text width
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    var fontProperties = this.determineFontProperties(style.font);
    for (var i = 0; i < lines.length; i++)
    {
        var lineWidth = this.context.measureText(lines[i]).width;
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }

    var width = maxLineWidth + style.strokeThickness;
    var isLinePositionY = typeof style.linePositionY !== 'undefined';
    if (style.dropShadow)
    {
        width += style.dropShadowDistance;
    }

    this.canvas.width = ( width + this.context.lineWidth ) * this.resolution;

    // calculate text height
    var lineHeight = this.style.lineHeight || fontProperties.fontSize + style.strokeThickness;

    var height = lineHeight * lines.length;
    if (style.dropShadow)
    {
        height += style.dropShadowDistance;
    }

    this.canvas.height = ( height + this._style.padding * 2 ) * this.resolution;

    this.context.scale( this.resolution, this.resolution);

    if (navigator.isCocoonJS)
    {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

    }

    //this.context.fillStyle="#FF0000";
    //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

    this.context.font = style.font;
    this.context.strokeStyle = style.stroke;
    this.context.lineWidth = style.strokeThickness;
    this.context.textBaseline = style.textBaseline;
    this.context.lineJoin = style.lineJoin;
    this.context.miterLimit = style.miterLimit;

    var linePositionX;
    var linePositionY;

    if (style.dropShadow)
    {
        if (style.dropShadowBlur > 0) {
            this.context.shadowColor = style.dropShadowColor;
            this.context.shadowBlur = style.dropShadowBlur;
        } else {
            this.context.fillStyle = style.dropShadowColor;
        }

        var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
        var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;

        for (i = 0; i < lines.length; i++)
        {
            linePositionX = style.strokeThickness / 2;
            //TODO: pull request of pixi
            linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;
            if (isLinePositionY) {
              linePositionY = style.linePositionY + i * lineHeight;
            }

            if (style.align === 'right')
            {
                linePositionX += maxLineWidth - lineWidths[i];
            }
            else if (style.align === 'center')
            {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }

            if (style.fill)
            {
                this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset + this._style.padding);
            }
        }
    }

    //set canvas text styles
    this.context.fillStyle = style.fill;

    //draw lines line by line
    for (i = 0; i < lines.length; i++)
    {
        linePositionX = style.strokeThickness / 2;
        linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;
        if (isLinePositionY) {
          linePositionY = style.linePositionY + i * lineHeight;
        }

        if (style.align === 'right')
        {
            linePositionX += maxLineWidth - lineWidths[i];
        }
        else if (style.align === 'center')
        {
            linePositionX += (maxLineWidth - lineWidths[i]) / 2;
        }

        if (style.stroke && style.strokeThickness)
        {
            this.context.strokeText(lines[i], linePositionX, linePositionY + this._style.padding);
        }

        if (style.fill)
        {
            this.context.fillText(lines[i], linePositionX, linePositionY + this._style.padding);
        }
    }

    this.updateTexture();
};

/**
 * Updates texture size based on canvas size
 *
 * @private
 */
Text.prototype.updateTexture = function ()
{
    var texture = this._texture;

    texture.baseTexture.hasLoaded = true;
    texture.baseTexture.resolution = this.resolution;

    texture.baseTexture.width = this.canvas.width / this.resolution;
    texture.baseTexture.height = this.canvas.height / this.resolution;
    texture.crop.width = texture._frame.width = this.canvas.width / this.resolution;
    texture.crop.height = texture._frame.height = this.canvas.height / this.resolution;

    texture.trim.x = 0;
    texture.trim.y = -this._style.padding;

    texture.trim.width = texture._frame.width;
    texture.trim.height = texture._frame.height - this._style.padding*2;

    this._width = this.canvas.width / this.resolution;
    this._height = this.canvas.height / this.resolution;

    texture.baseTexture.emit('update',  texture.baseTexture);

    this.dirty = false;
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer}
 */
Text.prototype.renderWebGL = function (renderer)
{
    if (this.dirty)
    {
        //this.resolution = 1//renderer.resolution;

        this.updateText();
    }

    Sprite.prototype.renderWebGL.call(this, renderer);
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer}
 * @private
 */
Text.prototype._renderCanvas = function (renderer)
{
    if (this.dirty)
    {
     //   this.resolution = 1//renderer.resolution;

        this.updateText();
    }

    Sprite.prototype._renderCanvas.call(this, renderer);
};

/**
 * Calculates the ascent, descent and fontSize of a given fontStyle
 *
 * @param fontStyle {object}
 * @private
 */
Text.prototype.determineFontProperties = function (fontStyle)
{
    var properties = Text.fontPropertiesCache[fontStyle];

    if (!properties)
    {
        properties = {};

        var canvas = Text.fontPropertiesCanvas;
        var context = Text.fontPropertiesContext;

        context.font = fontStyle;

        var width = Math.max(Math.ceil(context.measureText('|MÉq').width), 1);
        var baseline = Math.max(Math.ceil(context.measureText('M').width), 1);
        var height =  2 * baseline;

        baseline = baseline * 1.4 | 0;

        canvas.width = width;
        canvas.height = height;

        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);

        context.font = fontStyle;

        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText('|MÉq', 0, baseline);

        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;

        var i, j;

        var idx = 0;
        var stop = false;

        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; i++)
        {
            for (j = 0; j < line; j += 4)
            {
                if (imagedata[idx + j] !== 255)
                {
                    stop = true;
                    break;
                }
            }
            if (!stop)
            {
                idx += line;
            }
            else
            {
                break;
            }
        }

        properties.ascent = baseline - i;

        idx = pixels - line;
        stop = false;

        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; i--)
        {
            for (j = 0; j < line; j += 4)
            {
                if (imagedata[idx + j] !== 255)
                {
                    stop = true;
                    break;
                }
            }
            if (!stop)
            {
                idx -= line;
            }
            else
            {
                break;
            }
        }

        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;

        Text.fontPropertiesCache[fontStyle] = properties;
    }

    return properties;
};

/**
 * Applies newlines to a string to have it optimally fit into the horizontal
 * bounds set by the Text object's wordWrapWidth property.
 *
 * @param text {string}
 * @private
 */
Text.prototype.wordWrap = function (text)
{
    // Greedy wrapping algorithm that will wrap words as the line grows longer
    // than its horizontal bounds.
    var result = '';
    var lines = text.split('\n');
    var wordWrapWidth = this._style.wordWrapWidth;
    for (var i = 0; i < lines.length; i++)
    {
        var spaceLeft = wordWrapWidth;
        var words = lines[i].split(' ');
        for (var j = 0; j < words.length; j++)
        {
            var wordWidth = this.context.measureText(words[j]).width;
            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;
            if (j === 0 || wordWidthWithSpace > spaceLeft)
            {
                // Skip printing the newline if it's the first word of the line that is
                // greater than the word wrap width.
                if (j > 0)
                {
                    result += '\n';
                }
                result += words[j];
                spaceLeft = wordWrapWidth - wordWidth;
            }
            else
            {
                spaceLeft -= wordWidthWithSpace;
                result += ' ' + words[j];
            }
        }

        if (i < lines.length-1)
        {
            result += '\n';
        }
    }
    return result;
};

/**
 * Returns the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {PIXI.Matrix} the transformation matrix of the Text
 * @return {PIXI.Rectangle} the framing rectangle
 */
Text.prototype.getBounds = function (matrix)
{
    if (this.dirty)
    {
        this.updateText();
    }

    return Sprite.prototype.getBounds.call(this, matrix);
};

/**
 * Destroys this text object.
 *
 * @param [destroyBaseTexture=true] {boolean} whether to destroy the base texture as well
 */
Text.prototype.destroy = function (destroyBaseTexture)
{
    // make sure to reset the the context and canvas.. dont want this hanging around in memory!
    this.context = null;
    this.canvas = null;

    this._style = null;

    this._texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);
};

},{"../const":23,"../math":33,"../sprites/Sprite":67,"../textures/Texture":72,"../utils":77}],70:[function(require,module,exports){
var utils = require('../utils'),
    CONST = require('../const'),
    EventEmitter = require('eventemitter3');

/**
 * A texture stores the information that represents an image. All textures have a base texture.
 *
 * @class
 * @memberof PIXI
 * @param source {Image|Canvas} the source object of the texture.
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} See {@link PIXI.SCALE_MODES} for possible values
 * @param resolution {number} the resolution of the texture for devices with different pixel ratios
 */
function BaseTexture(source, scaleMode, resolution)
{
    EventEmitter.call(this);

    this.uid = utils.uid();

    /**
     * The Resolution of the texture.
     *
     * @member {number}
     */
    this.resolution = resolution || 1;

    /**
     * The width of the base texture set when the image has loaded
     *
     * @member {number}
     * @readOnly
     */
    this.width = 100;

    /**
     * The height of the base texture set when the image has loaded
     *
     * @member {number}
     * @readOnly
     */
    this.height = 100;

    // TODO docs
    // used to store the actual dimensions of the source
    /**
     * Used to store the actual width of the source of this texture
     *
     * @member {number}
     * @readOnly
     */
    this.realWidth = 100;
    /**
     * Used to store the actual height of the source of this texture
     *
     * @member {number}
     * @readOnly
     */
    this.realHeight = 100;

    /**
     * The scale mode to apply when scaling this texture
     *
     * @member {number}
     * @default PIXI.SCALE_MODES.LINEAR
     * @see PIXI.SCALE_MODES
     */
    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;

    /**
     * Set to true once the base texture has successfully loaded.
     *
     * This is never true if the underlying source fails to load or has no texture data.
     *
     * @member {boolean}
     * @readOnly
     */
    this.hasLoaded = false;

    /**
     * Set to true if the source is currently loading.
     *
     * If an Image source is loading the 'loaded' or 'error' event will be
     * dispatched when the operation ends. An underyling source that is
     * immediately-available bypasses loading entirely.
     *
     * @member {boolean}
     * @readonly
     */
    this.isLoading = false;

    /**
     * The image source that is used to create the texture.
     *
     * TODO: Make this a setter that calls loadSource();
     *
     * @member {Image|Canvas}
     * @readonly
     */
    this.source = null; // set in loadSource, if at all

    /**
     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
     *
     * @member {boolean}
     * @default true
     */
    this.premultipliedAlpha = true;

    /**
     * @member {string}
     */
    this.imageUrl = null;

    /**
     * Wether or not the texture is a power of two, try to use power of two textures as much as you can
     * @member {boolean}
     * @private
     */
    this.isPowerOfTwo = false;

    // used for webGL

    /**
     *
     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
     * Also the texture must be a power of two size to work
     *
     * @member {boolean}
     */
    this.mipmap = false;

    /**
     * A map of renderer IDs to webgl textures
     *
     * @member {object<number, WebGLTexture>}
     * @private
     */
    this._glTextures = {};

    // if no source passed don't try to load
    if (source)
    {
        this.loadSource(source);
    }

    /**
     * Fired when a not-immediately-available source finishes loading.
     *
     * @event loaded
     * @memberof PIXI.BaseTexture#
     * @protected
     */

    /**
     * Fired when a not-immediately-available source fails to load.
     *
     * @event error
     * @memberof PIXI.BaseTexture#
     * @protected
     */
}

BaseTexture.prototype = Object.create(EventEmitter.prototype);
BaseTexture.prototype.constructor = BaseTexture;
module.exports = BaseTexture;

/**
 * Updates the texture on all the webgl renderers, this also assumes the src has changed.
 *
 * @fires update
 */
BaseTexture.prototype.update = function ()
{
    this.realWidth = this.source.naturalWidth || this.source.width;
    this.realHeight = this.source.naturalHeight || this.source.height;

    this.width = this.realWidth / this.resolution;
    this.height = this.realHeight / this.resolution;

    this.isPowerOfTwo = utils.isPowerOfTwo(this.realWidth, this.realHeight);

    this.emit('update', this);
};

/**
 * Load a source.
 *
 * If the source is not-immediately-available, such as an image that needs to be
 * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
 * and `hasLoaded` will remain false after this call.
 *
 * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
 *
 *     if (texture.hasLoaded)
 {
 *        // texture ready for use
 *     } else if (texture.isLoading)
 {
 *        // listen to 'loaded' and/or 'error' events on texture
 *     } else {
 *        // not loading, not going to load UNLESS the source is reloaded
 *        // (it may still make sense to listen to the events)
 *     }
 *
 * @protected
 * @param source {Image|Canvas} the source object of the texture.
 */
BaseTexture.prototype.loadSource = function (source)
{
    var wasLoading = this.isLoading;
    this.hasLoaded = false;
    this.isLoading = false;

    if (wasLoading && this.source)
    {
        this.source.onload = null;
        this.source.onerror = null;
    }

    this.source = source;

    // Apply source if loaded. Otherwise setup appropriate loading monitors.
    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)
    {
        this._sourceLoaded();
    }
    else if (!source.getContext)
    {

        // Image fail / not ready
        this.isLoading = true;

        var scope = this;

        source.onload = function ()
        {
            source.onload = null;
            source.onerror = null;

            if (!scope.isLoading)
            {
                return;
            }

            scope.isLoading = false;
            scope._sourceLoaded();

            scope.emit('loaded', scope);
        };

        source.onerror = function ()
        {
            source.onload = null;
            source.onerror = null;

            if (!scope.isLoading)
            {
                return;
            }

            scope.isLoading = false;
            scope.emit('error', scope);
        };

        // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element
        //   "The value of `complete` can thus change while a script is executing."
        // So complete needs to be re-checked after the callbacks have been added..
        // NOTE: complete will be true if the image has no src so best to check if the src is set.
        if (source.complete && source.src)
        {
            this.isLoading = false;

            // ..and if we're complete now, no need for callbacks
            source.onload = null;
            source.onerror = null;

            if (source.width && source.height)
            {
                this._sourceLoaded();

                // If any previous subscribers possible
                if (wasLoading)
                {
                    this.emit('loaded', this);
                }
            }
            else
            {
                // If any previous subscribers possible
                if (wasLoading)
                {
                    this.emit('error', this);
                }
            }
        }
    }
};

/**
 * Used internally to update the width, height, and some other tracking vars once
 * a source has successfully loaded.
 *
 * @private
 */
BaseTexture.prototype._sourceLoaded = function ()
{
    this.hasLoaded = true;
    this.update();
};

/**
 * Destroys this base texture
 *
 */
BaseTexture.prototype.destroy = function ()
{
    if (this.imageUrl)
    {
        delete utils.BaseTextureCache[this.imageUrl];
        delete utils.TextureCache[this.imageUrl];

        this.imageUrl = null;

        if (!navigator.isCocoonJS)
        {
            this.source.src = '';
        }
    }
    else if (this.source && this.source._pixiId)
    {
        delete utils.BaseTextureCache[this.source._pixiId];
    }

    this.source = null;

    this.dispose();
};

/**
 * Frees the texture from WebGL memory without destroying this texture object.
 * This means you can still use the texture later which will upload it to GPU
 * memory again.
 *
 */
BaseTexture.prototype.dispose = function ()
{
    this.emit('dispose', this);

    // this should no longer be needed, the renderers should cleanup all the gl textures.
    // this._glTextures = {};
};

/**
 * Changes the source image of the texture.
 * The original source must be an Image element.
 *
 * @param newSrc {string} the path of the image
 */
BaseTexture.prototype.updateSourceImage = function (newSrc)
{
    this.source.src = newSrc;

    this.loadSource(this.source);
};

/**
 * Helper function that creates a base texture from the given image url.
 * If the image is not in the base texture cache it will be created and loaded.
 *
 * @static
 * @param imageUrl {string} The image url of the texture
 * @param [crossorigin=(auto)] {boolean} Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return PIXI.BaseTexture
 */
BaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode)
{
    var baseTexture = utils.BaseTextureCache[imageUrl];

    if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0)
    {
        crossorigin = true;
    }

    if (!baseTexture)
    {
        // new Image() breaks tex loading in some versions of Chrome.
        // See https://code.google.com/p/chromium/issues/detail?id=238071
        var image = new Image();//document.createElement('img');
        if (crossorigin)
        {
            image.crossOrigin = '';
        }

        baseTexture = new BaseTexture(image, scaleMode);
        baseTexture.imageUrl = imageUrl;

        image.src = imageUrl;

        utils.BaseTextureCache[imageUrl] = baseTexture;

        // if there is an @2x at the end of the url we are going to assume its a highres image
        baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);
    }

    return baseTexture;
};

/**
 * Helper function that creates a base texture from the given canvas element.
 *
 * @static
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return PIXI.BaseTexture
 */
BaseTexture.fromCanvas = function (canvas, scaleMode)
{
    if (!canvas._pixiId)
    {
        canvas._pixiId = 'canvas_' + utils.uid();
    }

    var baseTexture = utils.BaseTextureCache[canvas._pixiId];

    if (!baseTexture)
    {
        baseTexture = new BaseTexture(canvas, scaleMode);
        utils.BaseTextureCache[canvas._pixiId] = baseTexture;
    }

    return baseTexture;
};

},{"../const":23,"../utils":77,"eventemitter3":10}],71:[function(require,module,exports){
var BaseTexture = require('./BaseTexture'),
    Texture = require('./Texture'),
    RenderTarget = require('../renderers/webgl/utils/RenderTarget'),
    FilterManager = require('../renderers/webgl/managers/FilterManager'),
    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),
    math = require('../math'),
    CONST = require('../const'),
    tempMatrix = new math.Matrix();

/**
 * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * A RenderTexture takes a snapshot of any Display Object given to its render method. The position
 * and rotation of the given Display Objects is ignored. For example:
 *
 * ```js
 * var renderer = PIXI.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });
 * var renderTexture = new PIXI.RenderTexture(renderer, 800, 600);
 * var sprite = PIXI.Sprite.fromImage("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * renderTexture.render(sprite);
 * ```
 *
 * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual
 * position a Container should be used:
 *
 * ```js
 * var doc = new PIXI.Container();
 *
 * doc.addChild(sprite);
 *
 * renderTexture.render(doc);  // Renders to center of renderTexture
 * ```
 *
 * @class
 * @extends PIXI.Texture
 * @memberof PIXI
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used for this RenderTexture
 * @param [width=100] {number} The width of the render texture
 * @param [height=100] {number} The height of the render texture
 * @param [scaleMode] {number} See {@link PIXI.SCALE_MODES} for possible values
 * @param [resolution=1] {number} The resolution of the texture being generated
 */
function RenderTexture(renderer, width, height, scaleMode, resolution)
{
    if (!renderer)
    {
        throw new Error('Unable to create RenderTexture, you must pass a renderer into the constructor.');
    }

    width = width || 100;
    height = height || 100;
    resolution = resolution || CONST.RESOLUTION;

    /**
     * The base texture object that this texture uses
     *
     * @member {BaseTexture}
     */
    var baseTexture = new BaseTexture();
    baseTexture.width = width;
    baseTexture.height = height;
    baseTexture.resolution = resolution;
    baseTexture.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;
    baseTexture.hasLoaded = true;


    Texture.call(this,
        baseTexture,
        new math.Rectangle(0, 0, width, height)
    );


    /**
     * The with of the render texture
     *
     * @member {number}
     */
    this.width = width;

    /**
     * The height of the render texture
     *
     * @member {number}
     */
    this.height = height;

    /**
     * The Resolution of the texture.
     *
     * @member {number}
     */
    this.resolution = resolution;

    /**
     * Draw/render the given DisplayObject onto the texture.
     *
     * The displayObject and descendents are transformed during this operation.
     * If `updateTransform` is true then the transformations will be restored before the
     * method returns. Otherwise it is up to the calling code to correctly use or reset
     * the transformed display objects.
     *
     * The display object is always rendered with a worldAlpha value of 1.
     *
     * @method
     * @param displayObject {PIXI.DisplayObject} The display object to render this texture on
     * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.
     * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn
     * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children
     *  transformations will be restored. Not restoring this information will be a little faster.
     */
    this.render = null;

    /**
     * The renderer this RenderTexture uses. A RenderTexture can only belong to one renderer at the moment if its webGL.
     *
     * @member {PIXI.CanvasRenderer|PIXI.WebGLRenderer}
     */
    this.renderer = renderer;

    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        var gl = this.renderer.gl;

        this.textureBuffer = new RenderTarget(gl, this.width, this.height, baseTexture.scaleMode, this.resolution);//, this.baseTexture.scaleMode);
        this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture;

        //TODO refactor filter manager.. as really its no longer a manager if we use it here..
        this.filterManager = new FilterManager(this.renderer);
        this.filterManager.onContextChange();
        this.filterManager.resize(width, height);
        this.render = this.renderWebGL;

        // the creation of a filter manager unbinds the buffers..
        this.renderer.currentRenderer.start();
        this.renderer.currentRenderTarget.activate();
    }
    else
    {

        this.render = this.renderCanvas;
        this.textureBuffer = new CanvasBuffer(this.width* this.resolution, this.height* this.resolution);
        this.baseTexture.source = this.textureBuffer.canvas;
    }

    /**
     * @member {boolean}
     */
    this.valid = true;

    this._updateUvs();
}

RenderTexture.prototype = Object.create(Texture.prototype);
RenderTexture.prototype.constructor = RenderTexture;
module.exports = RenderTexture;

/**
 * Resizes the RenderTexture.
 *
 * @param width {number} The width to resize to.
 * @param height {number} The height to resize to.
 * @param updateBase {boolean} Should the baseTexture.width and height values be resized as well?
 */
RenderTexture.prototype.resize = function (width, height, updateBase)
{
    if (width === this.width && height === this.height)
    {
        return;
    }

    this.valid = (width > 0 && height > 0);

    this.width = this._frame.width = this.crop.width = width;
    this.height =  this._frame.height = this.crop.height = height;

    if (updateBase)
    {
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
    }

    if (!this.valid)
    {
        return;
    }

    this.textureBuffer.resize(this.width, this.height);

    if(this.filterManager)
    {
        this.filterManager.resize(this.width, this.height);
    }
};

/**
 * Clears the RenderTexture.
 *
 */
RenderTexture.prototype.clear = function ()
{
    if (!this.valid)
    {
        return;
    }

    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
    }

    this.textureBuffer.clear();
};

/**
 * Internal method assigned to the `render` property if using a CanvasRenderer.
 *
 * @private
 * @param displayObject {PIXI.DisplayObject} The display object to render this texture on
 * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.
 * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn
 * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children
 *  transformations will be restored. Not restoring this information will be a little faster.
 */
RenderTexture.prototype.renderWebGL = function (displayObject, matrix, clear, updateTransform)
{
    if (!this.valid)
    {
        return;
    }


    updateTransform = (updateTransform !== undefined) ? updateTransform : true;//!updateTransform;

    this.textureBuffer.transform = matrix;

    //TODO not a fan that this is here... it will move!
    this.textureBuffer.activate();

    // setWorld Alpha to ensure that the object is renderer at full opacity
    displayObject.worldAlpha = 1;

    if (updateTransform)
    {

        // reset the matrix of the displatyObject..
        displayObject.worldTransform.identity();

        displayObject.currentBounds = null;

        // Time to update all the children of the displayObject with the new matrix..
        var children = displayObject.children;
        var i, j;

        for (i = 0, j = children.length; i < j; ++i)
        {
            children[i].updateTransform();
        }
    }

    //TODO rename textureBuffer to renderTarget..
    var temp =  this.renderer.filterManager;

    this.renderer.filterManager = this.filterManager;
    this.renderer.renderDisplayObject(displayObject, this.textureBuffer, clear);

    this.renderer.filterManager = temp;
};


/**
 * Internal method assigned to the `render` property if using a CanvasRenderer.
 *
 * @private
 * @param displayObject {PIXI.DisplayObject} The display object to render this texture on
 * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.
 * @param [clear] {boolean} If true the texture will be cleared before the displayObject is drawn
 */
RenderTexture.prototype.renderCanvas = function (displayObject, matrix, clear, updateTransform)
{
    if (!this.valid)
    {
        return;
    }

    updateTransform = !!updateTransform;

    var wt = tempMatrix;

    wt.identity();

    if (matrix)
    {
        wt.append(matrix);
    }

    var cachedWt = displayObject.worldTransform;
    displayObject.worldTransform = wt;

    // setWorld Alpha to ensure that the object is renderer at full opacity
    displayObject.worldAlpha = 1;

    // Time to update all the children of the displayObject with the new matrix..
    var children = displayObject.children;
    var i, j;

    for (i = 0, j = children.length; i < j; ++i)
    {
        children[i].updateTransform();
    }

    if (clear)
    {
        this.textureBuffer.clear();
    }


//    this.textureBuffer.
    var context = this.textureBuffer.context;

    var realResolution = this.renderer.resolution;

    this.renderer.resolution = this.resolution;

    this.renderer.renderDisplayObject(displayObject, context);

    this.renderer.resolution = realResolution;

    if(displayObject.worldTransform === wt)
    {
        // fixes cacheAsBitmap Happening during the above..
        displayObject.worldTransform = cachedWt;
    }

};

/**
 * Destroys this texture
 *
 * @param destroyBase {boolean} Whether to destroy the base texture as well
 */
RenderTexture.prototype.destroy = function ()
{
    Texture.prototype.destroy.call(this, true);

    this.textureBuffer.destroy();

    // destroy the filtermanager..
    if(this.filterManager)
    {
        this.filterManager.destroy();
    }

    this.renderer = null;
};

/**
 * Will return a HTML Image of the texture
 *
 * @return {Image}
 */
RenderTexture.prototype.getImage = function ()
{
    var image = new Image();
    image.src = this.getBase64();
    return image;
};

/**
 * Will return a a base64 encoded string of this texture. It works by calling RenderTexture.getCanvas and then running toDataURL on that.
 *
 * @return {string} A base64 encoded string of the texture.
 */
RenderTexture.prototype.getBase64 = function ()
{
    return this.getCanvas().toDataURL();
};

/**
 * Creates a Canvas element, renders this RenderTexture to it and then returns it.
 *
 * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
 */
RenderTexture.prototype.getCanvas = function ()
{
    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        var gl = this.renderer.gl;
        var width = this.textureBuffer.size.width;
        var height = this.textureBuffer.size.height;

        var webGLPixels = new Uint8Array(4 * width * height);

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        var tempCanvas = new CanvasBuffer(width, height);
        var canvasData = tempCanvas.context.getImageData(0, 0, width, height);
        canvasData.data.set(webGLPixels);

        tempCanvas.context.putImageData(canvasData, 0, 0);

        return tempCanvas.canvas;
    }
    else
    {
        return this.textureBuffer.canvas;
    }
};

/**
 * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA order, with integer values between 0 and 255 (included).
 *
 * @return {Uint8ClampedArray}
 */
RenderTexture.prototype.getPixels = function ()
{
    var width, height;

    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        var gl = this.renderer.gl;
        width = this.textureBuffer.size.width;
        height = this.textureBuffer.size.height;

        var webGLPixels = new Uint8Array(4 * width * height);

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return webGLPixels;
    }
    else
    {
        width = this.textureBuffer.canvas.width;
        height = this.textureBuffer.canvas.height;

        return this.textureBuffer.canvas.getContext('2d').getImageData(0, 0, width, height).data;
    }
};

/**
 * Will return a one-dimensional array containing the pixel data of a pixel within the texture in RGBA order, with integer values between 0 and 255 (included).
 *
 * @param x {number} The x coordinate of the pixel to retrieve.
 * @param y {number} The y coordinate of the pixel to retrieve.
 * @return {Uint8ClampedArray}
 */
RenderTexture.prototype.getPixel = function (x, y)
{
    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        var gl = this.renderer.gl;

        var webGLPixels = new Uint8Array(4);

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return webGLPixels;
    }
    else
    {
        return this.textureBuffer.canvas.getContext('2d').getImageData(x, y, 1, 1).data;
    }
};

},{"../const":23,"../math":33,"../renderers/canvas/utils/CanvasBuffer":45,"../renderers/webgl/managers/FilterManager":54,"../renderers/webgl/utils/RenderTarget":65,"./BaseTexture":70,"./Texture":72}],72:[function(require,module,exports){
var BaseTexture = require('./BaseTexture'),
    VideoBaseTexture = require('./VideoBaseTexture'),
    TextureUvs = require('./TextureUvs'),
    EventEmitter = require('eventemitter3'),
    math = require('../math'),
    utils = require('../utils');

/**
 * A texture stores the information that represents an image or part of an image. It cannot be added
 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.
 *
 * You can directly create a texture from an image and then reuse it multiple times like this :
 *
 * ```js
 * var texture = PIXI.Texture.fromImage('assets/image.png');
 * var sprite1 = new PIXI.Sprite(texture);
 * var sprite2 = new PIXI.Sprite(texture);
 * ```
 *
 * @class
 * @memberof PIXI
 * @param baseTexture {PIXI.BaseTexture} The base texture source to create the texture from
 * @param [frame] {PIXI.Rectangle} The rectangle frame of the texture to show
 * @param [crop] {PIXI.Rectangle} The area of original texture
 * @param [trim] {PIXI.Rectangle} Trimmed texture rectangle
 * @param [rotate] {boolean} indicates whether the texture should be rotated by 90 degrees ( used by texture packer )
 */
function Texture(baseTexture, frame, crop, trim, rotate)
{
    EventEmitter.call(this);

    /**
     * Does this Texture have any frame data assigned to it?
     *
     * @member {boolean}
     */
    this.noFrame = false;

    if (!frame)
    {
        this.noFrame = true;
        frame = new math.Rectangle(0, 0, 1, 1);
    }

    if (baseTexture instanceof Texture)
    {
        baseTexture = baseTexture.baseTexture;
    }

    /**
     * The base texture that this texture uses.
     *
     * @member {PIXI.BaseTexture}
     */
    this.baseTexture = baseTexture;

    /**
     * The frame specifies the region of the base texture that this texture uses
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._frame = frame;

    /**
     * The texture trim data.
     *
     * @member {PIXI.Rectangle}
     */
    this.trim = trim;

    /**
     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
     *
     * @member {boolean}
     */
    this.valid = false;

    /**
     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
     *
     * @member {boolean}
     */
    this.requiresUpdate = false;

    /**
     * The WebGL UV data cache.
     *
     * @member {PIXI.TextureUvs}
     * @private
     */
    this._uvs = null;

    /**
     * The width of the Texture in pixels.
     *
     * @member {number}
     */
    this.width = 0;

    /**
     * The height of the Texture in pixels.
     *
     * @member {number}
     */
    this.height = 0;

    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     *
     * @member {PIXI.Rectangle}
     */
    this.crop = crop || frame;//new math.Rectangle(0, 0, 1, 1);

    /**
     * Indicates whether the texture should be rotated by 90 degrees
     *
     * @private
     * @member {boolean}
     */
    this.rotate = !!rotate;

    if (baseTexture.hasLoaded)
    {
        if (this.noFrame)
        {
            frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);

            // if there is no frame we should monitor for any base texture changes..
            baseTexture.on('update', this.onBaseTextureUpdated, this);
        }
        this.frame = frame;
    }
    else
    {
        baseTexture.once('loaded', this.onBaseTextureLoaded, this);
    }

    /**
     * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.
     *
     * @event update
     * @memberof PIXI.Texture#
     * @protected
     */
}

Texture.prototype = Object.create(EventEmitter.prototype);
Texture.prototype.constructor = Texture;
module.exports = Texture;

Object.defineProperties(Texture.prototype, {
    /**
     * The frame specifies the region of the base texture that this texture uses.
     *
     * @member {PIXI.Rectangle}
     * @memberof PIXI.Texture#
     */
    frame: {
        get: function ()
        {
            return this._frame;
        },
        set: function (frame)
        {
            this._frame = frame;

            this.noFrame = false;

            this.width = frame.width;
            this.height = frame.height;

            if (!this.trim && !this.rotate && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))
            {
                throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
            }

            //this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
            this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;

            if (this.trim)
            {
                this.width = this.trim.width;
                this.height = this.trim.height;
                this._frame.width = this.trim.width;
                this._frame.height = this.trim.height;
            }
            else
            {
                this.crop = frame;
            }

            if (this.valid)
            {
                this._updateUvs();
            }
        }
    }
});

/**
 * Updates this texture on the gpu.
 *
 */
Texture.prototype.update = function ()
{
    this.baseTexture.update();
};

/**
 * Called when the base texture is loaded
 *
 * @private
 */
Texture.prototype.onBaseTextureLoaded = function (baseTexture)
{
    // TODO this code looks confusing.. boo to abusing getters and setterss!
    if (this.noFrame)
    {
        this.frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
    }
    else
    {
        this.frame = this._frame;
    }

    this.emit('update', this);
};

/**
 * Called when the base texture is updated
 *
 * @private
 */
Texture.prototype.onBaseTextureUpdated = function (baseTexture)
{
    this._frame.width = baseTexture.width;
    this._frame.height = baseTexture.height;

    this.emit('update', this);
};

/**
 * Destroys this texture
 *
 * @param [destroyBase=false] {boolean} Whether to destroy the base texture as well
 */
Texture.prototype.destroy = function (destroyBase)
{
    if (this.baseTexture)
    {
        if (destroyBase)
        {
            this.baseTexture.destroy();
        }

        this.baseTexture.off('update', this.onBaseTextureUpdated, this);
        this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);

        this.baseTexture = null;
    }

    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.crop = null;

    this.valid = false;

    this.off('dispose', this.dispose, this);
    this.off('update', this.update, this);
};

/**
 * Creates a new texture object that acts the same as this one.
 *
 * @return {PIXI.Texture}
 */
Texture.prototype.clone = function ()
{
    return new Texture(this.baseTexture, this.frame, this.crop, this.trim, this.rotate);
};

/**
 * Updates the internal WebGL UV cache.
 *
 * @private
 */
Texture.prototype._updateUvs = function ()
{
    if (!this._uvs)
    {
        this._uvs = new TextureUvs();
    }

    this._uvs.set(this.crop, this.baseTexture, this.rotate);
};

/**
 * Helper function that creates a Texture object from the given image url.
 * If the image is not in the texture cache it will be  created and loaded.
 *
 * @static
 * @param imageUrl {string} The image url of the texture
 * @param crossorigin {boolean} Whether requests should be treated as crossorigin
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} The newly created texture
 */
Texture.fromImage = function (imageUrl, crossorigin, scaleMode)
{
    var texture = utils.TextureCache[imageUrl];

    if (!texture)
    {
        texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
        utils.TextureCache[imageUrl] = texture;
    }

    return texture;
};

/**
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {string} The frame Id of the texture in the cache
 * @return {PIXI.Texture} The newly created texture
 */
Texture.fromFrame = function (frameId)
{
    var texture = utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
    }

    return texture;
};

/**
 * Helper function that creates a new Texture based on the given canvas element.
 *
 * @static
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture}
 */
Texture.fromCanvas = function (canvas, scaleMode)
{
    return new Texture(BaseTexture.fromCanvas(canvas, scaleMode));
};

/**
 * Helper function that creates a new Texture based on the given video element.
 *
 * @static
 * @param video {HTMLVideoElement}
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} A Texture
 */
Texture.fromVideo = function (video, scaleMode)
{
    if (typeof video === 'string')
    {
        return Texture.fromVideoUrl(video, scaleMode);
    }
    else
    {
        return new Texture(VideoBaseTexture.fromVideo(video, scaleMode));
    }
};

/**
 * Helper function that creates a new Texture based on the video url.
 *
 * @static
 * @param videoUrl {string}
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} A Texture
 */
Texture.fromVideoUrl = function (videoUrl, scaleMode)
{
    return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode));
};

/**
 * Adds a texture to the global utils.TextureCache. This cache is shared across the whole PIXI object.
 *
 * @static
 * @param texture {PIXI.Texture} The Texture to add to the cache.
 * @param id {string} The id that the texture will be stored against.
 */
Texture.addTextureToCache = function (texture, id)
{
    utils.TextureCache[id] = texture;
};

/**
 * Remove a texture from the global utils.TextureCache.
 *
 * @static
 * @param id {string} The id of the texture to be removed
 * @return {PIXI.Texture} The texture that was removed
 */
Texture.removeTextureFromCache = function (id)
{
    var texture = utils.TextureCache[id];

    delete utils.TextureCache[id];
    delete utils.BaseTextureCache[id];

    return texture;
};

/**
 * An empty texture, used often to not have to create multiple empty textures.
 *
 * @static
 * @constant
 */
Texture.EMPTY = new Texture(new BaseTexture());

},{"../math":33,"../utils":77,"./BaseTexture":70,"./TextureUvs":73,"./VideoBaseTexture":74,"eventemitter3":10}],73:[function(require,module,exports){

/**
 * A standard object to store the Uvs of a texture
 *
 * @class
 * @private
 * @memberof PIXI
 */
function TextureUvs()
{
    this.x0 = 0;
    this.y0 = 0;

    this.x1 = 1;
    this.y1 = 0;

    this.x2 = 1;
    this.y2 = 1;

    this.x3 = 0;
    this.y3 = 1;
}

module.exports = TextureUvs;

/**
 * Sets the texture Uvs based on the given frame information
 * @param frame {PIXI.Rectangle}
 * @param baseFrame {PIXI.Rectangle}
 * @param rotate {boolean} Whether or not the frame is rotated
 * @private
 */
TextureUvs.prototype.set = function (frame, baseFrame, rotate)
{
    var tw = baseFrame.width;
    var th = baseFrame.height;

    if(rotate)
    {
        this.x0 = (frame.x + frame.height) / tw;
        this.y0 = frame.y / th;

        this.x1 = (frame.x + frame.height) / tw;
        this.y1 = (frame.y + frame.width) / th;

        this.x2 = frame.x / tw;
        this.y2 = (frame.y + frame.width) / th;

        this.x3 = frame.x / tw;
        this.y3 = frame.y / th;
    }
    else
    {

        this.x0 = frame.x / tw;
        this.y0 = frame.y / th;

        this.x1 = (frame.x + frame.width) / tw;
        this.y1 = frame.y / th;

        this.x2 = (frame.x + frame.width) / tw;
        this.y2 = (frame.y + frame.height) / th;

        this.x3 = frame.x / tw;
        this.y3 = (frame.y + frame.height) / th;
    }
};

},{}],74:[function(require,module,exports){
var BaseTexture = require('./BaseTexture'),
    utils = require('../utils');

/**
 * A texture of a [playing] Video.
 *
 * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.
 *
 * This can be used in several ways, such as:
 *
 * ```js
 * var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
 *
 * var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
 *
 * var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
 *
 * var texture = PIXI.VideoBaseTexture.fromUrls([
 *     { src: '/video.webm', mime: 'video/webm' },
 *     { src: '/video.mp4', mime: 'video/mp4' }
 * ]);
 * ```
 *
 * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
 *
 * @class
 * @extends PIXI.BaseTexture
 * @memberof PIXI
 * @param source {HTMLVideoElement}
 * @param [scaleMode] {number} See {@link PIXI.SCALE_MODES} for possible values
 */
function VideoBaseTexture(source, scaleMode)
{
    if (!source)
    {
        throw new Error('No video source element specified.');
    }

    // hook in here to check if video is already available.
    // BaseTexture looks for a source.complete boolean, plus width & height.

    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height)
    {
        source.complete = true;
    }

    BaseTexture.call(this, source, scaleMode);

    /**
     * Should the base texture automatically update itself, set to true by default
     *
     * @member {boolean}
     * @default true
     */
    this.autoUpdate = false;

    this._onUpdate = this._onUpdate.bind(this);
    this._onCanPlay = this._onCanPlay.bind(this);

    if (!source.complete)
    {
        source.addEventListener('canplay', this._onCanPlay);
        source.addEventListener('canplaythrough', this._onCanPlay);

        // started playing..
        source.addEventListener('play', this._onPlayStart.bind(this));
        source.addEventListener('pause', this._onPlayStop.bind(this));
    }

    this.__loaded = false;
}

VideoBaseTexture.prototype = Object.create(BaseTexture.prototype);
VideoBaseTexture.prototype.constructor = VideoBaseTexture;
module.exports = VideoBaseTexture;

/**
 * The internal update loop of the video base texture, only runs when autoUpdate is set to true
 *
 * @private
 */
VideoBaseTexture.prototype._onUpdate = function ()
{
    if (this.autoUpdate)
    {
        window.requestAnimationFrame(this._onUpdate);
        this.update();
    }
};

/**
 * Runs the update loop when the video is ready to play
 *
 * @private
 */
VideoBaseTexture.prototype._onPlayStart = function ()
{
    if (!this.autoUpdate)
    {
        window.requestAnimationFrame(this._onUpdate);
        this.autoUpdate = true;
    }
};

/**
 * Fired when a pause event is triggered, stops the update loop
 *
 * @private
 */
VideoBaseTexture.prototype._onPlayStop = function ()
{
    this.autoUpdate = false;
};

/**
 * Fired when the video is loaded and ready to play
 *
 * @private
 */
VideoBaseTexture.prototype._onCanPlay = function ()
{
    this.hasLoaded = true;

    if (this.source)
    {
        this.source.removeEventListener('canplay', this._onCanPlay);
        this.source.removeEventListener('canplaythrough', this._onCanPlay);

        this.width = this.source.videoWidth;
        this.height = this.source.videoHeight;

        this.source.play();

        // prevent multiple loaded dispatches..
        if (!this.__loaded)
        {
            this.__loaded = true;
            this.emit('loaded', this);
        }
    }
};

/**
 * Destroys this texture
 *
 */
VideoBaseTexture.prototype.destroy = function ()
{
    if (this.source && this.source._pixiId)
    {
        delete utils.BaseTextureCache[ this.source._pixiId ];
        delete this.source._pixiId;
    }

    BaseTexture.prototype.destroy.call(this);
};

/**
 * Mimic Pixi BaseTexture.from.... method.
 *
 * @static
 * @param video {HTMLVideoElement}
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.VideoBaseTexture}
 */
VideoBaseTexture.fromVideo = function (video, scaleMode)
{
    if (!video._pixiId)
    {
        video._pixiId = 'video_' + utils.uid();
    }

    var baseTexture = utils.BaseTextureCache[video._pixiId];

    if (!baseTexture)
    {
        baseTexture = new VideoBaseTexture(video, scaleMode);
        utils.BaseTextureCache[ video._pixiId ] = baseTexture;
    }

    return baseTexture;
};

/**
 * Helper function that creates a new BaseTexture based on the given video element.
 * This BaseTexture can then be used to create a texture
 *
 * @static
 * @param videoSrc {string|object|string[]|object[]} The URL(s) for the video.
 * @param [videoSrc.src] {string} One of the source urls for the video
 * @param [videoSrc.mime] {string} The mimetype of the video (e.g. 'video/mp4'). If not specified
 *  the url's extension will be used as the second part of the mime type.
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.VideoBaseTexture}
 */
VideoBaseTexture.fromUrl = function (videoSrc, scaleMode)
{
    var video = document.createElement('video');

    // array of objects or strings
    if (Array.isArray(videoSrc))
    {
        for (var i = 0; i < videoSrc.length; ++i)
        {
            video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));
        }
    }
    // single object or string
    else
    {
        video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));
    }

    video.load();
    video.play();

    return VideoBaseTexture.fromVideo(video, scaleMode);
};

VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;

function createSource(path, type)
{
    if (!type)
    {
        type = 'video/' + path.substr(path.lastIndexOf('.') + 1);
    }

    var source = document.createElement('source');

    source.src = path;
    source.type = type;

    return source;
}

},{"../utils":77,"./BaseTexture":70}],75:[function(require,module,exports){
var CONST = require('../const'),
    EventEmitter = require('eventemitter3'),
    // Internal event used by composed emitter
    TICK = 'tick';

/**
 * A Ticker class that runs an update loop that other objects listen to.
 * This class is composed around an EventEmitter object to add listeners
 * meant for execution on the next requested animation frame.
 * Animation frames are requested only when necessary,
 * e.g. When the ticker is started and the emitter has listeners.
 *
 * @class
 * @memberof PIXI.ticker
 */
function Ticker()
{
    var _this = this;

    /**
     * Internal tick method bound to ticker instance.
     * This is because in early 2015, Function.bind
     * is still 60% slower in high performance scenarios.
     * Also separating frame requests from update method
     * so listeners may be called at any time and with
     * any animation API, just invoke ticker.update(time).
     *
     * @private
     */
    this._tick = function _tick(time) {

        _this._requestId = null;

        if (_this.started)
        {
            // Invoke listeners now
            _this.update(time);
            // Listener side effects may have modified ticker state.
            if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true))
            {
                _this._requestId = requestAnimationFrame(_this._tick);
            }
        }
    };

    /**
     * Internal emitter used to fire 'tick' event
     * @private
     */
    this._emitter = new EventEmitter();

    /**
     * Internal current frame request ID
     * @private
     */
    this._requestId = null;

    /**
     * Internal value managed by minFPS property setter and getter.
     * This is the maximum allowed milliseconds between updates.
     * @private
     */
    this._maxElapsedMS = 100;

    /**
     * Whether or not this ticker should invoke the method
     * {@link PIXI.ticker.Ticker#start} automatically
     * when a listener is added.
     *
     * @member {boolean}
     * @default false
     */
    this.autoStart = false;

    /**
     * Scalar time value from last frame to this frame.
     * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}
     * and is scaled with {@link PIXI.ticker.Ticker#speed}.
     * **Note:** The cap may be exceeded by scaling.
     *
     * @member {number}
     * @default 1
     */
    this.deltaTime = 1;

    /**
     * Time elapsed in milliseconds from last frame to this frame.
     * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}
     * is based, this value is neither capped nor scaled.
     * If the platform supports DOMHighResTimeStamp,
     * this value will have a precision of 1 µs.
     *
     * @member {DOMHighResTimeStamp|number}
     * @default 1 / TARGET_FPMS
     */
    this.elapsedMS = 1 / CONST.TARGET_FPMS; // default to target frame time

    /**
     * The last time {@link PIXI.ticker.Ticker#update} was invoked.
     * This value is also reset internally outside of invoking
     * update, but only when a new animation frame is requested.
     * If the platform supports DOMHighResTimeStamp,
     * this value will have a precision of 1 µs.
     *
     * @member {DOMHighResTimeStamp|number}
     * @default 0
     */
    this.lastTime = 0;

    /**
     * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.
     * @example
     * // Scales ticker.deltaTime to what would be
     * // the equivalent of approximately 120 FPS
     * ticker.speed = 2;
     *
     * @member {number}
     * @default 1
     */
    this.speed = 1;

    /**
     * Whether or not this ticker has been started.
     * `true` if {@link PIXI.ticker.Ticker#start} has been called.
     * `false` if {@link PIXI.ticker.Ticker#stop} has been called.
     * While `false`, this value may change to `true` in the
     * event of {@link PIXI.ticker.Ticker#autoStart} being `true`
     * and a listener is added.
     *
     * @member {boolean}
     * @default false
     */
    this.started = false;
}

Object.defineProperties(Ticker.prototype, {
    /**
     * The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.ticker.Ticker#speed}, which is specific
     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.
     *
     * @member
     * @memberof PIXI.ticker.Ticker#
     * @readonly
     */
    FPS: {
        get: function()
        {
            return 1000 / this.elapsedMS;
        }
    },

    /**
     * Manages the maximum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.ticker.Ticker#update}.
     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},
     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `0` and `PIXI.TARGET_FPMS * 1000`.
     *
     * @member
     * @memberof PIXI.ticker.Ticker#
     * @default 10
     */
    minFPS: {
        get: function()
        {
            return 1000 / this._maxElapsedMS;
        },
        set: function(fps)
        {
            // Clamp: 0 to TARGET_FPMS
            var minFPMS = Math.min(Math.max(0, fps) / 1000, CONST.TARGET_FPMS);
            this._maxElapsedMS = 1 / minFPMS;
        }
    }
});

/**
 * Conditionally requests a new animation frame.
 * If a frame has not already been requested, and if the internal
 * emitter has listeners, a new frame is requested.
 *
 * @private
 */
Ticker.prototype._requestIfNeeded = function _requestIfNeeded()
{
    if (this._requestId === null && this._emitter.listeners(TICK, true))
    {
        // ensure callbacks get correct delta
        this.lastTime = performance.now();
        this._requestId = requestAnimationFrame(this._tick);
    }
};

/**
 * Conditionally cancels a pending animation frame.
 *
 * @private
 */
Ticker.prototype._cancelIfNeeded = function _cancelIfNeeded()
{
    if (this._requestId !== null)
    {
        cancelAnimationFrame(this._requestId);
        this._requestId = null;
    }
};

/**
 * Conditionally requests a new animation frame.
 * If the ticker has been started it checks if a frame has not already
 * been requested, and if the internal emitter has listeners. If these
 * conditions are met, a new frame is requested. If the ticker has not
 * been started, but autoStart is `true`, then the ticker starts now,
 * and continues with the previous conditions to request a new frame.
 *
 * @private
 */
Ticker.prototype._startIfPossible = function _startIfPossible()
{
    if (this.started)
    {
        this._requestIfNeeded();
    }
    else if (this.autoStart)
    {
        this.start();
    }
};

/**
 * Calls {@link module:eventemitter3.EventEmitter#on} internally for the
 * internal 'tick' event. It checks if the emitter has listeners,
 * and if so it requests a new animation frame at this point.
 *
 * @param fn {Function} The listener function to be added for updates
 * @param [context] {Function} The listener context
 * @returns {PIXI.ticker.Ticker} this
 */
Ticker.prototype.add = function add(fn, context)
{
    this._emitter.on(TICK, fn, context);

    this._startIfPossible();

    return this;
};

/**
 * Calls {@link module:eventemitter3.EventEmitter#once} internally for the
 * internal 'tick' event. It checks if the emitter has listeners,
 * and if so it requests a new animation frame at this point.
 *
 * @param fn {Function} The listener function to be added for one update
 * @param [context] {Function} The listener context
 * @returns {PIXI.ticker.Ticker} this
 */
Ticker.prototype.addOnce = function addOnce(fn, context)
{
    this._emitter.once(TICK, fn, context);

    this._startIfPossible();

    return this;
};

/**
 * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.
 * It checks if the emitter has listeners for 'tick' event.
 * If it does, then it cancels the animation frame.
 *
 * @param [fn] {Function} The listener function to be removed
 * @param [context] {Function} The listener context to be removed
 * @returns {PIXI.ticker.Ticker} this
 */
Ticker.prototype.remove = function remove(fn, context)
{
    this._emitter.off(TICK, fn, context);

    if (!this._emitter.listeners(TICK, true))
    {
        this._cancelIfNeeded();
    }

    return this;
};

/**
 * Starts the ticker. If the ticker has listeners
 * a new animation frame is requested at this point.
 */
Ticker.prototype.start = function start()
{
    if (!this.started)
    {
        this.started = true;
        this._requestIfNeeded();
    }
};

/**
 * Stops the ticker. If the ticker has requested
 * an animation frame it is canceled at this point.
 */
Ticker.prototype.stop = function stop()
{
    if (this.started)
    {
        this.started = false;
        this._cancelIfNeeded();
    }
};

/**
 * Triggers an update. An update entails setting the
 * current {@link PIXI.ticker.Ticker#elapsedMS},
 * the current {@link PIXI.ticker.Ticker#deltaTime},
 * invoking all listeners with current deltaTime,
 * and then finally setting {@link PIXI.ticker.Ticker#lastTime}
 * with the value of currentTime that was provided.
 * This method will be called automatically by animation
 * frame callbacks if the ticker instance has been started
 * and listeners are added.
 *
 * @param [currentTime=performance.now()] {DOMHighResTimeStamp|number} the current time of execution
 */
Ticker.prototype.update = function update(currentTime)
{
    var elapsedMS;

    // Allow calling update directly with default currentTime.
    currentTime = currentTime || performance.now();
    // Save uncapped elapsedMS for measurement
    elapsedMS = this.elapsedMS = currentTime - this.lastTime;

    // cap the milliseconds elapsed used for deltaTime
    if (elapsedMS > this._maxElapsedMS)
    {
        elapsedMS = this._maxElapsedMS;
    }

    this.deltaTime = elapsedMS * CONST.TARGET_FPMS * this.speed;

    // Invoke listeners added to internal emitter
    this._emitter.emit(TICK, this.deltaTime);

    this.lastTime = currentTime;
};

module.exports = Ticker;

},{"../const":23,"eventemitter3":10}],76:[function(require,module,exports){
var Ticker = require('./Ticker');

/**
 * The shared ticker instance used by {@link PIXI.extras.MovieClip}.
 * and by {@link PIXI.interaction.InteractionManager}.
 * The property {@link PIXI.ticker.Ticker#autoStart} is set to `true`
 * for this instance. Please follow the examples for usage, including
 * how to opt-out of auto-starting the shared ticker.
 *
 * @example
 * var ticker = PIXI.ticker.shared;
 * // Set this to prevent starting this ticker when listeners are added.
 * // By default this is true only for the PIXI.ticker.shared instance.
 * ticker.autoStart = false;
 * // FYI, call this to ensure the ticker is stopped. It should be stopped
 * // if you have not attempted to render anything yet.
 * ticker.stop();
 * // Call this when you are ready for a running shared ticker.
 * ticker.start();
 *
 * @example
 * // You may use the shared ticker to render...
 * var renderer = PIXI.autoDetectRenderer(800, 600);
 * var stage = new PIXI.Container();
 * var interactionManager = PIXI.interaction.InteractionManager(renderer);
 * document.body.appendChild(renderer.view);
 * ticker.add(function (time) {
 *     renderer.render(stage);
 * });
 *
 * @example
 * // Or you can just update it manually.
 * ticker.autoStart = false;
 * ticker.stop();
 * function animate(time) {
 *     ticker.update(time);
 *     renderer.render(stage);
 *     requestAnimationFrame(animate);
 * }
 * animate(performance.now());
 *
 * @type {PIXI.ticker.Ticker}
 * @memberof PIXI.ticker
 */
var shared = new Ticker();
shared.autoStart = true;

/**
 * @namespace PIXI.ticker
 */
module.exports = {
    shared: shared,
    Ticker: Ticker
};

},{"./Ticker":75}],77:[function(require,module,exports){
var CONST = require('../const');

/**
 * @namespace PIXI.utils
 */
var utils = module.exports = {
    _uid: 0,
    _saidHello: false,

    EventEmitter:   require('eventemitter3'),
    pluginTarget:   require('./pluginTarget'),
    async:          require('async'),

    /**
     * Gets the next unique identifier
     *
     * @return {number} The next unique identifier to use.
     */
    uid: function ()
    {
        return ++utils._uid;
    },

    /**
     * Converts a hex color number to an [R, G, B] array
     *
     * @param hex {number}
     * @param  {number[]} [out=[]]
     * @return {number[]} An array representing the [R, G, B] of the color.
     */
    hex2rgb: function (hex, out)
    {
        out = out || [];

        out[0] = (hex >> 16 & 0xFF) / 255;
        out[1] = (hex >> 8 & 0xFF) / 255;
        out[2] = (hex & 0xFF) / 255;

        return out;
    },

    /**
     * Converts a hex color number to a string.
     *
     * @param hex {number}
     * @return {string} The string color.
     */
    hex2string: function (hex)
    {
        hex = hex.toString(16);
        hex = '000000'.substr(0, 6 - hex.length) + hex;

        return '#' + hex;
    },

    /**
     * Converts a color as an [R, G, B] array to a hex number
     *
     * @param rgb {number[]}
     * @return {number} The color number
     */
    rgb2hex: function (rgb)
    {
        return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);
    },

    /**
     * Checks whether the Canvas BlendModes are supported by the current browser
     *
     * @return {boolean} whether they are supported
     */
    canUseNewCanvasBlendModes: function ()
    {
        if (typeof document === 'undefined')
        {
            return false;
        }

        var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
        var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';

        var magenta = new Image();
        magenta.src = pngHead + 'AP804Oa6' + pngEnd;

        var yellow = new Image();
        yellow.src = pngHead + '/wCKxvRF' + pngEnd;

        var canvas = document.createElement('canvas');
        canvas.width = 6;
        canvas.height = 1;

        var context = canvas.getContext('2d');
        context.globalCompositeOperation = 'multiply';
        context.drawImage(magenta, 0, 0);
        context.drawImage(yellow, 2, 0);

        var data = context.getImageData(2,0,1,1).data;

        return (data[0] === 255 && data[1] === 0 && data[2] === 0);
    },

    /**
     * Given a number, this function returns the closest number that is a power of two
     * this function is taken from Starling Framework as its pretty neat ;)
     *
     * @param number {number}
     * @return {number} the closest number that is a power of two
     */
    getNextPowerOfTwo: function (number)
    {
        // see: http://en.wikipedia.org/wiki/Power_of_two#Fast_algorithm_to_check_if_a_positive_number_is_a_power_of_two
        if (number > 0 && (number & (number - 1)) === 0)
        {
            return number;
        }
        else
        {
            var result = 1;

            while (result < number)
            {
                result <<= 1;
            }

            return result;
        }
    },

    /**
     * checks if the given width and height make a power of two rectangle
     *
     * @param width {number}
     * @param height {number}
     * @return {boolean}
     */
    isPowerOfTwo: function (width, height)
    {
        return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
    },

    /**
     * get the resolution of an asset by looking for the prefix
     * used by spritesheets and image urls
     *
     * @param url {string} the image path
     * @return {number}
     */
    getResolutionOfUrl: function (url)
    {
        var resolution = CONST.RETINA_PREFIX.exec(url);

        if (resolution)
        {
           return parseFloat(resolution[1]);
        }

        return 1;
    },

    /**
     * Logs out the version and renderer information for this running instance of PIXI.
     * If you don't want to see this message you can set `PIXI.utils._saidHello = true;`
     * so the library thinks it already said it. Keep in mind that doing that will forever
     * makes you a jerk face.
     *
     * @param {string} type - The string renderer type to log.
     * @constant
     * @static
     */
    sayHello: function (type)
    {
        if (utils._saidHello)
        {
            return;
        }

        if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1)
        {
            var args = [
                '\n %c %c %c Pixi.js ' + CONST.VERSION + ' - ✰ ' + type + ' ✰  %c ' + ' %c ' + ' http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n',
                'background: #ff66a5; padding:5px 0;',
                'background: #ff66a5; padding:5px 0;',
                'color: #ff66a5; background: #030307; padding:5px 0;',
                'background: #ff66a5; padding:5px 0;',
                'background: #ffc3dc; padding:5px 0;',
                'background: #ff66a5; padding:5px 0;',
                'color: #ff2424; background: #fff; padding:5px 0;',
                'color: #ff2424; background: #fff; padding:5px 0;',
                'color: #ff2424; background: #fff; padding:5px 0;'
            ];

            window.console.log.apply(console, args); //jshint ignore:line
        }
        else if (window.console)
        {
            window.console.log('Pixi.js ' + CONST.VERSION + ' - ' + type + ' - http://www.pixijs.com/'); //jshint ignore:line
        }

        utils._saidHello = true;
    },

    /**
     * Helper for checking for webgl support
     *
     * @return {boolean}
     */
    isWebGLSupported: function ()
    {
        var contextOptions = { stencil: true };
        try
        {
            if (!window.WebGLRenderingContext)
            {
                return false;
            }

            var canvas = document.createElement('canvas'),
                gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);

            return !!(gl && gl.getContextAttributes().stencil);
        }
        catch (e)
        {
            return false;
        }
    },

    /**
     * Returns sign of number
     *
     * @param n {number}
     * @returns {number} 0 if n is 0, -1 if n is negative, 1 if n i positive
     */
    sign: function (n)
    {
        return n ? (n < 0 ? -1 : 1) : 0;
    },

    /**
     * removeItems
     *
     * @param {array} arr The target array
     * @param {number} startIdx The index to begin removing from (inclusive)
     * @param {number} removeCount How many items to remove
     */
    removeItems: function (arr, startIdx, removeCount)
    {
        var length = arr.length;

        if (startIdx >= length || removeCount === 0)
        {
            return;
        }

        removeCount = (startIdx+removeCount > length ? length-startIdx : removeCount);
        for (var i = startIdx, len = length-removeCount; i < len; ++i)
        {
            arr[i] = arr[i + removeCount];
        }

        arr.length = len;
    },

    /**
     * @todo Describe property usage
     * @private
     */
    TextureCache: {},

    /**
     * @todo Describe property usage
     * @private
     */
    BaseTextureCache: {}
};

},{"../const":23,"./pluginTarget":78,"async":1,"eventemitter3":10}],78:[function(require,module,exports){
/**
 * Mixins functionality to make an object have "plugins".
 *
 * @mixin
 * @memberof PIXI.utils
 * @param obj {object} The object to mix into.
 * @example
 *      function MyObject() {}
 *
 *      pluginTarget.mixin(MyObject);
 */
function pluginTarget(obj)
{
    obj.__plugins = {};

    /**
     * Adds a plugin to an object
     *
     * @param pluginName {string} The events that should be listed.
     * @param ctor {Function} The constructor function for the plugin.
     */
    obj.registerPlugin = function (pluginName, ctor)
    {
        obj.__plugins[pluginName] = ctor;
    };

    /**
     * Instantiates all the plugins of this object
     *
     */
    obj.prototype.initPlugins = function ()
    {
        this.plugins = this.plugins || {};

        for (var o in obj.__plugins)
        {
            this.plugins[o] = new (obj.__plugins[o])(this);
        }
    };

    /**
     * Removes all the plugins of this object
     *
     */
    obj.prototype.destroyPlugins = function ()
    {
        for (var o in this.plugins)
        {
            this.plugins[o].destroy();
            this.plugins[o] = null;
        }

        this.plugins = null;
    };
}


module.exports = {
    /**
     * Mixes in the properties of the pluginTarget into another object
     *
     * @param object {object} The obj to mix into
     */
    mixin: function mixin(obj)
    {
        pluginTarget(obj);
    }
};

},{}],79:[function(require,module,exports){
/*global console */
var core = require('./core'),
    mesh = require('./mesh'),
    extras = require('./extras'),
    filters = require('./filters');

/**
 * @class
 * @private
 * @name SpriteBatch
 * @memberof PIXI
 * @see PIXI.ParticleContainer
 * @throws {ReferenceError} SpriteBatch does not exist any more, please use the new ParticleContainer instead.
 * @deprecated since version 3.0.0
 */
core.SpriteBatch = function()
{
    throw new ReferenceError('SpriteBatch does not exist any more, please use the new ParticleContainer instead.');
};

/**
 * @class
 * @private
 * @name AssetLoader
 * @memberof PIXI
 * @see PIXI.loaders.Loader
 * @throws {ReferenceError} The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.
 * @deprecated since version 3.0.0
 */
core.AssetLoader = function()
{
    throw new ReferenceError('The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.');
};

Object.defineProperties(core, {

    /**
     * @class
     * @private
     * @name Stage
     * @memberof PIXI
     * @see PIXI.Container
     * @deprecated since version 3.0.0
     */
    Stage: {
        get: function()
        {
            console.warn('You do not need to use a PIXI Stage any more, you can simply render any container.');
            return core.Container;
        }
    },

    /**
     * @class
     * @private
     * @name DisplayObjectContainer
     * @memberof PIXI
     * @see PIXI.Container
     * @deprecated since version 3.0.0
     */
    DisplayObjectContainer: {
        get: function()
        {
            console.warn('DisplayObjectContainer has been shortened to Container, please use Container from now on.');
            return core.Container;
        }
    },

    /**
     * @class
     * @private
     * @name Strip
     * @memberof PIXI
     * @see PIXI.mesh.Mesh
     * @deprecated since version 3.0.0
     */
    Strip: {
        get: function()
        {
            console.warn('The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on.');
            return mesh.Mesh;
        }
    },

    /**
     * @class
     * @private
     * @name Rope
     * @memberof PIXI
     * @see PIXI.mesh.Rope
     * @deprecated since version 3.0.0
     */
    Rope: {
        get: function()
        {
            console.warn('The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on.');
            return mesh.Rope;
        }
    },

    /**
     * @class
     * @private
     * @name MovieClip
     * @memberof PIXI
     * @see PIXI.extras.MovieClip
     * @deprecated since version 3.0.0
     */
    MovieClip: {
        get: function()
        {
            console.warn('The MovieClip class has been moved to extras.MovieClip, please use extras.MovieClip from now on.');
            return extras.MovieClip;
        }
    },

    /**
     * @class
     * @private
     * @name TilingSprite
     * @memberof PIXI
     * @see PIXI.extras.TilingSprite
     * @deprecated since version 3.0.0
     */
    TilingSprite: {
        get: function()
        {
            console.warn('The TilingSprite class has been moved to extras.TilingSprite, please use extras.TilingSprite from now on.');
            return extras.TilingSprite;
        }
    },

    /**
     * @class
     * @private
     * @name BitmapText
     * @memberof PIXI
     * @see PIXI.extras.BitmapText
     * @deprecated since version 3.0.0
     */
    BitmapText: {
        get: function()
        {
            console.warn('The BitmapText class has been moved to extras.BitmapText, please use extras.BitmapText from now on.');
            return extras.BitmapText;
        }
    },

    /**
     * @class
     * @private
     * @name blendModes
     * @memberof PIXI
     * @see PIXI.BLEND_MODES
     * @deprecated since version 3.0.0
     */
    blendModes: {
        get: function()
        {
            console.warn('The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on.');
            return core.BLEND_MODES;
        }
    },

    /**
     * @class
     * @private
     * @name scaleModes
     * @memberof PIXI
     * @see PIXI.SCALE_MODES
     * @deprecated since version 3.0.0
     */
    scaleModes: {
        get: function()
        {
            console.warn('The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on.');
            return core.SCALE_MODES;
        }
    },

    /**
     * @class
     * @private
     * @name BaseTextureCache
     * @memberof PIXI
     * @see PIXI.utils.BaseTextureCache
     * @deprecated since version 3.0.0
     */
    BaseTextureCache: {
        get: function ()
        {
            console.warn('The BaseTextureCache class has been moved to utils.BaseTextureCache, please use utils.BaseTextureCache from now on.');
            return core.utils.BaseTextureCache;
        }
    },

    /**
     * @class
     * @private
     * @name TextureCache
     * @memberof PIXI
     * @see PIXI.utils.TextureCache
     * @deprecated since version 3.0.0
     */
    TextureCache: {
        get: function ()
        {
            console.warn('The TextureCache class has been moved to utils.TextureCache, please use utils.TextureCache from now on.');
            return core.utils.TextureCache;
        }
    },

    /**
     * @namespace
     * @private
     * @name math
     * @memberof PIXI
     * @see PIXI
     * @deprecated since version 3.0.6
     */
    math: {
        get: function ()
        {
            console.warn('The math namespace is deprecated, please access members already accessible on PIXI.');
            return core;
        }
    }
});

/**
 * @method
 * @private
 * @name PIXI.Sprite#setTexture
 * @see PIXI.Sprite#texture
 * @deprecated since version 3.0.0
 */
core.Sprite.prototype.setTexture = function(texture)
{
    this.texture = texture;
    console.warn('setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;');
};

/**
 * @method
 * @name PIXI.extras.BitmapText#setText
 * @see PIXI.extras.BitmapText#text
 * @deprecated since version 3.0.0
 */
extras.BitmapText.prototype.setText = function(text)
{
    this.text = text;
    console.warn('setText is now deprecated, please use the text property, e.g : myBitmapText.text = \'my text\';');
};

/**
 * @method
 * @name PIXI.Text#setText
 * @see PIXI.Text#text
 * @deprecated since version 3.0.0
 */
core.Text.prototype.setText = function(text)
{
    this.text = text;
    console.warn('setText is now deprecated, please use the text property, e.g : myText.text = \'my text\';');
};

/**
 * @method
 * @name PIXI.Text#setStyle
 * @see PIXI.Text#style
 * @deprecated since version 3.0.0
 */
core.Text.prototype.setStyle = function(style)
{
    this.style = style;
    console.warn('setStyle is now deprecated, please use the style property, e.g : myText.style = style;');
};

/**
 * @method
 * @name PIXI.Texture#setFrame
 * @see PIXI.Texture#setFrame
 * @deprecated since version 3.0.0
 */
core.Texture.prototype.setFrame = function(frame)
{
    this.frame = frame;
    console.warn('setFrame is now deprecated, please use the frame property, e.g : myTexture.frame = frame;');
};

Object.defineProperties(filters, {

    /**
     * @class
     * @private
     * @name PIXI.filters.AbstractFilter
     * @see PIXI.AbstractFilter
     * @deprecated since version 3.0.6
     */
    AbstractFilter: {
        get: function()
        {
            console.warn('filters.AbstractFilter is an undocumented alias, please use AbstractFilter from now on.');
            return core.AbstractFilter;
        }
    },

    /**
     * @class
     * @private
     * @name PIXI.filters.FXAAFilter
     * @see PIXI.FXAAFilter
     * @deprecated since version 3.0.6
     */
    FXAAFilter: {
        get: function()
        {
            console.warn('filters.FXAAFilter is an undocumented alias, please use FXAAFilter from now on.');
            return core.FXAAFilter;
        }
    },

    /**
     * @class
     * @private
     * @name PIXI.filters.SpriteMaskFilter
     * @see PIXI.SpriteMaskFilter
     * @deprecated since version 3.0.6
     */
    SpriteMaskFilter: {
        get: function()
        {
            console.warn('filters.SpriteMaskFilter is an undocumented alias, please use SpriteMaskFilter from now on.');
            return core.SpriteMaskFilter;
        }
    }
});

/**
 * @method
 * @name PIXI.utils.uuid
 * @see PIXI.utils.uid
 * @deprecated since version 3.0.6
 */
core.utils.uuid = function ()
{
    console.warn('utils.uuid() is deprecated, please use utils.uid() from now on.');
    return core.utils.uid();
};

},{"./core":30,"./extras":86,"./filters":103,"./mesh":128}],80:[function(require,module,exports){
var core = require('../core');

/**
 * A BitmapText object will create a line or multiple lines of text using bitmap font. To
 * split a line you can use '\n', '\r' or '\r\n' in your string. You can generate the fnt files using:
 *
 * A BitmapText can only be created when the font is loaded
 *
 * ```js
 * // in this case the font is in a file called 'desyrel.fnt'
 * var bitmapText = new PIXI.extras.BitmapText("text using a fancy font!", {font: "35px Desyrel", align: "right"});
 * ```
 *
 *
 * http://www.angelcode.com/products/bmfont/ for windows or
 * http://www.bmglyph.com/ for mac.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI.extras
 * @param text {string} The copy that you would like the text to display
 * @param style {object} The style parameters
 * @param style.font {string|object} The font descriptor for the object, can be passed as a string of form
 *      "24px FontName" or "FontName" or as an object with explicit name/size properties.
 * @param [style.font.name] {string} The bitmap font id
 * @param [style.font.size] {number} The size of the font in pixels, e.g. 24
 * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect
 *      single line text
 * @param [style.tint=0xFFFFFF] {number} The tint color
 */
function BitmapText(text, style)
{
    core.Container.call(this);

    style = style || {};

    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @member {number}
     * @readOnly
     */
    this.textWidth = 0;

    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @member {number}
     * @readOnly
     */
    this.textHeight = 0;

    /**
     * Private tracker for the letter sprite pool.
     *
     * @member {PIXI.Sprite[]}
     * @private
     */
    this._glyphs = [];

    /**
     * Private tracker for the current style.
     *
     * @member {object}
     * @private
     */
    this._font = {
        tint: style.tint !== undefined ? style.tint : 0xFFFFFF,
        align: style.align || 'left',
        name: null,
        size: 0
    };

    /**
     * Private tracker for the current font.
     *
     * @member {object}
     * @private
     */
    this.font = style.font; // run font setter

    /**
     * Private tracker for the current text.
     *
     * @member {string}
     * @private
     */
    this._text = text;

    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting value to 0
     *
     * @member {number}
     */
    this.maxWidth = 0;

    /**
     * The max line height. This is useful when trying to use the total height of the Text, ie: when trying to vertically align.
     *
     * @member {number}
     */
    this.maxLineHeight = 0;

    /**
     * The dirty state of this object.
     *
     * @member {boolean}
     */
    this.dirty = false;

    this.updateText();
}

// constructor
BitmapText.prototype = Object.create(core.Container.prototype);
BitmapText.prototype.constructor = BitmapText;
module.exports = BitmapText;

Object.defineProperties(BitmapText.prototype, {
    /**
     * The tint of the BitmapText object
     *
     * @member {number}
     * @memberof PIXI.extras.BitmapText#
     */
    tint: {
        get: function ()
        {
            return this._font.tint;
        },
        set: function (value)
        {
            this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;

            this.dirty = true;
        }
    },

    /**
     * The alignment of the BitmapText object
     *
     * @member {string}
     * @default 'left'
     * @memberof PIXI.extras.BitmapText#
     */
    align: {
        get: function ()
        {
            return this._font.align;
        },
        set: function (value)
        {
            this._font.align = value || 'left';

            this.dirty = true;
        }
    },

    /**
     * The font descriptor of the BitmapText object
     *
     * @member {Font}
     * @memberof PIXI.extras.BitmapText#
     */
    font: {
        get: function ()
        {
            return this._font;
        },
        set: function (value)
        {
            if (!value) {
                return;
            }

            if (typeof value === 'string') {
                value = value.split(' ');

                this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');
                this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;
            }
            else {
                this._font.name = value.name;
                this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);
            }

            this.dirty = true;
        }
    },

    /**
     * The text of the BitmapText object
     *
     * @member {string}
     * @memberof PIXI.extras.BitmapText#
     */
    text: {
        get: function ()
        {
            return this._text;
        },
        set: function (value)
        {
            value = value.toString() || ' ';
            if (this._text === value)
            {
                return;
            }
            this._text = value;
            this.dirty = true;
        }
    }
});

/**
 * Renders text and updates it when needed
 *
 * @private
 */
BitmapText.prototype.updateText = function ()
{
    var data = BitmapText.fonts[this._font.name];
    var pos = new core.Point();
    var prevCharCode = null;
    var chars = [];
    var lastLineWidth = 0;
    var maxLineWidth = 0;
    var lineWidths = [];
    var line = 0;
    var scale = this._font.size / data.size;
    var lastSpace = -1;
    var maxLineHeight = 0;

    for (var i = 0; i < this.text.length; i++)
    {
        var charCode = this.text.charCodeAt(i);
        lastSpace = /(\s)/.test(this.text.charAt(i)) ? i : lastSpace;

        if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i)))
        {
            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            line++;

            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
        }

        if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth)
        {
            core.utils.removeItems(chars, lastSpace, i - lastSpace);
            i = lastSpace;
            lastSpace = -1;

            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            line++;

            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
        }

        var charData = data.chars[charCode];

        if (!charData)
        {
            continue;
        }

        if (prevCharCode && charData.kerning[prevCharCode])
        {
            pos.x += charData.kerning[prevCharCode];
        }

        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});
        lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);
        pos.x += charData.xAdvance;
        maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));
        prevCharCode = charCode;
    }

    lineWidths.push(lastLineWidth);
    maxLineWidth = Math.max(maxLineWidth, lastLineWidth);

    var lineAlignOffsets = [];

    for (i = 0; i <= line; i++)
    {
        var alignOffset = 0;

        if (this._font.align === 'right')
        {
            alignOffset = maxLineWidth - lineWidths[i];
        }
        else if (this._font.align === 'center')
        {
            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
        }

        lineAlignOffsets.push(alignOffset);
    }

    var lenChars = chars.length;
    var tint = this.tint;

    for (i = 0; i < lenChars; i++)
    {
        var c = this._glyphs[i]; // get the next glyph sprite

        if (c)
        {
            c.texture = chars[i].texture;
        }
        else
        {
            c = new core.Sprite(chars[i].texture);
            this._glyphs.push(c);
        }

        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
        c.position.y = chars[i].position.y * scale;
        c.scale.x = c.scale.y = scale;
        c.tint = tint;

        if (!c.parent)
        {
            this.addChild(c);
        }
    }

    // remove unnecessary children.
    for (i = lenChars; i < this._glyphs.length; ++i)
    {
        this.removeChild(this._glyphs[i]);
    }

    this.textWidth = maxLineWidth * scale;
    this.textHeight = (pos.y + data.lineHeight) * scale;
    this.maxLineHeight = maxLineHeight * scale;
};

/**
 * Updates the transform of this object
 *
 * @private
 */
BitmapText.prototype.updateTransform = function ()
{
    this.validate();
    this.containerUpdateTransform();
};

/**
 * Validates text before calling parent's getLocalBounds
 *
 * @return {PIXI.Rectangle} The rectangular bounding area
 */

BitmapText.prototype.getLocalBounds = function()
{
    this.validate();
    return core.Container.prototype.getLocalBounds.call(this);
};

/**
 * Updates text when needed
 *
 * @private
 */
BitmapText.prototype.validate = function()
{
    if (this.dirty)
    {
        this.updateText();
        this.dirty = false;
    }
};

BitmapText.fonts = {};

},{"../core":30}],81:[function(require,module,exports){
var core = require('../core');

/**
 * A MovieClip is a simple way to display an animation depicted by a list of textures.
 *
 * ```js
 * var alienImages = ["image_sequence_01.png","image_sequence_02.png","image_sequence_03.png","image_sequence_04.png"];
 * var textureArray = [];
 *
 * for (var i=0; i < 4; i++)
 * {
 *      var texture = PIXI.Texture.fromImage(alienImages[i]);
 *      textureArray.push(texture);
 * };
 *
 * var mc = new PIXI.MovieClip(textureArray);
 * ```
 *
 * @class
 * @extends PIXI.Sprite
 * @memberof PIXI.extras
 * @param textures {PIXI.Texture[]|Object[]} an array of {@link PIXI.Texture} or frame objects that make up the animation
 * @param textures[].texture {PIXI.Texture} the {@link PIXI.Texture} of the frame
 * @param textures[].time {number} the duration of the frame in ms
 */
function MovieClip(textures)
{
    core.Sprite.call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture);

    /**
     * @private
     */
    this._textures = null;

    /**
     * @private
     */
    this._durations = null;

    this.textures = textures;

    /**
     * The speed that the MovieClip will play at. Higher is faster, lower is slower
     *
     * @member {number}
     * @default 1
     */
    this.animationSpeed = 1;

    /**
     * Whether or not the movie clip repeats after playing.
     *
     * @member {boolean}
     * @default true
     */
    this.loop = true;

    /**
     * Function to call when a MovieClip finishes playing
     *
     * @method
     * @memberof PIXI.extras.MovieClip#
     */
    this.onComplete = null;

    /**
     * Elapsed time since animation has been started, used internally to display current texture
     *
     * @member {number}
     * @private
     */
    this._currentTime = 0;

    /**
     * Indicates if the MovieClip is currently playing
     *
     * @member {boolean}
     * @readonly
     */
    this.playing = false;
}

// constructor
MovieClip.prototype = Object.create(core.Sprite.prototype);
MovieClip.prototype.constructor = MovieClip;
module.exports = MovieClip;

Object.defineProperties(MovieClip.prototype, {
    /**
     * totalFrames is the total number of frames in the MovieClip. This is the same as number of textures
     * assigned to the MovieClip.
     *
     * @member {number}
     * @memberof PIXI.extras.MovieClip#
     * @default 0
     * @readonly
     */
    totalFrames: {
        get: function()
        {
            return this._textures.length;
        }
    },

    /**
     * The array of textures used for this MovieClip
     *
     * @member {PIXI.Texture[]}
     * @memberof PIXI.extras.MovieClip#
     *
     */
    textures: {
        get: function ()
        {
            return this._textures;
        },
        set: function (value)
        {
            if(value[0] instanceof core.Texture)
            {
                this._textures = value;
                this._durations = null;
            }
            else
            {
                this._textures = [];
                this._durations = [];
                for(var i = 0; i < value.length; i++)
                {
                    this._textures.push(value[i].texture);
                    this._durations.push(value[i].time);
                }
            }
        }
    },

    /**
    * The MovieClips current frame index
    *
    * @member {number}
    * @memberof PIXI.extras.MovieClip#
    * @readonly
    */
    currentFrame: {
        get: function ()
        {
            var currentFrame = Math.floor(this._currentTime) % this._textures.length;
            if (currentFrame < 0)
            {
                currentFrame += this._textures.length;
            }
            return currentFrame;
        }
    }

});

/**
 * Stops the MovieClip
 *
 */
MovieClip.prototype.stop = function ()
{
    if(!this.playing)
    {
        return;
    }

    this.playing = false;
    core.ticker.shared.remove(this.update, this);
};

/**
 * Plays the MovieClip
 *
 */
MovieClip.prototype.play = function ()
{
    if(this.playing)
    {
        return;
    }

    this.playing = true;
    core.ticker.shared.add(this.update, this);
};

/**
 * Stops the MovieClip and goes to a specific frame
 *
 * @param frameNumber {number} frame index to stop at
 */
MovieClip.prototype.gotoAndStop = function (frameNumber)
{
    this.stop();

    this._currentTime = frameNumber;

    this._texture = this._textures[this.currentFrame];
};

/**
 * Goes to a specific frame and begins playing the MovieClip
 *
 * @param frameNumber {number} frame index to start at
 */
MovieClip.prototype.gotoAndPlay = function (frameNumber)
{
    this._currentTime = frameNumber;

    this.play();
};

/*
 * Updates the object transform for rendering
 * @private
 */
MovieClip.prototype.update = function (deltaTime)
{
    var elapsed = this.animationSpeed * deltaTime;

    if (this._durations !== null)
    {
        var lag = this._currentTime % 1 * this._durations[this.currentFrame];

        lag += elapsed / 60 * 1000;

        while (lag < 0)
        {
            this._currentTime--;
            lag += this._durations[this.currentFrame];
        }

        var sign = Math.sign(this.animationSpeed * deltaTime);
        this._currentTime = Math.floor(this._currentTime);

        while (lag >= this._durations[this.currentFrame])
        {
            lag -= this._durations[this.currentFrame] * sign;
            this._currentTime += sign;
        }

        this._currentTime += lag / this._durations[this.currentFrame];
    }
    else
    {
        this._currentTime += elapsed;
    }

    if (this._currentTime < 0 && !this.loop)
    {
        this.gotoAndStop(0);

        if (this.onComplete)
        {
            this.onComplete();
        }
    }
    else if (this._currentTime >= this._textures.length && !this.loop)
    {
        this.gotoAndStop(this._textures.length - 1);

        if (this.onComplete)
        {
            this.onComplete();
        }
    }
    else
    {
        this._texture = this._textures[this.currentFrame];
    }

};

/*
 * Stops the MovieClip and destroys it
 *
 */
MovieClip.prototype.destroy = function ( )
{
    this.stop();
    core.Sprite.prototype.destroy.call(this);
};

/**
 * A short hand way of creating a movieclip from an array of frame ids
 *
 * @static
 * @param frames {string[]} the array of frames ids the movieclip will use as its texture frames
 */
MovieClip.fromFrames = function (frames)
{
    var textures = [];

    for (var i = 0; i < frames.length; ++i)
    {
        textures.push(new core.Texture.fromFrame(frames[i]));
    }

    return new MovieClip(textures);
};

/**
 * A short hand way of creating a movieclip from an array of image ids
 *
 * @static
 * @param images {string[]} the array of image urls the movieclip will use as its texture frames
 */
MovieClip.fromImages = function (images)
{
    var textures = [];

    for (var i = 0; i < images.length; ++i)
    {
        textures.push(new core.Texture.fromImage(images[i]));
    }

    return new MovieClip(textures);
};
},{"../core":30}],82:[function(require,module,exports){
var core = require('../core'),
    // a sprite use dfor rendering textures..
    tempPoint = new core.Point(),
    CanvasTinter = require('../core/renderers/canvas/utils/CanvasTinter');

/**
 * A tiling sprite is a fast way of rendering a tiling image
 *
 * @class
 * @extends PIXI.Sprite
 * @memberof PIXI.extras
 * @param texture {Texture} the texture of the tiling sprite
 * @param width {number}  the width of the tiling sprite
 * @param height {number} the height of the tiling sprite
 */
function TilingSprite(texture, width, height)
{
    core.Sprite.call(this, texture);

    /**
     * The scaling of the image that is being tiled
     *
     * @member {PIXI.Point}
     */
    this.tileScale = new core.Point(1,1);


    /**
     * The offset position of the image that is being tiled
     *
     * @member {PIXI.Point}
     */
    this.tilePosition = new core.Point(0,0);

    ///// private

    /**
     * The with of the tiling sprite
     *
     * @member {number}
     * @private
     */
    this._width = width || 100;

    /**
     * The height of the tiling sprite
     *
     * @member {number}
     * @private
     */
    this._height = height || 100;

    /**
     * An internal WebGL UV cache.
     *
     * @member {PIXI.TextureUvs}
     * @private
     */
    this._uvs = new core.TextureUvs();

    this._canvasPattern = null;

    //TODO move..
    this.shader = new core.AbstractFilter(

      [
        'precision lowp float;',
        'attribute vec2 aVertexPosition;',
        'attribute vec2 aTextureCoord;',
        'attribute vec4 aColor;',

        'uniform mat3 projectionMatrix;',

        'uniform vec4 uFrame;',
        'uniform vec4 uTransform;',

        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',

        'void main(void){',
        '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',

        '   vec2 coord = aTextureCoord;',
        '   coord -= uTransform.xy;',
        '   coord /= uTransform.zw;',
        '   vTextureCoord = coord;',

        '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',
        '}'
      ].join('\n'),
      [
        'precision lowp float;',

        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',

        'uniform sampler2D uSampler;',
        'uniform vec4 uFrame;',
        'uniform vec2 uPixelSize;',

        'void main(void){',

        '   vec2 coord = mod(vTextureCoord, uFrame.zw);',
        '   coord = clamp(coord, uPixelSize, uFrame.zw - uPixelSize);',
        '   coord += uFrame.xy;',

        '   gl_FragColor =  texture2D(uSampler, coord) * vColor ;',
        '}'
      ].join('\n'),

            // set the uniforms
            {
                uFrame: { type: '4fv', value: [0,0,1,1] },
                uTransform: { type: '4fv', value: [0,0,1,1] },
                uPixelSize : { type : '2fv', value: [1, 1]}
            }
      );
}

TilingSprite.prototype = Object.create(core.Sprite.prototype);
TilingSprite.prototype.constructor = TilingSprite;
module.exports = TilingSprite;


Object.defineProperties(TilingSprite.prototype, {
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.extras.TilingSprite#
     */
    width: {
        get: function ()
        {
            return this._width;
        },
        set: function (value)
        {
            this._width = value;
        }
    },

    /**
     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.extras.TilingSprite#
     */
    height: {
        get: function ()
        {
            return this._height;
        },
        set: function (value)
        {
            this._height = value;
        }
    }
});

TilingSprite.prototype._onTextureUpdate = function ()
{
    return;
};


/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer}
 * @private
 */
TilingSprite.prototype._renderWebGL = function (renderer)
{
    // tweak our texture temporarily..
    var texture = this._texture;

    if(!texture || !texture._uvs)
    {
        return;
    }

    var tempUvs = texture._uvs,
        tempWidth = texture._frame.width,
        tempHeight = texture._frame.height,
        tw = texture.baseTexture.width,
        th = texture.baseTexture.height;

    texture._uvs = this._uvs;
    texture._frame.width = this.width;
    texture._frame.height = this.height;

    this.shader.uniforms.uPixelSize.value[0] = 1.0/tw;
    this.shader.uniforms.uPixelSize.value[1] = 1.0/th;

    this.shader.uniforms.uFrame.value[0] = tempUvs.x0;
    this.shader.uniforms.uFrame.value[1] = tempUvs.y0;
    this.shader.uniforms.uFrame.value[2] = tempUvs.x1 - tempUvs.x0;
    this.shader.uniforms.uFrame.value[3] = tempUvs.y2 - tempUvs.y0;

    this.shader.uniforms.uTransform.value[0] = (this.tilePosition.x % (tempWidth * this.tileScale.x)) / this._width;
    this.shader.uniforms.uTransform.value[1] = (this.tilePosition.y % (tempHeight * this.tileScale.y)) / this._height;
    this.shader.uniforms.uTransform.value[2] = ( tw / this._width ) * this.tileScale.x;
    this.shader.uniforms.uTransform.value[3] = ( th / this._height ) * this.tileScale.y;

    renderer.setObjectRenderer(renderer.plugins.sprite);
    renderer.plugins.sprite.render(this);

    texture._uvs = tempUvs;
    texture._frame.width = tempWidth;
    texture._frame.height = tempHeight;
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer} a reference to the canvas renderer
 * @private
 */
TilingSprite.prototype._renderCanvas = function (renderer)
{
    var texture = this._texture;

    if (!texture.baseTexture.hasLoaded)
    {
      return;
    }

    var context = renderer.context,
        transform = this.worldTransform,
        resolution = renderer.resolution,
        baseTexture = texture.baseTexture,
        modX = (this.tilePosition.x / this.tileScale.x) % texture._frame.width,
        modY = (this.tilePosition.y / this.tileScale.y) % texture._frame.height;

    // create a nice shiny pattern!
    // TODO this needs to be refreshed if texture changes..
    if(!this._canvasPattern)
    {
        // cut an object from a spritesheet..
        var tempCanvas = new core.CanvasBuffer(texture._frame.width, texture._frame.height);

        // Tint the tiling sprite
        if (this.tint !== 0xFFFFFF)
        {
            if (this.cachedTint !== this.tint)
            {
                this.cachedTint = this.tint;

                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);
            }
            tempCanvas.context.drawImage(this.tintedTexture, 0, 0);
        }
        else
        {
            tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x, -texture._frame.y);
        }
        this._canvasPattern = tempCanvas.context.createPattern( tempCanvas.canvas, 'repeat' );
    }

    // set context state..
    context.globalAlpha = this.worldAlpha;
    context.setTransform(transform.a * resolution,
                       transform.b * resolution,
                       transform.c * resolution,
                       transform.d * resolution,
                       transform.tx * resolution,
                       transform.ty * resolution);

    // TODO - this should be rolled into the setTransform above..
    context.scale(this.tileScale.x,this.tileScale.y);

    context.translate(modX + (this.anchor.x * -this._width ),
                      modY + (this.anchor.y * -this._height));

    // check blend mode
    var compositeOperation = renderer.blendModes[this.blendMode];
    if (compositeOperation !== renderer.context.globalCompositeOperation)
    {
        context.globalCompositeOperation = compositeOperation;
    }

    // fill the pattern!
    context.fillStyle = this._canvasPattern;
    context.fillRect(-modX,
                     -modY,
                     this._width / this.tileScale.x,
                     this._height / this.tileScale.y);


    //TODO - pretty sure this can be deleted...
    //context.translate(-this.tilePosition.x + (this.anchor.x * this._width), -this.tilePosition.y + (this.anchor.y * this._height));
    //context.scale(1 / this.tileScale.x, 1 / this.tileScale.y);
};


/**
 * Returns the framing rectangle of the sprite as a Rectangle object
*
 * @return {PIXI.Rectangle} the framing rectangle
 */
TilingSprite.prototype.getBounds = function ()
{
    var width = this._width;
    var height = this._height;

    var w0 = width * (1-this.anchor.x);
    var w1 = width * -this.anchor.x;

    var h0 = height * (1-this.anchor.y);
    var h1 = height * -this.anchor.y;

    var worldTransform = this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.b;
    var c = worldTransform.c;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var minX,
        maxX,
        minY,
        maxY;

    minX = x1;
    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y1;
    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x1;
    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y1;
    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};

/**
 * Checks if a point is inside this tiling sprite
 * @param point {PIXI.Point} the point to check
 */
TilingSprite.prototype.containsPoint = function( point )
{
    this.worldTransform.applyInverse(point,  tempPoint);

    var width = this._width;
    var height = this._height;
    var x1 = -width * this.anchor.x;
    var y1;

    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )
    {
        y1 = -height * this.anchor.y;

        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )
        {
            return true;
        }
    }

    return false;
};

/**
 * Destroys this tiling sprite
 *
 */
TilingSprite.prototype.destroy = function () {
    core.Sprite.prototype.destroy.call(this);

    this.tileScale = null;
    this._tileScaleOffset = null;
    this.tilePosition = null;

    this._uvs = null;
};

/**
 * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {string} The frame Id of the texture in the cache
 * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId
 * @param width {number}  the width of the tiling sprite
 * @param height {number} the height of the tiling sprite
 */
TilingSprite.fromFrame = function (frameId,width,height)
{
    var texture = core.utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ' + this);
    }

    return new TilingSprite(texture,width,height);
};

/**
 * Helper function that creates a sprite that will contain a texture based on an image url
 * If the image is not in the texture cache it will be loaded
 *
 * @static
 * @param imageId {string} The image url of the texture
 * @param width {number}  the width of the tiling sprite
 * @param height {number} the height of the tiling sprite
 * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} if you want to specify the scale mode, see {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id
 */
TilingSprite.fromImage = function (imageId, width, height, crossorigin, scaleMode)
{
    return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode),width,height);
};

},{"../core":30,"../core/renderers/canvas/utils/CanvasTinter":48}],83:[function(require,module,exports){
var core = require('../core'),
    DisplayObject = core.DisplayObject,
    _tempMatrix = new core.Matrix();

DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._originalRenderWebGL = null;
DisplayObject.prototype._originalRenderCanvas = null;

DisplayObject.prototype._originalUpdateTransform = null;
DisplayObject.prototype._originalHitTest = null;
DisplayObject.prototype._originalDestroy = null;
DisplayObject.prototype._cachedSprite = null;

Object.defineProperties(DisplayObject.prototype, {

    /**
     * Set this to true if you want this display object to be cached as a bitmap.
     * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects.
     * To remove simply set this property to 'false'
     *
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */
    cacheAsBitmap: {
        get: function ()
        {
            return this._cacheAsBitmap;
        },
        set: function (value)
        {
            if (this._cacheAsBitmap === value)
            {
                return;
            }

            this._cacheAsBitmap = value;

            if (value)
            {
                this._originalRenderWebGL = this.renderWebGL;
                this._originalRenderCanvas = this.renderCanvas;

                this._originalUpdateTransform = this.updateTransform;
                this._originalGetBounds = this.getBounds;

                this._originalDestroy = this.destroy;

                this._originalContainsPoint = this.containsPoint;

                this.renderWebGL = this._renderCachedWebGL;
                this.renderCanvas = this._renderCachedCanvas;

                this.destroy = this._cacheAsBitmapDestroy;

            }
            else
            {
                if (this._cachedSprite)
                {
                    this._destroyCachedDisplayObject();
                }

                this.renderWebGL = this._originalRenderWebGL;
                this.renderCanvas = this._originalRenderCanvas;
                this.getBounds = this._originalGetBounds;

                this.destroy = this._originalDestroy;

                this.updateTransform = this._originalUpdateTransform;
                this.containsPoint = this._originalContainsPoint;
            }
        }
    }
});
/**
* Renders a cached version of the sprite with WebGL
*
* @param renderer {PIXI.WebGLRenderer} the WebGL renderer
* @private
*/
DisplayObject.prototype._renderCachedWebGL = function (renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
    {
        return;
    }

    this._initCachedDisplayObject( renderer );

    this._cachedSprite.worldAlpha = this.worldAlpha;

    renderer.setObjectRenderer(renderer.plugins.sprite);
    renderer.plugins.sprite.render( this._cachedSprite );
};

/**
* Prepares the WebGL renderer to cache the sprite
*
* @param renderer {PIXI.WebGLRenderer} the WebGL renderer
* @private
*/
DisplayObject.prototype._initCachedDisplayObject = function (renderer)
{
    if(this._cachedSprite)
    {
        return;
    }

    // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
    renderer.currentRenderer.flush();
    //this.filters= [];
    // next we find the dimensions of the untransformed object
    // this function also calls updatetransform on all its children as part of the measuring. This means we don't need to update the transform again in this function
    // TODO pass an object to clone too? saves having to create a new one each time!
    var bounds = this.getLocalBounds().clone();

    // add some padding!
    if(this._filters)
    {
        var padding = this._filters[0].padding;
        bounds.x -= padding;
        bounds.y -= padding;

        bounds.width += padding * 2;
        bounds.height += padding * 2;
    }

    // for now we cache the current renderTarget that the webGL renderer is currently using.
    // this could be more elegent..
    var cachedRenderTarget = renderer.currentRenderTarget;
    // We also store the filter stack - I will definitely look to change how this works a little later down the line.
    var stack = renderer.filterManager.filterStack;

    // this renderTexture will be used to store the cached DisplayObject
    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);

    // need to set //
    var m = _tempMatrix;

    m.tx = -bounds.x;
    m.ty = -bounds.y;



    // set all properties to there original so we can render to a texture
    this.renderWebGL = this._originalRenderWebGL;

    renderTexture.render(this, m, true, true);

    // now restore the state be setting the new properties
    renderer.setRenderTarget(cachedRenderTarget);
    renderer.filterManager.filterStack = stack;

    this.renderWebGL     = this._renderCachedWebGL;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.getBounds       = this._getCachedBounds;


    // create our cached sprite
    this._cachedSprite = new core.Sprite(renderTexture);
    this._cachedSprite.worldTransform = this.worldTransform;
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

    // restore the transform of the cached sprite to avoid the nasty flicker..
    this.updateTransform();

    // map the hit test..
    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);
};

/**
* Renders a cached version of the sprite with canvas
*
* @param renderer {PIXI.CanvasRenderer} the Canvas renderer
* @private
*/
DisplayObject.prototype._renderCachedCanvas = function (renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
    {
        return;
    }

    this._initCachedDisplayObjectCanvas( renderer );

    this._cachedSprite.worldAlpha = this.worldAlpha;

    this._cachedSprite.renderCanvas(renderer);
};

//TODO this can be the same as the webGL verison.. will need to do a little tweaking first though..
/**
* Prepares the Canvas renderer to cache the sprite
*
* @param renderer {PIXI.CanvasRenderer} the Canvas renderer
* @private
*/
DisplayObject.prototype._initCachedDisplayObjectCanvas = function (renderer)
{
    if(this._cachedSprite)
    {
        return;
    }

    //get bounds actually transforms the object for us already!
    var bounds = this.getLocalBounds();

    var cachedRenderTarget = renderer.context;

    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);

    // need to set //
    var m = _tempMatrix;

    m.tx = -bounds.x;
    m.ty = -bounds.y;

    // set all properties to there original so we can render to a texture
    this.renderCanvas = this._originalRenderCanvas;

    renderTexture.render(this, m, true);

    // now restore the state be setting the new properties
    renderer.context = cachedRenderTarget;

    this.renderCanvas = this._renderCachedCanvas;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.getBounds  = this._getCachedBounds;


    // create our cached sprite
    this._cachedSprite = new core.Sprite(renderTexture);
    this._cachedSprite.worldTransform = this.worldTransform;
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

    this.updateTransform();

    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);
};

/**
* Calculates the bounds of the cached sprite
*
* @private
*/
DisplayObject.prototype._getCachedBounds = function ()
{
    this._cachedSprite._currentBounds = null;

    return this._cachedSprite.getBounds();
};

/**
* Destroys the cached sprite.
*
* @private
*/
DisplayObject.prototype._destroyCachedDisplayObject = function ()
{
    this._cachedSprite._texture.destroy();
    this._cachedSprite = null;
};

DisplayObject.prototype._cacheAsBitmapDestroy = function ()
{
    this.cacheAsBitmap = false;
    this._originalDestroy();
};

},{"../core":30}],84:[function(require,module,exports){
var core = require('../core');

/**
 * The instance name of the object.
 *
 * @memberof PIXI.DisplayObject#
 * @member {string}
 */
core.DisplayObject.prototype.name = null;

/**
* Returns the display object in the container
*
* @memberof PIXI.Container#
* @param name {string} instance name
* @return {PIXI.DisplayObject}
*/
core.Container.prototype.getChildByName = function (name)
{
    for (var i = 0; i < this.children.length; i++)
    {
        if (this.children[i].name === name)
        {
            return this.children[i];
        }
    }
    return null;
};

},{"../core":30}],85:[function(require,module,exports){
var core = require('../core');

/**
* Returns the global position of the displayObject
*
* @memberof PIXI.DisplayObject#
* @param point {Point} the point to write the global value to. If null a new point will be returned
* @return {Point}
*/
core.DisplayObject.prototype.getGlobalPosition = function (point)
{
    point = point || new core.Point();

    if(this.parent)
    {
        this.displayObjectUpdateTransform();

        point.x = this.worldTransform.tx;
        point.y = this.worldTransform.ty;
    }
    else
    {
        point.x = this.position.x;
        point.y = this.position.y;
    }

    return point;
};

},{"../core":30}],86:[function(require,module,exports){
/**
 * @file        Main export of the PIXI extras library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

require('./cacheAsBitmap');
require('./getChildByName');
require('./getGlobalPosition');

/**
 * @namespace PIXI.extras
 */
module.exports = {
    MovieClip:      require('./MovieClip'),
    TilingSprite:   require('./TilingSprite'),
    BitmapText:     require('./BitmapText')
};

},{"./BitmapText":80,"./MovieClip":81,"./TilingSprite":82,"./cacheAsBitmap":83,"./getChildByName":84,"./getGlobalPosition":85}],87:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


// TODO (cengler) - The Y is flipped in this shader for some reason.

/**
 * @author Vico @vicocotea
 * original shader : https://www.shadertoy.com/view/lssGDj by @movAX13h
 */

/**
 * An ASCII filter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function AsciiFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nuniform vec4 dimensions;\r\nuniform float pixelSize;\r\nuniform sampler2D uSampler;\r\n\r\nfloat character(float n, vec2 p)\r\n{\r\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\r\n    if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\r\n    {\r\n        if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\r\n    }\r\n    return 0.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec2 uv = gl_FragCoord.xy;\r\n\r\n    vec3 col = texture2D(uSampler, floor( uv / pixelSize ) * pixelSize / dimensions.xy).rgb;\r\n\r\n    float gray = (col.r + col.g + col.b) / 3.0;\r\n\r\n    float n =  65536.0;             // .\r\n    if (gray > 0.2) n = 65600.0;    // :\r\n    if (gray > 0.3) n = 332772.0;   // *\r\n    if (gray > 0.4) n = 15255086.0; // o\r\n    if (gray > 0.5) n = 23385164.0; // &\r\n    if (gray > 0.6) n = 15252014.0; // 8\r\n    if (gray > 0.7) n = 13199452.0; // @\r\n    if (gray > 0.8) n = 11512810.0; // #\r\n\r\n    vec2 p = mod( uv / ( pixelSize * 0.5 ), 2.0) - vec2(1.0);\r\n    col = col * character(n, p);\r\n\r\n    gl_FragColor = vec4(col, 1.0);\r\n}\r\n",
        // custom uniforms
        {
            dimensions: { type: '4fv', value: new Float32Array([0, 0, 0, 0]) },
            pixelSize:  { type: '1f', value: 8 }
        }
    );
}

AsciiFilter.prototype = Object.create(core.AbstractFilter.prototype);
AsciiFilter.prototype.constructor = AsciiFilter;
module.exports = AsciiFilter;

Object.defineProperties(AsciiFilter.prototype, {
    /**
     * The pixel size used by the filter.
     *
     * @member {number}
     * @memberof PIXI.filters.AsciiFilter#
     */
    size: {
        get: function ()
        {
            return this.uniforms.pixelSize.value;
        },
        set: function (value)
        {
            this.uniforms.pixelSize.value = value;
        }
    }
});

},{"../../core":30}],88:[function(require,module,exports){
var core = require('../../core'),
    BlurXFilter = require('../blur/BlurXFilter'),
    BlurYFilter = require('../blur/BlurYFilter');

/**
 * The BloomFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BloomFilter()
{
    core.AbstractFilter.call(this);

    this.blurXFilter = new BlurXFilter();
    this.blurYFilter = new BlurYFilter();

    this.defaultFilter = new core.AbstractFilter();
}

BloomFilter.prototype = Object.create(core.AbstractFilter.prototype);
BloomFilter.prototype.constructor = BloomFilter;
module.exports = BloomFilter;

BloomFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    //TODO - copyTexSubImage2D could be used here?
    this.defaultFilter.applyFilter(renderer, input, output);

    this.blurXFilter.applyFilter(renderer, input, renderTarget);

    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.SCREEN);

    this.blurYFilter.applyFilter(renderer, renderTarget, output);

    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);

    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(BloomFilter.prototype, {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @memberOf PIXI.filters.BloomFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = this.blurYFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @memberOf PIXI.filters.BloomFilter#
     * @default 2
     */
    blurX: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @memberOf PIXI.filters.BloomFilter#
     * @default 2
     */
    blurY: {
        get: function ()
        {
            return this.blurYFilter.blur;
        },
        set: function (value)
        {
            this.blurYFilter.blur = value;
        }
    }
});

},{"../../core":30,"../blur/BlurXFilter":91,"../blur/BlurYFilter":92}],89:[function(require,module,exports){
var core = require('../../core');


/**
 * The BlurDirFilter applies a Gaussian blur toward a direction to an object.
 *
 * @class
 * @param {number} dirX
 * @param {number} dirY
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BlurDirFilter(dirX, dirY)
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nuniform float strength;\r\nuniform float dirX;\r\nuniform float dirY;\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying vec2 vBlurTexCoords[3];\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n\r\n    vBlurTexCoords[0] = aTextureCoord + vec2( (0.004 * strength) * dirX, (0.004 * strength) * dirY );\r\n    vBlurTexCoords[1] = aTextureCoord + vec2( (0.008 * strength) * dirX, (0.008 * strength) * dirY );\r\n    vBlurTexCoords[2] = aTextureCoord + vec2( (0.012 * strength) * dirX, (0.012 * strength) * dirY );\r\n\r\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\r\n}\r\n",
        // fragment shader
        "precision lowp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec2 vBlurTexCoords[3];\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    gl_FragColor = vec4(0.0);\r\n\r\n    gl_FragColor += texture2D(uSampler, vTextureCoord     ) * 0.3989422804014327;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0]) * 0.2419707245191454;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1]) * 0.05399096651318985;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2]) * 0.004431848411938341;\r\n}\r\n",
        // set the uniforms
        {
            strength: { type: '1f', value: 1 },
            dirX: { type: '1f', value: dirX || 0 },
            dirY: { type: '1f', value: dirY || 0 }
        }
    );

    this.defaultFilter = new core.AbstractFilter();

    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @default 1
     */
    this.passes = 1;

    /**
     * Sets the X direction of the blur
     *
     * @member {number}
     * @default 0
     */
    this.dirX = dirX || 0;

    /**
     * Sets the Y direction of the blur
     *
     * @member {number}
     * @default 0
     */
    this.dirY = dirY || 0;

    this.strength = 4;
}

BlurDirFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurDirFilter.prototype.constructor = BlurDirFilter;
module.exports = BlurDirFilter;

BlurDirFilter.prototype.applyFilter = function (renderer, input, output, clear) {

    var shader = this.getShader(renderer);

    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);

    if (this.passes === 1) {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    } else {
        var renderTarget = renderer.filterManager.getRenderTarget(true);

        renderer.filterManager.applyFilter(shader, input, renderTarget, clear);

        for(var i = 0; i < this.passes-2; i++)
        {
            //this.uniforms.strength.value = this.strength / 4 / (this.passes+(i*2)) * (input.frame.width / input.size.width);
            renderer.filterManager.applyFilter(shader, renderTarget, renderTarget, clear);
        }

        renderer.filterManager.applyFilter(shader, renderTarget, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurDirFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurDirFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.strength;
        },
        set: function (value)
        {
            this.padding = value * 0.5;
            this.strength = value;
        }
    },
    /**
     * Sets the X direction of the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurYFilter#
     * @default 0
     */
    dirX: {
        get: function ()
        {
            return this.dirX;
        },
        set: function (value)
        {
            this.uniforms.dirX.value = value;
        }
    },
    /**
     * Sets the Y direction of the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurDirFilter#
     * @default 0
     */
    dirY: {
        get: function ()
        {
            return this.dirY;
        },
        set: function (value)
        {
            this.uniforms.dirY.value = value;
        }
    }
});

},{"../../core":30}],90:[function(require,module,exports){
var core = require('../../core'),
    BlurXFilter = require('./BlurXFilter'),
    BlurYFilter = require('./BlurYFilter');

/**
 * The BlurFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BlurFilter()
{
    core.AbstractFilter.call(this);

    this.blurXFilter = new BlurXFilter();
    this.blurYFilter = new BlurYFilter();
}

BlurFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurFilter.prototype.constructor = BlurFilter;
module.exports = BlurFilter;

BlurFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    this.blurXFilter.applyFilter(renderer, input, renderTarget);
    this.blurYFilter.applyFilter(renderer, renderTarget, output);

    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(BlurFilter.prototype, {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @memberOf PIXI.filters.BlurFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.padding = Math.abs(value) * 0.5;
            this.blurXFilter.blur = this.blurYFilter.blur = value;
        }
    },

    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurYFilter#
     * @default 1
     */
    passes: {
        get: function ()
        {
            return  this.blurXFilter.passes;
        },
        set: function (value)
        {
            this.blurXFilter.passes = this.blurYFilter.passes = value;
        }
    },

    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @memberOf PIXI.filters.BlurFilter#
     * @default 2
     */
    blurX: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @memberOf PIXI.filters.BlurFilter#
     * @default 2
     */
    blurY: {
        get: function ()
        {
            return this.blurYFilter.blur;
        },
        set: function (value)
        {
            this.blurYFilter.blur = value;
        }
    }
});

},{"../../core":30,"./BlurXFilter":91,"./BlurYFilter":92}],91:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The BlurXFilter applies a horizontal Gaussian blur to an object.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BlurXFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nuniform float strength;\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying vec2 vBlurTexCoords[6];\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n\r\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);\r\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);\r\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);\r\n    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);\r\n    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);\r\n    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);\r\n\r\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\r\n}\r\n",
        // fragment shader
        "precision lowp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec2 vBlurTexCoords[6];\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    gl_FragColor = vec4(0.0);\r\n\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\r\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\r\n}\r\n",
        // set the uniforms
        {
            strength: { type: '1f', value: 1 }
        }
    );

    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @default 1
     */
    this.passes = 1;

    this.strength = 4;
}

BlurXFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurXFilter.prototype.constructor = BlurXFilter;
module.exports = BlurXFilter;

BlurXFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);

    if(this.passes === 1)
    {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    }
    else
    {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        var flip = input;
        var flop = renderTarget;

        for(var i = 0; i < this.passes-1; i++)
        {
            renderer.filterManager.applyFilter(shader, flip, flop, true);

           var temp = flop;
           flop = flip;
           flip = temp;
        }

        renderer.filterManager.applyFilter(shader, flip, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurXFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurXFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return  this.strength;
        },
        set: function (value)
        {
            this.padding =  Math.abs(value) * 0.5;
            this.strength = value;
        }
    }
});

},{"../../core":30}],92:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The BlurYFilter applies a horizontal Gaussian blur to an object.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BlurYFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nuniform float strength;\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying vec2 vBlurTexCoords[6];\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n\r\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\r\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\r\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\r\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\r\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\r\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\r\n\r\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\r\n}\r\n",
        // fragment shader
        "precision lowp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec2 vBlurTexCoords[6];\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    gl_FragColor = vec4(0.0);\r\n\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\r\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\r\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\r\n}\r\n",
        // set the uniforms
        {
            strength: { type: '1f', value: 1 }
        }
    );

    this.passes = 1;
    this.strength = 4;
}

BlurYFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurYFilter.prototype.constructor = BlurYFilter;
module.exports = BlurYFilter;

BlurYFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    this.uniforms.strength.value = Math.abs(this.strength) / 4 / this.passes * (input.frame.height / input.size.height);

    if(this.passes === 1)
    {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    }
    else
    {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        var flip = input;
        var flop = renderTarget;

        for(var i = 0; i < this.passes-1; i++)
        {
            renderer.filterManager.applyFilter(shader, flip, flop, true);

           var temp = flop;
           flop = flip;
           flip = temp;
        }

        renderer.filterManager.applyFilter(shader, flip, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurYFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurYFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return  this.strength;
        },
        set: function (value)
        {
            this.padding = Math.abs(value) * 0.5;
            this.strength = value;
        }
    }
});

},{"../../core":30}],93:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * A Smart Blur Filter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function SmartBlurFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec2 delta;\r\n\r\nfloat random(vec3 scale, float seed)\r\n{\r\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    vec4 color = vec4(0.0);\r\n    float total = 0.0;\r\n\r\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\r\n\r\n    for (float t = -30.0; t <= 30.0; t++)\r\n    {\r\n        float percent = (t + offset - 0.5) / 30.0;\r\n        float weight = 1.0 - abs(percent);\r\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta * percent);\r\n        sample.rgb *= sample.a;\r\n        color += sample * weight;\r\n        total += weight;\r\n    }\r\n\r\n    gl_FragColor = color / total;\r\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\r\n}\r\n",
        // uniforms
        {
          delta: { type: 'v2', value: { x: 0.1, y: 0.0 } }
        }
    );
}

SmartBlurFilter.prototype = Object.create(core.AbstractFilter.prototype);
SmartBlurFilter.prototype.constructor = SmartBlurFilter;
module.exports = SmartBlurFilter;

},{"../../core":30}],94:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The ColorMatrixFilter class lets you apply a 5x4 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. It's pretty powerful!
 *
 * ```js
 *  var colorMatrix = new PIXI.ColorMatrixFilter();
 *  container.filters = [colorMatrix];
 *  colorMatrix.contrast(2);
 * ```
 * @author Clément Chenebault <clement@goodboydigital.com>
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function ColorMatrixFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform float m[25];\r\n\r\nvoid main(void)\r\n{\r\n\r\n    vec4 c = texture2D(uSampler, vTextureCoord);\r\n\r\n    gl_FragColor.r = (m[0] * c.r);\r\n        gl_FragColor.r += (m[1] * c.g);\r\n        gl_FragColor.r += (m[2] * c.b);\r\n        gl_FragColor.r += (m[3] * c.a);\r\n        gl_FragColor.r += m[4];\r\n\r\n    gl_FragColor.g = (m[5] * c.r);\r\n        gl_FragColor.g += (m[6] * c.g);\r\n        gl_FragColor.g += (m[7] * c.b);\r\n        gl_FragColor.g += (m[8] * c.a);\r\n        gl_FragColor.g += m[9];\r\n\r\n     gl_FragColor.b = (m[10] * c.r);\r\n        gl_FragColor.b += (m[11] * c.g);\r\n        gl_FragColor.b += (m[12] * c.b);\r\n        gl_FragColor.b += (m[13] * c.a);\r\n        gl_FragColor.b += m[14];\r\n\r\n     gl_FragColor.a = (m[15] * c.r);\r\n        gl_FragColor.a += (m[16] * c.g);\r\n        gl_FragColor.a += (m[17] * c.b);\r\n        gl_FragColor.a += (m[18] * c.a);\r\n        gl_FragColor.a += m[19];\r\n\r\n}\r\n",
        // custom uniforms
        {
            m: {
                type: '1fv', value: [
                    1, 0, 0, 0, 0,
                    0, 1, 0, 0, 0,
                    0, 0, 1, 0, 0,
                    0, 0, 0, 1, 0
                ]
            }
        }
    );
}

ColorMatrixFilter.prototype = Object.create(core.AbstractFilter.prototype);
ColorMatrixFilter.prototype.constructor = ColorMatrixFilter;
module.exports = ColorMatrixFilter;


/**
 * Transforms current matrix and set the new one
 *
 * @param matrix {number[]} (mat 5x4)
 * @param multiply {boolean} if true, current matrix and matrix are multiplied. If false, just set the current matrix with @param matrix
 */
ColorMatrixFilter.prototype._loadMatrix = function (matrix, multiply)
{
    multiply = !!multiply;

    var newMatrix = matrix;

    if (multiply) {
        this._multiply(newMatrix, this.uniforms.m.value, matrix);
        newMatrix = this._colorMatrix(newMatrix);
    }

    // set the new matrix
    this.uniforms.m.value = newMatrix;
};

/**
 * Multiplies two mat5's
 *
 * @param out {number[]} (mat 5x4) the receiving matrix
 * @param a {number[]} (mat 5x4) the first operand
 * @param b {number[]} (mat 5x4) the second operand
 * @returns out {number[]} (mat 5x4)
 */
ColorMatrixFilter.prototype._multiply = function (out, a, b)
{

    // Red Channel
    out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);
    out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);
    out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);
    out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);
    out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]);

    // Green Channel
    out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);
    out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);
    out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);
    out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);
    out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]);

    // Blue Channel
    out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);
    out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);
    out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);
    out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);
    out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]);

    // Alpha Channel
    out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);
    out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);
    out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);
    out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);
    out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]);

    return out;
};

/**
 * Create a Float32 Array and normalize the offset component to 0-1
 *
 * @param matrix {number[]} (mat 5x4)
 * @return m {number[]} (mat 5x4) with all values between 0-1
 */
ColorMatrixFilter.prototype._colorMatrix = function (matrix)
{
    // Create a Float32 Array and normalize the offset component to 0-1
    var m = new Float32Array(matrix);
    m[4] /= 255;
    m[9] /= 255;
    m[14] /= 255;
    m[19] /= 255;

    return m;
};

/**
 * Adjusts brightness
 *
 * @param b {number} value of the brigthness (0 is black)
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.brightness = function (b, multiply)
{
    var matrix = [
        b, 0, 0, 0, 0,
        0, b, 0, 0, 0,
        0, 0, b, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Set the matrices in grey scales
 *
 * @param scale {number} value of the grey (0 is black)
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.greyscale = function (scale, multiply)
{
    var matrix = [
        scale, scale, scale, 0, 0,
        scale, scale, scale, 0, 0,
        scale, scale, scale, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};
//Americanized alias
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;

/**
 * Set the black and white matrice
 * Multiply the current matrix
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.blackAndWhite = function (multiply)
{
    var matrix = [
        0.3, 0.6, 0.1, 0, 0,
        0.3, 0.6, 0.1, 0, 0,
        0.3, 0.6, 0.1, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Set the hue property of the color
 *
 * @param rotation {number} in degrees
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.hue = function (rotation, multiply)
{
    rotation = (rotation || 0) / 180 * Math.PI;
    var cos = Math.cos(rotation),
        sin = Math.sin(rotation);

    // luminanceRed, luminanceGreen, luminanceBlue
    var lumR = 0.213, // or 0.3086
        lumG = 0.715, // or 0.6094
        lumB = 0.072; // or 0.0820

    var matrix = [
        lumR + cos * (1 - lumR) + sin * (-lumR), lumG + cos * (-lumG) + sin * (-lumG), lumB + cos * (-lumB) + sin * (1 - lumB), 0, 0,
        lumR + cos * (-lumR) + sin * (0.143), lumG + cos * (1 - lumG) + sin * (0.140), lumB + cos * (-lumB) + sin * (-0.283), 0, 0,
        lumR + cos * (-lumR) + sin * (-(1 - lumR)), lumG + cos * (-lumG) + sin * (lumG), lumB + cos * (1 - lumB) + sin * (lumB), 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};


/**
 * Set the contrast matrix, increase the separation between dark and bright
 * Increase contrast : shadows darker and highlights brighter
 * Decrease contrast : bring the shadows up and the highlights down
 *
 * @param amount {number} value of the contrast
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.contrast = function (amount, multiply)
{
    var v = (amount || 0) + 1;
    var o = -128 * (v - 1);

    var matrix = [
        v, 0, 0, 0, o,
        0, v, 0, 0, o,
        0, 0, v, 0, o,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Set the saturation matrix, increase the separation between colors
 * Increase saturation : increase contrast, brightness, and sharpness
 *
 * @param amount {number}
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.saturate = function (amount, multiply)
{
    var x = (amount || 0) * 2 / 3 + 1;
    var y = ((x - 1) * -0.5);

    var matrix = [
        x, y, y, 0, 0,
        y, x, y, 0, 0,
        y, y, x, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Desaturate image (remove color)
 *
 * Call the saturate function
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.desaturate = function (multiply) // jshint unused:false
{
    this.saturate(-1);
};

/**
 * Negative image (inverse of classic rgb matrix)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.negative = function (multiply)
{
    var matrix = [
        0, 1, 1, 0, 0,
        1, 0, 1, 0, 0,
        1, 1, 0, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Sepia image
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.sepia = function (multiply)
{
    var matrix = [
        0.393, 0.7689999, 0.18899999, 0, 0,
        0.349, 0.6859999, 0.16799999, 0, 0,
        0.272, 0.5339999, 0.13099999, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.technicolor = function (multiply)
{
    var matrix = [
        1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,
        -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,
        -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Polaroid filter
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.polaroid = function (multiply)
{
    var matrix = [
        1.438, -0.062, -0.062, 0, 0,
        -0.122, 1.378, -0.122, 0, 0,
        -0.016, -0.016, 1.483, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Filter who transforms : Red -> Blue and Blue -> Red
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.toBGR = function (multiply)
{
    var matrix = [
        0, 0, 1, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.kodachrome = function (multiply)
{
    var matrix = [
        1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
        -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
        -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Brown delicious browni filter (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.browni = function (multiply)
{
    var matrix = [
        0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,
        -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,
        0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * Vintage filter (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.vintage = function (multiply)
{
    var matrix = [
        0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,
        0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,
        0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * We don't know exactly what it does, kind of gradient map, but funny to play with!
 *
 * @param desaturation {number}
 * @param toned {number}
 * @param lightColor {string} (example : "0xFFE580")
 * @param darkColor {string}  (example : "0xFFE580")
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.colorTone = function (desaturation, toned, lightColor, darkColor, multiply)
{
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 0xFFE580;
    darkColor = darkColor || 0x338000;

    var lR = ((lightColor >> 16) & 0xFF) / 255;
    var lG = ((lightColor >> 8) & 0xFF) / 255;
    var lB = (lightColor & 0xFF) / 255;

    var dR = ((darkColor >> 16) & 0xFF) / 255;
    var dG = ((darkColor >> 8) & 0xFF) / 255;
    var dB = (darkColor & 0xFF) / 255;

    var matrix = [
        0.3, 0.59, 0.11, 0, 0,
        lR, lG, lB, desaturation, 0,
        dR, dG, dB, toned, 0,
        lR - dR, lG - dG, lB - dB, 0, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * Night effect
 *
 * @param intensity {number}
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.night = function (intensity, multiply)
{
    intensity = intensity || 0.1;
    var matrix = [
        intensity * ( -2.0), -intensity, 0, 0, 0,
        -intensity, 0, intensity, 0, 0,
        0, intensity, intensity * 2.0, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};


/*
 * Predator effect
 *
 * Erase the current matrix by setting a new indepent one
 *
 * @param amount {number} how much the predator feels his future victim
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.predator = function (amount, multiply)
{
    var matrix = [
        11.224130630493164 * amount, -4.794486999511719 * amount, -2.8746118545532227 * amount, 0 * amount, 0.40342438220977783 * amount,
        -3.6330697536468506 * amount, 9.193157196044922 * amount, -2.951810836791992 * amount, 0 * amount, -1.316135048866272 * amount,
        -3.2184197902679443 * amount, -4.2375030517578125 * amount, 7.476448059082031 * amount, 0 * amount, 0.8044459223747253 * amount,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * LSD effect
 *
 * Multiply the current matrix
 *
 * @param amount {number} How crazy is your effect
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.lsd = function (multiply)
{
    var matrix = [
        2, -0.4, 0.5, 0, 0,
        -0.5, 2, -0.4, 0, 0,
        -0.4, -0.5, 3, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * Erase the current matrix by setting the default one
 *
 */
ColorMatrixFilter.prototype.reset = function ()
{
    var matrix = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, false);
};


Object.defineProperties(ColorMatrixFilter.prototype, {
    /**
     * Sets the matrix of the color matrix filter
     *
     * @member {number[]}
     * @memberof PIXI.filters.ColorMatrixFilter#
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */
    matrix: {
        get: function ()
        {
            return this.uniforms.m.value;
        },
        set: function (value)
        {
            this.uniforms.m.value = value;
        }
    }
});

},{"../../core":30}],95:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This lowers the color depth of your image by the given amount, producing an image with a smaller palette.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function ColorStepFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform float step;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 color = texture2D(uSampler, vTextureCoord);\r\n\r\n    color = floor(color * step) / step;\r\n\r\n    gl_FragColor = color;\r\n}\r\n",
        // custom uniforms
        {
            step: { type: '1f', value: 5 }
        }
    );
}

ColorStepFilter.prototype = Object.create(core.AbstractFilter.prototype);
ColorStepFilter.prototype.constructor = ColorStepFilter;
module.exports = ColorStepFilter;

Object.defineProperties(ColorStepFilter.prototype, {
    /**
     * The number of steps to reduce the palette by.
     *
     * @member {number}
     * @memberof PIXI.filters.ColorStepFilter#
     */
    step: {
        get: function ()
        {
            return this.uniforms.step.value;
        },
        set: function (value)
        {
            this.uniforms.step.value = value;
        }
    }
});

},{"../../core":30}],96:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The ConvolutionFilter class applies a matrix convolution filter effect.
 * A convolution combines pixels in the input image with neighboring pixels to produce a new image.
 * A wide variety of image effects can be achieved through convolutions, including blurring, edge
 * detection, sharpening, embossing, and beveling. The matrix should be specified as a 9 point Array.
 * See http://docs.gimp.org/en/plug-in-convmatrix.html for more info.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 * @param matrix {number[]} An array of values used for matrix transformation. Specified as a 9 point Array.
 * @param width {number} Width of the object you are transforming
 * @param height {number} Height of the object you are transforming
 */
function ConvolutionFilter(matrix, width, height)
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying mediump vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec2 texelSize;\r\nuniform float matrix[9];\r\n\r\nvoid main(void)\r\n{\r\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\r\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\r\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\r\n\r\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\r\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\r\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\r\n\r\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\r\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\r\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\r\n\r\n   gl_FragColor =\r\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\r\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\r\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\r\n\r\n   gl_FragColor.a = c22.a;\r\n}\r\n",
        // custom uniforms
        {
            matrix:     { type: '1fv', value: new Float32Array(matrix) },
            texelSize:  { type: 'v2', value: { x: 1 / width, y: 1 / height } }
        }
    );
}

ConvolutionFilter.prototype = Object.create(core.AbstractFilter.prototype);
ConvolutionFilter.prototype.constructor = ConvolutionFilter;
module.exports = ConvolutionFilter;

Object.defineProperties(ConvolutionFilter.prototype, {
    /**
     * An array of values used for matrix transformation. Specified as a 9 point Array.
     *
     * @member {number[]}
     * @memberof PIXI.filters.ConvolutionFilter#
     */
    matrix: {
        get: function ()
        {
            return this.uniforms.matrix.value;
        },
        set: function (value)
        {
            this.uniforms.matrix.value = new Float32Array(value);
        }
    },

    /**
     * Width of the object you are transforming
     *
     * @member {number}
     * @memberof PIXI.filters.ConvolutionFilter#
     */
    width: {
        get: function ()
        {
            return 1/this.uniforms.texelSize.value.x;
        },
        set: function (value)
        {
            this.uniforms.texelSize.value.x = 1/value;
        }
    },

    /**
     * Height of the object you are transforming
     *
     * @member {number}
     * @memberof PIXI.filters.ConvolutionFilter#
     */
    height: {
        get: function ()
        {
            return 1/this.uniforms.texelSize.value.y;
        },
        set: function (value)
        {
            this.uniforms.texelSize.value.y = 1/value;
        }
    }
});

},{"../../core":30}],97:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * A Cross Hatch effect filter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function CrossHatchFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\r\n\r\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\n    if (lum < 1.00)\r\n    {\r\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\r\n        {\r\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n        }\r\n    }\r\n\r\n    if (lum < 0.75)\r\n    {\r\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\r\n        {\r\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n        }\r\n    }\r\n\r\n    if (lum < 0.50)\r\n    {\r\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\r\n        {\r\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n        }\r\n    }\r\n\r\n    if (lum < 0.3)\r\n    {\r\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\r\n        {\r\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n        }\r\n    }\r\n}\r\n"
    );
}

CrossHatchFilter.prototype = Object.create(core.AbstractFilter.prototype);
CrossHatchFilter.prototype.constructor = CrossHatchFilter;
module.exports = CrossHatchFilter;

},{"../../core":30}],98:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The DisplacementFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.
 * You can use this filter to apply all manor of crazy warping effects
 * Currently the r property of the texture is used to offset the x and the g property of the texture is used to offset the y.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 * @param sprite {PIXI.Sprite} the sprite used for the displacement map. (make sure its added to the scene!)
 */
function DisplacementFilter(sprite, scale)
{
    var maskMatrix = new core.Matrix();
    sprite.renderable = false;

    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 otherMatrix;\r\n\r\nvarying vec2 vMapCoord;\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nvoid main(void)\r\n{\r\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n   vTextureCoord = aTextureCoord;\r\n   vMapCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\r\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\r\n}\r\n",
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vMapCoord;\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform vec2 scale;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mapSampler;\r\n\r\nvoid main(void)\r\n{\r\n   vec4 map =  texture2D(mapSampler, vMapCoord);\r\n\r\n   map -= 0.5;\r\n   map.xy *= scale;\r\n\r\n   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y));\r\n}\r\n",
        // uniforms
        {
            mapSampler:     { type: 'sampler2D', value: sprite.texture },
            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) },
            scale:          { type: 'v2', value: { x: 1, y: 1 } }
        }
    );

    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;

    if (scale === null || scale === undefined)
    {
        scale = 20;
    }

    this.scale = new core.Point(scale, scale);
}

DisplacementFilter.prototype = Object.create(core.AbstractFilter.prototype);
DisplacementFilter.prototype.constructor = DisplacementFilter;
module.exports = DisplacementFilter;

DisplacementFilter.prototype.applyFilter = function (renderer, input, output)
{
    var filterManager = renderer.filterManager;

    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);

    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);
    this.uniforms.scale.value.x = this.scale.x * (1/input.frame.width);
    this.uniforms.scale.value.y = this.scale.y * (1/input.frame.height);

    var shader = this.getShader(renderer);
     // draw the filter...
    filterManager.applyFilter(shader, input, output);
};


Object.defineProperties(DisplacementFilter.prototype, {
    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {PIXI.Texture}
     * @memberof PIXI.filters.DisplacementFilter#
     */
    map: {
        get: function ()
        {
            return this.uniforms.mapSampler.value;
        },
        set: function (value)
        {
            this.uniforms.mapSampler.value = value;

        }
    }
});

},{"../../core":30}],99:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js
 */

/**
 * This filter applies a dotscreen effect making display objects appear to be made out of
 * black and white halftone dots like an old printer.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function DotScreenFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform vec4 dimensions;\r\nuniform sampler2D uSampler;\r\n\r\nuniform float angle;\r\nuniform float scale;\r\n\r\nfloat pattern()\r\n{\r\n   float s = sin(angle), c = cos(angle);\r\n   vec2 tex = vTextureCoord * dimensions.xy;\r\n   vec2 point = vec2(\r\n       c * tex.x - s * tex.y,\r\n       s * tex.x + c * tex.y\r\n   ) * scale;\r\n   return (sin(point.x) * sin(point.y)) * 4.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n   vec4 color = texture2D(uSampler, vTextureCoord);\r\n   float average = (color.r + color.g + color.b) / 3.0;\r\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\r\n}\r\n",
        // custom uniforms
        {
            scale:      { type: '1f', value: 1 },
            angle:      { type: '1f', value: 5 },
            dimensions: { type: '4fv', value: [0, 0, 0, 0] }
        }
    );
}

DotScreenFilter.prototype = Object.create(core.AbstractFilter.prototype);
DotScreenFilter.prototype.constructor = DotScreenFilter;
module.exports = DotScreenFilter;

Object.defineProperties(DotScreenFilter.prototype, {
    /**
     * The scale of the effect.
     * @member {number}
     * @memberof PIXI.filters.DotScreenFilter#
     */
    scale: {
        get: function ()
        {
            return this.uniforms.scale.value;
        },
        set: function (value)
        {
            this.uniforms.scale.value = value;
        }
    },

    /**
     * The radius of the effect.
     * @member {number}
     * @memberof PIXI.filters.DotScreenFilter#
     */
    angle: {
        get: function ()
        {
            return this.uniforms.angle.value;
        },
        set: function (value)
        {
            this.uniforms.angle.value = value;
        }
    }
});

},{"../../core":30}],100:[function(require,module,exports){
var core = require('../../core');

// @see https://github.com/substack/brfs/issues/25


/**
 * The BlurYTintFilter applies a vertical Gaussian blur to an object.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BlurYTintFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nuniform float strength;\r\nuniform vec2 offset;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying vec2 vBlurTexCoords[6];\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition+offset), 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n\r\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\r\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\r\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\r\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\r\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\r\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\r\n\r\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\r\n}\r\n",
        // fragment shader
        "precision lowp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec2 vBlurTexCoords[6];\r\nvarying vec4 vColor;\r\n\r\nuniform vec3 color;\r\nuniform float alpha;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    sum += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\r\n    sum += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\r\n    sum += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\r\n    sum += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\r\n    sum += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\r\n    sum += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\r\n    sum += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\r\n\r\n    gl_FragColor = vec4( color.rgb * sum.a * alpha, sum.a * alpha );\r\n}\r\n",
        // set the uniforms
        {
            blur: { type: '1f', value: 1 / 512 },
            color: { type: 'c', value: [0,0,0]},
            alpha: { type: '1f', value: 0.7 },
            offset: { type: '2f', value:[5, 5]},
            strength: { type: '1f', value:1}
        }
    );

    this.passes = 1;
    this.strength = 4;
}

BlurYTintFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurYTintFilter.prototype.constructor = BlurYTintFilter;
module.exports = BlurYTintFilter;

BlurYTintFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.height / input.size.height);

    if(this.passes === 1)
    {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    }
    else
    {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        var flip = input;
        var flop = renderTarget;

        for(var i = 0; i < this.passes-1; i++)
        {
            renderer.filterManager.applyFilter(shader, flip, flop, clear);

           var temp = flop;
           flop = flip;
           flip = temp;
        }

        renderer.filterManager.applyFilter(shader, flip, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurYTintFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurYTintFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return  this.strength;
        },
        set: function (value)
        {
            this.padding = value * 0.5;
            this.strength = value;
        }
    }
});

},{"../../core":30}],101:[function(require,module,exports){
var core = require('../../core'),
    BlurXFilter = require('../blur/BlurXFilter'),
    BlurYTintFilter = require('./BlurYTintFilter');

/**
 * The DropShadowFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function DropShadowFilter()
{
    core.AbstractFilter.call(this);

    this.blurXFilter = new BlurXFilter();
    this.blurYTintFilter = new BlurYTintFilter();

    this.defaultFilter = new core.AbstractFilter();

    this.padding = 30;

    this._dirtyPosition = true;
    this._angle = 45 * Math.PI / 180;
    this._distance = 10;
    this.alpha = 0.75;
    this.hideObject = false;
    this.blendMode = core.BLEND_MODES.MULTIPLY;
}

DropShadowFilter.prototype = Object.create(core.AbstractFilter.prototype);
DropShadowFilter.prototype.constructor = DropShadowFilter;
module.exports = DropShadowFilter;

DropShadowFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    //TODO - copyTexSubImage2D could be used here?
    if(this._dirtyPosition)
    {
        this._dirtyPosition = false;

        this.blurYTintFilter.uniforms.offset.value[0] = Math.sin(this._angle) * this._distance;
        this.blurYTintFilter.uniforms.offset.value[1] = Math.cos(this._angle) * this._distance;
    }

    this.blurXFilter.applyFilter(renderer, input, renderTarget);

    renderer.blendModeManager.setBlendMode(this.blendMode);

    this.blurYTintFilter.applyFilter(renderer, renderTarget, output);

    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);

    if(!this.hideObject)
    {

        this.defaultFilter.applyFilter(renderer, input, output);
    }


    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(DropShadowFilter.prototype, {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = this.blurYTintFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     * @default 2
     */
    blurX: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     * @default 2
     */
    blurY: {
        get: function ()
        {
            return this.blurYTintFilter.blur;
        },
        set: function (value)
        {
            this.blurYTintFilter.blur = value;
        }
    },

    /**
     * Sets the color of the shadow
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     */
    color: {
        get: function ()
        {
            return  core.utils.rgb2hex( this.blurYTintFilter.uniforms.color.value );
        },
        set: function (value)
        {
            this.blurYTintFilter.uniforms.color.value = core.utils.hex2rgb(value);
        }
    },

    /**
     * Sets the alpha of the shadow
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     */
    alpha: {
        get: function ()
        {
            return  this.blurYTintFilter.uniforms.alpha.value;
        },
        set: function (value)
        {
            this.blurYTintFilter.uniforms.alpha.value = value;
        }
    },

    /**
     * Sets the distance of the shadow
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     */
    distance: {
        get: function ()
        {
            return  this._distance;
        },
        set: function (value)
        {
            this._dirtyPosition = true;
            this._distance = value;
        }
    },

    /**
     * Sets the angle of the shadow
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     */
    angle: {
        get: function ()
        {
            return  this._angle;
        },
        set: function (value)
        {
            this._dirtyPosition = true;
            this._angle = value;
        }
    }
});

},{"../../core":30,"../blur/BlurXFilter":91,"./BlurYTintFilter":100}],102:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This greyscales the palette of your Display Objects.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function GrayFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\nuniform float gray;\r\n\r\nvoid main(void)\r\n{\r\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);\r\n}\r\n",
        // set the uniforms
        {
            gray: { type: '1f', value: 1 }
        }
    );
}

GrayFilter.prototype = Object.create(core.AbstractFilter.prototype);
GrayFilter.prototype.constructor = GrayFilter;
module.exports = GrayFilter;

Object.defineProperties(GrayFilter.prototype, {
    /**
     * The strength of the gray. 1 will make the object black and white, 0 will make the object its normal color.
     *
     * @member {number}
     * @memberof PIXI.filters.GrayFilter#
     */
    gray: {
        get: function ()
        {
            return this.uniforms.gray.value;
        },
        set: function (value)
        {
            this.uniforms.gray.value = value;
        }
    }
});

},{"../../core":30}],103:[function(require,module,exports){
/**
 * @file        Main export of the PIXI filters library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.filters
 */
module.exports = {
    AsciiFilter:        require('./ascii/AsciiFilter'),
    BloomFilter:        require('./bloom/BloomFilter'),
    BlurFilter:         require('./blur/BlurFilter'),
    BlurXFilter:        require('./blur/BlurXFilter'),
    BlurYFilter:        require('./blur/BlurYFilter'),
    BlurDirFilter:      require('./blur/BlurDirFilter'),
    ColorMatrixFilter:  require('./color/ColorMatrixFilter'),
    ColorStepFilter:    require('./color/ColorStepFilter'),
    ConvolutionFilter:  require('./convolution/ConvolutionFilter'),
    CrossHatchFilter:   require('./crosshatch/CrossHatchFilter'),
    DisplacementFilter: require('./displacement/DisplacementFilter'),
    DotScreenFilter:    require('./dot/DotScreenFilter'),
    GrayFilter:         require('./gray/GrayFilter'),
    DropShadowFilter:   require('./dropshadow/DropShadowFilter'),
    InvertFilter:       require('./invert/InvertFilter'),
    NoiseFilter:        require('./noise/NoiseFilter'),
    PixelateFilter:     require('./pixelate/PixelateFilter'),
    RGBSplitFilter:     require('./rgb/RGBSplitFilter'),
    ShockwaveFilter:    require('./shockwave/ShockwaveFilter'),
    SepiaFilter:        require('./sepia/SepiaFilter'),
    SmartBlurFilter:    require('./blur/SmartBlurFilter'),
    TiltShiftFilter:    require('./tiltshift/TiltShiftFilter'),
    TiltShiftXFilter:   require('./tiltshift/TiltShiftXFilter'),
    TiltShiftYFilter:   require('./tiltshift/TiltShiftYFilter'),
    TwistFilter:        require('./twist/TwistFilter')
};

},{"./ascii/AsciiFilter":87,"./bloom/BloomFilter":88,"./blur/BlurDirFilter":89,"./blur/BlurFilter":90,"./blur/BlurXFilter":91,"./blur/BlurYFilter":92,"./blur/SmartBlurFilter":93,"./color/ColorMatrixFilter":94,"./color/ColorStepFilter":95,"./convolution/ConvolutionFilter":96,"./crosshatch/CrossHatchFilter":97,"./displacement/DisplacementFilter":98,"./dot/DotScreenFilter":99,"./dropshadow/DropShadowFilter":101,"./gray/GrayFilter":102,"./invert/InvertFilter":104,"./noise/NoiseFilter":105,"./pixelate/PixelateFilter":106,"./rgb/RGBSplitFilter":107,"./sepia/SepiaFilter":108,"./shockwave/ShockwaveFilter":109,"./tiltshift/TiltShiftFilter":111,"./tiltshift/TiltShiftXFilter":112,"./tiltshift/TiltShiftYFilter":113,"./twist/TwistFilter":114}],104:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This inverts your Display Objects colors.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function InvertFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform float invert;\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n\r\n    gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);\r\n}\r\n",
        // custom uniforms
        {
            invert: { type: '1f', value: 1 }
        }
    );
}

InvertFilter.prototype = Object.create(core.AbstractFilter.prototype);
InvertFilter.prototype.constructor = InvertFilter;
module.exports = InvertFilter;

Object.defineProperties(InvertFilter.prototype, {
    /**
     * The strength of the invert. `1` will fully invert the colors, and
     * `0` will make the object its normal color.
     *
     * @member {number}
     * @memberof PIXI.filters.InvertFilter#
     */
    invert: {
        get: function ()
        {
            return this.uniforms.invert.value;
        },
        set: function (value)
        {
            this.uniforms.invert.value = value;
        }
    }
});

},{"../../core":30}],105:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * @author Vico @vicocotea
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js
 */

/**
 * A Noise effect filter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function NoiseFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision highp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform float noise;\r\nuniform sampler2D uSampler;\r\n\r\nfloat rand(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec4 color = texture2D(uSampler, vTextureCoord);\r\n\r\n    float diff = (rand(vTextureCoord) - 0.5) * noise;\r\n\r\n    color.r += diff;\r\n    color.g += diff;\r\n    color.b += diff;\r\n\r\n    gl_FragColor = color;\r\n}\r\n",
        // custom uniforms
        {
            noise: { type: '1f', value: 0.5 }
        }
    );
}

NoiseFilter.prototype = Object.create(core.AbstractFilter.prototype);
NoiseFilter.prototype.constructor = NoiseFilter;
module.exports = NoiseFilter;

Object.defineProperties(NoiseFilter.prototype, {
    /**
     * The amount of noise to apply.
     *
     * @member {number}
     * @memberof PIXI.filters.NoiseFilter#
     * @default 0.5
     */
    noise: {
        get: function ()
        {
            return this.uniforms.noise.value;
        },
        set: function (value)
        {
            this.uniforms.noise.value = value;
        }
    }
});

},{"../../core":30}],106:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This filter applies a pixelate effect making display objects appear 'blocky'.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function PixelateFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 dimensions;\r\nuniform vec2 pixelSize;\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    vec2 coord = vTextureCoord;\r\n\r\n    vec2 size = dimensions.xy / pixelSize;\r\n\r\n    vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;\r\n\r\n    gl_FragColor = texture2D(uSampler, color);\r\n}\r\n",
        // custom uniforms
        {
            dimensions: { type: '4fv',  value: new Float32Array([0, 0, 0, 0]) },
            pixelSize:  { type: 'v2',   value: { x: 10, y: 10 } }
        }
    );
}

PixelateFilter.prototype = Object.create(core.AbstractFilter.prototype);
PixelateFilter.prototype.constructor = PixelateFilter;
module.exports = PixelateFilter;

Object.defineProperties(PixelateFilter.prototype, {
    /**
     * This a point that describes the size of the blocks.
     * x is the width of the block and y is the height.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.PixelateFilter#
     */
    size: {
        get: function ()
        {
            return this.uniforms.pixelSize.value;
        },
        set: function (value)
        {
            this.uniforms.pixelSize.value = value;
        }
    }
});

},{"../../core":30}],107:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * An RGB Split Filter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function RGBSplitFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 dimensions;\r\nuniform vec2 red;\r\nuniform vec2 green;\r\nuniform vec2 blue;\r\n\r\nvoid main(void)\r\n{\r\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;\r\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;\r\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;\r\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\r\n}\r\n",
        // custom uniforms
        {
            red:        { type: 'v2', value: { x: 20, y: 20 } },
            green:      { type: 'v2', value: { x: -20, y: 20 } },
            blue:       { type: 'v2', value: { x: 20, y: -20 } },
            dimensions: { type: '4fv', value: [0, 0, 0, 0] }
        }
    );
}

RGBSplitFilter.prototype = Object.create(core.AbstractFilter.prototype);
RGBSplitFilter.prototype.constructor = RGBSplitFilter;
module.exports = RGBSplitFilter;

Object.defineProperties(RGBSplitFilter.prototype, {
    /**
     * Red channel offset.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.RGBSplitFilter#
     */
    red: {
        get: function ()
        {
            return this.uniforms.red.value;
        },
        set: function (value)
        {
            this.uniforms.red.value = value;
        }
    },

    /**
     * Green channel offset.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.RGBSplitFilter#
     */
    green: {
        get: function ()
        {
            return this.uniforms.green.value;
        },
        set: function (value)
        {
            this.uniforms.green.value = value;
        }
    },

    /**
     * Blue offset.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.RGBSplitFilter#
     */
    blue: {
        get: function ()
        {
            return this.uniforms.blue.value;
        },
        set: function (value)
        {
            this.uniforms.blue.value = value;
        }
    }
});

},{"../../core":30}],108:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This applies a sepia effect to your Display Objects.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function SepiaFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform float sepia;\r\n\r\nconst mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);\r\n\r\nvoid main(void)\r\n{\r\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);\r\n}\r\n",
        // custom uniforms
        {
            sepia: { type: '1f', value: 1 }
        }
    );
}

SepiaFilter.prototype = Object.create(core.AbstractFilter.prototype);
SepiaFilter.prototype.constructor = SepiaFilter;
module.exports = SepiaFilter;

Object.defineProperties(SepiaFilter.prototype, {
    /**
     * The strength of the sepia. `1` will apply the full sepia effect, and
     * `0` will make the object its normal color.
     *
     * @member {number}
     * @memberof PIXI.filters.SepiaFilter#
     */
    sepia: {
        get: function ()
        {
            return this.uniforms.sepia.value;
        },
        set: function (value)
        {
            this.uniforms.sepia.value = value;
        }
    }
});

},{"../../core":30}],109:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The ColorMatrixFilter class lets you apply a 4x4 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. It's pretty powerful!
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function ShockwaveFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision lowp float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nuniform vec2 center;\r\nuniform vec3 params; // 10.0, 0.8, 0.1\r\nuniform float time;\r\n\r\nvoid main()\r\n{\r\n    vec2 uv = vTextureCoord;\r\n    vec2 texCoord = uv;\r\n\r\n    float dist = distance(uv, center);\r\n\r\n    if ( (dist <= (time + params.z)) && (dist >= (time - params.z)) )\r\n    {\r\n        float diff = (dist - time);\r\n        float powDiff = 1.0 - pow(abs(diff*params.x), params.y);\r\n\r\n        float diffTime = diff  * powDiff;\r\n        vec2 diffUV = normalize(uv - center);\r\n        texCoord = uv + (diffUV * diffTime);\r\n    }\r\n\r\n    gl_FragColor = texture2D(uSampler, texCoord);\r\n}\r\n",
        // custom uniforms
        {
            center: { type: 'v2', value: { x: 0.5, y: 0.5 } },
            params: { type: 'v3', value: { x: 10, y: 0.8, z: 0.1 } },
            time: { type: '1f', value: 0 }
        }
    );
}

ShockwaveFilter.prototype = Object.create(core.AbstractFilter.prototype);
ShockwaveFilter.prototype.constructor = ShockwaveFilter;
module.exports = ShockwaveFilter;

Object.defineProperties(ShockwaveFilter.prototype, {
    /**
     * Sets the center of the shockwave in normalized screen coords. That is
     * (0,0) is the top-left and (1,1) is the bottom right.
     *
     * @member {object<string, number>}
     * @memberof PIXI.filters.ShockwaveFilter#
     */
    center: {
        get: function ()
        {
            return this.uniforms.center.value;
        },
        set: function (value)
        {
            this.uniforms.center.value = value;
        }
    },
    /**
     * Sets the params of the shockwave. These modify the look and behavior of
     * the shockwave as it ripples out.
     *
     * @member {object<string, number>}
     * @memberof PIXI.filters.ShockwaveFilter#
     */
    params: {
        get: function ()
        {
            return this.uniforms.params.value;
        },
        set: function (value)
        {
            this.uniforms.params.value = value;
        }
    },
    /**
     * Sets the elapsed time of the shockwave. This controls the speed at which
     * the shockwave ripples out.
     *
     * @member {number}
     * @memberof PIXI.filters.ShockwaveFilter#
     */
    time: {
        get: function ()
        {
            return this.uniforms.time.value;
        },
        set: function (value)
        {
            this.uniforms.time.value = value;
        }
    }
});

},{"../../core":30}],110:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShiftAxisFilter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function TiltShiftAxisFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform float blur;\r\nuniform float gradientBlur;\r\nuniform vec2 start;\r\nuniform vec2 end;\r\nuniform vec2 delta;\r\nuniform vec2 texSize;\r\n\r\nfloat random(vec3 scale, float seed)\r\n{\r\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    vec4 color = vec4(0.0);\r\n    float total = 0.0;\r\n\r\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\r\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\r\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\r\n\r\n    for (float t = -30.0; t <= 30.0; t++)\r\n    {\r\n        float percent = (t + offset - 0.5) / 30.0;\r\n        float weight = 1.0 - abs(percent);\r\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\r\n        sample.rgb *= sample.a;\r\n        color += sample * weight;\r\n        total += weight;\r\n    }\r\n\r\n    gl_FragColor = color / total;\r\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\r\n}\r\n",
        // custom uniforms
        {
            blur:           { type: '1f', value: 100 },
            gradientBlur:   { type: '1f', value: 600 },
            start:          { type: 'v2', value: { x: 0,    y: window.innerHeight / 2 } },
            end:            { type: 'v2', value: { x: 600,  y: window.innerHeight / 2 } },
            delta:          { type: 'v2', value: { x: 30,   y: 30 } },
            texSize:        { type: 'v2', value: { x: window.innerWidth, y: window.innerHeight } }
        }
    );

    this.updateDelta();
}

TiltShiftAxisFilter.prototype = Object.create(core.AbstractFilter.prototype);
TiltShiftAxisFilter.prototype.constructor = TiltShiftAxisFilter;
module.exports = TiltShiftAxisFilter;

/**
 * Updates the filter delta values.
 * This is overridden in the X and Y filters, does nothing for this class.
 *
 */
TiltShiftAxisFilter.prototype.updateDelta = function ()
{
    this.uniforms.delta.value.x = 0;
    this.uniforms.delta.value.y = 0;
};

Object.defineProperties(TiltShiftAxisFilter.prototype, {
    /**
     * The strength of the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftAxisFilter#
     */
    blur: {
        get: function ()
        {
            return this.uniforms.blur.value;
        },
        set: function (value)
        {
            this.uniforms.blur.value = value;
        }
    },

    /**
     * The strength of the gradient blur.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftAxisFilter#
     */
    gradientBlur: {
        get: function ()
        {
            return this.uniforms.gradientBlur.value;
        },
        set: function (value)
        {
            this.uniforms.gradientBlur.value = value;
        }
    },

    /**
     * The X value to start the effect at.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.TiltShiftAxisFilter#
     */
    start: {
        get: function ()
        {
            return this.uniforms.start.value;
        },
        set: function (value)
        {
            this.uniforms.start.value = value;
            this.updateDelta();
        }
    },

    /**
     * The X value to end the effect at.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.TiltShiftAxisFilter#
     */
    end: {
        get: function ()
        {
            return this.uniforms.end.value;
        },
        set: function (value)
        {
            this.uniforms.end.value = value;
            this.updateDelta();
        }
    }
});

},{"../../core":30}],111:[function(require,module,exports){
var core = require('../../core'),
    TiltShiftXFilter = require('./TiltShiftXFilter'),
    TiltShiftYFilter = require('./TiltShiftYFilter');

/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShift Filter. Manages the pass of both a TiltShiftXFilter and TiltShiftYFilter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function TiltShiftFilter()
{
    core.AbstractFilter.call(this);

    this.tiltShiftXFilter = new TiltShiftXFilter();
    this.tiltShiftYFilter = new TiltShiftYFilter();
}

TiltShiftFilter.prototype = Object.create(core.AbstractFilter.prototype);
TiltShiftFilter.prototype.constructor = TiltShiftFilter;
module.exports = TiltShiftFilter;

TiltShiftFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    this.tiltShiftXFilter.applyFilter(renderer, input, renderTarget);

    this.tiltShiftYFilter.applyFilter(renderer, renderTarget, output);

    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(TiltShiftFilter.prototype, {
    /**
     * The strength of the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftFilter#
     */
    blur: {
        get: function ()
        {
            return this.tiltShiftXFilter.blur;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.blur = this.tiltShiftYFilter.blur = value;
        }
    },

    /**
     * The strength of the gradient blur.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftFilter#
     */
    gradientBlur: {
        get: function ()
        {
            return this.tiltShiftXFilter.gradientBlur;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.gradientBlur = this.tiltShiftYFilter.gradientBlur = value;
        }
    },

    /**
     * The Y value to start the effect at.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftFilter#
     */
    start: {
        get: function ()
        {
            return this.tiltShiftXFilter.start;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.start = this.tiltShiftYFilter.start = value;
        }
    },

    /**
     * The Y value to end the effect at.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftFilter#
     */
    end: {
        get: function ()
        {
            return this.tiltShiftXFilter.end;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.end = this.tiltShiftYFilter.end = value;
        }
    }
});

},{"../../core":30,"./TiltShiftXFilter":112,"./TiltShiftYFilter":113}],112:[function(require,module,exports){
var TiltShiftAxisFilter = require('./TiltShiftAxisFilter');

/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShiftXFilter.
 *
 * @class
 * @extends PIXI.TiltShiftAxisFilter
 * @memberof PIXI.filters
 */
function TiltShiftXFilter()
{
    TiltShiftAxisFilter.call(this);
}

TiltShiftXFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);
TiltShiftXFilter.prototype.constructor = TiltShiftXFilter;
module.exports = TiltShiftXFilter;

/**
 * Updates the filter delta values.
 *
 */
TiltShiftXFilter.prototype.updateDelta = function ()
{
    var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;
    var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;
    var d = Math.sqrt(dx * dx + dy * dy);

    this.uniforms.delta.value.x = dx / d;
    this.uniforms.delta.value.y = dy / d;
};

},{"./TiltShiftAxisFilter":110}],113:[function(require,module,exports){
var TiltShiftAxisFilter = require('./TiltShiftAxisFilter');

/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShiftYFilter.
 *
 * @class
 * @extends PIXI.TiltShiftAxisFilter
 * @memberof PIXI.filters
 */
function TiltShiftYFilter()
{
    TiltShiftAxisFilter.call(this);
}

TiltShiftYFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);
TiltShiftYFilter.prototype.constructor = TiltShiftYFilter;
module.exports = TiltShiftYFilter;

/**
 * Updates the filter delta values.
 *
 */
TiltShiftYFilter.prototype.updateDelta = function ()
{
    var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;
    var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;
    var d = Math.sqrt(dx * dx + dy * dy);

    this.uniforms.delta.value.x = -dy / d;
    this.uniforms.delta.value.y = dx / d;
};

},{"./TiltShiftAxisFilter":110}],114:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This filter applies a twist effect making display objects appear twisted in the given direction.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function TwistFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform float radius;\r\nuniform float angle;\r\nuniform vec2 offset;\r\n\r\nvoid main(void)\r\n{\r\n   vec2 coord = vTextureCoord - offset;\r\n   float dist = length(coord);\r\n\r\n   if (dist < radius)\r\n   {\r\n       float ratio = (radius - dist) / radius;\r\n       float angleMod = ratio * ratio * angle;\r\n       float s = sin(angleMod);\r\n       float c = cos(angleMod);\r\n       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\r\n   }\r\n\r\n   gl_FragColor = texture2D(uSampler, coord+offset);\r\n}\r\n",
        // custom uniforms
        {
            radius:     { type: '1f', value: 0.5 },
            angle:      { type: '1f', value: 5 },
            offset:     { type: 'v2', value: { x: 0.5, y: 0.5 } }
        }
    );
}

TwistFilter.prototype = Object.create(core.AbstractFilter.prototype);
TwistFilter.prototype.constructor = TwistFilter;
module.exports = TwistFilter;

Object.defineProperties(TwistFilter.prototype, {
    /**
     * This point describes the the offset of the twist.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.TwistFilter#
     */
    offset: {
        get: function ()
        {
            return this.uniforms.offset.value;
        },
        set: function (value)
        {
            this.uniforms.offset.value = value;
        }
    },

    /**
     * This radius of the twist.
     *
     * @member {number}
     * @memberof PIXI.filters.TwistFilter#
     */
    radius: {
        get: function ()
        {
            return this.uniforms.radius.value;
        },
        set: function (value)
        {
            this.uniforms.radius.value = value;
        }
    },

    /**
     * This angle of the twist.
     *
     * @member {number}
     * @memberof PIXI.filters.TwistFilter#
     */
    angle: {
        get: function ()
        {
            return this.uniforms.angle.value;
        },
        set: function (value)
        {
            this.uniforms.angle.value = value;
        }
    }
});

},{"../../core":30}],115:[function(require,module,exports){
(function (global){
// run the polyfills
require('./polyfill');

var core = module.exports = require('./core');

// add core plugins.
core.extras         = require('./extras');
core.filters        = require('./filters');
core.interaction    = require('./interaction');
core.loaders        = require('./loaders');
core.mesh           = require('./mesh');
core.accessibility  = require('./accessibility');

// export a premade loader instance
/**
 * A premade instance of the loader that can be used to loader resources.
 *
 * @name loader
 * @memberof PIXI
 * @property {PIXI.loaders.Loader}
 */
core.loader = new core.loaders.Loader();

// mixin the deprecation features.
Object.assign(core, require('./deprecation'));

// Always export pixi globally.
global.PIXI = core;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./accessibility":22,"./core":30,"./deprecation":79,"./extras":86,"./filters":103,"./interaction":118,"./loaders":121,"./mesh":128,"./polyfill":133}],116:[function(require,module,exports){
var core = require('../core');

/**
 * Holds all information related to an Interaction event
 *
 * @class
 * @memberof PIXI.interaction
 */
function InteractionData()
{
    /**
     * This point stores the global coords of where the touch/mouse event happened
     *
     * @member {PIXI.Point}
     */
    this.global = new core.Point();

    /**
     * The target Sprite that was interacted with
     *
     * @member {PIXI.Sprite}
     */
    this.target = null;

    /**
     * When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @member {Event}
     */
    this.originalEvent = null;
}

InteractionData.prototype.constructor = InteractionData;
module.exports = InteractionData;

/**
 * This will return the local coordinates of the specified displayObject for this InteractionData
 *
 * @param displayObject {PIXI.DisplayObject} The DisplayObject that you would like the local coords off
 * @param [point] {PIXI.Point} A Point object in which to store the value, optional (otherwise will create a new point)
 * @param [globalPos] {PIXI.Point} A Point object containing your custom global coords, optional (otherwise will use the current global coords)
 * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject
 */
InteractionData.prototype.getLocalPosition = function (displayObject, point, globalPos)
{
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
};

},{"../core":30}],117:[function(require,module,exports){
var core = require('../core'),
    InteractionData = require('./InteractionData');

// Mix interactiveTarget into core.DisplayObject.prototype
Object.assign(
    core.DisplayObject.prototype,
    require('./interactiveTarget')
);

/**
 * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
 * if its interactive parameter is set to true
 * This manager also supports multitouch.
 *
 * @class
 * @memberof PIXI.interaction
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} A reference to the current renderer
 * @param [options] {object}
 * @param [options.autoPreventDefault=true] {boolean} Should the manager automatically prevent default browser actions.
 * @param [options.interactionFrequency=10] {number} Frequency increases the interaction events will be checked.
 */
function InteractionManager(renderer, options)
{
    options = options || {};

    /**
     * The renderer this interaction manager works for.
     *
     * @member {PIXI.SystemRenderer}
     */
    this.renderer = renderer;

    /**
     * Should default browser actions automatically be prevented.
     *
     * @member {boolean}
     * @default true
     */
    this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;

    /**
     * As this frequency increases the interaction events will be checked more often.
     *
     * @member {number}
     * @default 10
     */
    this.interactionFrequency = options.interactionFrequency || 10;

    /**
     * The mouse data
     *
     * @member {PIXI.interaction.InteractionData}
     */
    this.mouse = new InteractionData();

    /**
     * An event data object to handle all the event tracking/dispatching
     *
     * @member {object}
     */
    this.eventData = {
        stopped: false,
        target: null,
        type: null,
        data: this.mouse,
        stopPropagation:function(){
            this.stopped = true;
        }
    };

    /**
     * Tiny little interactiveData pool !
     *
     * @member {PIXI.interaction.InteractionData[]}
     */
    this.interactiveDataPool = [];

    /**
     * The DOM element to bind to.
     *
     * @member {HTMLElement}
     * @private
     */
    this.interactionDOMElement = null;

    /**
     * Have events been attached to the dom element?
     *
     * @member {boolean}
     * @private
     */
    this.eventsAdded = false;

    //this will make it so that you don't have to call bind all the time

    /**
     * @member {Function}
     */
    this.onMouseUp = this.onMouseUp.bind(this);
    this.processMouseUp = this.processMouseUp.bind( this );


    /**
     * @member {Function}
     */
    this.onMouseDown = this.onMouseDown.bind(this);
    this.processMouseDown = this.processMouseDown.bind( this );

    /**
     * @member {Function}
     */
    this.onMouseMove = this.onMouseMove.bind( this );
    this.processMouseMove = this.processMouseMove.bind( this );

    /**
     * @member {Function}
     */
    this.onMouseOut = this.onMouseOut.bind(this);
    this.processMouseOverOut = this.processMouseOverOut.bind( this );


    /**
     * @member {Function}
     */
    this.onTouchStart = this.onTouchStart.bind(this);
    this.processTouchStart = this.processTouchStart.bind(this);

    /**
     * @member {Function}
     */
    this.onTouchEnd = this.onTouchEnd.bind(this);
    this.processTouchEnd = this.processTouchEnd.bind(this);

    /**
     * @member {Function}
     */
    this.onTouchMove = this.onTouchMove.bind(this);
    this.processTouchMove = this.processTouchMove.bind(this);

    /**
     * @member {number}
     */
    this.last = 0;

    /**
     * The css style of the cursor that is being used
     * @member {string}
     */
    this.currentCursorStyle = 'inherit';

    /**
     * Internal cached var
     * @member {PIXI.Point}
     * @private
     */
    this._tempPoint = new core.Point();

    /**
     * The current resolution
     * @member {number}
     */
    this.resolution = 1;

    this.setTargetElement(this.renderer.view, this.renderer.resolution);
}

InteractionManager.prototype.constructor = InteractionManager;
module.exports = InteractionManager;

/**
 * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
 * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate
 * another DOM element to receive those events.
 *
 * @param element {HTMLElement} the DOM element which will receive mouse and touch events.
 * @param [resolution=1] {number} THe resolution of the new element (relative to the canvas).
 * @private
 */
InteractionManager.prototype.setTargetElement = function (element, resolution)
{
    this.removeEvents();

    this.interactionDOMElement = element;

    this.resolution = resolution || 1;

    this.addEvents();
};

/**
 * Registers all the DOM events
 *
 * @private
 */
InteractionManager.prototype.addEvents = function ()
{
    if (!this.interactionDOMElement)
    {
        return;
    }

    core.ticker.shared.add(this.update, this);

    if (window.navigator.msPointerEnabled)
    {
        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
        this.interactionDOMElement.style['-ms-touch-action'] = 'none';
    }

    window.document.addEventListener('mousemove',    this.onMouseMove, true);
    this.interactionDOMElement.addEventListener('mousedown',    this.onMouseDown, true);
    this.interactionDOMElement.addEventListener('mouseout',     this.onMouseOut, true);

    this.interactionDOMElement.addEventListener('touchstart',   this.onTouchStart, true);
    this.interactionDOMElement.addEventListener('touchend',     this.onTouchEnd, true);
    this.interactionDOMElement.addEventListener('touchmove',    this.onTouchMove, true);

    window.addEventListener('mouseup',  this.onMouseUp, true);

    this.eventsAdded = true;
};

/**
 * Removes all the DOM events that were previously registered
 *
 * @private
 */
InteractionManager.prototype.removeEvents = function ()
{
    if (!this.interactionDOMElement)
    {
        return;
    }

    core.ticker.shared.remove(this.update);

    if (window.navigator.msPointerEnabled)
    {
        this.interactionDOMElement.style['-ms-content-zooming'] = '';
        this.interactionDOMElement.style['-ms-touch-action'] = '';
    }

    window.document.removeEventListener('mousemove', this.onMouseMove, true);
    this.interactionDOMElement.removeEventListener('mousedown', this.onMouseDown, true);
    this.interactionDOMElement.removeEventListener('mouseout',  this.onMouseOut, true);

    this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);
    this.interactionDOMElement.removeEventListener('touchend',  this.onTouchEnd, true);
    this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);

    this.interactionDOMElement = null;

    window.removeEventListener('mouseup',  this.onMouseUp, true);

    this.eventsAdded = false;
};

/**
 * Updates the state of interactive objects.
 * Invoked by a throttled ticker update from
 * {@link PIXI.ticker.shared}.
 *
 * @param deltaTime {number}
 */
InteractionManager.prototype.update = function (deltaTime)
{
    this._deltaTime += deltaTime;

    if (this._deltaTime < this.interactionFrequency)
    {
        return;
    }

    this._deltaTime = 0;

    if (!this.interactionDOMElement)
    {
        return;
    }

    // if the user move the mouse this check has already been dfone using the mouse move!
    if(this.didMove)
    {
        this.didMove = false;
        return;
    }

    this.cursor = 'inherit';

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, true );

    if (this.currentCursorStyle !== this.cursor)
    {
        this.currentCursorStyle = this.cursor;
        this.interactionDOMElement.style.cursor = this.cursor;
    }

    //TODO
};

/**
 * Dispatches an event on the display object that was interacted with
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} the display object in question
 * @param eventString {string} the name of the event (e.g, mousedown)
 * @param eventData {object} the event data object
 * @private
 */
InteractionManager.prototype.dispatchEvent = function ( displayObject, eventString, eventData )
{
    if(!eventData.stopped)
    {
        eventData.target = displayObject;
        eventData.type = eventString;

        displayObject.emit( eventString, eventData );

        if( displayObject[eventString] )
        {
            displayObject[eventString]( eventData );
        }
    }
};

/**
 * Maps x and y coords from a DOM object and maps them correctly to the pixi view. The resulting value is stored in the point.
 * This takes into account the fact that the DOM element could be scaled and positioned anywhere on the screen.
 *
 * @param  {PIXI.Point} point the point that the result will be stored in
 * @param  {number} x     the x coord of the position to map
 * @param  {number} y     the y coord of the position to map
 */
InteractionManager.prototype.mapPositionToPoint = function ( point, x, y )
{
    var rect = this.interactionDOMElement.getBoundingClientRect();
    point.x = ( ( x - rect.left ) * (this.interactionDOMElement.width  / rect.width  ) ) / this.resolution;
    point.y = ( ( y - rect.top  ) * (this.interactionDOMElement.height / rect.height ) ) / this.resolution;
};

/**
 * This function is provides a neat way of crawling through the scene graph and running a specified function on all interactive objects it finds.
 * It will also take care of hit testing the interactive objects and passes the hit across in the function.
 *
 * @param  {PIXI.Point} point the point that is tested for collision
 * @param  {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject the displayObject that will be hit test (recurcsivly crawls its children)
 * @param  {Function} func the function that will be called on each interactive object. The displayObject and hit will be passed to the function
 * @param  {boolean} hitTest this indicates if the objects inside should be hit test against the point
 * @return {boolean} returns true if the displayObject hit the point
 */
InteractionManager.prototype.processInteractive = function (point, displayObject, func, hitTest, interactive)
{
    if(!displayObject || !displayObject.visible)
    {
        return false;
    }

    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^
    // 
    // This function will now loop through all objects and then only hit test the objects it HAS to, not all of them. MUCH faster..
    // An object will be hit test if the following is true:
    // 
    // 1: It is interactive.
    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.
    // 
    // As another little optimisation once an interactive object has been hit we can carry on through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests
    // A final optimisation is that an object is not hit test directly if a child has already been hit.
    
    var hit = false,
        interactiveParent = interactive = displayObject.interactive || interactive;

    // if the displayobject has a hitArea, then it does not need to hitTest children.
    if(displayObject.hitArea)
    {
        interactiveParent = false;
    }

    // ** FREE TIP **! If an object is not interacttive or has no buttons in it (such as a game scene!) set interactiveChildren to false for that displayObject.
    // This will allow pixi to completly ignore and bypass checking the displayObjects children.
    if(displayObject.interactiveChildren)
    {       
        var children = displayObject.children;
        
        for (var i = children.length-1; i >= 0; i--)
        {
            // time to get recursive.. if this function will return if somthing is hit..
            if( this.processInteractive(point, children[i], func, hitTest, interactiveParent) )
            {
                hit = true;

                // we no longer need to hit test any more objects in this container as we we now know the parent has been hit
                interactiveParent = false;
                
                // If the child is interactive , that means that the object hit was actually interactive and not just the child of an interactive object. 
                // This means we no longer need to hit test anything else. We still need to run through all objects, but we don't need to perform any hit tests.
                if(children[i].interactive)
                {
                    hitTest = false;
                }
            }
        }
    }

    // no point running this if the item is not interactive or does not have an interactive parent.
    if(interactive)
    {
        // if we are hit testing (as in we have no hit any objects yet)
        // We also don't need to worry about hit testing if once of the displayObjects children has already been hit!
        if(hitTest && !hit)
        {  
            if(displayObject.hitArea)
            {
                displayObject.worldTransform.applyInverse(point,  this._tempPoint);
                hit = displayObject.hitArea.contains( this._tempPoint.x, this._tempPoint.y );
            }
            else if(displayObject.containsPoint)
            {
                hit = displayObject.containsPoint(point);
            }
        }

        if(displayObject.interactive)
        {
            func(displayObject, hit); 
        }
    }

    return hit;
  
};


/**
 * Is called when the mouse button is pressed down on the renderer element
 *
 * @param event {Event} The DOM event of a mouse button being pressed down
 * @private
 */
InteractionManager.prototype.onMouseDown = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.data = this.mouse;
    this.eventData.stopped = false;

    // Update internal mouse reference
    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);

    if (this.autoPreventDefault)
    {
        this.mouse.originalEvent.preventDefault();
    }

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseDown, true );
};

/**
 * Processes the result of the mouse down check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the dispay object
 * @private
 */
InteractionManager.prototype.processMouseDown = function ( displayObject, hit )
{
    var e = this.mouse.originalEvent;
    
    var isRightButton = e.button === 2 || e.which === 3;

    if(hit)
    {
        displayObject[ isRightButton ? '_isRightDown' : '_isLeftDown' ] = true;
        this.dispatchEvent( displayObject, isRightButton ? 'rightdown' : 'mousedown', this.eventData );
    }
};



/**
 * Is called when the mouse button is released on the renderer element
 *
 * @param event {Event} The DOM event of a mouse button being released
 * @private
 */
InteractionManager.prototype.onMouseUp = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.data = this.mouse;
    this.eventData.stopped = false;

    // Update internal mouse reference
    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseUp, true );
};

/**
 * Processes the result of the mouse up check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processMouseUp = function ( displayObject, hit )
{
    var e = this.mouse.originalEvent;

    var isRightButton = e.button === 2 || e.which === 3;
    var isDown =  isRightButton ? '_isRightDown' : '_isLeftDown';

    if(hit)
    {
        this.dispatchEvent( displayObject, isRightButton ? 'rightup' : 'mouseup', this.eventData );

        if( displayObject[ isDown ] )
        {
            displayObject[ isDown ] = false;
            this.dispatchEvent( displayObject, isRightButton ? 'rightclick' : 'click', this.eventData );
        }
    }
    else
    {
        if( displayObject[ isDown ] )
        {
            displayObject[ isDown ] = false;
            this.dispatchEvent( displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', this.eventData );
        }
    }
};


/**
 * Is called when the mouse moves across the renderer element
 *
 * @param event {Event} The DOM event of the mouse moving
 * @private
 */
InteractionManager.prototype.onMouseMove = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.data = this.mouse;
    this.eventData.stopped = false;

    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);

    this.didMove = true;

    this.cursor = 'inherit';

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseMove, true );

    if (this.currentCursorStyle !== this.cursor)
    {
        this.currentCursorStyle = this.cursor;
        this.interactionDOMElement.style.cursor = this.cursor;
    }

    //TODO BUG for parents ineractive object (border order issue)
};

/**
 * Processes the result of the mouse move check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processMouseMove = function ( displayObject, hit )
{
    this.dispatchEvent( displayObject, 'mousemove', this.eventData);
    this.processMouseOverOut(displayObject, hit);
};


/**
 * Is called when the mouse is moved out of the renderer element
 *
 * @param event {Event} The DOM event of a mouse being moved out
 * @private
 */
InteractionManager.prototype.onMouseOut = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.stopped = false;

    // Update internal mouse reference
    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);

    this.interactionDOMElement.style.cursor = 'inherit';

    // TODO optimize by not check EVERY TIME! maybe half as often? //
    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY );

    this.processInteractive( this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, false );
};

/**
 * Processes the result of the mouse over/out check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processMouseOverOut = function ( displayObject, hit )
{
    if(hit)
    {
        if(!displayObject._over)
        {
            displayObject._over = true;
            this.dispatchEvent( displayObject, 'mouseover', this.eventData );
        }

        if (displayObject.buttonMode)
        {
            this.cursor = displayObject.defaultCursor;
        }
    }
    else
    {
        if(displayObject._over)
        {
            displayObject._over = false;
            this.dispatchEvent( displayObject, 'mouseout', this.eventData);
        }
    }
};


/**
 * Is called when a touch is started on the renderer element
 *
 * @param event {Event} The DOM event of a touch starting on the renderer view
 * @private
 */
InteractionManager.prototype.onTouchStart = function (event)
{
    if (this.autoPreventDefault)
    {
        event.preventDefault();
    }

    var changedTouches = event.changedTouches;
    var cLength = changedTouches.length;

    for (var i=0; i < cLength; i++)
    {
        var touchEvent = changedTouches[i];
        //TODO POOL
        var touchData = this.getTouchData( touchEvent );

        touchData.originalEvent = event;

        this.eventData.data = touchData;
        this.eventData.stopped = false;

        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchStart, true );

        this.returnTouchData( touchData );
    }
};

/**
 * Processes the result of a touch check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processTouchStart = function ( displayObject, hit )
{
    if(hit)
    {
        displayObject._touchDown = true;
        this.dispatchEvent( displayObject, 'touchstart', this.eventData );
    }
};


/**
 * Is called when a touch ends on the renderer element
 *
 * @param event {Event} The DOM event of a touch ending on the renderer view
 */
InteractionManager.prototype.onTouchEnd = function (event)
{
    if (this.autoPreventDefault)
    {
        event.preventDefault();
    }

    var changedTouches = event.changedTouches;
    var cLength = changedTouches.length;

    for (var i=0; i < cLength; i++)
    {
        var touchEvent = changedTouches[i];

        var touchData = this.getTouchData( touchEvent );

        touchData.originalEvent = event;

        //TODO this should be passed along.. no set
        this.eventData.data = touchData;
        this.eventData.stopped = false;


        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchEnd, true );

        this.returnTouchData( touchData );
    }
};

/**
 * Processes the result of the end of a touch and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processTouchEnd = function ( displayObject, hit )
{
    if(hit)
    {
        this.dispatchEvent( displayObject, 'touchend', this.eventData );

        if( displayObject._touchDown )
        {
            displayObject._touchDown = false;
            this.dispatchEvent( displayObject, 'tap', this.eventData );
        }
    }
    else
    {
        if( displayObject._touchDown )
        {
            displayObject._touchDown = false;
            this.dispatchEvent( displayObject, 'touchendoutside', this.eventData );
        }
    }
};

/**
 * Is called when a touch is moved across the renderer element
 *
 * @param event {Event} The DOM event of a touch moving across the renderer view
 * @private
 */
InteractionManager.prototype.onTouchMove = function (event)
{
    if (this.autoPreventDefault)
    {
        event.preventDefault();
    }

    var changedTouches = event.changedTouches;
    var cLength = changedTouches.length;

    for (var i=0; i < cLength; i++)
    {
        var touchEvent = changedTouches[i];

        var touchData = this.getTouchData( touchEvent );

        touchData.originalEvent = event;

        this.eventData.data = touchData;
        this.eventData.stopped = false;

        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchMove, true );

        this.returnTouchData( touchData );
    }
};

/**
 * Processes the result of a touch move check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processTouchMove = function ( displayObject, hit )
{
    hit = hit;
    this.dispatchEvent( displayObject, 'touchmove', this.eventData);
};

/**
 * Grabs an interaction data object from the internal pool
 *
 * @param touchEvent {EventData} The touch event we need to pair with an interactionData object
 *
 * @private
 */
InteractionManager.prototype.getTouchData = function (touchEvent)
{
    var touchData = this.interactiveDataPool.pop();

    if(!touchData)
    {
        touchData = new InteractionData();
    }

    touchData.identifier = touchEvent.identifier;
    this.mapPositionToPoint( touchData.global, touchEvent.clientX, touchEvent.clientY );

    if(navigator.isCocoonJS)
    {
        touchData.global.x = touchData.global.x / this.resolution;
        touchData.global.y = touchData.global.y / this.resolution;
    }

    touchEvent.globalX = touchData.global.x;
    touchEvent.globalY = touchData.global.y;

    return touchData;
};

/**
 * Returns an interaction data object to the internal pool
 *
 * @param touchData {PIXI.interaction.InteractionData} The touch data object we want to return to the pool
 *
 * @private
 */
InteractionManager.prototype.returnTouchData = function ( touchData )
{
    this.interactiveDataPool.push( touchData );
};

/**
 * Destroys the interaction manager
 *
 */
InteractionManager.prototype.destroy = function () {
    this.removeEvents();

    this.renderer = null;

    this.mouse = null;

    this.eventData = null;

    this.interactiveDataPool = null;

    this.interactionDOMElement = null;

    this.onMouseUp = null;
    this.processMouseUp = null;


    this.onMouseDown = null;
    this.processMouseDown = null;

    this.onMouseMove = null;
    this.processMouseMove = null;

    this.onMouseOut = null;
    this.processMouseOverOut = null;


    this.onTouchStart = null;
    this.processTouchStart = null;

    this.onTouchEnd = null;
    this.processTouchEnd = null;

    this.onTouchMove = null;
    this.processTouchMove = null;

    this._tempPoint = null;
};

core.WebGLRenderer.registerPlugin('interaction', InteractionManager);
core.CanvasRenderer.registerPlugin('interaction', InteractionManager);

},{"../core":30,"./InteractionData":116,"./interactiveTarget":119}],118:[function(require,module,exports){
/**
 * @file        Main export of the PIXI interactions library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.interaction
 */
module.exports = {
    InteractionData:    require('./InteractionData'),
    InteractionManager: require('./InteractionManager'),
    interactiveTarget:  require('./interactiveTarget')
};

},{"./InteractionData":116,"./InteractionManager":117,"./interactiveTarget":119}],119:[function(require,module,exports){
/**
 * Default property values of interactive objects
 * used by {@link PIXI.interaction.InteractionManager}.
 *
 * @mixin
 * @memberof PIXI.interaction
 * @example
 *      function MyObject() {}
 *
 *      Object.assign(
 *          MyObject.prototype,
 *          PIXI.interaction.interactiveTarget
 *      );
 */
var interactiveTarget = {
    /**
     * @todo Needs docs.
     */
    interactive: false,
    /**
     * @todo Needs docs.
     */
    buttonMode: false,
    /**
     * @todo Needs docs.
     */
    interactiveChildren: true,
    /**
     * @todo Needs docs.
     */
    defaultCursor: 'pointer',

    // some internal checks..

    /**
     * @todo Needs docs.
     * @private
     */
    _over: false,
    /**
     * @todo Needs docs.
     * @private
     */
    _touchDown: false
};

module.exports = interactiveTarget;

},{}],120:[function(require,module,exports){
var Resource = require('resource-loader').Resource,
    core = require('../core'),
    extras = require('../extras'),
    path = require('path');


function parse(resource, texture) {
    var data = {};
    var info = resource.data.getElementsByTagName('info')[0];
    var common = resource.data.getElementsByTagName('common')[0];

    data.font = info.getAttribute('face');
    data.size = parseInt(info.getAttribute('size'), 10);
    data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
    data.chars = {};

    //parse letters
    var letters = resource.data.getElementsByTagName('char');

    for (var i = 0; i < letters.length; i++)
    {
        var charCode = parseInt(letters[i].getAttribute('id'), 10);

        var textureRect = new core.Rectangle(
            parseInt(letters[i].getAttribute('x'), 10) + texture.frame.x,
            parseInt(letters[i].getAttribute('y'), 10) + texture.frame.y,
            parseInt(letters[i].getAttribute('width'), 10),
            parseInt(letters[i].getAttribute('height'), 10)
        );

        data.chars[charCode] = {
            xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),
            yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),
            xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),
            kerning: {},
            texture: new core.Texture(texture.baseTexture, textureRect)

        };
    }

    //parse kernings
    var kernings = resource.data.getElementsByTagName('kerning');
    for (i = 0; i < kernings.length; i++)
    {
        var first = parseInt(kernings[i].getAttribute('first'), 10);
        var second = parseInt(kernings[i].getAttribute('second'), 10);
        var amount = parseInt(kernings[i].getAttribute('amount'), 10);

        data.chars[second].kerning[first] = amount;
    }

    resource.bitmapFont = data;

    // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3
    // but it's very likely to change
    extras.BitmapText.fonts[data.font] = data;
}


module.exports = function ()
{
    return function (resource, next)
    {
        // skip if no data or not xml data
        if (!resource.data || !resource.isXml)
        {
            return next();
        }

        // skip if not bitmap font data, using some silly duck-typing
        if (
            resource.data.getElementsByTagName('page').length === 0 ||
            resource.data.getElementsByTagName('info').length === 0 ||
            resource.data.getElementsByTagName('info')[0].getAttribute('face') === null
            )
        {
            return next();
        }

        var xmlUrl = path.dirname(resource.url);

        if (xmlUrl === '.') {
            xmlUrl = '';
        }

        if (this.baseUrl && xmlUrl) {
            // if baseurl has a trailing slash then add one to xmlUrl so the replace works below
            if (this.baseUrl.charAt(this.baseUrl.length - 1) === '/') {
                xmlUrl += '/';
            }

            // remove baseUrl from xmlUrl
            xmlUrl = xmlUrl.replace(this.baseUrl, '');
        }

        // if there is an xmlUrl now, it needs a trailing slash. Ensure that it does if the string isn't empty.
        if (xmlUrl && xmlUrl.charAt(xmlUrl.length - 1) !== '/') {
            xmlUrl += '/';
        }
        var textureUrl = xmlUrl + resource.data.getElementsByTagName('page')[0].getAttribute('file');
        if (core.utils.TextureCache[textureUrl]) {
            //reuse existing texture
            parse(resource, core.utils.TextureCache[textureUrl]);
            next();
        }
        else {
            var loadOptions = {
                crossOrigin: resource.crossOrigin,
                loadType: Resource.LOAD_TYPE.IMAGE,
                metadata: resource.metadata.imageMetadata
            };
            // load the texture for the font
            this.add(resource.name + '_image', textureUrl, loadOptions, function (res) {
                parse(resource, res.texture);
                next();
            });
        }
    };
};

},{"../core":30,"../extras":86,"path":2,"resource-loader":16}],121:[function(require,module,exports){
/**
 * @file        Main export of the PIXI loaders library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.loaders
 */
module.exports = {
    Loader:             require('./loader'),

    // parsers
    bitmapFontParser:   require('./bitmapFontParser'),
    spritesheetParser:  require('./spritesheetParser'),
    textureParser:      require('./textureParser'),
    Resource:           require('resource-loader').Resource
};

},{"./bitmapFontParser":120,"./loader":122,"./spritesheetParser":123,"./textureParser":124,"resource-loader":16}],122:[function(require,module,exports){
var ResourceLoader = require('resource-loader'),
    textureParser = require('./textureParser'),
    spritesheetParser = require('./spritesheetParser'),
    bitmapFontParser = require('./bitmapFontParser');

/**
 *
 * The new loader, extends Resource Loader by Chad Engler : https://github.com/englercj/resource-loader
 *
 * ```js
 * var loader = PIXI.loader; // pixi exposes a premade instance for you to use.
 * //or
 * var loader = new PIXI.loaders.Loader(); // you can also create your own if you want
 *
 * loader.add('bunny',"data/bunny.png");
 *
 * loader.once('complete',onAssetsLoaded);
 *
 * loader.load();
 * ```
 *
 * @class
 * @extends PIXI.ResourceLoader
 * @memberof PIXI.loaders
 * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.
 * @param [concurrency=10] {number} The number of resources to load concurrently.
 */
function Loader(baseUrl, concurrency)
{
    ResourceLoader.call(this, baseUrl, concurrency);

    for (var i = 0; i < Loader._pixiMiddleware.length; ++i) {
        this.use(Loader._pixiMiddleware[i]());
    }
}

Loader.prototype = Object.create(ResourceLoader.prototype);
Loader.prototype.constructor = Loader;

module.exports = Loader;

Loader._pixiMiddleware = [
    // parse any blob into more usable objects (e.g. Image)
    ResourceLoader.middleware.parsing.blob,
    // parse any Image objects into textures
    textureParser,
    // parse any spritesheet data into multiple textures
    spritesheetParser,
    // parse any spritesheet data into multiple textures
    bitmapFontParser
];

Loader.addPixiMiddleware = function (fn) {
    Loader._pixiMiddleware.push(fn);
};

// Add custom extentions
var Resource = ResourceLoader.Resource;

Resource.setExtensionXhrType('fnt', Resource.XHR_RESPONSE_TYPE.DOCUMENT);

},{"./bitmapFontParser":120,"./spritesheetParser":123,"./textureParser":124,"resource-loader":16}],123:[function(require,module,exports){
var Resource = require('resource-loader').Resource,
    path = require('path'),
    core = require('../core');

module.exports = function ()
{
    return function (resource, next)
    {
        // skip if no data, its not json, or it isn't spritesheet data
        if (!resource.data || !resource.isJson || !resource.data.frames)
        {
            return next();
        }

        var loadOptions = {
            crossOrigin: resource.crossOrigin,
            loadType: Resource.LOAD_TYPE.IMAGE,
            metadata: resource.metadata.imageMetadata
        };

        var route = path.dirname(resource.url.replace(this.baseUrl, ''));

        var resolution = core.utils.getResolutionOfUrl( resource.url );

        // load the image for this sheet
        this.add(resource.name + '_image', route + '/' + resource.data.meta.image, loadOptions, function (res)
        {
            resource.textures = {};

            var frames = resource.data.frames;

            for (var i in frames)
            {
                var rect = frames[i].frame;

                if (rect)
                {
                    var size = null;
                    var trim = null;

                    if (frames[i].rotated) {
                        size = new core.Rectangle(rect.x, rect.y, rect.h, rect.w);
                    }
                    else {
                        size = new core.Rectangle(rect.x, rect.y, rect.w, rect.h);
                    }

                    //  Check to see if the sprite is trimmed
                    if (frames[i].trimmed)
                    {
                        trim = new core.Rectangle(
                            frames[i].spriteSourceSize.x / resolution,
                            frames[i].spriteSourceSize.y / resolution,
                            frames[i].sourceSize.w / resolution,
                            frames[i].sourceSize.h / resolution
                         );
                    }

                    // flip the width and height!
                    if (frames[i].rotated)
                    {
                        var temp = size.width;
                        size.width = size.height;
                        size.height = temp;
                    }

                    size.x /= resolution;
                    size.y /= resolution;
                    size.width /= resolution;
                    size.height /= resolution;

                    resource.textures[i] = new core.Texture(res.texture.baseTexture, size, size.clone(), trim, frames[i].rotated);

                    // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
                    core.utils.TextureCache[i] = resource.textures[i];
                }
            }

            next();
        });
    };
};

},{"../core":30,"path":2,"resource-loader":16}],124:[function(require,module,exports){
var core = require('../core');

module.exports = function ()
{
    return function (resource, next)
    {
        // create a new texture if the data is an Image object
        if (resource.data && resource.isImage)
        {
            var baseTexture = new core.BaseTexture(resource.data, null, core.utils.getResolutionOfUrl(resource.url));
            baseTexture.imageUrl = resource.url;
            resource.texture = new core.Texture(baseTexture);
            // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions
            core.utils.BaseTextureCache[resource.url] = baseTexture;
            core.utils.TextureCache[resource.url] = resource.texture;
        }

        next();
    };
};

},{"../core":30}],125:[function(require,module,exports){
var core = require('../core'),
    tempPoint = new core.Point(),
    tempPolygon = new core.Polygon();

/**
 * Base mesh class
 * @class
 * @extends PIXI.Container
 * @memberof PIXI.mesh
 * @param texture {PIXI.Texture} The texture to use
 * @param [vertices] {Float32Arrif you want to specify the vertices
 * @param [uvs] {Float32Array} if you want to specify the uvs
 * @param [indices] {Uint16Array} if you want to specify the indices
 * @param [drawMode] {number} the drawMode, can be any of the Mesh.DRAW_MODES consts
 */
function Mesh(texture, vertices, uvs, indices, drawMode)
{
    core.Container.call(this);

    /**
     * The texture of the Mesh
     *
     * @member {PIXI.Texture}
     * @private
     */
    this._texture = null;

    /**
     * The Uvs of the Mesh
     *
     * @member {Float32Array}
     */
    this.uvs = uvs || new Float32Array([0, 0,
        1, 0,
        1, 1,
        0, 1]);

    /**
     * An array of vertices
     *
     * @member {Float32Array}
     */
    this.vertices = vertices || new Float32Array([0, 0,
        100, 0,
        100, 100,
        0, 100]);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    //  TODO auto generate this based on draw mode!
    this.indices = indices || new Uint16Array([0, 1, 3, 2]);

    /**
     * Whether the Mesh is dirty or not
     *
     * @member {boolean}
     */
    this.dirty = true;

    /**
     * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove any blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    this.blendMode = core.BLEND_MODES.NORMAL;

    /**
     * Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.
     *
     * @member {number}
     */
    this.canvasPadding = 0;

    /**
     * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts
     *
     * @member {number}
     * @see PIXI.mesh.Mesh.DRAW_MODES
     */
    this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;

    // run texture setter;
    this.texture = texture;

     /**
     * The default shader that is used if a mesh doesn't have a more specific one.
     *
     * @member {PIXI.Shader}
     */
    this.shader = null;
}

// constructor
Mesh.prototype = Object.create(core.Container.prototype);
Mesh.prototype.constructor = Mesh;
module.exports = Mesh;

Object.defineProperties(Mesh.prototype, {
    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     * @memberof PIXI.mesh.Mesh#
     */
    texture: {
        get: function ()
        {
            return  this._texture;
        },
        set: function (value)
        {
            if (this._texture === value)
            {
                return;
            }

            this._texture = value;

            if (value)
            {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded)
                {
                    this._onTextureUpdate();
                }
                else
                {
                    value.once('update', this._onTextureUpdate, this);
                }
            }
        }
    }
});

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer} a reference to the WebGL renderer
 * @private
 */
Mesh.prototype._renderWebGL = function (renderer)
{
    renderer.setObjectRenderer(renderer.plugins.mesh);
    renderer.plugins.mesh.render(this);
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer}
 * @private
 */
Mesh.prototype._renderCanvas = function (renderer)
{
    var context = renderer.context;

    var transform = this.worldTransform;

    if (renderer.roundPixels)
    {
        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx | 0, transform.ty | 0);
    }
    else
    {
        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
    }

    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH)
    {
        this._renderCanvasTriangleMesh(context);
    }
    else
    {
        this._renderCanvasTriangles(context);
    }
};

/**
 * Draws the object in Triangle Mesh mode using canvas
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @private
 */
Mesh.prototype._renderCanvasTriangleMesh = function (context)
{
    // draw triangles!!
    var vertices = this.vertices;
    var uvs = this.uvs;

    var length = vertices.length / 2;
    // this.count++;

    for (var i = 0; i < length - 2; i++)
    {
        // draw some triangles!
        var index = i * 2;
        this._renderCanvasDrawTriangle(context, vertices, uvs, index, (index + 2), (index + 4));
    }
};

/**
 * Draws the object in triangle mode using canvas
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @private
 */
Mesh.prototype._renderCanvasTriangles = function (context)
{
    // draw triangles!!
    var vertices = this.vertices;
    var uvs = this.uvs;
    var indices = this.indices;

    var length = indices.length;
    // this.count++;

    for (var i = 0; i < length; i += 3)
    {
        // draw some triangles!
        var index0 = indices[i] * 2, index1 = indices[i + 1] * 2, index2 = indices[i + 2] * 2;
        this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);
    }
};

/**
 * Draws one of the triangles that form this Mesh
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @param vertices {Float32Array} a reference to the vertices of the Mesh
 * @param uvs {Float32Array} a reference to the uvs of the Mesh
 * @param index0 {number} the index of the first vertex
 * @param index1 {number} the index of the second vertex
 * @param index2 {number} the index of the third vertex
 * @private
 */
Mesh.prototype._renderCanvasDrawTriangle = function (context, vertices, uvs, index0, index1, index2)
{
    var textureSource = this._texture.baseTexture.source;
    var textureWidth = this._texture.baseTexture.width;
    var textureHeight = this._texture.baseTexture.height;

    var x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2];
    var y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1];

    var u0 = uvs[index0] * textureWidth, u1 = uvs[index1] * textureWidth, u2 = uvs[index2] * textureWidth;
    var v0 = uvs[index0 + 1] * textureHeight, v1 = uvs[index1 + 1] * textureHeight, v2 = uvs[index2 + 1] * textureHeight;

    if (this.canvasPadding > 0)
    {
        var paddingX = this.canvasPadding / this.worldTransform.a;
        var paddingY = this.canvasPadding / this.worldTransform.d;
        var centerX = (x0 + x1 + x2) / 3;
        var centerY = (y0 + y1 + y2) / 3;

        var normX = x0 - centerX;
        var normY = y0 - centerY;

        var dist = Math.sqrt(normX * normX + normY * normY);
        x0 = centerX + (normX / dist) * (dist + paddingX);
        y0 = centerY + (normY / dist) * (dist + paddingY);

        //

        normX = x1 - centerX;
        normY = y1 - centerY;

        dist = Math.sqrt(normX * normX + normY * normY);
        x1 = centerX + (normX / dist) * (dist + paddingX);
        y1 = centerY + (normY / dist) * (dist + paddingY);

        normX = x2 - centerX;
        normY = y2 - centerY;

        dist = Math.sqrt(normX * normX + normY * normY);
        x2 = centerX + (normX / dist) * (dist + paddingX);
        y2 = centerY + (normY / dist) * (dist + paddingY);
    }

    context.save();
    context.beginPath();


    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);

    context.closePath();

    context.clip();

    // Compute matrix transform
    var delta =  (u0 * v1)      + (v0 * u2)      + (u1 * v2)      - (v1 * u2)      - (v0 * u1)      - (u0 * v2);
    var deltaA = (x0 * v1)      + (v0 * x2)      + (x1 * v2)      - (v1 * x2)      - (v0 * x1)      - (x0 * v2);
    var deltaB = (u0 * x1)      + (x0 * u2)      + (u1 * x2)      - (x1 * u2)      - (x0 * u1)      - (u0 * x2);
    var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
    var deltaD = (y0 * v1)      + (v0 * y2)      + (y1 * v2)      - (v1 * y2)      - (v0 * y1)      - (y0 * v2);
    var deltaE = (u0 * y1)      + (y0 * u2)      + (u1 * y2)      - (y1 * u2)      - (y0 * u1)      - (u0 * y2);
    var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);

    context.transform(deltaA / delta, deltaD / delta,
        deltaB / delta, deltaE / delta,
        deltaC / delta, deltaF / delta);

    context.drawImage(textureSource, 0, 0);
    context.restore();
};



/**
 * Renders a flat Mesh
 *
 * @param Mesh {PIXI.mesh.Mesh} The Mesh to render
 * @private
 */
Mesh.prototype.renderMeshFlat = function (Mesh)
{
    var context = this.context;
    var vertices = Mesh.vertices;

    var length = vertices.length/2;
    // this.count++;

    context.beginPath();
    for (var i=1; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = vertices[index],   x1 = vertices[index+2], x2 = vertices[index+4];
        var y0 = vertices[index+1], y1 = vertices[index+3], y2 = vertices[index+5];

        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
    }

    context.fillStyle = '#FF0000';
    context.fill();
    context.closePath();
};

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @param event
 * @private
 */
Mesh.prototype._onTextureUpdate = function ()
{
    this.updateFrame = true;
};

/**
 * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {PIXI.Matrix} the transformation matrix of the sprite
 * @return {PIXI.Rectangle} the framing rectangle
 */
Mesh.prototype.getBounds = function (matrix)
{
    if (!this._currentBounds) {
        var worldTransform = matrix || this.worldTransform;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var maxX = -Infinity;
        var maxY = -Infinity;

        var minX = Infinity;
        var minY = Infinity;

        var vertices = this.vertices;
        for (var i = 0, n = vertices.length; i < n; i += 2) {
            var rawX = vertices[i], rawY = vertices[i + 1];
            var x = (a * rawX) + (c * rawY) + tx;
            var y = (d * rawY) + (b * rawX) + ty;

            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;

            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }

        if (minX === -Infinity || maxY === Infinity) {
            return core.Rectangle.EMPTY;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.width = maxX - minX;

        bounds.y = minY;
        bounds.height = maxY - minY;

        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

/**
 * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH
 *
 * @param point {PIXI.Point} the point to test
 * @return {boolean} the result of the test
 */
Mesh.prototype.containsPoint = function( point ) {
    if (!this.getBounds().contains(point.x, point.y)) {
        return false;
    }
    this.worldTransform.applyInverse(point,  tempPoint);

    var vertices = this.vertices;
    var points = tempPolygon.points;
    var i, len;

    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLES) {
        var indices = this.indices;
        len = this.indices.length;
        //TODO: inline this.
        for (i=0;i<len;i+=3) {
            var ind0 = indices[i]*2, ind1 = indices[i+1]*2, ind2 = indices[i+2]*2;
            points[0] = vertices[ind0];
            points[1] = vertices[ind0+1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1+1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2+1];
            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
                return true;
            }
        }
    } else {
        len = vertices.length;
        for (i=0;i<len;i+=6) {
            points[0] = vertices[i];
            points[1] = vertices[i+1];
            points[2] = vertices[i+2];
            points[3] = vertices[i+3];
            points[4] = vertices[i+4];
            points[5] = vertices[i+5];
            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
                return true;
            }
        }
    }
    return false;
};

/**
 * Different drawing buffer modes supported
 *
 * @static
 * @constant
 * @property {object} DRAW_MODES
 * @property {number} DRAW_MODES.TRIANGLE_MESH
 * @property {number} DRAW_MODES.TRIANGLES
 */
Mesh.DRAW_MODES = {
    TRIANGLE_MESH: 0,
    TRIANGLES: 1
};

},{"../core":30}],126:[function(require,module,exports){
var Mesh = require('./Mesh');

/**
 * The Plane allows you to draw a texture across several points and them manipulate these points
 *
 *```js
 * for (var i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * var Plane = new PIXI.Plane(PIXI.Texture.fromImage("snake.png"), points);
 *  ```
 *
 * @class
 * @extends PIXI.mesh.Mesh
 * @memberof PIXI.mesh
 * @param {PIXI.Texture} texture - The texture to use on the Plane.
 * @param {int} segmentsX - The number ox x segments
 * @param {int} segmentsY - The number of y segments
 *
 */
function Plane(texture, segmentsX, segmentsY)
{
    Mesh.call(this, texture);

    /**
     * Tracker for if the Plane is ready to be drawn. Needed because Mesh ctor can
     * call _onTextureUpdated which could call refresh too early.
     *
     * @member {boolean}
     * @private
     */
    this._ready = true;

    this.segmentsX =  segmentsX || 10;
    this.segmentsY = segmentsY || 10;

    this.drawMode = Mesh.DRAW_MODES.TRIANGLES;
    this.refresh();

}


// constructor
Plane.prototype = Object.create( Mesh.prototype );
Plane.prototype.constructor = Plane;
module.exports = Plane;

/**
 * Refreshes
 *
 */
Plane.prototype.refresh = function()
{
    var total = this.segmentsX * this.segmentsY;
    var verts = [];
    var colors = [];
    var uvs = [];
    var indices = [];
    var texture = this.texture;

  //  texture.width = 800 texture.width || 800;
 //   texture.height = 800//texture.height || 800;

    var segmentsXSub = this.segmentsX - 1;
    var segmentsYSub = this.segmentsY - 1;
    var i = 0;

    // TODO MAP UVS..
    var sizeX = texture.width / segmentsXSub;
    var sizeY = texture.height / segmentsYSub;

    for (i = 0; i < total; i++) {

        var x = (i % this.segmentsX);
        var y = ( (i / this.segmentsX ) | 0 );


        verts.push((x * sizeX),
                   (y * sizeY));

        uvs.push(x / (this.segmentsX-1), y/ (this.segmentsY-1));
    }

    //  cons

    var totalSub = segmentsXSub * segmentsYSub;

    for (i = 0; i < totalSub; i++) {

        var xpos = i % segmentsXSub;
        var ypos = (i / segmentsXSub ) | 0;


        var  value = (ypos * this.segmentsX) + xpos;
        var  value2 = (ypos * this.segmentsX) + xpos + 1;
        var  value3 = ((ypos+1) * this.segmentsX) + xpos;
        var  value4 = ((ypos+1) * this.segmentsX) + xpos + 1;

        indices.push(value, value2, value3);
        indices.push(value2, value4, value3);
    }


    //console.log(indices)
    this.vertices = new Float32Array(verts);
    this.uvs = new Float32Array(uvs);
    this.colors = new Float32Array(colors);
    this.indices = new Uint16Array(indices);
};

/**
 * Clear texture UVs when new texture is set
 *
 * @private
 */
Plane.prototype._onTextureUpdate = function ()
{
    Mesh.prototype._onTextureUpdate.call(this);

    // wait for the Plane ctor to finish before calling refresh
    if (this._ready) {
        this.refresh();
    }
};

},{"./Mesh":125}],127:[function(require,module,exports){
var Mesh = require('./Mesh');
var core = require('../core');

/**
 * The rope allows you to draw a texture across several points and them manipulate these points
 *
 *```js
 * for (var i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * var rope = new PIXI.Rope(PIXI.Texture.fromImage("snake.png"), points);
 *  ```
 *
 * @class
 * @extends PIXI.mesh.Mesh
 * @memberof PIXI.mesh
 * @param {PIXI.Texture} texture - The texture to use on the rope.
 * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.
 *
 */
function Rope(texture, points)
{
    Mesh.call(this, texture);

    /*
     * @member {PIXI.Point[]} An array of points that determine the rope
     */
    this.points = points;

    /*
     * @member {Float32Array} An array of vertices used to construct this rope.
     */
    this.vertices = new Float32Array(points.length * 4);

    /*
     * @member {Float32Array} The WebGL Uvs of the rope.
     */
    this.uvs = new Float32Array(points.length * 4);

    /*
     * @member {Float32Array} An array containing the color components
     */
    this.colors = new Float32Array(points.length * 2);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    this.indices = new Uint16Array(points.length * 2);

    /**
     * Tracker for if the rope is ready to be drawn. Needed because Mesh ctor can
     * call _onTextureUpdated which could call refresh too early.
     *
     * @member {boolean}
     * @private
     */
     this._ready = true;

     this.refresh();
}


// constructor
Rope.prototype = Object.create(Mesh.prototype);
Rope.prototype.constructor = Rope;
module.exports = Rope;

/**
 * Refreshes
 *
 */
Rope.prototype.refresh = function ()
{
    var points = this.points;

    // if too little points, or texture hasn't got UVs set yet just move on.
    if (points.length < 1 || !this._texture._uvs)
    {
        return;
    }

    var uvs = this.uvs;

    var indices = this.indices;
    var colors = this.colors;

    var textureUvs = this._texture._uvs;
    var offset = new core.Point(textureUvs.x0, textureUvs.y0);
    var factor = new core.Point(textureUvs.x2 - textureUvs.x0, textureUvs.y2 - textureUvs.y0);

    uvs[0] = 0 + offset.x;
    uvs[1] = 0 + offset.y;
    uvs[2] = 0 + offset.x;
    uvs[3] = 1 * factor.y + offset.y;

    colors[0] = 1;
    colors[1] = 1;

    indices[0] = 0;
    indices[1] = 1;

    var total = points.length,
        point, index, amount;

    for (var i = 1; i < total; i++)
    {
        point = points[i];
        index = i * 4;
        // time to do some smart drawing!
        amount = i / (total-1);

        uvs[index] = amount * factor.x + offset.x;
        uvs[index+1] = 0 + offset.y;

        uvs[index+2] = amount * factor.x + offset.x;
        uvs[index+3] = 1 * factor.y + offset.y;

        index = i * 2;
        colors[index] = 1;
        colors[index+1] = 1;

        index = i * 2;
        indices[index] = index;
        indices[index + 1] = index + 1;
    }

    this.dirty = true;
};

/**
 * Clear texture UVs when new texture is set
 *
 * @private
 */
Rope.prototype._onTextureUpdate = function ()
{
    Mesh.prototype._onTextureUpdate.call(this);

    // wait for the Rope ctor to finish before calling refresh
    if (this._ready) {
        this.refresh();
    }
};

/**
 * Updates the object transform for rendering
 *
 * @private
 */
Rope.prototype.updateTransform = function ()
{
    var points = this.points;

    if (points.length < 1)
    {
        return;
    }

    var lastPoint = points[0];
    var nextPoint;
    var perpX = 0;
    var perpY = 0;

    // this.count -= 0.2;

    var vertices = this.vertices;
    var total = points.length,
        point, index, ratio, perpLength, num;

    for (var i = 0; i < total; i++)
    {
        point = points[i];
        index = i * 4;

        if (i < points.length-1)
        {
            nextPoint = points[i+1];
        }
        else
        {
            nextPoint = point;
        }

        perpY = -(nextPoint.x - lastPoint.x);
        perpX = nextPoint.y - lastPoint.y;

        ratio = (1 - (i / (total-1))) * 10;

        if (ratio > 1)
        {
            ratio = 1;
        }

        perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        num = this._texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
        perpX /= perpLength;
        perpY /= perpLength;

        perpX *= num;
        perpY *= num;

        vertices[index] = point.x + perpX;
        vertices[index+1] = point.y + perpY;
        vertices[index+2] = point.x - perpX;
        vertices[index+3] = point.y - perpY;

        lastPoint = point;
    }

    this.containerUpdateTransform();
};

},{"../core":30,"./Mesh":125}],128:[function(require,module,exports){
/**
 * @file        Main export of the PIXI extras library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.mesh
 */
module.exports = {
    Mesh:           require('./Mesh'),
    Plane:           require('./Plane'),
    Rope:           require('./Rope'),
    MeshRenderer:   require('./webgl/MeshRenderer'),
    MeshShader:     require('./webgl/MeshShader')
};

},{"./Mesh":125,"./Plane":126,"./Rope":127,"./webgl/MeshRenderer":129,"./webgl/MeshShader":130}],129:[function(require,module,exports){
var core = require('../../core'),
    Mesh = require('../Mesh');

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's MeshRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/MeshRenderer.java
 */

/**
 *
 * @class
 * @private
 * @memberof PIXI.mesh
 * @extends PIXI.ObjectRenderer
 * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.
 */
function MeshRenderer(renderer)
{
    core.ObjectRenderer.call(this, renderer);


    /**
     * Holds the indices
     *
     * @member {Uint16Array}
     */
    
    this.indices = new Uint16Array(15000);

    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers
    for (var i=0, j=0; i < 15000; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    this.currentShader = null;
}

MeshRenderer.prototype = Object.create(core.ObjectRenderer.prototype);
MeshRenderer.prototype.constructor = MeshRenderer;
module.exports = MeshRenderer;

core.WebGLRenderer.registerPlugin('mesh', MeshRenderer);

/**
 * Sets up the renderer context and necessary buffers.
 *
 * @private
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 */
MeshRenderer.prototype.onContextChange = function ()
{

};

/**
 * Renders the sprite object.
 *
 * @param mesh {PIXI.mesh.Mesh} the mesh to render
 */
MeshRenderer.prototype.render = function (mesh)
{
    if(!mesh._vertexBuffer)
    {
        this._initWebGL(mesh);
    }

    var renderer = this.renderer,
        gl = renderer.gl,
        texture = mesh._texture.baseTexture,
        shader = mesh.shader;// || renderer.shaderManager.plugins.meshShader;

    var drawMode = mesh.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;

    renderer.blendModeManager.setBlendMode(mesh.blendMode);

    //TODO cache custom state..
    if (!shader)
    {
        shader = renderer.shaderManager.plugins.meshShader;
    }
    else
    {
        shader = shader.shaders[gl.id] || shader.getShader(renderer);// : shader;
    }

    this.renderer.shaderManager.setShader(shader);

    shader.uniforms.translationMatrix.value = mesh.worldTransform.toArray(true);
    shader.uniforms.projectionMatrix.value = renderer.currentRenderTarget.projectionMatrix.toArray(true);
    shader.uniforms.alpha.value = mesh.worldAlpha;

    shader.syncUniforms();

    if (!mesh.dirty)
    {

        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, mesh.vertices);
        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);

        // update the uvs
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
        gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);


        gl.activeTexture(gl.TEXTURE0);

       if (!texture._glTextures[gl.id])
        {
            this.renderer.updateTexture(texture);
        }
        else
        {
            // bind the current texture
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, mesh.indices);
    }
    else
    {

        mesh.dirty = false;
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);
        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);

        // update the uvs
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.uvs, gl.STATIC_DRAW);
        gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);

         gl.activeTexture(gl.TEXTURE0);

        if (!texture._glTextures[gl.id])
        {
            this.renderer.updateTexture(texture);
        }
        else
        {
            // bind the current texture
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        }

        // dont need to upload!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);

    }

    gl.drawElements(drawMode, mesh.indices.length, gl.UNSIGNED_SHORT, 0);

};

/**
 * Prepares all the buffers to render this mesh
 * @param mesh {PIXI.mesh.Mesh} the mesh to render
 */
MeshRenderer.prototype._initWebGL = function (mesh)
{
    // build the strip!
    var gl = this.renderer.gl;

    mesh._vertexBuffer = gl.createBuffer();
    mesh._indexBuffer = gl.createBuffer();
    mesh._uvBuffer = gl.createBuffer();



    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
    gl.bufferData(gl.ARRAY_BUFFER,  mesh.uvs, gl.STATIC_DRAW);

    if(mesh.colors){
        mesh._colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.colors, gl.STATIC_DRAW);
    }

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);
};


/**
 * Empties the current batch.
 *
 */
MeshRenderer.prototype.flush = function ()
{

};

/**
 * Starts a new mesh renderer.
 *
 */
MeshRenderer.prototype.start = function ()
{
    

    this.currentShader = null;
};

/**
 * Destroys the Mesh renderer
 *
 */
MeshRenderer.prototype.destroy = function ()
{
    core.ObjectRenderer.prototype.destroy.call(this);
};

},{"../../core":30,"../Mesh":125}],130:[function(require,module,exports){
var core = require('../../core');

/**
 * @class
 * @extends PIXI.Shader
 * @memberof PIXI.mesh
 * @param shaderManager {PIXI.ShaderManager} The WebGL shader manager this shader works for.
 */
function MeshShader(shaderManager)
{
    core.Shader.call(this,
        shaderManager,
        // vertex shader
        [
            'precision lowp float;',
            'attribute vec2 aVertexPosition;',
            'attribute vec2 aTextureCoord;',

            'uniform mat3 translationMatrix;',
            'uniform mat3 projectionMatrix;',

            'varying vec2 vTextureCoord;',

            'void main(void){',
            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
            '   vTextureCoord = aTextureCoord;',
            '}'
        ].join('\n'),
        [
            'precision lowp float;',

            'varying vec2 vTextureCoord;',
            'uniform float alpha;',

            'uniform sampler2D uSampler;',

            'void main(void){',
            '   gl_FragColor = texture2D(uSampler, vTextureCoord) * alpha ;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            alpha:  { type: '1f', value: 0 },
            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
        },
        // custom attributes
        {
            aVertexPosition:0,
            aTextureCoord:0
        }
    );
}

MeshShader.prototype = Object.create(core.Shader.prototype);
MeshShader.prototype.constructor = MeshShader;
module.exports = MeshShader;

core.ShaderManager.registerPlugin('meshShader', MeshShader);

},{"../../core":30}],131:[function(require,module,exports){
// References:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

if (!Math.sign)
{
    Math.sign = function (x) {
        x = +x;
        if (x === 0 || isNaN(x))
        {
            return x;
        }
        return x > 0 ? 1 : -1;
    };
}

},{}],132:[function(require,module,exports){
// References:
// https://github.com/sindresorhus/object-assign
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

if (!Object.assign)
{
    Object.assign = require('object-assign');
}

},{"object-assign":11}],133:[function(require,module,exports){
require('./Object.assign');
require('./requestAnimationFrame');
require('./Math.sign');

},{"./Math.sign":131,"./Object.assign":132,"./requestAnimationFrame":134}],134:[function(require,module,exports){
(function (global){
// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();
    if (!global.performance) {
        global.performance = {};
    }
    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
        global[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now(),
            delay = 16 + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[115])(115)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvbGliL2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZXNvdXJjZS1sb2FkZXIvbm9kZV9tb2R1bGVzL2FzeW5jL2xpYi9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9yZXNvdXJjZS1sb2FkZXIvc3JjL0xvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZXNvdXJjZS1sb2FkZXIvc3JjL1Jlc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc291cmNlLWxvYWRlci9zcmMvYjY0LmpzIiwibm9kZV9tb2R1bGVzL3Jlc291cmNlLWxvYWRlci9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVzb3VyY2UtbG9hZGVyL3NyYy9taWRkbGV3YXJlcy9jYWNoaW5nL21lbW9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZXNvdXJjZS1sb2FkZXIvc3JjL21pZGRsZXdhcmVzL3BhcnNpbmcvYmxvYi5qcyIsInBhY2thZ2UuanNvbiIsInNyYy9hY2Nlc3NpYmlsaXR5L0FjY2Vzc2liaWxpdHlNYW5hZ2VyLmpzIiwic3JjL2FjY2Vzc2liaWxpdHkvYWNjZXNzaWJsZVRhcmdldC5qcyIsInNyYy9hY2Nlc3NpYmlsaXR5L2luZGV4LmpzIiwic3JjL2NvcmUvY29uc3QuanMiLCJzcmMvY29yZS9kaXNwbGF5L0NvbnRhaW5lci5qcyIsInNyYy9jb3JlL2Rpc3BsYXkvRGlzcGxheU9iamVjdC5qcyIsInNyYy9jb3JlL2dyYXBoaWNzL0dyYXBoaWNzLmpzIiwic3JjL2NvcmUvZ3JhcGhpY3MvR3JhcGhpY3NEYXRhLmpzIiwic3JjL2NvcmUvZ3JhcGhpY3Mvd2ViZ2wvR3JhcGhpY3NSZW5kZXJlci5qcyIsInNyYy9jb3JlL2dyYXBoaWNzL3dlYmdsL1dlYkdMR3JhcGhpY3NEYXRhLmpzIiwic3JjL2NvcmUvaW5kZXguanMiLCJzcmMvY29yZS9tYXRoL01hdHJpeC5qcyIsInNyYy9jb3JlL21hdGgvUG9pbnQuanMiLCJzcmMvY29yZS9tYXRoL2luZGV4LmpzIiwic3JjL2NvcmUvbWF0aC9zaGFwZXMvQ2lyY2xlLmpzIiwic3JjL2NvcmUvbWF0aC9zaGFwZXMvRWxsaXBzZS5qcyIsInNyYy9jb3JlL21hdGgvc2hhcGVzL1BvbHlnb24uanMiLCJzcmMvY29yZS9tYXRoL3NoYXBlcy9SZWN0YW5nbGUuanMiLCJzcmMvY29yZS9tYXRoL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLmpzIiwic3JjL2NvcmUvcGFydGljbGVzL1BhcnRpY2xlQ29udGFpbmVyLmpzIiwic3JjL2NvcmUvcGFydGljbGVzL3dlYmdsL1BhcnRpY2xlQnVmZmVyLmpzIiwic3JjL2NvcmUvcGFydGljbGVzL3dlYmdsL1BhcnRpY2xlUmVuZGVyZXIuanMiLCJzcmMvY29yZS9wYXJ0aWNsZXMvd2ViZ2wvUGFydGljbGVTaGFkZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvU3lzdGVtUmVuZGVyZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvY2FudmFzL0NhbnZhc1JlbmRlcmVyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNCdWZmZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0dyYXBoaWNzLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNNYXNrTWFuYWdlci5qcyIsInNyYy9jb3JlL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvQ2FudmFzVGludGVyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvZmlsdGVycy9BYnN0cmFjdEZpbHRlci5qcyIsInNyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL0ZYQUFGaWx0ZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvZmlsdGVycy9TcHJpdGVNYXNrRmlsdGVyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL0JsZW5kTW9kZU1hbmFnZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvRmlsdGVyTWFuYWdlci5qcyIsInNyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9NYXNrTWFuYWdlci5qcyIsInNyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9TaGFkZXJNYW5hZ2VyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL1N0ZW5jaWxNYW5hZ2VyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL1dlYkdMTWFuYWdlci5qcyIsInNyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9zaGFkZXJzL0NvbXBsZXhQcmltaXRpdmVTaGFkZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvc2hhZGVycy9QcmltaXRpdmVTaGFkZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvc2hhZGVycy9TaGFkZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvc2hhZGVycy9UZXh0dXJlU2hhZGVyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL09iamVjdFJlbmRlcmVyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1F1YWQuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvUmVuZGVyVGFyZ2V0LmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1N0ZW5jaWxNYXNrU3RhY2suanMiLCJzcmMvY29yZS9zcHJpdGVzL1Nwcml0ZS5qcyIsInNyYy9jb3JlL3Nwcml0ZXMvd2ViZ2wvU3ByaXRlUmVuZGVyZXIuanMiLCJzcmMvY29yZS90ZXh0L1RleHQuanMiLCJzcmMvY29yZS90ZXh0dXJlcy9CYXNlVGV4dHVyZS5qcyIsInNyYy9jb3JlL3RleHR1cmVzL1JlbmRlclRleHR1cmUuanMiLCJzcmMvY29yZS90ZXh0dXJlcy9UZXh0dXJlLmpzIiwic3JjL2NvcmUvdGV4dHVyZXMvVGV4dHVyZVV2cy5qcyIsInNyYy9jb3JlL3RleHR1cmVzL1ZpZGVvQmFzZVRleHR1cmUuanMiLCJzcmMvY29yZS90aWNrZXIvVGlja2VyLmpzIiwic3JjL2NvcmUvdGlja2VyL2luZGV4LmpzIiwic3JjL2NvcmUvdXRpbHMvaW5kZXguanMiLCJzcmMvY29yZS91dGlscy9wbHVnaW5UYXJnZXQuanMiLCJzcmMvZGVwcmVjYXRpb24uanMiLCJzcmMvZXh0cmFzL0JpdG1hcFRleHQuanMiLCJzcmMvZXh0cmFzL01vdmllQ2xpcC5qcyIsInNyYy9leHRyYXMvVGlsaW5nU3ByaXRlLmpzIiwic3JjL2V4dHJhcy9jYWNoZUFzQml0bWFwLmpzIiwic3JjL2V4dHJhcy9nZXRDaGlsZEJ5TmFtZS5qcyIsInNyYy9leHRyYXMvZ2V0R2xvYmFsUG9zaXRpb24uanMiLCJzcmMvZXh0cmFzL2luZGV4LmpzIiwic3JjL2ZpbHRlcnMvYXNjaWkvQXNjaWlGaWx0ZXIuanMiLCJzcmMvZmlsdGVycy9ibG9vbS9CbG9vbUZpbHRlci5qcyIsInNyYy9maWx0ZXJzL2JsdXIvQmx1ckRpckZpbHRlci5qcyIsInNyYy9maWx0ZXJzL2JsdXIvQmx1ckZpbHRlci5qcyIsInNyYy9maWx0ZXJzL2JsdXIvQmx1clhGaWx0ZXIuanMiLCJzcmMvZmlsdGVycy9ibHVyL0JsdXJZRmlsdGVyLmpzIiwic3JjL2ZpbHRlcnMvYmx1ci9TbWFydEJsdXJGaWx0ZXIuanMiLCJzcmMvZmlsdGVycy9jb2xvci9Db2xvck1hdHJpeEZpbHRlci5qcyIsInNyYy9maWx0ZXJzL2NvbG9yL0NvbG9yU3RlcEZpbHRlci5qcyIsInNyYy9maWx0ZXJzL2NvbnZvbHV0aW9uL0NvbnZvbHV0aW9uRmlsdGVyLmpzIiwic3JjL2ZpbHRlcnMvY3Jvc3NoYXRjaC9Dcm9zc0hhdGNoRmlsdGVyLmpzIiwic3JjL2ZpbHRlcnMvZGlzcGxhY2VtZW50L0Rpc3BsYWNlbWVudEZpbHRlci5qcyIsInNyYy9maWx0ZXJzL2RvdC9Eb3RTY3JlZW5GaWx0ZXIuanMiLCJzcmMvZmlsdGVycy9kcm9wc2hhZG93L0JsdXJZVGludEZpbHRlci5qcyIsInNyYy9maWx0ZXJzL2Ryb3BzaGFkb3cvRHJvcFNoYWRvd0ZpbHRlci5qcyIsInNyYy9maWx0ZXJzL2dyYXkvR3JheUZpbHRlci5qcyIsInNyYy9maWx0ZXJzL2luZGV4LmpzIiwic3JjL2ZpbHRlcnMvaW52ZXJ0L0ludmVydEZpbHRlci5qcyIsInNyYy9maWx0ZXJzL25vaXNlL05vaXNlRmlsdGVyLmpzIiwic3JjL2ZpbHRlcnMvcGl4ZWxhdGUvUGl4ZWxhdGVGaWx0ZXIuanMiLCJzcmMvZmlsdGVycy9yZ2IvUkdCU3BsaXRGaWx0ZXIuanMiLCJzcmMvZmlsdGVycy9zZXBpYS9TZXBpYUZpbHRlci5qcyIsInNyYy9maWx0ZXJzL3Nob2Nrd2F2ZS9TaG9ja3dhdmVGaWx0ZXIuanMiLCJzcmMvZmlsdGVycy90aWx0c2hpZnQvVGlsdFNoaWZ0QXhpc0ZpbHRlci5qcyIsInNyYy9maWx0ZXJzL3RpbHRzaGlmdC9UaWx0U2hpZnRGaWx0ZXIuanMiLCJzcmMvZmlsdGVycy90aWx0c2hpZnQvVGlsdFNoaWZ0WEZpbHRlci5qcyIsInNyYy9maWx0ZXJzL3RpbHRzaGlmdC9UaWx0U2hpZnRZRmlsdGVyLmpzIiwic3JjL2ZpbHRlcnMvdHdpc3QvVHdpc3RGaWx0ZXIuanMiLCJzcmNcXHNyY1xcaW5kZXguanMiLCJzcmMvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb25EYXRhLmpzIiwic3JjL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uTWFuYWdlci5qcyIsInNyYy9pbnRlcmFjdGlvbi9pbmRleC5qcyIsInNyYy9pbnRlcmFjdGlvbi9pbnRlcmFjdGl2ZVRhcmdldC5qcyIsInNyYy9sb2FkZXJzL2JpdG1hcEZvbnRQYXJzZXIuanMiLCJzcmMvbG9hZGVycy9pbmRleC5qcyIsInNyYy9sb2FkZXJzL2xvYWRlci5qcyIsInNyYy9sb2FkZXJzL3Nwcml0ZXNoZWV0UGFyc2VyLmpzIiwic3JjL2xvYWRlcnMvdGV4dHVyZVBhcnNlci5qcyIsInNyYy9tZXNoL01lc2guanMiLCJzcmMvbWVzaC9QbGFuZS5qcyIsInNyYy9tZXNoL1JvcGUuanMiLCJzcmMvbWVzaC9pbmRleC5qcyIsInNyYy9tZXNoL3dlYmdsL01lc2hSZW5kZXJlci5qcyIsInNyYy9tZXNoL3dlYmdsL01lc2hTaGFkZXIuanMiLCJzcmMvcG9seWZpbGwvTWF0aC5zaWduLmpzIiwic3JjL3BvbHlmaWxsL09iamVjdC5hc3NpZ24uanMiLCJzcmMvcG9seWZpbGwvaW5kZXguanMiLCJzcmMvcG9seWZpbGwvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNubUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaHlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25uQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qIVxuICogYXN5bmNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYW9sYW4vYXN5bmNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMC0yMDE0IENhb2xhbiBNY01haG9uXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBhc3luYyA9IHt9O1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHYpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvQm9vbCh2KSB7XG4gICAgICAgIHJldHVybiAhIXY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vdElkKHYpIHtcbiAgICAgICAgcmV0dXJuICF2O1xuICAgIH1cblxuICAgIC8vIGdsb2JhbCBvbiB0aGUgc2VydmVyLCB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcbiAgICB2YXIgcHJldmlvdXNfYXN5bmM7XG5cbiAgICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCAoYHNlbGZgKSBpbiB0aGUgYnJvd3NlciwgYGdsb2JhbGBcbiAgICAvLyBvbiB0aGUgc2VydmVyLCBvciBgdGhpc2AgaW4gc29tZSB2aXJ0dWFsIG1hY2hpbmVzLiBXZSB1c2UgYHNlbGZgXG4gICAgLy8gaW5zdGVhZCBvZiBgd2luZG93YCBmb3IgYFdlYldvcmtlcmAgc3VwcG9ydC5cbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZiB8fFxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCB8fFxuICAgICAgICAgICAgdGhpcztcblxuICAgIGlmIChyb290ICE9IG51bGwpIHtcbiAgICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xuICAgIH1cblxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBwcmV2aW91c19hc3luYztcbiAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbmx5X29uY2UoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGZuID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb25jZShmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZm4gPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8vLyBjcm9zcy1icm93c2VyIGNvbXBhdGlibGl0eSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgdmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICB2YXIgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuICAgIC8vIFBvcnRlZCBmcm9tIHVuZGVyc2NvcmUuanMgaXNPYmplY3RcbiAgICB2YXIgX2lzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9pc0FycmF5TGlrZShhcnIpIHtcbiAgICAgICAgcmV0dXJuIF9pc0FycmF5KGFycikgfHwgKFxuICAgICAgICAgICAgLy8gaGFzIGEgcG9zaXRpdmUgaW50ZWdlciBsZW5ndGggcHJvcGVydHlcbiAgICAgICAgICAgIHR5cGVvZiBhcnIubGVuZ3RoID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICBhcnIubGVuZ3RoID49IDAgJiZcbiAgICAgICAgICAgIGFyci5sZW5ndGggJSAxID09PSAwXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FycmF5RWFjaChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2luZGV4XSwgaW5kZXgsIGFycik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfbWFwKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdG9yKGFycltpbmRleF0sIGluZGV4LCBhcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JhbmdlKGNvdW50KSB7XG4gICAgICAgIHJldHVybiBfbWFwKEFycmF5KGNvdW50KSwgZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIGk7IH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWR1Y2UoYXJyLCBpdGVyYXRvciwgbWVtbykge1xuICAgICAgICBfYXJyYXlFYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIG1lbW8gPSBpdGVyYXRvcihtZW1vLCB4LCBpLCBhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mb3JFYWNoT2Yob2JqZWN0LCBpdGVyYXRvcikge1xuICAgICAgICBfYXJyYXlFYWNoKF9rZXlzKG9iamVjdCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrZXldLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5kZXhPZihhcnIsIGl0ZW0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgX2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfa2V5SXRlcmF0b3IoY29sbCkge1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIga2V5cztcbiAgICAgICAgaWYgKF9pc0FycmF5TGlrZShjb2xsKSkge1xuICAgICAgICAgICAgbGVuID0gY29sbC5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyBpIDogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXlzID0gX2tleXMoY29sbCk7XG4gICAgICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGxlbiA/IGtleXNbaV0gOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNpbWlsYXIgdG8gRVM2J3MgcmVzdCBwYXJhbSAoaHR0cDovL2FyaXlhLm9maWxhYnMuY29tLzIwMTMvMDMvZXM2LWFuZC1yZXN0LXBhcmFtZXRlci5odG1sKVxuICAgIC8vIFRoaXMgYWNjdW11bGF0ZXMgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byBhbiBhcnJheSwgYWZ0ZXIgYSBnaXZlbiBpbmRleC5cbiAgICAvLyBGcm9tIHVuZGVyc2NvcmUuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzIxNDApLlxuICAgIGZ1bmN0aW9uIF9yZXN0UGFyYW0oZnVuYywgc3RhcnRJbmRleCkge1xuICAgICAgICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCA9PSBudWxsID8gZnVuYy5sZW5ndGggLSAxIDogK3N0YXJ0SW5kZXg7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChhcmd1bWVudHMubGVuZ3RoIC0gc3RhcnRJbmRleCwgMCk7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXggKyBzdGFydEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCByZXN0KTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCByZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSB1bnVzZWQgYnV0IGhhbmRsZSBjYXNlcyBvdXRzaWRlIG9mIHRoZSBzd2l0Y2ggc3RhdGVtZW50OlxuICAgICAgICAgICAgLy8gdmFyIGFyZ3MgPSBBcnJheShzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgICAvLyBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBzdGFydEluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gYXJnc1tzdGFydEluZGV4XSA9IHJlc3Q7XG4gICAgICAgICAgICAvLyByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfd2l0aG91dEluZGV4KGl0ZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yKHZhbHVlLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8vLyBleHBvcnRlZCBhc3luYyBtb2R1bGUgZnVuY3Rpb25zIC8vLy9cblxuICAgIC8vLy8gbmV4dFRpY2sgaW1wbGVtZW50YXRpb24gd2l0aCBicm93c2VyLWNvbXBhdGlibGUgZmFsbGJhY2sgLy8vL1xuXG4gICAgLy8gY2FwdHVyZSB0aGUgZ2xvYmFsIHJlZmVyZW5jZSB0byBndWFyZCBhZ2FpbnN0IGZha2VUaW1lciBtb2Nrc1xuICAgIHZhciBfc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXRJbW1lZGlhdGU7XG5cbiAgICB2YXIgX2RlbGF5ID0gX3NldEltbWVkaWF0ZSA/IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgIF9zZXRJbW1lZGlhdGUoZm4pO1xuICAgIH0gOiBmdW5jdGlvbihmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhc3luYy5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBfZGVsYXk7XG4gICAgfVxuICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IF9zZXRJbW1lZGlhdGUgPyBfZGVsYXkgOiBhc3luYy5uZXh0VGljaztcblxuXG4gICAgYXN5bmMuZm9yRWFjaCA9XG4gICAgYXN5bmMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXN5bmMuZWFjaE9mKGFyciwgX3dpdGhvdXRJbmRleChpdGVyYXRvciksIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuZm9yRWFjaFNlcmllcyA9XG4gICAgYXN5bmMuZWFjaFNlcmllcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXN5bmMuZWFjaE9mU2VyaWVzKGFyciwgX3dpdGhvdXRJbmRleChpdGVyYXRvciksIGNhbGxiYWNrKTtcbiAgICB9O1xuXG5cbiAgICBhc3luYy5mb3JFYWNoTGltaXQgPVxuICAgIGFzeW5jLmVhY2hMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9lYWNoT2ZMaW1pdChsaW1pdCkoYXJyLCBfd2l0aG91dEluZGV4KGl0ZXJhdG9yKSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5mb3JFYWNoT2YgPVxuICAgIGFzeW5jLmVhY2hPZiA9IGZ1bmN0aW9uIChvYmplY3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICBvYmplY3QgPSBvYmplY3QgfHwgW107XG5cbiAgICAgICAgdmFyIGl0ZXIgPSBfa2V5SXRlcmF0b3Iob2JqZWN0KTtcbiAgICAgICAgdmFyIGtleSwgY29tcGxldGVkID0gMDtcblxuICAgICAgICB3aGlsZSAoKGtleSA9IGl0ZXIoKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICBpdGVyYXRvcihvYmplY3Rba2V5XSwga2V5LCBvbmx5X29uY2UoZG9uZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBsZXRlZCA9PT0gMCkgY2FsbGJhY2sobnVsbCk7XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgICAgIGNvbXBsZXRlZC0tO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBrZXkgaXMgbnVsbCBpbiBjYXNlIGl0ZXJhdG9yIGlzbid0IGV4aGF1c3RlZFxuICAgICAgICAgICAgLy8gYW5kIGRvbmUgcmVzb2x2ZWQgc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gbnVsbCAmJiBjb21wbGV0ZWQgPD0gMCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmZvckVhY2hPZlNlcmllcyA9XG4gICAgYXN5bmMuZWFjaE9mU2VyaWVzID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIG9iaiA9IG9iaiB8fCBbXTtcbiAgICAgICAgdmFyIG5leHRLZXkgPSBfa2V5SXRlcmF0b3Iob2JqKTtcbiAgICAgICAgdmFyIGtleSA9IG5leHRLZXkoKTtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRvcihvYmpba2V5XSwga2V5LCBvbmx5X29uY2UoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5leHRLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoaXRlcmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHN5bmMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRlKCk7XG4gICAgfTtcblxuXG5cbiAgICBhc3luYy5mb3JFYWNoT2ZMaW1pdCA9XG4gICAgYXN5bmMuZWFjaE9mTGltaXQgPSBmdW5jdGlvbiAob2JqLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9lYWNoT2ZMaW1pdChsaW1pdCkob2JqLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfZWFjaE9mTGltaXQobGltaXQpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IFtdO1xuICAgICAgICAgICAgdmFyIG5leHRLZXkgPSBfa2V5SXRlcmF0b3Iob2JqKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBydW5uaW5nID0gMDtcbiAgICAgICAgICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgICAgIGlmIChkb25lICYmIHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiAhZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gbmV4dEtleSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKG9ialtrZXldLCBrZXksIG9ubHlfb25jZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGRvUGFyYWxsZWwoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZuKGFzeW5jLmVhY2hPZiwgb2JqLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb1BhcmFsbGVsTGltaXQoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmbihfZWFjaE9mTGltaXQobGltaXQpLCBvYmosIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvU2VyaWVzKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmbihhc3luYy5lYWNoT2ZTZXJpZXMsIG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXN5bmNNYXAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICBhcnIgPSBhcnIgfHwgW107XG4gICAgICAgIHZhciByZXN1bHRzID0gX2lzQXJyYXlMaWtlKGFycikgPyBbXSA6IHt9O1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IodmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5tYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwU2VyaWVzID0gZG9TZXJpZXMoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfYXN5bmNNYXApO1xuXG4gICAgLy8gcmVkdWNlIG9ubHkgaGFzIGEgc2VyaWVzIHZlcnNpb24sIGFzIGRvaW5nIHJlZHVjZSBpbiBwYXJhbGxlbCB3b24ndFxuICAgIC8vIHdvcmsgaW4gbWFueSBzaXR1YXRpb25zLlxuICAgIGFzeW5jLmluamVjdCA9XG4gICAgYXN5bmMuZm9sZGwgPVxuICAgIGFzeW5jLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoT2ZTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgaSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5mb2xkciA9XG4gICAgYXN5bmMucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJldmVyc2VkID0gX21hcChhcnIsIGlkZW50aXR5KS5yZXZlcnNlKCk7XG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMudHJhbnNmb3JtID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGl0ZXJhdG9yO1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBtZW1vO1xuICAgICAgICAgICAgbWVtbyA9IF9pc0FycmF5KGFycikgPyBbXSA6IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMuZWFjaE9mKGFyciwgZnVuY3Rpb24odiwgaywgY2IpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHYsIGssIGNiKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2ZpbHRlcihlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBpbmRleCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtpbmRleDogaW5kZXgsIHZhbHVlOiB4fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMuc2VsZWN0ID1cbiAgICBhc3luYy5maWx0ZXIgPSBkb1BhcmFsbGVsKF9maWx0ZXIpO1xuXG4gICAgYXN5bmMuc2VsZWN0TGltaXQgPVxuICAgIGFzeW5jLmZpbHRlckxpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9maWx0ZXIpO1xuXG4gICAgYXN5bmMuc2VsZWN0U2VyaWVzID1cbiAgICBhc3luYy5maWx0ZXJTZXJpZXMgPSBkb1NlcmllcyhfZmlsdGVyKTtcblxuICAgIGZ1bmN0aW9uIF9yZWplY3QoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBfZmlsdGVyKGVhY2hmbiwgYXJyLCBmdW5jdGlvbih2YWx1ZSwgY2IpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgY2IoIXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RTZXJpZXMgPSBkb1NlcmllcyhfcmVqZWN0KTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVUZXN0ZXIoZWFjaGZuLCBjaGVjaywgZ2V0UmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2IpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiKSBjYihnZXRSZXN1bHQoZmFsc2UsIHZvaWQgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZWUoeCwgXywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNiKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2IgJiYgY2hlY2sodikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGdldFJlc3VsdCh0cnVlLCB4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYiA9IGl0ZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgIGVhY2hmbihhcnIsIGxpbWl0LCBpdGVyYXRlZSwgZG9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiID0gaXRlcmF0b3I7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBsaW1pdDtcbiAgICAgICAgICAgICAgICBlYWNoZm4oYXJyLCBpdGVyYXRlZSwgZG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMuYW55ID1cbiAgICBhc3luYy5zb21lID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2YsIHRvQm9vbCwgaWRlbnRpdHkpO1xuXG4gICAgYXN5bmMuc29tZUxpbWl0ID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2ZMaW1pdCwgdG9Cb29sLCBpZGVudGl0eSk7XG5cbiAgICBhc3luYy5hbGwgPVxuICAgIGFzeW5jLmV2ZXJ5ID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2YsIG5vdElkLCBub3RJZCk7XG5cbiAgICBhc3luYy5ldmVyeUxpbWl0ID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2ZMaW1pdCwgbm90SWQsIG5vdElkKTtcblxuICAgIGZ1bmN0aW9uIF9maW5kR2V0UmVzdWx0KHYsIHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGFzeW5jLmRldGVjdCA9IF9jcmVhdGVUZXN0ZXIoYXN5bmMuZWFjaE9mLCBpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpO1xuICAgIGFzeW5jLmRldGVjdFNlcmllcyA9IF9jcmVhdGVUZXN0ZXIoYXN5bmMuZWFjaE9mU2VyaWVzLCBpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpO1xuICAgIGFzeW5jLmRldGVjdExpbWl0ID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2ZMaW1pdCwgaWRlbnRpdHksIF9maW5kR2V0UmVzdWx0KTtcblxuICAgIGFzeW5jLnNvcnRCeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgX21hcChyZXN1bHRzLnNvcnQoY29tcGFyYXRvciksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBjb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5hdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjb25jdXJyZW5jeSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGNvbmN1cnJlbmN5IGlzIG9wdGlvbmFsLCBzaGlmdCB0aGUgYXJncy5cbiAgICAgICAgICAgIGNhbGxiYWNrID0gY29uY3VycmVuY3k7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sgPSBfb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgdmFyIGtleXMgPSBfa2V5cyh0YXNrcyk7XG4gICAgICAgIHZhciByZW1haW5pbmdUYXNrcyA9IGtleXMubGVuZ3RoO1xuICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSByZW1haW5pbmdUYXNrcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgIHZhciBydW5uaW5nVGFza3MgPSAwO1xuXG4gICAgICAgIHZhciBoYXNFcnJvciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoZm4pIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGZuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihmbikge1xuICAgICAgICAgICAgdmFyIGlkeCA9IF9pbmRleE9mKGxpc3RlbmVycywgZm4pO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSBsaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKCkge1xuICAgICAgICAgICAgcmVtYWluaW5nVGFza3MtLTtcbiAgICAgICAgICAgIF9hcnJheUVhY2gobGlzdGVuZXJzLnNsaWNlKDApLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9hcnJheUVhY2goa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcikgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHRhc2sgPSBfaXNBcnJheSh0YXNrc1trXSkgPyB0YXNrc1trXTogW3Rhc2tzW2tdXTtcbiAgICAgICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBfcmVzdFBhcmFtKGZ1bmN0aW9uKGVyciwgYXJncykge1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfZm9yRWFjaE9mKHJlc3VsdHMsIGZ1bmN0aW9uKHZhbCwgcmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUodGFza0NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlcyA9IHRhc2suc2xpY2UoMCwgdGFzay5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZGVhZC1sb2Nrc1xuICAgICAgICAgICAgdmFyIGxlbiA9IHJlcXVpcmVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkZXA7XG4gICAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShkZXAgPSB0YXNrc1tyZXF1aXJlc1tsZW5dXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXMgbm9uZXhpc3RlbnQgZGVwZW5kZW5jeSBpbiAnICsgcmVxdWlyZXMuam9pbignLCAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheShkZXApICYmIF9pbmRleE9mKGRlcCwgaykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhcyBjeWNsaWMgZGVwZW5kZW5jaWVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmdUYXNrcyA8IGNvbmN1cnJlbmN5ICYmIF9yZWR1Y2UocmVxdWlyZXMsIGZ1bmN0aW9uIChhLCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYSAmJiByZXN1bHRzLmhhc093blByb3BlcnR5KHgpKTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKSAmJiAhcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ1Rhc2tzKys7XG4gICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGFza3MrKztcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG4gICAgYXN5bmMucmV0cnkgPSBmdW5jdGlvbih0aW1lcywgdGFzaywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIERFRkFVTFRfVElNRVMgPSA1O1xuICAgICAgICB2YXIgREVGQVVMVF9JTlRFUlZBTCA9IDA7XG5cbiAgICAgICAgdmFyIGF0dGVtcHRzID0gW107XG5cbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICB0aW1lczogREVGQVVMVF9USU1FUyxcbiAgICAgICAgICAgIGludGVydmFsOiBERUZBVUxUX0lOVEVSVkFMXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VUaW1lcyhhY2MsIHQpe1xuICAgICAgICAgICAgaWYodHlwZW9mIHQgPT09ICdudW1iZXInKXtcbiAgICAgICAgICAgICAgICBhY2MudGltZXMgPSBwYXJzZUludCh0LCAxMCkgfHwgREVGQVVMVF9USU1FUztcbiAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YgdCA9PT0gJ29iamVjdCcpe1xuICAgICAgICAgICAgICAgIGFjYy50aW1lcyA9IHBhcnNlSW50KHQudGltZXMsIDEwKSB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICAgICAgICAgIGFjYy5pbnRlcnZhbCA9IHBhcnNlSW50KHQuaW50ZXJ2YWwsIDEwKSB8fCBERUZBVUxUX0lOVEVSVkFMO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFyZ3VtZW50IHR5cGUgZm9yIFxcJ3RpbWVzXFwnOiAnICsgdHlwZW9mIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAxIHx8IGxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgLSBtdXN0IGJlIGVpdGhlciAodGFzayksICh0YXNrLCBjYWxsYmFjayksICh0aW1lcywgdGFzaykgb3IgKHRpbWVzLCB0YXNrLCBjYWxsYmFjayknKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPD0gMiAmJiB0eXBlb2YgdGltZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGFzaztcbiAgICAgICAgICAgIHRhc2sgPSB0aW1lcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRpbWVzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwYXJzZVRpbWVzKG9wdHMsIHRpbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIG9wdHMudGFzayA9IHRhc2s7XG5cbiAgICAgICAgZnVuY3Rpb24gd3JhcHBlZFRhc2sod3JhcHBlZENhbGxiYWNrLCB3cmFwcGVkUmVzdWx0cykge1xuICAgICAgICAgICAgZnVuY3Rpb24gcmV0cnlBdHRlbXB0KHRhc2ssIGZpbmFsQXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzZXJpZXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKGZ1bmN0aW9uKGVyciwgcmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0NhbGxiYWNrKCFlcnIgfHwgZmluYWxBdHRlbXB0LCB7ZXJyOiBlcnIsIHJlc3VsdDogcmVzdWx0fSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHdyYXBwZWRSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZXRyeUludGVydmFsKGludGVydmFsKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VyaWVzQ2FsbGJhY2spe1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNDYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChvcHRzLnRpbWVzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmluYWxBdHRlbXB0ID0gIShvcHRzLnRpbWVzLT0xKTtcbiAgICAgICAgICAgICAgICBhdHRlbXB0cy5wdXNoKHJldHJ5QXR0ZW1wdChvcHRzLnRhc2ssIGZpbmFsQXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIGlmKCFmaW5hbEF0dGVtcHQgJiYgb3B0cy5pbnRlcnZhbCA+IDApe1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0cy5wdXNoKHJldHJ5SW50ZXJ2YWwob3B0cy5pbnRlcnZhbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXN5bmMuc2VyaWVzKGF0dGVtcHRzLCBmdW5jdGlvbihkb25lLCBkYXRhKXtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICh3cmFwcGVkQ2FsbGJhY2sgfHwgb3B0cy5jYWxsYmFjaykoZGF0YS5lcnIsIGRhdGEucmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHJ1biB0aGlzIGFzIGEgY29udHJvbGwgZmxvd1xuICAgICAgICByZXR1cm4gb3B0cy5jYWxsYmFjayA/IHdyYXBwZWRUYXNrKCkgOiB3cmFwcGVkVGFzaztcbiAgICB9O1xuXG4gICAgYXN5bmMud2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICBpZiAoIV9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJyk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JhcEl0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbiAoZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbZXJyXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlQXN5bmMoaXRlcmF0b3IpLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBJdGVyYXRvcihhc3luYy5pdGVyYXRvcih0YXNrcykpKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9wYXJhbGxlbChlYWNoZm4sIHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgICAgIHZhciByZXN1bHRzID0gX2lzQXJyYXlMaWtlKHRhc2tzKSA/IFtdIDoge307XG5cbiAgICAgICAgZWFjaGZuKHRhc2tzLCBmdW5jdGlvbiAodGFzaywga2V5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGFzayhfcmVzdFBhcmFtKGZ1bmN0aW9uIChlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gYXJncztcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5wYXJhbGxlbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKGFzeW5jLmVhY2hPZiwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKF9lYWNoT2ZMaW1pdChsaW1pdCksIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnNlcmllcyA9IGZ1bmN0aW9uKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoYXN5bmMuZWFjaE9mU2VyaWVzLCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5pdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICAgICAgICBmdW5jdGlvbiBtYWtlQ2FsbGJhY2soaW5kZXgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZuKCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3NbaW5kZXhdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCB0YXNrcy5sZW5ndGggLSAxKSA/IG1ha2VDYWxsYmFjayhpbmRleCArIDEpOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xuICAgIH07XG5cbiAgICBhc3luYy5hcHBseSA9IF9yZXN0UGFyYW0oZnVuY3Rpb24gKGZuLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uIChjYWxsQXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KFxuICAgICAgICAgICAgICAgIG51bGwsIGFyZ3MuY29uY2F0KGNhbGxBcmdzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBfY29uY2F0KGVhY2hmbiwgYXJyLCBmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgaW5kZXgsIGNiKSB7XG4gICAgICAgICAgICBmbih4LCBmdW5jdGlvbiAoZXJyLCB5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh5IHx8IFtdKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jLmNvbmNhdCA9IGRvUGFyYWxsZWwoX2NvbmNhdCk7XG4gICAgYXN5bmMuY29uY2F0U2VyaWVzID0gZG9TZXJpZXMoX2NvbmNhdCk7XG5cbiAgICBhc3luYy53aGlsc3QgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICAgICAgaWYgKHRlc3QoKSkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBfcmVzdFBhcmFtKGZ1bmN0aW9uKGVyciwgYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRlc3QuYXBwbHkodGhpcywgYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IobmV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdGVyYXRvcihuZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvV2hpbHN0ID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY2FsbHMgPSAwO1xuICAgICAgICByZXR1cm4gYXN5bmMud2hpbHN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICsrY2FsbHMgPD0gMSB8fCB0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnVudGlsID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXN5bmMud2hpbHN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmRvVW50aWwgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhc3luYy5kb1doaWxzdChpdGVyYXRvciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5kdXJpbmcgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblxuICAgICAgICB2YXIgbmV4dCA9IF9yZXN0UGFyYW0oZnVuY3Rpb24oZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGNoZWNrKTtcbiAgICAgICAgICAgICAgICB0ZXN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbihlcnIsIHRydXRoKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJ1dGgpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcihuZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGVzdChjaGVjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmRvRHVyaW5nID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY2FsbHMgPSAwO1xuICAgICAgICBhc3luYy5kdXJpbmcoZnVuY3Rpb24obmV4dCkge1xuICAgICAgICAgICAgaWYgKGNhbGxzKysgPCAxKSB7XG4gICAgICAgICAgICAgICAgbmV4dChudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfcXVldWUod29ya2VyLCBjb25jdXJyZW5jeSwgcGF5bG9hZCkge1xuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoY29uY3VycmVuY3kgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uY3VycmVuY3kgbXVzdCBub3QgYmUgemVybycpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXNrIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID09PSAwICYmIHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYXJyYXlFYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrIHx8IG5vb3BcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcS50YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX25leHQocSwgdGFza3MpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHdvcmtlcnMgLT0gMTtcblxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgX2FycmF5RWFjaCh0YXNrcywgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgX2FycmF5RWFjaCh3b3JrZXJzTGlzdCwgZnVuY3Rpb24gKHdvcmtlciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JrZXIgPT09IHRhc2sgJiYgIXJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29ya2VycyA9IDA7XG4gICAgICAgIHZhciB3b3JrZXJzTGlzdCA9IFtdO1xuICAgICAgICB2YXIgcSA9IHtcbiAgICAgICAgICAgIHRhc2tzOiBbXSxcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG5vb3AsXG4gICAgICAgICAgICBlbXB0eTogbm9vcCxcbiAgICAgICAgICAgIGRyYWluOiBub29wLFxuICAgICAgICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICAgICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBxLmRyYWluID0gbm9vcDtcbiAgICAgICAgICAgICAgICBxLnRhc2tzID0gW107XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHdoaWxlKCFxLnBhdXNlZCAmJiB3b3JrZXJzIDwgcS5jb25jdXJyZW5jeSAmJiBxLnRhc2tzLmxlbmd0aCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2tzID0gcS5wYXlsb2FkID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHEudGFza3Muc3BsaWNlKDAsIHEucGF5bG9hZCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoMCwgcS50YXNrcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX21hcCh0YXNrcywgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChxLnRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3QucHVzaCh0YXNrc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlfb25jZShfbmV4dChxLCB0YXNrcykpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIoZGF0YSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdvcmtlcnNMaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnNMaXN0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bWVDb3VudCA9IE1hdGgubWluKHEuY29uY3VycmVuY3ksIHEudGFza3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGNhbGwgcS5wcm9jZXNzIG9uY2UgcGVyIGNvbmN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyB3b3JrZXIgdG8gcHJlc2VydmUgZnVsbCBjb25jdXJyZW5jeSBhZnRlciBwYXVzZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIHcgPSAxOyB3IDw9IHJlc3VtZUNvdW50OyB3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9XG5cbiAgICBhc3luYy5xdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIHZhciBxID0gX3F1ZXVlKGZ1bmN0aW9uIChpdGVtcywgY2IpIHtcbiAgICAgICAgICAgIHdvcmtlcihpdGVtc1swXSwgY2IpO1xuICAgICAgICB9LCBjb25jdXJyZW5jeSwgMSk7XG5cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIGFzeW5jLnByaW9yaXR5UXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuXG4gICAgICAgIGZ1bmN0aW9uIF9jb21wYXJlVGFza3MoYSwgYil7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfYmluYXJ5U2VhcmNoKHNlcXVlbmNlLCBpdGVtLCBjb21wYXJlKSB7XG4gICAgICAgICAgICB2YXIgYmVnID0gLTEsXG4gICAgICAgICAgICAgICAgZW5kID0gc2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChiZWcgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWlkID0gYmVnICsgKChlbmQgLSBiZWcgKyAxKSA+Pj4gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoaXRlbSwgc2VxdWVuY2VbbWlkXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBiZWcgPSBtaWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gbWlkIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmVnO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2FycmF5RWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbm9vcFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBxLnRhc2tzLnNwbGljZShfYmluYXJ5U2VhcmNoKHEudGFza3MsIGl0ZW0sIF9jb21wYXJlVGFza3MpICsgMSwgMCwgaXRlbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocS50YXNrcy5sZW5ndGggPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYSBub3JtYWwgcXVldWVcbiAgICAgICAgdmFyIHEgPSBhc3luYy5xdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcblxuICAgICAgICAvLyBPdmVycmlkZSBwdXNoIHRvIGFjY2VwdCBzZWNvbmQgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBwcmlvcml0eVxuICAgICAgICBxLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHVuc2hpZnQgZnVuY3Rpb25cbiAgICAgICAgZGVsZXRlIHEudW5zaGlmdDtcblxuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY2FyZ28gPSBmdW5jdGlvbiAod29ya2VyLCBwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfcXVldWUod29ya2VyLCAxLCBwYXlsb2FkKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NvbnNvbGVfZm4obmFtZSkge1xuICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbiAoZm4sIGFyZ3MpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtfcmVzdFBhcmFtKGZ1bmN0aW9uIChlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hcnJheUVhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KV0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jLmxvZyA9IF9jb25zb2xlX2ZuKCdsb2cnKTtcbiAgICBhc3luYy5kaXIgPSBfY29uc29sZV9mbignZGlyJyk7XG4gICAgLyphc3luYy5pbmZvID0gX2NvbnNvbGVfZm4oJ2luZm8nKTtcbiAgICBhc3luYy53YXJuID0gX2NvbnNvbGVfZm4oJ3dhcm4nKTtcbiAgICBhc3luYy5lcnJvciA9IF9jb25zb2xlX2ZuKCdlcnJvcicpOyovXG5cbiAgICBhc3luYy5tZW1vaXplID0gZnVuY3Rpb24gKGZuLCBoYXNoZXIpIHtcbiAgICAgICAgdmFyIG1lbW8gPSB7fTtcbiAgICAgICAgdmFyIHF1ZXVlcyA9IHt9O1xuICAgICAgICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgaGFzaGVyID0gaGFzaGVyIHx8IGlkZW50aXR5O1xuICAgICAgICB2YXIgbWVtb2l6ZWQgPSBfcmVzdFBhcmFtKGZ1bmN0aW9uIG1lbW9pemVkKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKG1lbW8sIGtleSkpIHsgICBcbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzLmNhbGwocXVldWVzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW19yZXN0UGFyYW0oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb1trZXldID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxW2ldLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcbiAgICAgICAgbWVtb2l6ZWQudW5tZW1vaXplZCA9IGZuO1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfTtcblxuICAgIGFzeW5jLnVubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfdGltZXMobWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgbWFwcGVyKF9yYW5nZShjb3VudCksIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMudGltZXMgPSBfdGltZXMoYXN5bmMubWFwKTtcbiAgICBhc3luYy50aW1lc1NlcmllcyA9IF90aW1lcyhhc3luYy5tYXBTZXJpZXMpO1xuICAgIGFzeW5jLnRpbWVzTGltaXQgPSBmdW5jdGlvbiAoY291bnQsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcExpbWl0KF9yYW5nZShjb3VudCksIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXEgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXN5bmMucmVkdWNlKGZucywgYXJncywgZnVuY3Rpb24gKG5ld2FyZ3MsIGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KFtfcmVzdFBhcmFtKGZ1bmN0aW9uIChlcnIsIG5leHRhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pXSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5jb21wb3NlID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgICByZXR1cm4gYXN5bmMuc2VxLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gX2FwcGx5RWFjaChlYWNoZm4pIHtcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24oZm5zLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgZ28gPSBfcmVzdFBhcmFtKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBfLCBjYikge1xuICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChbY2JdKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnby5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMuYXBwbHlFYWNoID0gX2FwcGx5RWFjaChhc3luYy5lYWNoT2YpO1xuICAgIGFzeW5jLmFwcGx5RWFjaFNlcmllcyA9IF9hcHBseUVhY2goYXN5bmMuZWFjaE9mU2VyaWVzKTtcblxuXG4gICAgYXN5bmMuZm9yZXZlciA9IGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRvbmUgPSBvbmx5X29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIHZhciB0YXNrID0gZW5zdXJlQXN5bmMoZm4pO1xuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZW5zdXJlQXN5bmMoZm4pIHtcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHN5bmMgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMuZW5zdXJlQXN5bmMgPSBlbnN1cmVBc3luYztcblxuICAgIGFzeW5jLmNvbnN0YW50ID0gX3Jlc3RQYXJhbShmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbbnVsbF0uY29uY2F0KHZhbHVlcyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGFzeW5jLndyYXBTeW5jID1cbiAgICBhc3luYy5hc3luY2lmeSA9IGZ1bmN0aW9uIGFzeW5jaWZ5KGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHJlc3VsdCBpcyBQcm9taXNlIG9iamVjdFxuICAgICAgICAgICAgaWYgKF9pc09iamVjdChyZXN1bHQpICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyci5tZXNzYWdlID8gZXJyIDogbmV3IEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gTm9kZS5qc1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuICAgIH1cbiAgICAvLyBBTUQgLyBSZXF1aXJlSlNcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlZCBkaXJlY3RseSB2aWEgPHNjcmlwdD4gdGFnXG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBhc3luYztcbiAgICB9XG5cbn0oKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjAgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlKSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIHNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBzaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBzaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgc3VtID0gMCxcbiAgICAgICAgaSwgaiwgbGFzdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBvcmlnaW5hbCB3aW5kaW5nIG9yZGVyIG9mIGEgcG9seWdvbiByaW5nXG4gICAgZm9yIChpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuICAgICAgICBqID0gaTtcbiAgICB9XG5cbiAgICAvLyBsaW5rIHBvaW50cyBpbnRvIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdCBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc3VtID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgcGFzcykge1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgaWYgKCFwYXNzICYmIHNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoc2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgc2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGljZSBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGVhciwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBwID0gZWFyLm5leHQubmV4dDtcblxuICAgIHdoaWxlIChwICE9PSBlYXIucHJldikge1xuICAgICAgICBpZiAocG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIHNpemUpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciBtaW5UWCA9IGEueCA8IGIueCA/IChhLnggPCBjLnggPyBhLnggOiBjLngpIDogKGIueCA8IGMueCA/IGIueCA6IGMueCksXG4gICAgICAgIG1pblRZID0gYS55IDwgYi55ID8gKGEueSA8IGMueSA/IGEueSA6IGMueSkgOiAoYi55IDwgYy55ID8gYi55IDogYy55KSxcbiAgICAgICAgbWF4VFggPSBhLnggPiBiLnggPyAoYS54ID4gYy54ID8gYS54IDogYy54KSA6IChiLnggPiBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtYXhUWSA9IGEueSA+IGIueSA/IChhLnkgPiBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA+IGMueSA/IGIueSA6IGMueSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgc2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHZhciBwID0gZWFyLm5leHRaO1xuXG4gICAgd2hpbGUgKHAgJiYgcC56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHRaO1xuICAgIH1cblxuICAgIC8vIHRoZW4gbG9vayBmb3IgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHAgPSBlYXIucHJldlo7XG5cbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICAvLyBhIHNlbGYtaW50ZXJzZWN0aW9uIHdoZXJlIGVkZ2UgKHZbaS0xXSx2W2ldKSBpbnRlcnNlY3RzICh2W2krMV0sdltpKzJdKVxuICAgICAgICBpZiAoaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG5cbiAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gcDtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICAgICAgb3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgb3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAob3V0ZXJOb2RlKSB7XG4gICAgICAgIHZhciBiID0gc3BsaXRQb2x5Z29uKG91dGVyTm9kZSwgaG9sZSk7XG4gICAgICAgIGZpbHRlclBvaW50cyhiLCBiLm5leHQpO1xuICAgIH1cbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXG4gICAgICAgIGh4ID0gaG9sZS54LFxuICAgICAgICBoeSA9IGhvbGUueSxcbiAgICAgICAgcXggPSAtSW5maW5pdHksXG4gICAgICAgIG07XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGhvbGUueCA9PT0gbS54KSByZXR1cm4gbS5wcmV2OyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsb3dlciBlbmRwb2ludFxuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgc3RvcCA9IG0sXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbS5uZXh0O1xuXG4gICAgd2hpbGUgKHAgIT09IHN0b3ApIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbS54ICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbS55ID8gaHggOiBxeCwgaHksIG0ueCwgbS55LCBoeSA8IG0ueSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcblxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG4gICAgICAgICAgICBpZiAoKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgcC54ID4gbS54KSkgJiYgbG9jYWxseUluc2lkZShwLCBob2xlKSkge1xuICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIHNpemUpIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueiA9PT0gbnVsbCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBwLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocVNpemUgPT09IDAgfHwgIXEpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocC56IDw9IHEueikge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgIGluU2l6ZSAqPSAyO1xuXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgc2l6ZSBvZiB0aGUgZGF0YSBib3VuZGluZyBib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuICAgIHggPSAzMjc2NyAqICh4IC0gbWluWCkgLyBzaXplO1xuICAgIHkgPSAzMjc2NyAqICh5IC0gbWluWSkgLyBzaXplO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCkgbGVmdG1vc3QgPSBwO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgLSAoYXggLSBweCkgKiAoY3kgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgLSAoYnggLSBweCkgKiAoYXkgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgLSAoY3ggLSBweCkgKiAoYnkgLSBweSkgPj0gMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiBlcXVhbHMoYSwgYikgfHwgYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJlxuICAgICAgICAgICBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpO1xufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIHJldHVybiBhcmVhKHAxLCBxMSwgcDIpID4gMCAhPT0gYXJlYShwMSwgcTEsIHEyKSA+IDAgJiZcbiAgICAgICAgICAgYXJlYShwMiwgcTIsIHAxKSA+IDAgIT09IGFyZWEocDIsIHEyLCBxMSkgPiAwO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICAgIHZhciBwID0gYTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICAgIHZhciBwID0gYSxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRpY2UgaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgICB0aGlzLmkgPSBpO1xuXG4gICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGljZSBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSBudWxsO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy9cbi8vIFdlIHN0b3JlIG91ciBFRSBvYmplY3RzIGluIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGB+YCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBvdmVycmlkZGVuIG9yXG4vLyB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vLyBXZSBhbHNvIGFzc3VtZSB0aGF0IGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBhdmFpbGFibGUgd2hlbiB0aGUgZXZlbnQgbmFtZVxuLy8gaXMgYW4gRVM2IFN5bWJvbC5cbi8vXG52YXIgcHJlZml4ID0gdHlwZW9mIE9iamVjdC5jcmVhdGUgIT09ICdmdW5jdGlvbicgPyAnficgOiBmYWxzZTtcblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBFdmVudEVtaXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlciB0byBiZSBjYWxsZWQuXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IENvbnRleHQgZm9yIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IGVtaXQgb25jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIEV2ZW50RW1pdHRlciBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogRXZlbnRFbWl0dGVyIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHsgLyogTm90aGluZyB0byBzZXQgKi8gfVxuXG4vKipcbiAqIEhvbGRzIHRoZSBhc3NpZ25lZCBFdmVudEVtaXR0ZXJzIGJ5IG5hbWUuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGFzc2lnbmVkIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50cyB0aGF0IHNob3VsZCBiZSBsaXN0ZWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4aXN0cyBXZSBvbmx5IG5lZWQgdG8ga25vdyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0FycmF5fEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCwgZXhpc3RzKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBhdmFpbGFibGUgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGV4aXN0cykgcmV0dXJuICEhYXZhaWxhYmxlO1xuICBpZiAoIWF2YWlsYWJsZSkgcmV0dXJuIFtdO1xuICBpZiAoYXZhaWxhYmxlLmZuKSByZXR1cm4gW2F2YWlsYWJsZS5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdmFpbGFibGUubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gYXZhaWxhYmxlW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBFbWl0IGFuIGV2ZW50IHRvIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRpb24gaWYgd2UndmUgZW1pdHRlZCBhbiBldmVudC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgRXZlbnRMaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IFRoZSBjb250ZXh0IG9mIHRoZSBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSBwcmVmaXggPyB7fSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHRoaXMuX2V2ZW50c1tldnRdID0gbGlzdGVuZXI7XG4gIGVsc2Uge1xuICAgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0uZm4pIHRoaXMuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICAgIGVsc2UgdGhpcy5fZXZlbnRzW2V2dF0gPSBbXG4gICAgICB0aGlzLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJcbiAgICBdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBFdmVudExpc3RlbmVyIHRoYXQncyBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBUaGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcywgdHJ1ZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHByZWZpeCA/IHt9IDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgdGhpcy5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lcjtcbiAgZWxzZSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XS5mbikgdGhpcy5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gICAgZWxzZSB0aGlzLl9ldmVudHNbZXZ0XSA9IFtcbiAgICAgIHRoaXMuX2V2ZW50c1tldnRdLCBsaXN0ZW5lclxuICAgIF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHdlIHdhbnQgdG8gcmVtb3ZlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIHRoYXQgd2UgbmVlZCB0byBmaW5kLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBPbmx5IHJlbW92ZSBsaXN0ZW5lcnMgbWF0Y2hpbmcgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uY2UgbGlzdGVuZXJzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgZXZlbnRzID0gW107XG5cbiAgaWYgKGZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgICAgaWYgKFxuICAgICAgICAgICBsaXN0ZW5lcnMuZm4gIT09IGZuXG4gICAgICAgIHx8IChvbmNlICYmICFsaXN0ZW5lcnMub25jZSlcbiAgICAgICAgfHwgKGNvbnRleHQgJiYgbGlzdGVuZXJzLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmblxuICAgICAgICAgIHx8IChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSlcbiAgICAgICAgICB8fCAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICAgKSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgLy9cbiAgaWYgKGV2ZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9yIG9ubHkgdGhlIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHdhbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gIGlmIChldmVudCkgZGVsZXRlIHRoaXMuX2V2ZW50c1twcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XTtcbiAgZWxzZSB0aGlzLl9ldmVudHMgPSBwcmVmaXggPyB7fSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gZG9lc24ndCBhcHBseSBhbnltb3JlLlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiLyohXG4gKiBhc3luY1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Nhb2xhbi9hc3luY1xuICpcbiAqIENvcHlyaWdodCAyMDEwLTIwMTQgQ2FvbGFuIE1jTWFob25cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4vKmpzaGludCBvbmV2YXI6IGZhbHNlLCBpbmRlbnQ6NCAqL1xuLypnbG9iYWwgc2V0SW1tZWRpYXRlOiBmYWxzZSwgc2V0VGltZW91dDogZmFsc2UsIGNvbnNvbGU6IGZhbHNlICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGFzeW5jID0ge307XG5cbiAgICAvLyBnbG9iYWwgb24gdGhlIHNlcnZlciwgd2luZG93IGluIHRoZSBicm93c2VyXG4gICAgdmFyIHJvb3QsIHByZXZpb3VzX2FzeW5jO1xuXG4gICAgcm9vdCA9IHRoaXM7XG4gICAgaWYgKHJvb3QgIT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xuICAgIH1cblxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBwcmV2aW91c19hc3luYztcbiAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbmx5X29uY2UoZm4pIHtcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHJvb3QsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsaXR5IGZ1bmN0aW9ucyAvLy8vXG5cbiAgICB2YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgdmFyIF9lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltpXSwgaSwgYXJyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX21hcCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIubWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLm1hcChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yKHgsIGksIGEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICB2YXIgX3JlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtZW1vKSB7XG4gICAgICAgIGlmIChhcnIucmVkdWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLnJlZHVjZShpdGVyYXRvciwgbWVtbyk7XG4gICAgICAgIH1cbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yKG1lbW8sIHgsIGksIGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIHZhciBfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgLy8vLyBleHBvcnRlZCBhc3luYyBtb2R1bGUgZnVuY3Rpb25zIC8vLy9cblxuICAgIC8vLy8gbmV4dFRpY2sgaW1wbGVtZW50YXRpb24gd2l0aCBicm93c2VyLWNvbXBhdGlibGUgZmFsbGJhY2sgLy8vL1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShwcm9jZXNzLm5leHRUaWNrKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3luYy5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYy5lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIG9ubHlfb25jZShkb25lKSApO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoID0gYXN5bmMuZWFjaDtcblxuICAgIGFzeW5jLmVhY2hTZXJpZXMgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgdmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbY29tcGxldGVkXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaXRlcmF0ZSgpO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaFNlcmllcyA9IGFzeW5jLmVhY2hTZXJpZXM7XG5cbiAgICBhc3luYy5lYWNoTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmbiA9IF9lYWNoTGltaXQobGltaXQpO1xuICAgICAgICBmbi5hcHBseShudWxsLCBbYXJyLCBpdGVyYXRvciwgY2FsbGJhY2tdKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hMaW1pdCA9IGFzeW5jLmVhY2hMaW1pdDtcblxuICAgIHZhciBfZWFjaExpbWl0ID0gZnVuY3Rpb24gKGxpbWl0KSB7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIGlmICghYXJyLmxlbmd0aCB8fCBsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gMDtcbiAgICAgICAgICAgIHZhciBydW5uaW5nID0gMDtcblxuICAgICAgICAgICAgKGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgc3RhcnRlZCA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycltzdGFydGVkIC0gMV0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIGRvUGFyYWxsZWwgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbYXN5bmMuZWFjaF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBkb1BhcmFsbGVsTGltaXQgPSBmdW5jdGlvbihsaW1pdCwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbX2VhY2hMaW1pdChsaW1pdCldLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9TZXJpZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbYXN5bmMuZWFjaFNlcmllc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICB2YXIgX2FzeW5jTWFwID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbeC5pbmRleF0gPSB2O1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYXN5bmMubWFwID0gZG9QYXJhbGxlbChfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcFNlcmllcyA9IGRvU2VyaWVzKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfbWFwTGltaXQobGltaXQpKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgdmFyIF9tYXBMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHJldHVybiBkb1BhcmFsbGVsTGltaXQobGltaXQsIF9hc3luY01hcCk7XG4gICAgfTtcblxuICAgIC8vIHJlZHVjZSBvbmx5IGhhcyBhIHNlcmllcyB2ZXJzaW9uLCBhcyBkb2luZyByZWR1Y2UgaW4gcGFyYWxsZWwgd29uJ3RcbiAgICAvLyB3b3JrIGluIG1hbnkgc2l0dWF0aW9ucy5cbiAgICBhc3luYy5yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IobWVtbywgeCwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIG1lbW8gPSB2O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBtZW1vKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBpbmplY3QgYWxpYXNcbiAgICBhc3luYy5pbmplY3QgPSBhc3luYy5yZWR1Y2U7XG4gICAgLy8gZm9sZGwgYWxpYXNcbiAgICBhc3luYy5mb2xkbCA9IGFzeW5jLnJlZHVjZTtcblxuICAgIGFzeW5jLnJlZHVjZVJpZ2h0ID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXZlcnNlZCA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0pLnJldmVyc2UoKTtcbiAgICAgICAgYXN5bmMucmVkdWNlKHJldmVyc2VkLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLy8gZm9sZHIgYWxpYXNcbiAgICBhc3luYy5mb2xkciA9IGFzeW5jLnJlZHVjZVJpZ2h0O1xuXG4gICAgdmFyIF9maWx0ZXIgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5maWx0ZXIgPSBkb1BhcmFsbGVsKF9maWx0ZXIpO1xuICAgIGFzeW5jLmZpbHRlclNlcmllcyA9IGRvU2VyaWVzKF9maWx0ZXIpO1xuICAgIC8vIHNlbGVjdCBhbGlhc1xuICAgIGFzeW5jLnNlbGVjdCA9IGFzeW5jLmZpbHRlcjtcbiAgICBhc3luYy5zZWxlY3RTZXJpZXMgPSBhc3luYy5maWx0ZXJTZXJpZXM7XG5cbiAgICB2YXIgX3JlamVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5yZWplY3QgPSBkb1BhcmFsbGVsKF9yZWplY3QpO1xuICAgIGFzeW5jLnJlamVjdFNlcmllcyA9IGRvU2VyaWVzKF9yZWplY3QpO1xuXG4gICAgdmFyIF9kZXRlY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh4KTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmRldGVjdCA9IGRvUGFyYWxsZWwoX2RldGVjdCk7XG4gICAgYXN5bmMuZGV0ZWN0U2VyaWVzID0gZG9TZXJpZXMoX2RldGVjdCk7XG5cbiAgICBhc3luYy5zb21lID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gYW55IGFsaWFzXG4gICAgYXN5bmMuYW55ID0gYXN5bmMuc29tZTtcblxuICAgIGFzeW5jLmV2ZXJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFsbCBhbGlhc1xuICAgIGFzeW5jLmFsbCA9IGFzeW5jLmV2ZXJ5O1xuXG4gICAgYXN5bmMuc29ydEJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLm1hcChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKGVyciwgY3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhLCBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIF9tYXAocmVzdWx0cy5zb3J0KGZuKSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXV0byA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgdmFyIGtleXMgPSBfa2V5cyh0YXNrcyk7XG4gICAgICAgIHZhciByZW1haW5pbmdUYXNrcyA9IGtleXMubGVuZ3RoXG4gICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoZm4pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhc2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ1Rhc2tzLS1cbiAgICAgICAgICAgIF9lYWNoKGxpc3RlbmVycy5zbGljZSgwKSwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGZpbmFsIGNhbGxiYWNrIGZyb20gY2FsbGluZyBpdHNlbGYgaWYgaXQgZXJyb3JzXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfZWFjaChrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSBfaXNBcnJheSh0YXNrc1trXSkgPyB0YXNrc1trXTogW3Rhc2tzW2tdXTtcbiAgICAgICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfZWFjaChfa2V5cyhyZXN1bHRzKSwgZnVuY3Rpb24ocmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSByZXN1bHRzW3JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzdWJzZXF1ZW50IGVycm9ycyBoaXR0aW5nIGNhbGxiYWNrIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHRhc2tDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlcyA9IHRhc2suc2xpY2UoMCwgTWF0aC5hYnModGFzay5sZW5ndGggLSAxKSkgfHwgW107XG4gICAgICAgICAgICB2YXIgcmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2UocmVxdWlyZXMsIGZ1bmN0aW9uIChhLCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYSAmJiByZXN1bHRzLmhhc093blByb3BlcnR5KHgpKTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKSAmJiAhcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnJldHJ5ID0gZnVuY3Rpb24odGltZXMsIHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBERUZBVUxUX1RJTUVTID0gNTtcbiAgICAgICAgdmFyIGF0dGVtcHRzID0gW107XG4gICAgICAgIC8vIFVzZSBkZWZhdWx0cyBpZiB0aW1lcyBub3QgcGFzc2VkXG4gICAgICAgIGlmICh0eXBlb2YgdGltZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGFzaztcbiAgICAgICAgICAgIHRhc2sgPSB0aW1lcztcbiAgICAgICAgICAgIHRpbWVzID0gREVGQVVMVF9USU1FUztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGltZXMgaXMgYSBudW1iZXJcbiAgICAgICAgdGltZXMgPSBwYXJzZUludCh0aW1lcywgMTApIHx8IERFRkFVTFRfVElNRVM7XG4gICAgICAgIHZhciB3cmFwcGVkVGFzayA9IGZ1bmN0aW9uKHdyYXBwZWRDYWxsYmFjaywgd3JhcHBlZFJlc3VsdHMpIHtcbiAgICAgICAgICAgIHZhciByZXRyeUF0dGVtcHQgPSBmdW5jdGlvbih0YXNrLCBmaW5hbEF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VyaWVzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzayhmdW5jdGlvbihlcnIsIHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNDYWxsYmFjayghZXJyIHx8IGZpbmFsQXR0ZW1wdCwge2VycjogZXJyLCByZXN1bHQ6IHJlc3VsdH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB3cmFwcGVkUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aGlsZSAodGltZXMpIHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0cy5wdXNoKHJldHJ5QXR0ZW1wdCh0YXNrLCAhKHRpbWVzLT0xKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMuc2VyaWVzKGF0dGVtcHRzLCBmdW5jdGlvbihkb25lLCBkYXRhKXtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICh3cmFwcGVkQ2FsbGJhY2sgfHwgY2FsbGJhY2spKGRhdGEuZXJyLCBkYXRhLnJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIGNhbGxiYWNrIGlzIHBhc3NlZCwgcnVuIHRoaXMgYXMgYSBjb250cm9sbCBmbG93XG4gICAgICAgIHJldHVybiBjYWxsYmFjayA/IHdyYXBwZWRUYXNrKCkgOiB3cmFwcGVkVGFza1xuICAgIH07XG5cbiAgICBhc3luYy53YXRlcmZhbGwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJyk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwSXRlcmF0b3IgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwSXRlcmF0b3IobmV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHdyYXBJdGVyYXRvcihhc3luYy5pdGVyYXRvcih0YXNrcykpKCk7XG4gICAgfTtcblxuICAgIHZhciBfcGFyYWxsZWwgPSBmdW5jdGlvbihlYWNoZm4sIHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgICBlYWNoZm4ubWFwKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgICAgICBlYWNoZm4uZWFjaChfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IGFzeW5jLm1hcCwgZWFjaDogYXN5bmMuZWFjaCB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24odGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IF9tYXBMaW1pdChsaW1pdCksIGVhY2g6IF9lYWNoTGltaXQobGltaXQpIH0sIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnNlcmllcyA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKF9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICAgICAgYXN5bmMubWFwU2VyaWVzKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgICAgICBhc3luYy5lYWNoU2VyaWVzKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuaXRlcmF0b3IgPSBmdW5jdGlvbiAodGFza3MpIHtcbiAgICAgICAgdmFyIG1ha2VDYWxsYmFjayA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3NbaW5kZXhdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5uZXh0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm4ubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4IDwgdGFza3MubGVuZ3RoIC0gMSkgPyBtYWtlQ2FsbGJhY2soaW5kZXggKyAxKTogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYWtlQ2FsbGJhY2soMCk7XG4gICAgfTtcblxuICAgIGFzeW5jLmFwcGx5ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShcbiAgICAgICAgICAgICAgICBudWxsLCBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIF9jb25jYXQgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGZuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2IpIHtcbiAgICAgICAgICAgIGZuKHgsIGZ1bmN0aW9uIChlcnIsIHkpIHtcbiAgICAgICAgICAgICAgICByID0gci5jb25jYXQoeSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmNvbmNhdCA9IGRvUGFyYWxsZWwoX2NvbmNhdCk7XG4gICAgYXN5bmMuY29uY2F0U2VyaWVzID0gZG9TZXJpZXMoX2NvbmNhdCk7XG5cbiAgICBhc3luYy53aGlsc3QgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0ZXN0KCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy53aGlsc3QodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5kb1doaWxzdCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgaWYgKHRlc3QuYXBwbHkobnVsbCwgYXJncykpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1doaWxzdChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnVudGlsID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLnVudGlsKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9VbnRpbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgaWYgKCF0ZXN0LmFwcGx5KG51bGwsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9VbnRpbChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbmN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHBvcywgY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoIXEuc3RhcnRlZCl7XG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgIHJldHVybiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgIGlmIChxLmRyYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHEudGFza3MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocS5zYXR1cmF0ZWQgJiYgcS50YXNrcy5sZW5ndGggPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29ya2VycyA9IDA7XG4gICAgICAgIHZhciBxID0ge1xuICAgICAgICAgICAgdGFza3M6IFtdLFxuICAgICAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcbiAgICAgICAgICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcGF1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2lsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBxLmRyYWluID0gbnVsbDtcbiAgICAgICAgICAgICAgcS50YXNrcyA9IFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFxLnBhdXNlZCAmJiB3b3JrZXJzIDwgcS5jb25jdXJyZW5jeSAmJiBxLnRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHEudGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEuZW1wdHkgJiYgcS50YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VycyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2suY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbiAmJiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25seV9vbmNlKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIodGFzay5kYXRhLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWRsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gdHJ1ZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gY2FsbCBxLnByb2Nlc3Mgb25jZSBwZXIgY29uY3VycmVudFxuICAgICAgICAgICAgICAgIC8vIHdvcmtlciB0byBwcmVzZXJ2ZSBmdWxsIGNvbmN1cnJlbmN5IGFmdGVyIHBhdXNlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDE7IHcgPD0gcS5jb25jdXJyZW5jeTsgdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIGFzeW5jLnByaW9yaXR5UXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuXG4gICAgICAgIGZ1bmN0aW9uIF9jb21wYXJlVGFza3MoYSwgYil7XG4gICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5hcnlTZWFyY2goc2VxdWVuY2UsIGl0ZW0sIGNvbXBhcmUpIHtcbiAgICAgICAgICB2YXIgYmVnID0gLTEsXG4gICAgICAgICAgICAgIGVuZCA9IHNlcXVlbmNlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGJlZyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IGJlZyArICgoZW5kIC0gYmVnICsgMSkgPj4+IDEpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmUoaXRlbSwgc2VxdWVuY2VbbWlkXSkgPj0gMCkge1xuICAgICAgICAgICAgICBiZWcgPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmVnO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoIXEuc3RhcnRlZCl7XG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgIHJldHVybiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgIGlmIChxLmRyYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoX2JpbmFyeVNlYXJjaChxLnRhc2tzLCBpdGVtLCBfY29tcGFyZVRhc2tzKSArIDEsIDAsIGl0ZW0pO1xuXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYSBub3JtYWwgcXVldWVcbiAgICAgICAgdmFyIHEgPSBhc3luYy5xdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcblxuICAgICAgICAvLyBPdmVycmlkZSBwdXNoIHRvIGFjY2VwdCBzZWNvbmQgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBwcmlvcml0eVxuICAgICAgICBxLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgX2luc2VydChxLCBkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlbW92ZSB1bnNoaWZ0IGZ1bmN0aW9uXG4gICAgICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XG5cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIGFzeW5jLmNhcmdvID0gZnVuY3Rpb24gKHdvcmtlciwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgd29ya2luZyAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHRhc2tzICAgICAgID0gW107XG5cbiAgICAgICAgdmFyIGNhcmdvID0ge1xuICAgICAgICAgICAgdGFza3M6IHRhc2tzLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBkcmFpbmVkOiB0cnVlLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmdvLmRyYWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmdvLnNhdHVyYXRlZCAmJiB0YXNrcy5sZW5ndGggPT09IHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmdvLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGNhcmdvLnByb2Nlc3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNhcmdvLmRyYWluICYmICFjYXJnby5kcmFpbmVkKSBjYXJnby5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICBjYXJnby5kcmFpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0cyA9IHR5cGVvZiBwYXlsb2FkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFza3Muc3BsaWNlKDAsIHBheWxvYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXNrcy5zcGxpY2UoMCwgdGFza3MubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIHZhciBkcyA9IF9tYXAodHMsIGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZihjYXJnby5lbXB0eSkgY2FyZ28uZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB3b3JraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3b3JrZXIoZHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBfZWFjaCh0cywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjay5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JraW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FyZ287XG4gICAgfTtcblxuICAgIHZhciBfY29uc29sZV9mbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xuICAgIGFzeW5jLmRpciA9IF9jb25zb2xlX2ZuKCdkaXInKTtcbiAgICAvKmFzeW5jLmluZm8gPSBfY29uc29sZV9mbignaW5mbycpO1xuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xuICAgIGFzeW5jLmVycm9yID0gX2NvbnNvbGVfZm4oJ2Vycm9yJyk7Ki9cblxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xuICAgICAgICB2YXIgbWVtbyA9IHt9O1xuICAgICAgICB2YXIgcXVldWVzID0ge307XG4gICAgICAgIGhhc2hlciA9IGhhc2hlciB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBtZW1vKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XG4gICAgICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH07XG5cbiAgICBhc3luYy51bm1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcChjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lc1NlcmllcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXBTZXJpZXMoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VxID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIGFzeW5jLnJlZHVjZShmbnMsIGFyZ3MsIGZ1bmN0aW9uIChuZXdhcmdzLCBmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjYihlcnIsIG5leHRhcmdzKTtcbiAgICAgICAgICAgICAgICB9XSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY29tcG9zZSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgIHJldHVybiBhc3luYy5zZXEuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgdmFyIF9hcHBseUVhY2ggPSBmdW5jdGlvbiAoZWFjaGZuLCBmbnMgLyphcmdzLi4uKi8pIHtcbiAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCBmdW5jdGlvbiAoZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncy5jb25jYXQoW2NiXSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ287XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLmFwcGx5RWFjaCA9IGRvUGFyYWxsZWwoX2FwcGx5RWFjaCk7XG4gICAgYXN5bmMuYXBwbHlFYWNoU2VyaWVzID0gZG9TZXJpZXMoX2FwcGx5RWFjaCk7XG5cbiAgICBhc3luYy5mb3JldmVyID0gZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG5cbiAgICAvLyBOb2RlLmpzXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4gICAgfVxuICAgIC8vIEFNRCAvIFJlcXVpcmVKU1xuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlZCBkaXJlY3RseSB2aWEgPHNjcmlwdD4gdGFnXG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBhc3luYztcbiAgICB9XG5cbn0oKSk7XG4iLCJ2YXIgYXN5bmMgICAgICAgPSByZXF1aXJlKCdhc3luYycpLFxuICAgIHVybFBhcnNlciAgID0gcmVxdWlyZSgndXJsJyksXG4gICAgUmVzb3VyY2UgICAgPSByZXF1aXJlKCcuL1Jlc291cmNlJyksXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0YXRlIGFuZCBsb2FkaW5nIG9mIG11bHRpcGxlIHJlc291cmNlcyB0byBsb2FkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIFtiYXNlVXJsPScnXSB7c3RyaW5nfSBUaGUgYmFzZSB1cmwgZm9yIGFsbCByZXNvdXJjZXMgbG9hZGVkIGJ5IHRoaXMgbG9hZGVyLlxuICogQHBhcmFtIFtjb25jdXJyZW5jeT0xMF0ge251bWJlcn0gVGhlIG51bWJlciBvZiByZXNvdXJjZXMgdG8gbG9hZCBjb25jdXJyZW50bHkuXG4gKi9cbmZ1bmN0aW9uIExvYWRlcihiYXNlVXJsLCBjb25jdXJyZW5jeSkge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeSB8fCAxMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIHVybCBmb3IgYWxsIHJlc291cmNlcyBsb2FkZWQgYnkgdGhpcyBsb2FkZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybCB8fCAnJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcm9ncmVzcyBwZXJjZW50IG9mIHRoZSBsb2FkZXIgZ29pbmcgdGhyb3VnaCB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBMb2FkaW5nIHN0YXRlIG9mIHRoZSBsb2FkZXIsIHRydWUgaWYgaXQgaXMgY3VycmVudGx5IGxvYWRpbmcgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwZXJjZW50YWdlIG9mIHRvdGFsIHByb2dyZXNzIHRoYXQgYSBzaW5nbGUgcmVzb3VyY2UgcmVwcmVzZW50cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9wcm9ncmVzc0NodW5rID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaWRkbGV3YXJlIHRvIHJ1biBiZWZvcmUgbG9hZGluZyBlYWNoIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7ZnVuY3Rpb25bXX1cbiAgICAgKi9cbiAgICB0aGlzLl9iZWZvcmVNaWRkbGV3YXJlID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWlkZGxld2FyZSB0byBydW4gYWZ0ZXIgbG9hZGluZyBlYWNoIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7ZnVuY3Rpb25bXX1cbiAgICAgKi9cbiAgICB0aGlzLl9hZnRlck1pZGRsZXdhcmUgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgX2xvYWRSZXNvdXJjZWAgZnVuY3Rpb24gYm91bmQgd2l0aCB0aGlzIG9iamVjdCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9ib3VuZExvYWRSZXNvdXJjZSA9IHRoaXMuX2xvYWRSZXNvdXJjZS5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBfb25Mb2FkYCBmdW5jdGlvbiBib3VuZCB3aXRoIHRoaXMgb2JqZWN0IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2JvdW5kT25Mb2FkID0gdGhpcy5fb25Mb2FkLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb3VyY2UgYnVmZmVyIHRoYXQgZmlsbHMgdW50aWwgYGxvYWRgIGlzIGNhbGxlZCB0byBzdGFydCBsb2FkaW5nIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlciB7UmVzb3VyY2VbXX1cbiAgICAgKi9cbiAgICB0aGlzLl9idWZmZXIgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdHJhY2sgbG9hZCBjb21wbGV0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fbnVtVG9Mb2FkID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXNvdXJjZXMgd2FpdGluZyB0byBiZSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge1Jlc291cmNlW119XG4gICAgICovXG4gICAgdGhpcy5fcXVldWUgPSBhc3luYy5xdWV1ZSh0aGlzLl9ib3VuZExvYWRSZXNvdXJjZSwgY29uY3VycmVuY3kpO1xuXG4gICAgLyoqXG4gICAgICogQWxsIHRoZSByZXNvdXJjZXMgZm9yIHRoaXMgbG9hZGVyIGtleWVkIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3Q8c3RyaW5nLCBSZXNvdXJjZT59XG4gICAgICovXG4gICAgdGhpcy5yZXNvdXJjZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgb25jZSBwZXIgbG9hZGVkIG9yIGVycm9yZWQgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgcHJvZ3Jlc3NcbiAgICAgKiBAbWVtYmVyb2YgTG9hZGVyI1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBvbmNlIHBlciBlcnJvcmVkIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQGV2ZW50IGVycm9yXG4gICAgICogQG1lbWJlcm9mIExvYWRlciNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgb25jZSBwZXIgbG9hZGVkIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQGV2ZW50IGxvYWRcbiAgICAgKiBAbWVtYmVyb2YgTG9hZGVyI1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBsb2FkZXIgYmVnaW5zIHRvIHByb2Nlc3MgdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQGV2ZW50IHN0YXJ0XG4gICAgICogQG1lbWJlcm9mIExvYWRlciNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgcXVldWVkIHJlc291cmNlcyBhbGwgbG9hZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjb21wbGV0ZVxuICAgICAqIEBtZW1iZXJvZiBMb2FkZXIjXG4gICAgICovXG59XG5cbkxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuTG9hZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvYWRlcjtcbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyO1xuXG4vKipcbiAqIEFkZHMgYSByZXNvdXJjZSAob3IgbXVsdGlwbGUgcmVzb3VyY2VzKSB0byB0aGUgbG9hZGVyIHF1ZXVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIHRha2UgYSB3aWRlIHZhcmlldHkgb2YgZGlmZmVyZW50IHBhcmFtZXRlcnMuIFRoZSBvbmx5IHRoaW5nIHRoYXQgaXMgYWx3YXlzXG4gKiByZXF1aXJlZCB0aGUgdXJsIHRvIGxvYWQuIEFsbCB0aGUgZm9sbG93aW5nIHdpbGwgd29yazpcbiAqXG4gKiBgYGBqc1xuICogbG9hZGVyXG4gKiAgICAgLy8gbm9ybWFsIHBhcmFtIHN5bnRheFxuICogICAgIC5hZGQoJ2tleScsICdodHRwOi8vLi4uJywgZnVuY3Rpb24gKCkge30pXG4gKiAgICAgLmFkZCgnaHR0cDovLy4uLicsIGZ1bmN0aW9uICgpIHt9KVxuICogICAgIC5hZGQoJ2h0dHA6Ly8uLi4nKVxuICpcbiAqICAgICAvLyBvYmplY3Qgc3ludGF4XG4gKiAgICAgLmFkZCh7XG4gKiAgICAgICAgIG5hbWU6ICdrZXkyJyxcbiAqICAgICAgICAgdXJsOiAnaHR0cDovLy4uLidcbiAqICAgICB9LCBmdW5jdGlvbiAoKSB7fSlcbiAqICAgICAuYWRkKHtcbiAqICAgICAgICAgdXJsOiAnaHR0cDovLy4uLidcbiAqICAgICB9LCBmdW5jdGlvbiAoKSB7fSlcbiAqICAgICAuYWRkKHtcbiAqICAgICAgICAgbmFtZTogJ2tleTMnLFxuICogICAgICAgICB1cmw6ICdodHRwOi8vLi4uJ1xuICogICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fVxuICogICAgIH0pXG4gKiAgICAgLmFkZCh7XG4gKiAgICAgICAgIHVybDogJ2h0dHBzOi8vLi4uJyxcbiAqICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge30sXG4gKiAgICAgICAgIGNyb3NzT3JpZ2luOiB0cnVlXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8geW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciB1cmxzIG9yIGJvdGhcbiAqICAgICAuYWRkKFtcbiAqICAgICAgICAgeyBuYW1lOiAna2V5NCcsIHVybDogJ2h0dHA6Ly8uLi4nLCBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fSB9LFxuICogICAgICAgICB7IHVybDogJ2h0dHA6Ly8uLi4nLCBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fSB9LFxuICogICAgICAgICAnaHR0cDovLy4uLidcbiAqICAgICBdKTtcbiAqIGBgYFxuICpcbiAqIEBhbGlhcyBlbnF1ZXVlXG4gKiBAcGFyYW0gW25hbWVdIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSByZXNvdXJjZSB0byBsb2FkLCBpZiBub3QgcGFzc2VkIHRoZSB1cmwgaXMgdXNlZC5cbiAqIEBwYXJhbSB1cmwge3N0cmluZ30gVGhlIHVybCBmb3IgdGhpcyByZXNvdXJjZSwgcmVsYXRpdmUgdG8gdGhlIGJhc2VVcmwgb2YgdGhpcyBsb2FkZXIuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHtvYmplY3R9IFRoZSBvcHRpb25zIGZvciB0aGUgbG9hZC5cbiAqIEBwYXJhbSBbb3B0aW9ucy5jcm9zc09yaWdpbl0ge2Jvb2xlYW59IElzIHRoaXMgcmVxdWVzdCBjcm9zcy1vcmlnaW4/IERlZmF1bHQgaXMgdG8gZGV0ZXJtaW5lIGF1dG9tYXRpY2FsbHkuXG4gKiBAcGFyYW0gW29wdGlvbnMubG9hZFR5cGU9UmVzb3VyY2UuTE9BRF9UWVBFLlhIUl0ge1Jlc291cmNlLlhIUl9MT0FEX1RZUEV9IEhvdyBzaG91bGQgdGhpcyByZXNvdXJjZSBiZSBsb2FkZWQ/XG4gKiBAcGFyYW0gW29wdGlvbnMueGhyVHlwZT1SZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ERUZBVUxUXSB7UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEV9IEhvdyBzaG91bGQgdGhlIGRhdGEgYmVpbmdcbiAqICAgICAgbG9hZGVkIGJlIGludGVycHJldGVkIHdoZW4gdXNpbmcgWEhSP1xuICogQHBhcmFtIFtjYWxsYmFja10ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBzcGVjaWZpYyByZXNvdXJjZSBjb21wbGV0ZXMgbG9hZGluZy5cbiAqIEByZXR1cm4ge0xvYWRlcn1cbiAqL1xuTG9hZGVyLnByb3RvdHlwZS5hZGQgPSBMb2FkZXIucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAobmFtZSwgdXJsLCBvcHRpb25zLCBjYikge1xuICAgIC8vIHNwZWNpYWwgY2FzZSBvZiBhbiBhcnJheSBvZiBvYmplY3RzIG9yIHVybHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKG5hbWVbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gaWYgYW4gb2JqZWN0IGlzIHBhc3NlZCBpbnN0ZWFkIG9mIHBhcmFtc1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY2IgPSB1cmwgfHwgbmFtZS5jYWxsYmFjayB8fCBuYW1lLm9uQ29tcGxldGU7XG4gICAgICAgIG9wdGlvbnMgPSBuYW1lO1xuICAgICAgICB1cmwgPSBuYW1lLnVybDtcbiAgICAgICAgbmFtZSA9IG5hbWUubmFtZSB8fCBuYW1lLmtleSB8fCBuYW1lLnVybDtcbiAgICB9XG5cbiAgICAvLyBjYXNlIHdoZXJlIG5vIG5hbWUgaXMgcGFzc2VkIHNoaWZ0IGFsbCBhcmdzIG92ZXIgYnkgb25lLlxuICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB1cmw7XG4gICAgICAgIHVybCA9IG5hbWU7XG4gICAgfVxuXG4gICAgLy8gbm93IHRoYXQgd2Ugc2hpZnRlZCBtYWtlIHN1cmUgd2UgaGF2ZSBhIHByb3BlciB1cmwuXG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdXJsIHBhc3NlZCB0byBhZGQgcmVzb3VyY2UgdG8gbG9hZGVyLicpO1xuICAgIH1cblxuICAgIC8vIG9wdGlvbnMgYXJlIG9wdGlvbmFsIHNvIHBlb3BsZSBtaWdodCBwYXNzIGEgZnVuY3Rpb24gYW5kIG5vIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiByZXNvdXJjZSBhbHJlYWR5IGV4aXN0cy5cbiAgICBpZiAodGhpcy5yZXNvdXJjZXNbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNvdXJjZSB3aXRoIG5hbWUgXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4nKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYmFzZSB1cmwgaWYgdGhpcyBpc24ndCBhbiBhYnNvbHV0ZSB1cmxcbiAgICB1cmwgPSB0aGlzLl9oYW5kbGVCYXNlVXJsKHVybCk7XG5cbiAgICAvLyBjcmVhdGUgdGhlIHN0b3JlIHRoZSByZXNvdXJjZVxuICAgIHRoaXMucmVzb3VyY2VzW25hbWVdID0gbmV3IFJlc291cmNlKG5hbWUsIHVybCwgb3B0aW9ucyk7XG5cbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVzb3VyY2VzW25hbWVdLm9uY2UoJ2FmdGVyTWlkZGxld2FyZScsIGNiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9udW1Ub0xvYWQrKztcblxuICAgIC8vIGlmIGFscmVhZHkgbG9hZGluZyBhZGQgaXQgdG8gdGhlIHdvcmtlciBxdWV1ZVxuICAgIGlmICh0aGlzLl9xdWV1ZS5zdGFydGVkKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGhpcy5yZXNvdXJjZXNbbmFtZV0pO1xuICAgICAgICB0aGlzLl9wcm9ncmVzc0NodW5rID0gKDEwMCAtIHRoaXMucHJvZ3Jlc3MpIC8gKHRoaXMuX3F1ZXVlLmxlbmd0aCgpICsgdGhpcy5fcXVldWUucnVubmluZygpKTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIGJ1ZmZlciBpdCB0byBiZSBhZGRlZCB0byB0aGUgcXVldWUgbGF0ZXJcbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyLnB1c2godGhpcy5yZXNvdXJjZXNbbmFtZV0pO1xuICAgICAgICB0aGlzLl9wcm9ncmVzc0NodW5rID0gMTAwIC8gdGhpcy5fYnVmZmVyLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkxvYWRlci5wcm90b3R5cGUuX2hhbmRsZUJhc2VVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgdmFyIHBhcnNlZFVybCA9IHVybFBhcnNlci5wYXJzZSh1cmwpO1xuXG4gICAgLy8gYWJzb2x1dGUgdXJsLCBqdXN0IHVzZSBpdCBhcyBpcy5cbiAgICBpZiAocGFyc2VkVXJsLnByb3RvY29sIHx8IHBhcnNlZFVybC5wYXRobmFtZS5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgLy8gaWYgYmFzZVVybCBkb2Vzbid0IGVuZCBpbiBzbGFzaCBhbmQgdXJsIGRvZXNuJ3Qgc3RhcnQgd2l0aCBzbGFzaCwgdGhlbiBhZGQgYSBzbGFzaCBpbmJldHdlZW5cbiAgICBpZiAoXG4gICAgICAgIHRoaXMuYmFzZVVybC5sZW5ndGggJiZcbiAgICAgICAgdGhpcy5iYXNlVXJsLmxhc3RJbmRleE9mKCcvJykgIT09IHRoaXMuYmFzZVVybC5sZW5ndGggLSAxICYmXG4gICAgICAgIHVybC5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlVXJsICsgJy8nICsgdXJsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVVybCArIHVybDtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogU2V0cyB1cCBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdGhhdCB3aWxsIHJ1biAqYmVmb3JlKiB0aGVcbiAqIHJlc291cmNlIGlzIGxvYWRlZC5cbiAqXG4gKiBAYWxpYXMgcHJlXG4gKiBAcGFyYW0gbWlkZGxld2FyZSB7ZnVuY3Rpb259IFRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyLlxuICogQHJldHVybiB7TG9hZGVyfVxuICovXG5Mb2FkZXIucHJvdG90eXBlLmJlZm9yZSA9IExvYWRlci5wcm90b3R5cGUucHJlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdGhpcy5fYmVmb3JlTWlkZGxld2FyZS5wdXNoKGZuKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0aGF0IHdpbGwgcnVuICphZnRlciogdGhlXG4gKiByZXNvdXJjZSBpcyBsb2FkZWQuXG4gKlxuICogQGFsaWFzIHVzZVxuICogQHBhcmFtIG1pZGRsZXdhcmUge2Z1bmN0aW9ufSBUaGUgbWlkZGxld2FyZSBmdW5jdGlvbiB0byByZWdpc3Rlci5cbiAqIEByZXR1cm4ge0xvYWRlcn1cbiAqL1xuTG9hZGVyLnByb3RvdHlwZS5hZnRlciA9IExvYWRlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdGhpcy5fYWZ0ZXJNaWRkbGV3YXJlLnB1c2goZm4pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgcXVldWUgb2YgdGhlIGxvYWRlciB0byBwcmVwYXJlIGZvciBhIG5ldyBsb2FkLlxuICpcbiAqIEByZXR1cm4ge0xvYWRlcn1cbiAqL1xuTG9hZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsIHx8ICcnO1xuXG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XG5cbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX3Byb2dyZXNzQ2h1bmsgPSAwO1xuXG4gICAgLy8gdGhpcy5fYmVmb3JlTWlkZGxld2FyZS5sZW5ndGggPSAwO1xuICAgIC8vIHRoaXMuX2FmdGVyTWlkZGxld2FyZS5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5fYnVmZmVyLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLl9udW1Ub0xvYWQgPSAwO1xuXG4gICAgdGhpcy5fcXVldWUua2lsbCgpO1xuICAgIHRoaXMuX3F1ZXVlLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMucmVzb3VyY2VzID0ge307XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBsb2FkaW5nIHRoZSBxdWV1ZWQgcmVzb3VyY2VzLlxuICpcbiAqIEBmaXJlcyBzdGFydFxuICogQHBhcmFtIFtjYWxsYmFja10ge2Z1bmN0aW9ufSBPcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgYm91bmQgdG8gdGhlIGBjb21wbGV0ZWAgZXZlbnQuXG4gKiBAcmV0dXJuIHtMb2FkZXJ9XG4gKi9cbkxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjYikge1xuICAgIC8vIHJlZ2lzdGVyIGNvbXBsZXRlIGNhbGxiYWNrIGlmIHRoZXkgcGFzcyBvbmVcbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMub25jZSgnY29tcGxldGUnLCBjYik7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHF1ZXVlIGhhcyBhbHJlYWR5IHN0YXJ0ZWQgd2UgYXJlIGRvbmUgaGVyZVxuICAgIGlmICh0aGlzLl9xdWV1ZS5zdGFydGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIG5vdGlmeSBvZiBzdGFydFxuICAgIHRoaXMuZW1pdCgnc3RhcnQnLCB0aGlzKTtcblxuICAgIC8vIHN0YXJ0IHRoZSBpbnRlcm5hbCBxdWV1ZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGhpcy5fYnVmZmVyW2ldKTtcbiAgICB9XG5cbiAgICAvLyBlbXB0eSB0aGUgYnVmZmVyXG4gICAgdGhpcy5fYnVmZmVyLmxlbmd0aCA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTG9hZHMgYSBzaW5nbGUgcmVzb3VyY2UuXG4gKlxuICogQGZpcmVzIHByb2dyZXNzXG4gKiBAcHJpdmF0ZVxuICovXG5Mb2FkZXIucHJvdG90eXBlLl9sb2FkUmVzb3VyY2UgPSBmdW5jdGlvbiAocmVzb3VyY2UsIGRlcXVldWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXNvdXJjZS5fZGVxdWV1ZSA9IGRlcXVldWU7XG5cbiAgICB0aGlzLl9ydW5NaWRkbGV3YXJlKHJlc291cmNlLCB0aGlzLl9iZWZvcmVNaWRkbGV3YXJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlc291cmNlLm9uKCdwcm9ncmVzcycsIHNlbGYuZW1pdC5iaW5kKHNlbGYsICdwcm9ncmVzcycpKTtcblxuICAgICAgICByZXNvdXJjZS5sb2FkKHNlbGYuX2JvdW5kT25Mb2FkKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uY2UgZWFjaCByZXNvdXJjZSBoYXMgbG9hZGVkLlxuICpcbiAqIEBmaXJlcyBjb21wbGV0ZVxuICogQHByaXZhdGVcbiAqL1xuTG9hZGVyLnByb3RvdHlwZS5fb25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVtaXQoJ2NvbXBsZXRlJywgdGhpcywgdGhpcy5yZXNvdXJjZXMpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgZWFjaCB0aW1lIGEgcmVzb3VyY2VzIGlzIGxvYWRlZC5cbiAqXG4gKiBAZmlyZXMgcHJvZ3Jlc3NcbiAqIEBmaXJlcyBlcnJvclxuICogQGZpcmVzIGxvYWRcbiAqIEBwcml2YXRlXG4gKi9cbkxvYWRlci5wcm90b3R5cGUuX29uTG9hZCA9IGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgIHRoaXMucHJvZ3Jlc3MgKz0gdGhpcy5fcHJvZ3Jlc3NDaHVuaztcblxuICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLCByZXNvdXJjZSk7XG5cbiAgICAvLyBydW4gbWlkZGxld2FyZSwgdGhpcyAqbXVzdCogaGFwcGVuIGJlZm9yZSBkZXF1ZXVlIHNvIHN1Yi1hc3NldHMgZ2V0IGFkZGVkIHByb3Blcmx5XG4gICAgdGhpcy5fcnVuTWlkZGxld2FyZShyZXNvdXJjZSwgdGhpcy5fYWZ0ZXJNaWRkbGV3YXJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc291cmNlLmVtaXQoJ2FmdGVyTWlkZGxld2FyZScsIHJlc291cmNlKTtcblxuICAgICAgICB0aGlzLl9udW1Ub0xvYWQtLTtcblxuICAgICAgICAvLyBkbyBjb21wbGV0aW9uIGNoZWNrXG4gICAgICAgIGlmICh0aGlzLl9udW1Ub0xvYWQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAxMDA7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChyZXNvdXJjZS5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHJlc291cmNlLmVycm9yLCB0aGlzLCByZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2xvYWQnLCB0aGlzLCByZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcblxuXG4gICAgLy8gcmVtb3ZlIHRoaXMgcmVzb3VyY2UgZnJvbSB0aGUgYXN5bmMgcXVldWVcbiAgICByZXNvdXJjZS5fZGVxdWV1ZSgpO1xufTtcblxuLyoqXG4gKiBSdW4gbWlkZGxld2FyZSBmdW5jdGlvbnMgb24gYSByZXNvdXJjZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5Mb2FkZXIucHJvdG90eXBlLl9ydW5NaWRkbGV3YXJlID0gZnVuY3Rpb24gKHJlc291cmNlLCBmbnMsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgYXN5bmMuZWFjaFNlcmllcyhmbnMsIGZ1bmN0aW9uIChmbiwgbmV4dCkge1xuICAgICAgICBmbi5jYWxsKHNlbGYsIHJlc291cmNlLCBuZXh0KTtcbiAgICB9LCBjYi5iaW5kKHRoaXMsIHJlc291cmNlKSk7XG59O1xuXG5Mb2FkZXIuTE9BRF9UWVBFID0gUmVzb3VyY2UuTE9BRF9UWVBFO1xuTG9hZGVyLlhIUl9SRUFEWV9TVEFURSA9IFJlc291cmNlLlhIUl9SRUFEWV9TVEFURTtcbkxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRSA9IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFO1xuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKSxcbiAgICBfdXJsID0gcmVxdWlyZSgndXJsJyksXG4gICAgLy8gdGVzdHMgaXMgQ09SUyBpcyBzdXBwb3J0ZWQgaW4gWEhSLCBpZiBub3Qgd2UgbmVlZCB0byB1c2UgWERSXG4gICAgdXNlWGRyID0gISEod2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gKG5ldyBYTUxIdHRwUmVxdWVzdCgpKSkpLFxuICAgIHRlbXBBbmNob3IgPSBudWxsO1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0YXRlIGFuZCBsb2FkaW5nIG9mIGEgc2luZ2xlIHJlc291cmNlIHJlcHJlc2VudGVkIGJ5XG4gKiBhIHNpbmdsZSBVUkwuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgcmVzb3VyY2UgdG8gbG9hZC5cbiAqIEBwYXJhbSB1cmwge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHVybCBmb3IgdGhpcyByZXNvdXJjZSwgZm9yIGF1ZGlvL3ZpZGVvIGxvYWRzIHlvdSBjYW4gcGFzcyBhbiBhcnJheSBvZiBzb3VyY2VzLlxuICogQHBhcmFtIFtvcHRpb25zXSB7b2JqZWN0fSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvYWQuXG4gKiBAcGFyYW0gW29wdGlvbnMuY3Jvc3NPcmlnaW5dIHtzdHJpbmd8Ym9vbGVhbn0gSXMgdGhpcyByZXF1ZXN0IGNyb3NzLW9yaWdpbj8gRGVmYXVsdCBpcyB0byBkZXRlcm1pbmUgYXV0b21hdGljYWxseS5cbiAqIEBwYXJhbSBbb3B0aW9ucy5sb2FkVHlwZT1SZXNvdXJjZS5MT0FEX1RZUEUuWEhSXSB7UmVzb3VyY2UuTE9BRF9UWVBFfSBIb3cgc2hvdWxkIHRoaXMgcmVzb3VyY2UgYmUgbG9hZGVkP1xuICogQHBhcmFtIFtvcHRpb25zLnhoclR5cGU9UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuREVGQVVMVF0ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSBIb3cgc2hvdWxkIHRoZSBkYXRhIGJlaW5nXG4gKiAgICAgIGxvYWRlZCBiZSBpbnRlcnByZXRlZCB3aGVuIHVzaW5nIFhIUj9cbiAqIEBwYXJhbSBbb3B0aW9ucy5tZXRhZGF0YV0ge29iamVjdH0gRXh0cmEgaW5mbyBmb3IgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gUmVzb3VyY2UobmFtZSwgdXJsLCBvcHRpb25zKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIG5hbWUgYW5kIHVybCBhcmUgcmVxdWlyZWQgZm9yIGNvbnN0cnVjdGluZyBhIHJlc291cmNlLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cmwgdXNlZCB0byBsb2FkIHRoaXMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy51cmwgPSB1cmw7XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgd2hldGhlciBvciBub3QgdGhpcyB1cmwgaXMgYSBkYXRhIHVybC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5pc0RhdGFVcmwgPSB0aGlzLnVybC5pbmRleE9mKCdkYXRhOicpID09PSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgdGhhdCB3YXMgbG9hZGVkIGJ5IHRoZSByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2FueX1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSXMgdGhpcyByZXF1ZXN0IGNyb3NzLW9yaWdpbj8gSWYgdW5zZXQsIGRldGVybWluZWQgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICdhbm9ueW1vdXMnIDogb3B0aW9ucy5jcm9zc09yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2Qgb2YgbG9hZGluZyB0byB1c2UgZm9yIHRoaXMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtSZXNvdXJjZS5MT0FEX1RZUEV9XG4gICAgICovXG4gICAgdGhpcy5sb2FkVHlwZSA9IG9wdGlvbnMubG9hZFR5cGUgfHwgdGhpcy5fZGV0ZXJtaW5lTG9hZFR5cGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIHVzZWQgdG8gbG9hZCB0aGUgcmVzb3VyY2UgdmlhIFhIUi4gSWYgdW5zZXQsIGRldGVybWluZWQgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnhoclR5cGUgPSBvcHRpb25zLnhoclR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYSBpbmZvIGZvciBtaWRkbGV3YXJlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5tZXRhZGF0YSA9IG9wdGlvbnMubWV0YWRhdGEgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXJyb3IgdGhhdCBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7RXJyb3J9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5lcnJvciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgWEhSIG9iamVjdCB0aGF0IHdhcyB1c2VkIHRvIGxvYWQgdGhpcyByZXNvdXJjZS4gVGhpcyBpcyBvbmx5IHNldFxuICAgICAqIHdoZW4gYGxvYWRUeXBlYCBpcyBgUmVzb3VyY2UuTE9BRF9UWVBFLlhIUmAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtYTUxIdHRwUmVxdWVzdH1cbiAgICAgKi9cbiAgICB0aGlzLnhociA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgaWYgdGhpcyByZXNvdXJjZSB3YXMgbG9hZGVkIGFzIGpzb24uIE9ubHkgdmFsaWQgYWZ0ZXIgdGhlIHJlc291cmNlXG4gICAgICogaGFzIGNvbXBsZXRlbHkgbG9hZGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzSnNvbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIGlmIHRoaXMgcmVzb3VyY2Ugd2FzIGxvYWRlZCBhcyB4bWwuIE9ubHkgdmFsaWQgYWZ0ZXIgdGhlIHJlc291cmNlXG4gICAgICogaGFzIGNvbXBsZXRlbHkgbG9hZGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzWG1sID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgaWYgdGhpcyByZXNvdXJjZSB3YXMgbG9hZGVkIGFzIGFuIGltYWdlIHRhZy4gT25seSB2YWxpZCBhZnRlciB0aGUgcmVzb3VyY2VcbiAgICAgKiBoYXMgY29tcGxldGVseSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNJbWFnZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIGlmIHRoaXMgcmVzb3VyY2Ugd2FzIGxvYWRlZCBhcyBhbiBhdWRpbyB0YWcuIE9ubHkgdmFsaWQgYWZ0ZXIgdGhlIHJlc291cmNlXG4gICAgICogaGFzIGNvbXBsZXRlbHkgbG9hZGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzQXVkaW8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyBpZiB0aGlzIHJlc291cmNlIHdhcyBsb2FkZWQgYXMgYSB2aWRlbyB0YWcuIE9ubHkgdmFsaWQgYWZ0ZXIgdGhlIHJlc291cmNlXG4gICAgICogaGFzIGNvbXBsZXRlbHkgbG9hZGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzVmlkZW8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgZGVxdWV1ZWAgbWV0aG9kIHRoYXQgd2lsbCBiZSB1c2VkIGEgc3RvcmFnZSBwbGFjZSBmb3IgdGhlIGFzeW5jIHF1ZXVlIGRlcXVldWUgbWV0aG9kXG4gICAgICogdXNlZCBwcml2YXRlbHkgYnkgdGhlIGxvYWRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVxdWV1ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYGNvbXBsZXRlYCBmdW5jdGlvbiBib3VuZCB0byB0aGlzIHJlc291cmNlJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYm91bmRDb21wbGV0ZSA9IHRoaXMuY29tcGxldGUuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgX29uRXJyb3JgIGZ1bmN0aW9uIGJvdW5kIHRvIHRoaXMgcmVzb3VyY2UncyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7ZnVuY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ib3VuZE9uRXJyb3IgPSB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYF9vblByb2dyZXNzYCBmdW5jdGlvbiBib3VuZCB0byB0aGlzIHJlc291cmNlJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYm91bmRPblByb2dyZXNzID0gdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpO1xuXG4gICAgLy8geGhyIGNhbGxiYWNrc1xuICAgIHRoaXMuX2JvdW5kWGhyT25FcnJvciA9IHRoaXMuX3hock9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZFhock9uQWJvcnQgPSB0aGlzLl94aHJPbkFib3J0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRYaHJPbkxvYWQgPSB0aGlzLl94aHJPbkxvYWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZFhkck9uVGltZW91dCA9IHRoaXMuX3hkck9uVGltZW91dC5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSByZXNvdXJjZSBiZWluZ3MgdG8gbG9hZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBzdGFydFxuICAgICAqIEBtZW1iZXJvZiBSZXNvdXJjZSNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgZWFjaCB0aW1lIHByb2dyZXNzIG9mIHRoaXMgcmVzb3VyY2UgbG9hZCB1cGRhdGVzLlxuICAgICAqIE5vdCBhbGwgcmVzb3VyY2VzIHR5cGVzIGFuZCBsb2FkZXIgc3lzdGVtcyBjYW4gc3VwcG9ydCB0aGlzIGV2ZW50XG4gICAgICogc28gc29tZXRpbWVzIGl0IG1heSBub3QgYmUgYXZhaWxhYmxlLiBJZiB0aGUgcmVzb3VyY2VcbiAgICAgKiBpcyBiZWluZyBsb2FkZWQgb24gYSBtb2Rlcm4gYnJvd3NlciwgdXNpbmcgWEhSLCBhbmQgdGhlIHJlbW90ZSBzZXJ2ZXJcbiAgICAgKiBwcm9wZXJseSBzZXRzIENvbnRlbnQtTGVuZ3RoIGhlYWRlcnMsIHRoZW4gdGhpcyB3aWxsIGJlIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBldmVudCBwcm9ncmVzc1xuICAgICAqIEBtZW1iZXJvZiBSZXNvdXJjZSNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgb25jZSB0aGlzIHJlc291cmNlIGhhcyBsb2FkZWQsIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBpdCB3aWxsXG4gICAgICogYmUgaW4gdGhlIGBlcnJvcmAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY29tcGxldGVcbiAgICAgKiBAbWVtYmVyb2YgUmVzb3VyY2UjXG4gICAgICovXG59XG5cblJlc291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5SZXNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXNvdXJjZTtcbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2U7XG5cbi8qKlxuICogTWFya3MgdGhlIHJlc291cmNlIGFzIGNvbXBsZXRlLlxuICpcbiAqIEBmaXJlcyBjb21wbGV0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETzogQ2xlYW4gdGhpcyB1cCBpbiBhIHdyYXBwZXIgb3Igc29tZXRoaW5nLi4uZ3Jvc3MuLi4uXG4gICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZE9uRXJyb3IpO1xuICAgICAgICB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kQ29tcGxldGUpO1xuICAgICAgICB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCB0aGlzLl9ib3VuZENvbXBsZXRlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy54aHIpIHtcbiAgICAgICAgaWYgKHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fYm91bmRYaHJPbkVycm9yKTtcbiAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpcy5fYm91bmRYaHJPbkFib3J0KTtcbiAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzKTtcbiAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9ib3VuZFhock9uTG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnhoci5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnhoci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMueGhyLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2NvbXBsZXRlJywgdGhpcyk7XG59O1xuXG4vKipcbiAqIEtpY2tzIG9mZiBsb2FkaW5nIG9mIHRoaXMgcmVzb3VyY2UuXG4gKlxuICogQGZpcmVzIHN0YXJ0XG4gKiBAcGFyYW0gW2NhbGxiYWNrXSB7ZnVuY3Rpb259IE9wdGlvbmFsIGNhbGxiYWNrIHRvIGNhbGwgb25jZSB0aGUgcmVzb3VyY2UgaXMgbG9hZGVkLlxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHRoaXMuZW1pdCgnc3RhcnQnLCB0aGlzKTtcblxuICAgIC8vIGlmIGEgY2FsbGJhY2sgaXMgc2V0LCBsaXN0ZW4gZm9yIGNvbXBsZXRlIGV2ZW50XG4gICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnY29tcGxldGUnLCBjYik7XG4gICAgfVxuXG4gICAgLy8gaWYgdW5zZXQsIGRldGVybWluZSB0aGUgdmFsdWVcbiAgICBpZiAodGhpcy5jcm9zc09yaWdpbiA9PT0gZmFsc2UgfHwgdHlwZW9mIHRoaXMuY3Jvc3NPcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB0aGlzLl9kZXRlcm1pbmVDcm9zc09yaWdpbih0aGlzLnVybCk7XG4gICAgfVxuXG4gICAgc3dpdGNoKHRoaXMubG9hZFR5cGUpIHtcbiAgICAgICAgY2FzZSBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0U6XG4gICAgICAgICAgICB0aGlzLl9sb2FkSW1hZ2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUmVzb3VyY2UuTE9BRF9UWVBFLkFVRElPOlxuICAgICAgICAgICAgdGhpcy5fbG9hZEVsZW1lbnQoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJlc291cmNlLkxPQURfVFlQRS5WSURFTzpcbiAgICAgICAgICAgIHRoaXMuX2xvYWRFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSZXNvdXJjZS5MT0FEX1RZUEUuWEhSOlxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHVzZVhkciAmJiB0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFhkcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFhocigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBJbWFnZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLl9sb2FkSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kYXRhID0gbmV3IEltYWdlKCk7XG5cbiAgICBpZiAodGhpcy5jcm9zc09yaWdpbikge1xuICAgICAgICB0aGlzLmRhdGEuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YS5zcmMgPSB0aGlzLnVybDtcblxuICAgIHRoaXMuaXNJbWFnZSA9IHRydWU7XG5cbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZE9uRXJyb3IsIGZhbHNlKTtcbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kQ29tcGxldGUsIGZhbHNlKTtcbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogTG9hZHMgdGhpcyByZXNvdXJjZXMgdXNpbmcgYW4gSFRNTEF1ZGlvRWxlbWVudCBvciBIVE1MVmlkZW9FbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5fbG9hZEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIHR5cGVvZiBBdWRpbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEF1ZGlvKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZWxlbWVudCAnICsgdHlwZSk7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnQgZm9yIENvY29vbkpTIENhbnZhcysgcnVudGltZSwgbGFja3MgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJylcbiAgICBpZiAobmF2aWdhdG9yLmlzQ29jb29uSlMpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNyYyA9IEFycmF5LmlzQXJyYXkodGhpcy51cmwpID8gdGhpcy51cmxbMF0gOiB0aGlzLnVybDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudXJsKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVybC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVTb3VyY2UodHlwZSwgdGhpcy51cmxbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVTb3VyY2UodHlwZSwgdGhpcy51cmwpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbJ2lzJyArIHR5cGVbMF0udG9VcHBlckNhc2UoKSArIHR5cGUuc3Vic3RyaW5nKDEpXSA9IHRydWU7XG5cbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZE9uRXJyb3IsIGZhbHNlKTtcbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kQ29tcGxldGUsIGZhbHNlKTtcbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCB0aGlzLl9ib3VuZENvbXBsZXRlLCBmYWxzZSk7XG5cbiAgICB0aGlzLmRhdGEubG9hZCgpO1xufTtcblxuLyoqXG4gKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBYTUxIdHRwUmVxdWVzdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX2xvYWRYaHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaWYgdW5zZXQsIGRldGVybWluZSB0aGUgdmFsdWVcbiAgICBpZiAodHlwZW9mIHRoaXMueGhyVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy54aHJUeXBlID0gdGhpcy5fZGV0ZXJtaW5lWGhyVHlwZSgpO1xuICAgIH1cblxuICAgIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gc2V0IHRoZSByZXF1ZXN0IHR5cGUgYW5kIHVybFxuICAgIHhoci5vcGVuKCdHRVQnLCB0aGlzLnVybCwgdHJ1ZSk7XG5cbiAgICAvLyBsb2FkIGpzb24gYXMgdGV4dCBhbmQgcGFyc2UgaXQgb3Vyc2VsdmVzLiBXZSBkbyB0aGlzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgIC8vICpjb3VnaCogc2FmYXJpICpjb3VnaCogY2FuJ3QgZGVhbCB3aXRoIGl0LlxuICAgIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkpTT04gfHwgdGhpcy54aHJUeXBlID09PSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLnhoclR5cGU7XG4gICAgfVxuXG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fYm91bmRYaHJPbkVycm9yLCBmYWxzZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpcy5fYm91bmRYaHJPbkFib3J0LCBmYWxzZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzLCBmYWxzZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9ib3VuZFhock9uTG9hZCwgZmFsc2UpO1xuXG4gICAgeGhyLnNlbmQoKTtcbn07XG5cbi8qKlxuICogTG9hZHMgdGhpcyByZXNvdXJjZXMgdXNpbmcgYW4gWERvbWFpblJlcXVlc3QuIFRoaXMgaXMgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gc3VwcG9ydCBJRTkgKGdyb3NzKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX2xvYWRYZHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaWYgdW5zZXQsIGRldGVybWluZSB0aGUgdmFsdWVcbiAgICBpZiAodHlwZW9mIHRoaXMueGhyVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy54aHJUeXBlID0gdGhpcy5fZGV0ZXJtaW5lWGhyVHlwZSgpO1xuICAgIH1cblxuICAgIHZhciB4ZHIgPSB0aGlzLnhociA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXG4gICAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmV3IHF1aXJrcy4gT2NjYXNpb25hbGx5IGl0IHdpbGwgYWJvcnQgcmVxdWVzdHNcbiAgICAvLyBBIHdheSB0byBhdm9pZCB0aGlzIGlzIHRvIG1ha2Ugc3VyZSBBTEwgY2FsbGJhY2tzIGFyZSBzZXQgZXZlbiBpZiBub3QgdXNlZFxuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1Nzg2OTY2L3hkb21haW5yZXF1ZXN0LWFib3J0cy1wb3N0LW9uLWllLTlcbiAgICB4ZHIudGltZW91dCA9IDUwMDA7XG5cbiAgICB4ZHIub25lcnJvciA9IHRoaXMuX2JvdW5kWGhyT25FcnJvcjtcbiAgICB4ZHIub250aW1lb3V0ID0gdGhpcy5fYm91bmRYZHJPblRpbWVvdXQ7XG4gICAgeGRyLm9ucHJvZ3Jlc3MgPSB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3M7XG4gICAgeGRyLm9ubG9hZCA9IHRoaXMuX2JvdW5kWGhyT25Mb2FkO1xuXG4gICAgeGRyLm9wZW4oJ0dFVCcsIHRoaXMudXJsLCB0cnVlKTtcblxuICAgIC8vICBOb3RlOiBUaGUgeGRyLnNlbmQoKSBjYWxsIGlzIHdyYXBwZWQgaW4gYSB0aW1lb3V0IHRvIHByZXZlbnQgYW4gaXNzdWUgd2l0aCB0aGUgaW50ZXJmYWNlIHdoZXJlIHNvbWUgcmVxdWVzdHMgYXJlIGxvc3RcbiAgICAvLyAgaWYgbXVsdGlwbGUgWERvbWFpblJlcXVlc3RzIGFyZSBiZWluZyBzZW50IGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gU29tZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvaXNzdWVzLzEyNDhcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgeGRyLnNlbmQoKTtcbiAgICB9LCAwKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNvdXJjZSB1c2VkIGluIGxvYWRpbmcgdmlhIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHR5cGUge3N0cmluZ30gVGhlIGVsZW1lbnQgdHlwZSAodmlkZW8gb3IgYXVkaW8pLlxuICogQHBhcmFtIHVybCB7c3RyaW5nfSBUaGUgc291cmNlIFVSTCB0byBsb2FkIGZyb20uXG4gKiBAcGFyYW0gW21pbWVdIHtzdHJpbmd9IFRoZSBtaW1lIHR5cGUgb2YgdGhlIHZpZGVvXG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX2NyZWF0ZVNvdXJjZSA9IGZ1bmN0aW9uICh0eXBlLCB1cmwsIG1pbWUpIHtcbiAgICBpZiAoIW1pbWUpIHtcbiAgICAgICAgbWltZSA9IHR5cGUgKyAnLycgKyB1cmwuc3Vic3RyKHVybC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuXG4gICAgc291cmNlLnNyYyA9IHVybDtcbiAgICBzb3VyY2UudHlwZSA9IG1pbWU7XG5cbiAgICByZXR1cm4gc291cmNlO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgYSBsb2FkIGVycm9ycyBvdXQuXG4gKlxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIGVycm9yIGV2ZW50IGZyb20gdGhlIGVsZW1lbnQgdGhhdCBlbWl0cyBpdC5cbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5fb25FcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZXJyb3IgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGVsZW1lbnQgdXNpbmcgJyArIGV2ZW50LnRhcmdldC5ub2RlTmFtZSk7XG4gICAgdGhpcy5jb21wbGV0ZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgYSBsb2FkIHByb2dyZXNzIGV2ZW50IGZpcmVzIGZvciB4aHIveGRyLlxuICpcbiAqIEBmaXJlcyBwcm9ncmVzc1xuICogQHBhcmFtIGV2ZW50IHtYTUxIdHRwUmVxdWVzdFByb2dyZXNzRXZlbnR8RXZlbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX29uUHJvZ3Jlc3MgPSAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRoaXMsIGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiBhbiBlcnJvciBldmVudCBmaXJlcyBmb3IgeGhyL3hkci5cbiAqXG4gKiBAcGFyYW0gZXZlbnQge1hNTEh0dHBSZXF1ZXN0RXJyb3JFdmVudHxFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5feGhyT25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICByZXFUeXBlKHRoaXMueGhyKSArICcgUmVxdWVzdCBmYWlsZWQuICcgK1xuICAgICAgICAnU3RhdHVzOiAnICsgdGhpcy54aHIuc3RhdHVzICsgJywgdGV4dDogXCInICsgdGhpcy54aHIuc3RhdHVzVGV4dCArICdcIidcbiAgICApO1xuXG4gICAgdGhpcy5jb21wbGV0ZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgYW4gYWJvcnQgZXZlbnQgZmlyZXMgZm9yIHhoci5cbiAqXG4gKiBAcGFyYW0gZXZlbnQge1hNTEh0dHBSZXF1ZXN0QWJvcnRFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5feGhyT25BYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVycm9yID0gbmV3IEVycm9yKHJlcVR5cGUodGhpcy54aHIpICsgJyBSZXF1ZXN0IHdhcyBhYm9ydGVkIGJ5IHRoZSB1c2VyLicpO1xuICAgIHRoaXMuY29tcGxldGUoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIGEgdGltZW91dCBldmVudCBmaXJlcyBmb3IgeGRyLlxuICpcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX3hkck9uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVycm9yID0gbmV3IEVycm9yKHJlcVR5cGUodGhpcy54aHIpICsgJyBSZXF1ZXN0IHRpbWVkIG91dC4nKTtcbiAgICB0aGlzLmNvbXBsZXRlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGRhdGEgc3VjY2Vzc2Z1bGx5IGxvYWRzIGZyb20gYW4geGhyL3hkciByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBldmVudCB7WE1MSHR0cFJlcXVlc3RMb2FkRXZlbnR8RXZlbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX3hock9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeGhyID0gdGhpcy54aHIsXG4gICAgICAgIHN0YXR1cyA9IHhoci5zdGF0dXMgIT09IHVuZGVmaW5lZCA/IHhoci5zdGF0dXMgOiAyMDA7IC8vWERSIGhhcyBubyBgLnN0YXR1c2AsIGFzc3VtZSAyMDAuXG5cbiAgICAvLyBzdGF0dXMgY2FuIGJlIDAgd2hlbiB1c2luZyB0aGUgZmlsZTovLyBwcm90b2NvbCwgYWxzbyBjaGVjayBpZiBhIHJlc3BvbnNlIHdhcyBmb3VuZFxuICAgIGlmIChzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNCB8fCAoc3RhdHVzID09PSAwICYmIHhoci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgLy8gaWYgdGV4dCwganVzdCByZXR1cm4gaXRcbiAgICAgICAgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBqc29uLCBwYXJzZSBpbnRvIGpzb24gb2JqZWN0XG4gICAgICAgIGVsc2UgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNKc29uID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBsb2FkZWQganNvbjonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB4bWwsIHBhcnNlIGludG8gYW4geG1sIGRvY3VtZW50IG9yIGRpdiBlbGVtZW50XG4gICAgICAgIGVsc2UgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbXBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZG9tcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0LCAndGV4dC94bWwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRpdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1htbCA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGxvYWRlZCB4bWw6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXIgdHlwZXMganVzdCByZXR1cm4gdGhlIHJlc3BvbnNlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0geGhyLnJlc3BvbnNlIHx8IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgRXJyb3IoJ1snICsgeGhyLnN0YXR1cyArICddJyArIHhoci5zdGF0dXNUZXh0ICsgJzonICsgeGhyLnJlc3BvbnNlVVJMKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlKCk7XG59O1xuXG5mdW5jdGlvbiByZXFUeXBlKHhocikge1xuICAgIHJldHVybiB4aHIudG9TdHJpbmcoKS5yZXBsYWNlKCdvYmplY3QgJywgJycpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGBjcm9zc09yaWdpbmAgcHJvcGVydHkgZm9yIHRoaXMgcmVzb3VyY2UgYmFzZWQgb24gaWYgdGhlIHVybFxuICogZm9yIHRoaXMgcmVzb3VyY2UgaXMgY3Jvc3Mtb3JpZ2luLiBJZiBjcm9zc09yaWdpbiB3YXMgbWFudWFsbHkgc2V0LCB0aGlzXG4gKiBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB1cmwge3N0cmluZ30gVGhlIHVybCB0byB0ZXN0LlxuICogQHBhcmFtIFtsb2NhdGlvbj13aW5kb3cubG9jYXRpb25dIHtvYmplY3R9IFRoZSBsb2NhdGlvbiBvYmplY3QgdG8gdGVzdCBhZ2FpbnN0LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY3Jvc3NPcmlnaW4gdmFsdWUgdG8gdXNlIChvciBlbXB0eSBzdHJpbmcgZm9yIG5vbmUpLlxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX2RldGVybWluZUNyb3NzT3JpZ2luID0gZnVuY3Rpb24gKHVybCwgbG9jKSB7XG4gICAgLy8gZGF0YTogYW5kIGphdmFzY3JpcHQ6IHVybHMgYXJlIGNvbnNpZGVyZWQgc2FtZS1vcmlnaW5cbiAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgaXMgd2luZG93LmxvY2F0aW9uXG4gICAgbG9jID0gbG9jIHx8IHdpbmRvdy5sb2NhdGlvbjtcblxuICAgIGlmICghdGVtcEFuY2hvcikge1xuICAgICAgICB0ZW1wQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIH1cblxuICAgIC8vIGxldCB0aGUgYnJvd3NlciBkZXRlcm1pbmUgdGhlIGZ1bGwgaHJlZiBmb3IgdGhlIHVybCBvZiB0aGlzIHJlc291cmNlIGFuZCB0aGVuXG4gICAgLy8gcGFyc2Ugd2l0aCB0aGUgbm9kZSB1cmwgbGliLCB3ZSBjYW4ndCB1c2UgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGFuY2hvciBlbGVtZW50XG4gICAgLy8gYmVjYXVzZSB0aGV5IGRvbid0IHdvcmsgaW4gSUU5IDooXG4gICAgdGVtcEFuY2hvci5ocmVmID0gdXJsO1xuICAgIHVybCA9IF91cmwucGFyc2UodGVtcEFuY2hvci5ocmVmKTtcblxuICAgIHZhciBzYW1lUG9ydCA9ICghdXJsLnBvcnQgJiYgbG9jLnBvcnQgPT09ICcnKSB8fCAodXJsLnBvcnQgPT09IGxvYy5wb3J0KTtcblxuICAgIC8vIGlmIGNyb3NzIG9yaWdpblxuICAgIGlmICh1cmwuaG9zdG5hbWUgIT09IGxvYy5ob3N0bmFtZSB8fCAhc2FtZVBvcnQgfHwgdXJsLnByb3RvY29sICE9PSBsb2MucHJvdG9jb2wpIHtcbiAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgcmVzcG9uc2VUeXBlIG9mIGFuIFhIUiByZXF1ZXN0IGJhc2VkIG9uIHRoZSBleHRlbnNpb24gb2YgdGhlXG4gKiByZXNvdXJjZSBiZWluZyBsb2FkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSBUaGUgcmVzcG9uc2VUeXBlIHRvIHVzZS5cbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLl9kZXRlcm1pbmVYaHJUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZXNvdXJjZS5feGhyVHlwZU1hcFt0aGlzLl9nZXRFeHRlbnNpb24oKV0gfHwgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDtcbn07XG5cblJlc291cmNlLnByb3RvdHlwZS5fZGV0ZXJtaW5lTG9hZFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlc291cmNlLl9sb2FkVHlwZU1hcFt0aGlzLl9nZXRFeHRlbnNpb24oKV0gfHwgUmVzb3VyY2UuTE9BRF9UWVBFLlhIUjtcbn07XG5cblJlc291cmNlLnByb3RvdHlwZS5fZ2V0RXh0ZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB1cmwgPSB0aGlzLnVybCxcbiAgICAgICAgZXh0O1xuXG4gICAgaWYgKHRoaXMuaXNEYXRhVXJsKSB7XG4gICAgICAgIHZhciBzbGFzaEluZGV4ID0gdXJsLmluZGV4T2YoJy8nKTtcbiAgICAgICAgZXh0ID0gdXJsLnN1YnN0cmluZyhzbGFzaEluZGV4ICsgMSwgdXJsLmluZGV4T2YoJzsnLCBzbGFzaEluZGV4KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XG4gICAgICAgIGlmIChxdWVyeVN0YXJ0ICE9PSAtMSkge1xuICAgICAgICAgICAgdXJsID0gdXJsLnN1YnN0cmluZygwLCBxdWVyeVN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dCA9IHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXh0O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBtaW1lIHR5cGUgb2YgYW4gWEhSIHJlcXVlc3QgYmFzZWQgb24gdGhlIHJlc3BvbnNlVHlwZSBvZlxuICogcmVzb3VyY2UgYmVpbmcgbG9hZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtaW1lIHR5cGUgdG8gdXNlLlxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX2dldE1pbWVGcm9tWGhyVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5CVUZGRVI6XG4gICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL29jdGV0LWJpbmFyeSc7XG5cbiAgICAgICAgY2FzZSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5CTE9COlxuICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9ibG9iJztcblxuICAgICAgICBjYXNlIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi94bWwnO1xuXG4gICAgICAgIGNhc2UgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTjpcbiAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vanNvbic7XG5cbiAgICAgICAgY2FzZSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ERUZBVUxUOlxuICAgICAgICBjYXNlIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLlRFWFQ6XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ3RleHQvcGxhaW4nO1xuXG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgdHlwZXMgb2YgbG9hZGluZyBhIHJlc291cmNlIGNhbiB1c2UuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAcHJvcGVydHkge29iamVjdH0gTE9BRF9UWVBFXG4gKiBAcHJvcGVydHkge251bWJlcn0gTE9BRF9UWVBFLlhIUiAtIFVzZXMgWE1MSHR0cFJlcXVlc3QgdG8gbG9hZCB0aGUgcmVzb3VyY2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gTE9BRF9UWVBFLklNQUdFIC0gVXNlcyBhbiBgSW1hZ2VgIG9iamVjdCB0byBsb2FkIHRoZSByZXNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMT0FEX1RZUEUuQVVESU8gLSBVc2VzIGFuIGBBdWRpb2Agb2JqZWN0IHRvIGxvYWQgdGhlIHJlc291cmNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IExPQURfVFlQRS5WSURFTyAtIFVzZXMgYSBgVmlkZW9gIG9iamVjdCB0byBsb2FkIHRoZSByZXNvdXJjZS5cbiAqL1xuUmVzb3VyY2UuTE9BRF9UWVBFID0ge1xuICAgIFhIUjogICAgMSxcbiAgICBJTUFHRTogIDIsXG4gICAgQVVESU86ICAzLFxuICAgIFZJREVPOiAgNFxufTtcblxuLyoqXG4gKiBUaGUgWEhSIHJlYWR5IHN0YXRlcywgdXNlZCBpbnRlcm5hbGx5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQHByb3BlcnR5IHtvYmplY3R9IFhIUl9SRUFEWV9TVEFURVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFhIUl9SRUFEWV9TVEFURS5VTlNFTlQgLSBvcGVuKCloYXMgbm90IGJlZW4gY2FsbGVkIHlldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBYSFJfUkVBRFlfU1RBVEUuT1BFTkVEIC0gc2VuZCgpaGFzIG5vdCBiZWVuIGNhbGxlZCB5ZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gWEhSX1JFQURZX1NUQVRFLkhFQURFUlNfUkVDRUlWRUQgLSBzZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgaGVhZGVycyBhbmQgc3RhdHVzIGFyZSBhdmFpbGFibGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gWEhSX1JFQURZX1NUQVRFLkxPQURJTkcgLSBEb3dubG9hZGluZzsgcmVzcG9uc2VUZXh0IGhvbGRzIHBhcnRpYWwgZGF0YS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBYSFJfUkVBRFlfU1RBVEUuRE9ORSAtIFRoZSBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gKi9cblJlc291cmNlLlhIUl9SRUFEWV9TVEFURSA9IHtcbiAgICBVTlNFTlQ6IDAsXG4gICAgT1BFTkVEOiAxLFxuICAgIEhFQURFUlNfUkVDRUlWRUQ6IDIsXG4gICAgTE9BRElORzogMyxcbiAgICBET05FOiA0XG59O1xuXG4vKipcbiAqIFRoZSBYSFIgcmVhZHkgc3RhdGVzLCB1c2VkIGludGVybmFsbHkuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAcHJvcGVydHkge29iamVjdH0gWEhSX1JFU1BPTlNFX1RZUEVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBYSFJfUkVTUE9OU0VfVFlQRS5ERUZBVUxUIC0gZGVmYXVsdHMgdG8gdGV4dFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFhIUl9SRVNQT05TRV9UWVBFLkJVRkZFUiAtIEFycmF5QnVmZmVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gWEhSX1JFU1BPTlNFX1RZUEUuQkxPQiAtIEJsb2JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBYSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCAtIERvY3VtZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gWEhSX1JFU1BPTlNFX1RZUEUuSlNPTiAtIE9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFhIUl9SRVNQT05TRV9UWVBFLlRFWFQgLSBTdHJpbmdcbiAqL1xuUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUgPSB7XG4gICAgREVGQVVMVDogICAgJ3RleHQnLFxuICAgIEJVRkZFUjogICAgICdhcnJheWJ1ZmZlcicsXG4gICAgQkxPQjogICAgICAgJ2Jsb2InLFxuICAgIERPQ1VNRU5UOiAgICdkb2N1bWVudCcsXG4gICAgSlNPTjogICAgICAgJ2pzb24nLFxuICAgIFRFWFQ6ICAgICAgICd0ZXh0J1xufTtcblxuUmVzb3VyY2UuX2xvYWRUeXBlTWFwID0ge1xuICAgICdnaWYnOiAgICAgIFJlc291cmNlLkxPQURfVFlQRS5JTUFHRSxcbiAgICAncG5nJzogICAgICBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0UsXG4gICAgJ2JtcCc6ICAgICAgUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgICdqcGcnOiAgICAgIFJlc291cmNlLkxPQURfVFlQRS5JTUFHRSxcbiAgICAnanBlZyc6ICAgICBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0UsXG4gICAgJ3RpZic6ICAgICAgUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgICd0aWZmJzogICAgIFJlc291cmNlLkxPQURfVFlQRS5JTUFHRSxcbiAgICAnd2VicCc6ICAgICBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0UsXG4gICAgJ3RnYSc6ICAgICAgUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFXG59O1xuXG5SZXNvdXJjZS5feGhyVHlwZU1hcCA9IHtcbiAgICAvLyB4bWxcbiAgICAneGh0bWwnOiAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICAnaHRtbCc6ICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICAnaHRtJzogICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICAneG1sJzogICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICAndG14JzogICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICAndHN4JzogICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICAnc3ZnJzogICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcblxuICAgIC8vIGltYWdlc1xuICAgICdnaWYnOiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgJ3BuZyc6ICAgICAgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICAnYm1wJzogICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxuICAgICdqcGcnOiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgJ2pwZWcnOiAgICAgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICAndGlmJzogICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxuICAgICd0aWZmJzogICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgJ3dlYnAnOiAgICAgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICAndGdhJzogICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxuXG4gICAgLy8ganNvblxuICAgICdqc29uJzogICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkpTT04sXG5cbiAgICAvLyB0ZXh0XG4gICAgJ3RleHQnOiAgICAgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVCxcbiAgICAndHh0JzogICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5URVhUXG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGxvYWQgdHlwZSB0byBiZSB1c2VkIGZvciBhIHNwZWNpZmljIGV4dGVuc2lvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZXh0bmFtZSB7c3RyaW5nfSBUaGUgZXh0ZW5zaW9uIHRvIHNldCB0aGUgdHlwZSBmb3IsIGUuZy4gXCJwbmdcIiBvciBcImZudFwiXG4gKiBAcGFyYW0gbG9hZFR5cGUge1Jlc291cmNlLkxPQURfVFlQRX0gVGhlIGxvYWQgdHlwZSB0byBzZXQgaXQgdG8uXG4gKi9cblJlc291cmNlLnNldEV4dGVuc2lvbkxvYWRUeXBlID0gZnVuY3Rpb24gKGV4dG5hbWUsIGxvYWRUeXBlKSB7XG4gICAgc2V0RXh0TWFwKFJlc291cmNlLl9sb2FkVHlwZU1hcCwgZXh0bmFtZSwgbG9hZFR5cGUpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsb2FkIHR5cGUgdG8gYmUgdXNlZCBmb3IgYSBzcGVjaWZpYyBleHRlbnNpb24uXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGV4dG5hbWUge3N0cmluZ30gVGhlIGV4dGVuc2lvbiB0byBzZXQgdGhlIHR5cGUgZm9yLCBlLmcuIFwicG5nXCIgb3IgXCJmbnRcIlxuICogQHBhcmFtIHhoclR5cGUge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSBUaGUgeGhyIHR5cGUgdG8gc2V0IGl0IHRvLlxuICovXG5SZXNvdXJjZS5zZXRFeHRlbnNpb25YaHJUeXBlID0gZnVuY3Rpb24gKGV4dG5hbWUsIHhoclR5cGUpIHtcbiAgICBzZXRFeHRNYXAoUmVzb3VyY2UuX3hoclR5cGVNYXAsIGV4dG5hbWUsIHhoclR5cGUpO1xufTtcblxuZnVuY3Rpb24gc2V0RXh0TWFwKG1hcCwgZXh0bmFtZSwgdmFsKSB7XG4gICAgaWYgKGV4dG5hbWUgJiYgZXh0bmFtZS5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgZXh0bmFtZSA9IGV4dG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIGlmICghZXh0bmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWFwW2V4dG5hbWVdID0gdmFsO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvLyBwcml2YXRlIHByb3BlcnR5XG4gICAgX2tleVN0cjogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLFxuXG4gICAgZW5jb2RlQmluYXJ5OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgICAgIHZhciBieXRlYnVmZmVyO1xuICAgICAgICB2YXIgZW5jb2RlZENoYXJJbmRleGVzID0gbmV3IEFycmF5KDQpO1xuICAgICAgICB2YXIgaW54ID0gMDtcbiAgICAgICAgdmFyIGpueCA9IDA7XG4gICAgICAgIHZhciBwYWRkaW5nQnl0ZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChpbnggPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgYnl0ZSBidWZmZXIgYXJyYXlcbiAgICAgICAgICAgIGJ5dGVidWZmZXIgPSBuZXcgQXJyYXkoMyk7XG4gICAgICAgICAgICBmb3IgKGpueCA9IDA7IGpueCA8IGJ5dGVidWZmZXIubGVuZ3RoOyBqbngrKykge1xuICAgICAgICAgICAgICAgIGlmIChpbnggPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgYXdheSBoaWdoLW9yZGVyIGJ5dGUsIGFzIGRvY3VtZW50ZWQgYXQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL0VuL1VzaW5nX1hNTEh0dHBSZXF1ZXN0I0hhbmRsaW5nX2JpbmFyeV9kYXRhXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVidWZmZXJbam54XSA9IGlucHV0LmNoYXJDb2RlQXQoaW54KyspICYgMHhmZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVidWZmZXJbam54XSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgZWFjaCBlbmNvZGVkIGNoYXJhY3RlciwgNiBiaXRzIGF0IGEgdGltZVxuICAgICAgICAgICAgLy8gaW5kZXggMTogZmlyc3QgNiBiaXRzXG4gICAgICAgICAgICBlbmNvZGVkQ2hhckluZGV4ZXNbMF0gPSBieXRlYnVmZmVyWzBdID4+IDI7XG4gICAgICAgICAgICAvLyBpbmRleCAyOiBzZWNvbmQgNiBiaXRzICgyIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBpbnB1dCBieXRlIDEgKyA0IG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBmcm9tIGJ5dGUgMilcbiAgICAgICAgICAgIGVuY29kZWRDaGFySW5kZXhlc1sxXSA9ICgoYnl0ZWJ1ZmZlclswXSAmIDB4MykgPDwgNCkgfCAoYnl0ZWJ1ZmZlclsxXSA+PiA0KTtcbiAgICAgICAgICAgIC8vIGluZGV4IDM6IHRoaXJkIDYgYml0cyAoNCBsZWFzdCBzaWduaWZpY2FudCBiaXRzIGZyb20gaW5wdXQgYnl0ZSAyICsgMiBtb3N0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBieXRlIDMpXG4gICAgICAgICAgICBlbmNvZGVkQ2hhckluZGV4ZXNbMl0gPSAoKGJ5dGVidWZmZXJbMV0gJiAweDBmKSA8PCAyKSB8IChieXRlYnVmZmVyWzJdID4+IDYpO1xuICAgICAgICAgICAgLy8gaW5kZXggMzogZm9ydGggNiBiaXRzICg2IGxlYXN0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBpbnB1dCBieXRlIDMpXG4gICAgICAgICAgICBlbmNvZGVkQ2hhckluZGV4ZXNbM10gPSBieXRlYnVmZmVyWzJdICYgMHgzZjtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgcGFkZGluZyBoYXBwZW5lZCwgYW5kIGFkanVzdCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgcGFkZGluZ0J5dGVzID0gaW54IC0gKGlucHV0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgc3dpdGNoIChwYWRkaW5nQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBsYXN0IDIgY2hhcmFjdGVycyB0byBwYWRkaW5nIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZENoYXJJbmRleGVzWzNdID0gNjQ7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWRDaGFySW5kZXhlc1syXSA9IDY0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGxhc3QgY2hhcmFjdGVyIHRvIHBhZGRpbmcgY2hhclxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkQ2hhckluZGV4ZXNbM10gPSA2NDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gTm8gcGFkZGluZyAtIHByb2NlZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHdlIHdpbGwgZ3JhYiBlYWNoIGFwcHJvcHJpYXRlIGNoYXJhY3RlciBvdXQgb2Ygb3VyIGtleXN0cmluZ1xuICAgICAgICAgICAgLy8gYmFzZWQgb24gb3VyIGluZGV4IGFycmF5IGFuZCBhcHBlbmQgaXQgdG8gdGhlIG91dHB1dCBzdHJpbmdcbiAgICAgICAgICAgIGZvciAoam54ID0gMDsgam54IDwgZW5jb2RlZENoYXJJbmRleGVzLmxlbmd0aDsgam54KyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdGhpcy5fa2V5U3RyLmNoYXJBdChlbmNvZGVkQ2hhckluZGV4ZXNbam54XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0xvYWRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cy5SZXNvdXJjZSA9IHJlcXVpcmUoJy4vUmVzb3VyY2UnKTtcblxubW9kdWxlLmV4cG9ydHMubWlkZGxld2FyZSA9IHtcbiAgICBjYWNoaW5nOiB7XG4gICAgICAgIG1lbW9yeTogcmVxdWlyZSgnLi9taWRkbGV3YXJlcy9jYWNoaW5nL21lbW9yeScpXG4gICAgfSxcbiAgICBwYXJzaW5nOiB7XG4gICAgICAgIGJsb2I6IHJlcXVpcmUoJy4vbWlkZGxld2FyZXMvcGFyc2luZy9ibG9iJylcbiAgICB9XG59O1xuIiwiLy8gYSBzaW1wbGUgaW4tbWVtb3J5IGNhY2hlIGZvciByZXNvdXJjZXNcbnZhciBjYWNoZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc291cmNlLCBuZXh0KSB7XG4gICAgICAgIC8vIGlmIGNhY2hlZCwgdGhlbiBzZXQgZGF0YSBhbmQgY29tcGxldGUgdGhlIHJlc291cmNlXG4gICAgICAgIGlmIChjYWNoZVtyZXNvdXJjZS51cmxdKSB7XG4gICAgICAgICAgICByZXNvdXJjZS5kYXRhID0gY2FjaGVbcmVzb3VyY2UudXJsXTtcbiAgICAgICAgICAgIHJlc291cmNlLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm90IGNhY2hlZCwgd2FpdCBmb3IgY29tcGxldGUgYW5kIHN0b3JlIGl0IGluIHRoZSBjYWNoZS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvdXJjZS5vbmNlKCdjb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgIGNhY2hlW3RoaXMudXJsXSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBuZXh0KCk7XG4gICAgfTtcbn07XG4iLCJ2YXIgUmVzb3VyY2UgPSByZXF1aXJlKCcuLi8uLi9SZXNvdXJjZScpLFxuICAgIGI2NCA9IHJlcXVpcmUoJy4uLy4uL2I2NCcpO1xuXG53aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXG4vLyBhIG1pZGRsZXdhcmUgZm9yIHRyYW5zZm9ybWluZyBYSFIgbG9hZGVkIEJsb2JzIGludG8gbW9yZSB1c2VmdWwgb2JqZWN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc291cmNlLCBuZXh0KSB7XG4gICAgICAgIGlmICghcmVzb3VyY2UuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoaXMgd2FzIGFuIFhIUiBsb2FkIG9mIGEgYmxvYlxuICAgICAgICBpZiAocmVzb3VyY2UueGhyICYmIHJlc291cmNlLnhoclR5cGUgPT09IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGJsb2Igc3VwcG9ydCB3ZSBwcm9iYWJseSBnb3QgYSBiaW5hcnkgc3RyaW5nIGJhY2tcbiAgICAgICAgICAgIGlmICghd2luZG93LkJsb2IgfHwgdHlwZW9mIHJlc291cmNlLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSByZXNvdXJjZS54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBpbWFnZSwgY29udmVydCB0aGUgYmluYXJ5IHN0cmluZyBpbnRvIGEgZGF0YSB1cmxcbiAgICAgICAgICAgICAgICBpZiAodHlwZSAmJiB0eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuZGF0YSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhLnNyYyA9ICdkYXRhOicgKyB0eXBlICsgJztiYXNlNjQsJyArIGI2NC5lbmNvZGVCaW5hcnkocmVzb3VyY2UueGhyLnJlc3BvbnNlVGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuaXNJbWFnZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgaW1hZ2UgbG9hZHMgYW5kIHRoZW4gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuZGF0YS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhLm9ubG9hZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjb250ZW50IHR5cGUgc2F5cyB0aGlzIGlzIGFuIGltYWdlLCB0aGVuIHdlIHNob3VsZCB0cmFuc2Zvcm0gdGhlIGJsb2IgaW50byBhbiBJbWFnZSBvYmplY3RcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc291cmNlLmRhdGEudHlwZS5pbmRleE9mKCdpbWFnZScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVzb3VyY2UuZGF0YSk7XG5cbiAgICAgICAgICAgICAgICByZXNvdXJjZS5ibG9iID0gcmVzb3VyY2UuZGF0YTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuZGF0YS5zcmMgPSBzcmM7XG5cbiAgICAgICAgICAgICAgICByZXNvdXJjZS5pc0ltYWdlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgdGhlIG5vIGxvbmdlciB1c2VkIGJsb2IgYWZ0ZXIgdGhlIGltYWdlIGxvYWRzXG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuZGF0YS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuZGF0YS5vbmxvYWQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJuYW1lXCI6IFwicGl4aS5qc1wiLFxyXG4gIFwidmVyc2lvblwiOiBcIjMuMC45XCIsXHJcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlBpeGkuanMgaXMgYSBmYXN0IGxpZ2h0d2VpZ2h0IDJEIGxpYnJhcnkgdGhhdCB3b3JrcyBhY3Jvc3MgYWxsIGRldmljZXMuXCIsXHJcbiAgXCJhdXRob3JcIjogXCJNYXQgR3JvdmVzXCIsXHJcbiAgXCJjb250cmlidXRvcnNcIjogW1xyXG4gICAgXCJDaGFkIEVuZ2xlciA8Y2hhZEBwYW50aGVyZGV2LmNvbT5cIixcclxuICAgIFwiUmljaGFyZCBEYXZleSA8cmRhdmV5QGdtYWlsLmNvbT5cIlxyXG4gIF0sXHJcbiAgXCJtYWluXCI6IFwiLi9zcmMvaW5kZXguanNcIixcclxuICBcImhvbWVwYWdlXCI6IFwiaHR0cDovL2dvb2Rib3lkaWdpdGFsLmNvbS9cIixcclxuICBcImJ1Z3NcIjogXCJodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGkuanMvaXNzdWVzXCIsXHJcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXHJcbiAgXCJyZXBvc2l0b3J5XCI6IHtcclxuICAgIFwidHlwZVwiOiBcImdpdFwiLFxyXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGkuanMuZ2l0XCJcclxuICB9LFxyXG4gIFwic2NyaXB0c1wiOiB7XHJcbiAgICBcInN0YXJ0XCI6IFwiZ3VscCAmJiBndWxwIHdhdGNoXCIsXHJcbiAgICBcInRlc3RcIjogXCJndWxwICYmIHRlc3RlbSBjaVwiLFxyXG4gICAgXCJidWlsZFwiOiBcImd1bHBcIixcclxuICAgIFwiZG9jc1wiOiBcImpzZG9jIC1jIC4vZ3VscC91dGlsL2pzZG9jLmNvbmYuanNvbiAtUiBSRUFETUUubWRcIlxyXG4gIH0sXHJcbiAgXCJmaWxlc1wiOiBbXHJcbiAgICBcImJpbi9cIixcclxuICAgIFwic3JjL1wiLFxyXG4gICAgXCJDT05UUklCVVRJTkcubWRcIixcclxuICAgIFwiTElDRU5TRVwiLFxyXG4gICAgXCJwYWNrYWdlLmpzb25cIixcclxuICAgIFwiUkVBRE1FLm1kXCJcclxuICBdLFxyXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcclxuICAgIFwiYXN5bmNcIjogXCJeMS41LjBcIixcclxuICAgIFwiYnJmc1wiOiBcIl4xLjQuMVwiLFxyXG4gICAgXCJlYXJjdXRcIjogXCJeMi4wLjdcIixcclxuICAgIFwiZXZlbnRlbWl0dGVyM1wiOiBcIl4xLjEuMVwiLFxyXG4gICAgXCJvYmplY3QtYXNzaWduXCI6IFwiXjQuMC4xXCIsXHJcbiAgICBcInJlc291cmNlLWxvYWRlclwiOiBcIl4xLjYuNFwiXHJcbiAgfSxcclxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XHJcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTEuMS4wXCIsXHJcbiAgICBcImNoYWlcIjogXCJeMy4yLjBcIixcclxuICAgIFwiZGVsXCI6IFwiXjIuMC4yXCIsXHJcbiAgICBcImd1bHBcIjogXCJeMy45LjBcIixcclxuICAgIFwiZ3VscC1jYWNoZWRcIjogXCJeMS4xLjBcIixcclxuICAgIFwiZ3VscC1jb25jYXRcIjogXCJeMi42LjBcIixcclxuICAgIFwiZ3VscC1kZWJ1Z1wiOiBcIl4yLjEuMFwiLFxyXG4gICAgXCJndWxwLWhlYWRlclwiOiBcIl4xLjcuMVwiLFxyXG4gICAgXCJndWxwLWpzaGludFwiOiBcIl4xLjExLjJcIixcclxuICAgIFwiZ3VscC1taXJyb3JcIjogXCJeMC40LjBcIixcclxuICAgIFwiZ3VscC1wbHVtYmVyXCI6IFwiXjEuMC4xXCIsXHJcbiAgICBcImd1bHAtcmVuYW1lXCI6IFwiXjEuMi4yXCIsXHJcbiAgICBcImd1bHAtc291cmNlbWFwc1wiOiBcIl4xLjUuMlwiLFxyXG4gICAgXCJndWxwLXVnbGlmeVwiOiBcIl4xLjQuMVwiLFxyXG4gICAgXCJndWxwLXV0aWxcIjogXCJeMy4wLjZcIixcclxuICAgIFwiamFndWFyanMtanNkb2NcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL2Rhdmlkc2hpbWpzL2phZ3VhcmpzLWpzZG9jLmdpdFwiLFxyXG4gICAgXCJqc2RvY1wiOiBcIl4zLjMuMlwiLFxyXG4gICAgXCJqc2hpbnQtc3VtbWFyeVwiOiBcIl4wLjQuMFwiLFxyXG4gICAgXCJtaW5pbWlzdFwiOiBcIl4xLjIuMFwiLFxyXG4gICAgXCJtb2NoYVwiOiBcIl4yLjMuMlwiLFxyXG4gICAgXCJyZXF1aXJlLWRpclwiOiBcIl4wLjMuMFwiLFxyXG4gICAgXCJydW4tc2VxdWVuY2VcIjogXCJeMS4xLjJcIixcclxuICAgIFwidGVzdGVtXCI6IFwiXjAuOS40XCIsXHJcbiAgICBcInZpbnlsLWJ1ZmZlclwiOiBcIl4xLjAuMFwiLFxyXG4gICAgXCJ2aW55bC1zb3VyY2Utc3RyZWFtXCI6IFwiXjEuMS4wXCIsXHJcbiAgICBcIndhdGNoaWZ5XCI6IFwiXjMuNC4wXCJcclxuICB9LFxyXG4gIFwiYnJvd3NlcmlmeVwiOiB7XHJcbiAgICBcInRyYW5zZm9ybVwiOiBbXHJcbiAgICAgIFwiYnJmc1wiXHJcbiAgICBdXHJcbiAgfVxyXG59XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xyXG5cclxuLy8gYWRkIHNvbWUgZXh0cmEgdmFyaWFibGVzIHRvIHRoZSBjb250YWluZXIuLlxyXG5PYmplY3QuYXNzaWduKFxyXG4gICAgY29yZS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSxcclxuICAgIHJlcXVpcmUoJy4vYWNjZXNzaWJsZVRhcmdldCcpXHJcbik7XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBBY2Nlc3NpYmlsaXR5IG1hbmFnZXIgcmVhY3JlYXRlcyB0aGUgYWJpbGl0eSB0byB0YWIgYW5kIGFuZCBoYXZlIGNvbnRlbnQgcmVhZCBieSBzY3JlZW4gcmVhZGVycy4gVGhpcyBpcyB2ZXJ5IGltcG9ydGFudCBhcyBpdCBjYW4gcG9zc2libHkgaGVscCBwZW9wbGUgd2l0aCBkaXNhYmlsaXRpZXMgYWNjZXNzIHBpeGkgY29udGVudC5cclxuICogTXVjaCBsaWtlIGludGVyYWN0aW9uIGFueSBEaXNwbGF5T2JqZWN0IGNhbiBiZSBtYWRlIGFjY2Vzc2libGUuIFRoaXMgbWFuYWdlciB3aWxsIG1hcCB0aGUgZXZlbnRzIGFzIGlmIHRoZSBtb3VzZSB3YXMgYmVpbmcgdXNlZCwgbWluaW1pemluZyB0aGUgZWZmZXJvdCByZXF1aXJlZCB0byBpbXBsZW1lbnQuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlclxyXG4gKi9cclxuZnVuY3Rpb24gQWNjZXNzaWJpbGl0eU1hbmFnZXIocmVuZGVyZXIpXHJcbntcclxuXHQvLyBmaXJzdCB3ZSBjcmVhdGUgYSBkaXYgdGhhdCB3aWxsIHNpdCBvdmVyIHRoZSBwaXhpIGVsZW1lbnQuIFRoaXMgaXMgd2hlcmUgdGhlIGRpdiBvdmVybGF5cyB3aWxsIGdvLlxyXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgXHJcbiAgICBkaXYuc3R5bGUud2lkdGggPSAxMDAgKyAncHgnO1xyXG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IDEwMCArICdweCc7XHJcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgZGl2LnN0eWxlLnRvcCA9IDA7XHJcbiAgICBkaXYuc3R5bGUubGVmdCA9IDA7XHJcbiAgIC8vXHJcbiAgICBkaXYuc3R5bGUuekluZGV4ID0gMjtcclxuICAgXHRcclxuICAgXHQvKipcclxuICAgXHQgKiBUaGlzIGlzIHRoZSBkb20gZWxlbWVudCB0aGF0IHdpbGwgc2l0IG92ZXIgdGhlIHBpeGkgZWxlbWVudC4gVGhpcyBpcyB3aGVyZSB0aGUgZGl2IG92ZXJsYXlzIHdpbGwgZ28uXHJcbiAgIFx0ICogXHJcbiAgIFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICBcdCAqIEBwcml2YXRlXHJcbiAgIFx0ICovXHJcbiAgIFx0dGhpcy5kaXYgPSBkaXY7XHJcblxyXG4gICBcdC8qKlxyXG4gICBcdCAqIEEgc2ltcGxlIHBvb2wgZm9yIHN0b3JpbmcgZGl2cy5cclxuICAgXHQgKiBcclxuICAgXHQgKiBAdHlwZSB7QXJyYXl9XHJcbiAgIFx0ICogQHByaXZhdGVcclxuICAgXHQgKi9cclxuIFx0dGhpcy5wb29sID0gW107XHJcblxyXG4gXHQvKipcclxuIFx0ICogVGhpcyBpcyBhIHRpY2sgdXNlZCB0byBjaGVjayBpZiBhbiBvYmplY3QgaXMgbm8gbG9uZ2VyIGJlaW5nIHJlbmRlcmVkLlxyXG4gXHQgKiBcclxuIFx0ICogQHR5cGUge051bWJlcn1cclxuIFx0ICogQHByaXZhdGVcclxuIFx0ICovXHJcbiAgIFx0dGhpcy5yZW5kZXJJZCA9IDA7XHJcblxyXG4gICBcdC8qKlxyXG4gICBcdCAqIFNldHRpbmcgdGhpcyB0byB0cnVlIHdpbGwgdmlzdWFsbHkgc2hvdyB0aGUgZGl2c1xyXG4gICBcdCAqIFxyXG4gICBcdCAqIEB0eXBlIHtCb29sZWFufVxyXG4gICBcdCAqL1xyXG4gICBcdHRoaXMuZGVidWcgPSBmYWxzZTtcclxuXHJcbiAgXHQvKipcclxuICAgICAqIFRoZSByZW5kZXJlciB0aGlzIGFjY2Vzc2liaWxpdHkgbWFuYWdlciB3b3JrcyBmb3IuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5TeXN0ZW1SZW5kZXJlcn1cclxuICAgICAqL1xyXG4gICBcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHJcbiAgIFx0LyoqXHJcbiAgICAgKiBUaGUgYXJyYXkgb2YgY3VycmVudGx5IGFjdGl2ZSBhY2Nlc3NpYmxlIGl0ZW1zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge0FycmF5fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICBcdHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgXHRcclxuICAgXHQvKipcclxuICAgICAqIHByZSBiaW5kIHRoZSBmdW5jdGlvbnMuLlxyXG4gICAgICovXHJcbiAgIFx0dGhpcy5fb25LZXlEb3duID0gdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcyk7XHJcbiAgIFx0dGhpcy5fb25Nb3VzZU1vdmUgPSB0aGlzLl9vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xyXG4gICBcdFxyXG4gICBcdC8qKlxyXG4gICAgICogc3RvcmVzIHRoZSBzdGF0ZSBvZiB0aGUgbWFuYWdlci4gSWYgdGhlcmUgYXJlIG5vIGFjY2Vzc2libGUgb2JqZWN0cyBvciB0aGUgbW91c2UgaXMgbW92aW5nIHRoZSB3aWxsIGJlIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge0FycmF5fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICBcdHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcclxuXHJcblxyXG4gICBcdC8vIGxldCBsaXN0ZW4gZm9yIHRhYi4uIG9uY2UgcHJlc3NlZCB3ZSBjYW4gZmlyZSB1cCBhbmQgc2hvdyB0aGUgYWNjZXNzaWJpbGl0eSBsYXllclxyXG4gICBcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XHJcbn1cclxuXHJcblxyXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlcjtcclxuXHJcbi8qKlxyXG4gKiBBY3RpdmF0aW5nIHdpbGwgY2F1c2UgdGhlIEFjY2Vzc2liaWxpdHkgbGF5ZXIgdG8gYmUgc2hvd24uIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIHByZXNlcyB0aGUgdGFiIGtleVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKVxyXG57XHJcblx0aWYodGhpcy5pc0FjdGl2ZSlcclxuXHR7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHR0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcclxuXHJcblx0d2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcclxuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xyXG5cclxuXHR0aGlzLnJlbmRlcmVyLm9uKCdwb3N0cmVuZGVyJywgdGhpcy51cGRhdGUsIHRoaXMpO1xyXG5cclxuXHR0aGlzLnJlbmRlcmVyLnZpZXcucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmRpdik7XHRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWFjdGl2YXRpbmcgd2lsbCBjYXVzZSB0aGUgQWNjZXNzaWJpbGl0eSBsYXllciB0byBiZSBoaWRkZW4uIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIG1vdmVzIHRoZSBtb3VzZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbigpXHJcbntcclxuXHRpZighdGhpcy5pc0FjdGl2ZSlcclxuXHR7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHR0aGlzLmlzQWN0aXZlID0gZmFsc2U7XHJcblxyXG5cdHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XHJcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcclxuXHJcblx0dGhpcy5yZW5kZXJlci5vZmYoJ3Bvc3RyZW5kZXInLCB0aGlzLnVwZGF0ZSk7XHJcblxyXG5cdHRoaXMuZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kaXYpO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHJlY3Vyc2l2ZSBmdW5jdGlvbiB3aWxsIHJ1biB0aHJvdWdodCBoZSBzY2VuZSBncmFwaCBhbmQgYWRkIGFueSBuZXcgYWNjZXNzaWJsZSBvYmplY3RzIHRvIHRoZSBET00gbGF5ZXIuXHJcbiAqIEBwYXJhbSBlbGVtZW50IHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IHRoZSBEaXNwbGF5T2JqZWN0IHRvIGNoZWNrLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzID0gZnVuY3Rpb24oZGlzcGxheU9iamVjdClcclxue1xyXG5cdGlmKCFkaXNwbGF5T2JqZWN0LnZpc2libGUpXHJcblx0e1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0aWYoZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlICYmIGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUpXHJcblx0e1xyXG5cdFx0aWYoIWRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuYWRkQ2hpbGQoZGlzcGxheU9iamVjdCk7XHJcblx0XHR9XHJcblx0ICAgXHRcclxuXHQgICBcdGRpc3BsYXlPYmplY3QucmVuZGVySWQgPSB0aGlzLnJlbmRlcklkO1xyXG5cdH1cclxuXHJcblx0dmFyIGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcclxuXHJcblx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcclxuXHRcdHRoaXMudXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoY2hpbGRyZW5baV0pO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogQmVmb3JlIGVhY2ggcmVuZGVyIHRoaXMgZnVuY3Rpb24gd2lsbCBlbnN1cmUgdGhhdCBhbGwgZGl2cyBhcmUgbWFwcGVkIGNvcnJlY3RseSB0byB0aGVpciBEaXNwbGF5T2JqZWN0c1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKClcclxue1xyXG5cclxuXHQvLyB1cGRhdGUgY2hpbGRyZW4uLi5cclxuXHR0aGlzLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCk7XHJcblxyXG5cdHZhciByZWN0ID0gdGhpcy5yZW5kZXJlci52aWV3LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdHZhciBzeCA9IHJlY3Qud2lkdGggIC8gdGhpcy5yZW5kZXJlci53aWR0aDtcclxuXHR2YXIgc3kgPSByZWN0LmhlaWdodCAvIHRoaXMucmVuZGVyZXIuaGVpZ2h0O1xyXG5cclxuXHR2YXIgZGl2ID0gdGhpcy5kaXY7XHJcblxyXG5cdGRpdi5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgJ3B4JztcclxuXHRkaXYuc3R5bGUudG9wID0gcmVjdC50b3AgKyAncHgnO1xyXG5cdGRpdi5zdHlsZS53aWR0aCA9IHRoaXMucmVuZGVyZXIud2lkdGggKyAncHgnO1xyXG5cdGRpdi5zdHlsZS5oZWlnaHQgPSB0aGlzLnJlbmRlcmVyLmhlaWdodCArICdweCc7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcclxuXHR7XHJcblxyXG5cdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuXHJcblx0XHRpZihjaGlsZC5yZW5kZXJJZCAhPT0gdGhpcy5yZW5kZXJJZClcclxuXHRcdHtcclxuXHRcdFx0Y2hpbGQuX2FjY2Vzc2libGVBY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGNvcmUudXRpbHMucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaSwgMSk7XHJcblx0XHRcdHRoaXMuZGl2LnJlbW92ZUNoaWxkKCBjaGlsZC5fYWNjZXNzaWJsZURpdiApO1xyXG5cdFx0XHR0aGlzLnBvb2wucHVzaChjaGlsZC5fYWNjZXNzaWJsZURpdik7XHJcblx0XHRcdGNoaWxkLl9hY2Nlc3NpYmxlRGl2ID0gbnVsbDtcclxuXHJcblx0XHRcdGktLTtcclxuXHJcblx0XHRcdGlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy5kZWFjdGl2YXRlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0Ly8gbWFwIGRpdiB0byBkaXNwbGF5Li5cclxuXHRcdFx0ZGl2ID0gY2hpbGQuX2FjY2Vzc2libGVEaXY7XHJcblx0XHRcdHZhciBoaXRBcmVhID0gY2hpbGQuaGl0QXJlYTtcclxuXHRcdFx0dmFyIHd0ID0gY2hpbGQud29ybGRUcmFuc2Zvcm07XHJcblxyXG5cdFx0XHRpZihjaGlsZC5oaXRBcmVhKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0ZGl2LnN0eWxlLmxlZnQgPSAoKHd0LnR4ICsgKGhpdEFyZWEueCAqIHd0LmEpKSAqIHN4KSArICdweCc7XHJcblx0XHRcdFx0ZGl2LnN0eWxlLnRvcCA9ICAoKHd0LnR5ICsgKGhpdEFyZWEueSAqIHd0LmQpKSAqIHN5KSArICAncHgnO1xyXG5cclxuXHRcdFx0XHRkaXYuc3R5bGUud2lkdGggPSAoaGl0QXJlYS53aWR0aCAqIHd0LmEgKiBzeCkgKyAncHgnO1xyXG5cdFx0XHRcdGRpdi5zdHlsZS5oZWlnaHQgPSAoaGl0QXJlYS5oZWlnaHQgKiB3dC5kICogc3kpICsgJ3B4JztcclxuXHRcdFx0XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aGl0QXJlYSA9IGNoaWxkLmdldEJvdW5kcygpO1xyXG5cclxuXHRcdFx0XHR0aGlzLmNhcEhpdEFyZWEoaGl0QXJlYSk7XHJcblxyXG5cdFx0XHRcdGRpdi5zdHlsZS5sZWZ0ID0gKGhpdEFyZWEueCAqIHN4KSArICdweCc7XHJcblx0XHRcdFx0ZGl2LnN0eWxlLnRvcCA9ICAoaGl0QXJlYS55ICogc3kpICsgICdweCc7XHJcblxyXG5cdFx0XHRcdGRpdi5zdHlsZS53aWR0aCA9IChoaXRBcmVhLndpZHRoICogc3gpICsgJ3B4JztcclxuXHRcdFx0XHRkaXYuc3R5bGUuaGVpZ2h0ID0gKGhpdEFyZWEuaGVpZ2h0ICogc3kpICsgJ3B4JztcclxuXHRcdFx0fVx0XHRcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGluY3JlbWVudCB0aGUgcmVuZGVyIGlkLi5cclxuXHR0aGlzLnJlbmRlcklkKys7XHJcbn07XHJcblxyXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuY2FwSGl0QXJlYSA9IGZ1bmN0aW9uIChoaXRBcmVhKVxyXG57XHJcbiAgICBpZiAoaGl0QXJlYS54IDwgMClcclxuICAgIHtcclxuICAgICAgICBoaXRBcmVhLndpZHRoICs9IGhpdEFyZWEueDtcclxuICAgICAgICBoaXRBcmVhLnggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChoaXRBcmVhLnkgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIGhpdEFyZWEuaGVpZ2h0ICs9IGhpdEFyZWEueTtcclxuICAgICAgICBoaXRBcmVhLnkgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICggaGl0QXJlYS54ICsgaGl0QXJlYS53aWR0aCA+IHRoaXMucmVuZGVyZXIud2lkdGggKVxyXG4gICAge1xyXG4gICAgICAgIGhpdEFyZWEud2lkdGggPSB0aGlzLnJlbmRlcmVyLndpZHRoIC0gaGl0QXJlYS54O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICggaGl0QXJlYS55ICsgaGl0QXJlYS5oZWlnaHQgPiB0aGlzLnJlbmRlcmVyLmhlaWdodCApXHJcbiAgICB7XHJcbiAgICAgICAgaGl0QXJlYS5oZWlnaHQgPSB0aGlzLnJlbmRlcmVyLmhlaWdodCAtIGhpdEFyZWEueTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogQWRkcyBhIERpc3BsYXlPYmplY3QgdG8gdGhlIGFjY2Vzc2liaWxpdHkgbWFuYWdlclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24oZGlzcGxheU9iamVjdClcclxue1xyXG4vL1x0dGhpcy5hY3RpdmF0ZSgpO1xyXG5cdFxyXG5cdHZhciBkaXYgPSB0aGlzLnBvb2wucG9wKCk7XHJcblxyXG5cdGlmKCFkaXYpXHJcblx0e1xyXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7IFxyXG5cclxuXHQgICAgZGl2LnN0eWxlLndpZHRoID0gMTAwICsgJ3B4JztcclxuXHQgICAgZGl2LnN0eWxlLmhlaWdodCA9IDEwMCArICdweCc7XHJcblx0ICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmRlYnVnID8gJ3JnYmEoMjU1LDAsMCwwLjUpJyA6ICd0cmFuc3BhcmVudCc7XHJcblx0ICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblx0ICAgIGRpdi5zdHlsZS56SW5kZXggPSAyO1xyXG5cdCAgICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnbm9uZSc7XHJcblxyXG5cdCAgICBcclxuXHQgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljay5iaW5kKHRoaXMpKTtcclxuXHQgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1cy5iaW5kKHRoaXMpKTtcclxuXHQgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5fb25Gb2N1c091dC5iaW5kKHRoaXMpKTtcclxuXHR9XHJcblx0ICAgXHRcclxuXHJcblxyXG5cclxuXHRkaXYudGl0bGUgPSBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZSB8fCAnZGlzcGxheU9iamVjdCAnICsgdGhpcy50YWJJbmRleDtcclxuXHJcblx0Ly9cclxuXHRcclxuXHRkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlQWN0aXZlID0gdHJ1ZTtcclxuXHRkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2ID0gZGl2O1xyXG5cdGRpdi5kaXNwbGF5T2JqZWN0ID0gZGlzcGxheU9iamVjdDtcclxuXHJcblxyXG5cdHRoaXMuY2hpbGRyZW4ucHVzaChkaXNwbGF5T2JqZWN0KTtcclxuXHR0aGlzLmRpdi5hcHBlbmRDaGlsZCggZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdiApO1xyXG5cdGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVEaXYudGFiSW5kZXggPSBkaXNwbGF5T2JqZWN0LnRhYkluZGV4O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBNYXBzIHRoZSBkaXYgYnV0dG9uIHByZXNzIHRvIHBpeGkncyBJbnRlcmFjdGlvbk1hbmFnZXIgKGNsaWNrKVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oZSlcclxue1xyXG5cdHZhciBpbnRlcmFjdGlvbk1hbmFnZXIgPSB0aGlzLnJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb247XHJcblx0aW50ZXJhY3Rpb25NYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZS50YXJnZXQuZGlzcGxheU9iamVjdCwgJ2NsaWNrJywgaW50ZXJhY3Rpb25NYW5hZ2VyLmV2ZW50RGF0YSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTWFwcyB0aGUgZGl2IGZvY3VzIGV2ZW50cyB0byBwaXhpcyBJbnRlcmFjdGlvbk1hbmFnZXIgKG1vdXNlb3ZlcilcclxuICogQHByaXZhdGVcclxuICovXHJcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fb25Gb2N1cyA9IGZ1bmN0aW9uKGUpXHJcbntcclxuXHR2YXIgaW50ZXJhY3Rpb25NYW5hZ2VyID0gdGhpcy5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uO1xyXG5cdGludGVyYWN0aW9uTWFuYWdlci5kaXNwYXRjaEV2ZW50KGUudGFyZ2V0LmRpc3BsYXlPYmplY3QsICdtb3VzZW92ZXInLCBpbnRlcmFjdGlvbk1hbmFnZXIuZXZlbnREYXRhKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXBzIHRoZSBkaXYgZm9jdXMgZXZlbnRzIHRvIHBpeGlzIEludGVyYWN0aW9uTWFuYWdlciAobW91c2VvdXQpXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuX29uRm9jdXNPdXQgPSBmdW5jdGlvbihlKVxyXG57XHJcblx0dmFyIGludGVyYWN0aW9uTWFuYWdlciA9IHRoaXMucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbjtcclxuXHRpbnRlcmFjdGlvbk1hbmFnZXIuZGlzcGF0Y2hFdmVudChlLnRhcmdldC5kaXNwbGF5T2JqZWN0LCAnbW91c2VvdXQnLCBpbnRlcmFjdGlvbk1hbmFnZXIuZXZlbnREYXRhKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJcyBjYWxsZWQgd2hlbiBhIGtleSBpcyBwcmVzc2VkXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuX29uS2V5RG93biA9IGZ1bmN0aW9uKGUpXHJcbntcclxuXHRpZihlLmtleUNvZGUgIT09IDkpXHJcblx0e1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0dGhpcy5hY3RpdmF0ZSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBhY3Jvc3MgdGhlIHJlbmRlcmVyIGVsZW1lbnRcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbigpXHJcbntcclxuXHR0aGlzLmRlYWN0aXZhdGUoKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRGVzdHJveXMgdGhlIGFjY2Vzc2liaWxpdHkgbWFuYWdlclxyXG4gKlxyXG4gKi9cclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSBcclxue1xyXG5cdHRoaXMuZGl2ID0gbnVsbDtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG5cdHtcclxuXHRcdHRoaXMuY2hpbGRyZW5baV0uZGl2ID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdFxyXG5cdHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XHJcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24pO1xyXG5cdFx0XHJcblx0dGhpcy5wb29sID0gbnVsbDtcclxuXHR0aGlzLmNoaWxkcmVuID0gbnVsbDtcclxuXHR0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5jb3JlLldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2FjY2Vzc2liaWxpdHknLCBBY2Nlc3NpYmlsaXR5TWFuYWdlcik7XHJcbmNvcmUuQ2FudmFzUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2FjY2Vzc2liaWxpdHknLCBBY2Nlc3NpYmlsaXR5TWFuYWdlcik7XHJcblxyXG4iLCIvKipcclxuICogRGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYWNjZXNzaWJsZSBvYmplY3RzXHJcbiAqIHVzZWQgYnkge0BsaW5rIFBJWEkuYWNjZXNzaWJpbGl0eS5BY2Nlc3NpYmlsaXR5TWFuYWdlcn0uXHJcbiAqXHJcbiAqIEBtaXhpblxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgIGZ1bmN0aW9uIE15T2JqZWN0KCkge31cclxuICpcclxuICogICAgICBPYmplY3QuYXNzaWduKFxyXG4gKiAgICAgICAgICBNeU9iamVjdC5wcm90b3R5cGUsXHJcbiAqICAgICAgICAgIFBJWEkuYWNjZXNzaWJpbGl0eS5hY2Nlc3NpYmxlVGFyZ2V0XHJcbiAqICAgICAgKTtcclxuICovXHJcbnZhciBhY2Nlc3NpYmxlVGFyZ2V0ID0ge1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXHJcbiAgICAgKi9cclxuICAgIGFjY2Vzc2libGU6ZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxyXG4gICAgICovXHJcbiAgICBhY2Nlc3NpYmxlVGl0bGU6bnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXHJcbiAgICAgKi9cclxuICAgIHRhYkluZGV4OjAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxyXG4gICAgICovXHJcbiAgICBfYWNjZXNzaWJsZUFjdGl2ZTpmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXHJcbiAgICAgKi9cclxuICAgIF9hY2Nlc3NpYmxlRGl2OmZhbHNlXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBhY2Nlc3NpYmxlVGFyZ2V0O1xyXG4iLCIvKipcclxuICogQGZpbGUgICAgICAgIE1haW4gZXhwb3J0IG9mIHRoZSBQSVhJIGFjY2Vzc2liaWxpdHkgbGlicmFyeVxyXG4gKiBAYXV0aG9yICAgICAgTWF0IEdyb3ZlcyA8bWF0QGdvb2Rib3lkaWdpdGFsLmNvbT5cclxuICogQGNvcHlyaWdodCAgIDIwMTMtMjAxNSBHb29kQm95RGlnaXRhbFxyXG4gKiBAbGljZW5zZSAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS5qcy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVCBMaWNlbnNlfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIFBJWEkuaW50ZXJhY3Rpb25cclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgYWNjZXNzaWJsZVRhcmdldDogICAgIHJlcXVpcmUoJy4vYWNjZXNzaWJsZVRhcmdldCcpLFxyXG4gICAgQWNjZXNzaWJpbGl0eU1hbmFnZXI6IHJlcXVpcmUoJy4vQWNjZXNzaWJpbGl0eU1hbmFnZXInKVxyXG59O1xyXG4iLCIvKipcclxuICogQ29uc3RhbnQgdmFsdWVzIHVzZWQgaW4gcGl4aVxyXG4gKlxyXG4gKiBAbGVuZHMgUElYSVxyXG4gKi9cclxudmFyIENPTlNUID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpbmcgb2YgdGhlIGN1cnJlbnQgUElYSSB2ZXJzaW9uXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gVkVSU0lPTlxyXG4gICAgICovXHJcbiAgICBWRVJTSU9OOiByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFBJXzIgLSBUd28gUGlcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBQSV8yOiBNYXRoLlBJICogMixcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSQURfVE9fREVHIC0gQ29uc3RhbnQgY29udmVyc2lvbiBmYWN0b3IgZm9yIGNvbnZlcnRpbmcgcmFkaWFucyB0byBkZWdyZWVzXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgUkFEX1RPX0RFRzogMTgwIC8gTWF0aC5QSSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBERUdfVE9fUkFEIC0gQ29uc3RhbnQgY29udmVyc2lvbiBmYWN0b3IgZm9yIGNvbnZlcnRpbmcgZGVncmVlcyB0byByYWRpYW5zXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgREVHX1RPX1JBRDogTWF0aC5QSSAvIDE4MCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRhcmdldCBmcmFtZXMgcGVyIG1pbGxpc2Vjb25kLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFRBUkdFVF9GUE1TPTAuMDZcclxuICAgICAqL1xyXG4gICAgVEFSR0VUX0ZQTVM6IDAuMDYsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdGFudCB0byBpZGVudGlmeSB0aGUgUmVuZGVyZXIgVHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBSRU5ERVJFUl9UWVBFXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gUkVOREVSRVJfVFlQRS5VTktOT1dOXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gUkVOREVSRVJfVFlQRS5XRUJHTFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFJFTkRFUkVSX1RZUEUuQ0FOVkFTXHJcbiAgICAgKi9cclxuICAgIFJFTkRFUkVSX1RZUEU6IHtcclxuICAgICAgICBVTktOT1dOOiAgICAwLFxyXG4gICAgICAgIFdFQkdMOiAgICAgIDEsXHJcbiAgICAgICAgQ0FOVkFTOiAgICAgMlxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhcmlvdXMgYmxlbmQgbW9kZXMgc3VwcG9ydGVkIGJ5IFBJWEkuIElNUE9SVEFOVCAtIFRoZSBXZWJHTCByZW5kZXJlciBvbmx5IHN1cHBvcnRzXHJcbiAgICAgKiB0aGUgTk9STUFMLCBBREQsIE1VTFRJUExZIGFuZCBTQ1JFRU4gYmxlbmQgbW9kZXMuIEFueXRoaW5nIGVsc2Ugd2lsbCBzaWxlbnRseSBhY3QgbGlrZVxyXG4gICAgICogTk9STUFMLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IEJMRU5EX01PREVTXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuTk9STUFMXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuQUREXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuTVVMVElQTFlcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5TQ1JFRU5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5PVkVSTEFZXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuREFSS0VOXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuTElHSFRFTlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkNPTE9SX0RPREdFXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuQ09MT1JfQlVSTlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkhBUkRfTElHSFRcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5TT0ZUX0xJR0hUXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuRElGRkVSRU5DRVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkVYQ0xVU0lPTlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkhVRVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLlNBVFVSQVRJT05cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5DT0xPUlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkxVTUlOT1NJVFlcclxuICAgICAqL1xyXG4gICAgQkxFTkRfTU9ERVM6IHtcclxuICAgICAgICBOT1JNQUw6ICAgICAgICAgMCxcclxuICAgICAgICBBREQ6ICAgICAgICAgICAgMSxcclxuICAgICAgICBNVUxUSVBMWTogICAgICAgMixcclxuICAgICAgICBTQ1JFRU46ICAgICAgICAgMyxcclxuICAgICAgICBPVkVSTEFZOiAgICAgICAgNCxcclxuICAgICAgICBEQVJLRU46ICAgICAgICAgNSxcclxuICAgICAgICBMSUdIVEVOOiAgICAgICAgNixcclxuICAgICAgICBDT0xPUl9ET0RHRTogICAgNyxcclxuICAgICAgICBDT0xPUl9CVVJOOiAgICAgOCxcclxuICAgICAgICBIQVJEX0xJR0hUOiAgICAgOSxcclxuICAgICAgICBTT0ZUX0xJR0hUOiAgICAgMTAsXHJcbiAgICAgICAgRElGRkVSRU5DRTogICAgIDExLFxyXG4gICAgICAgIEVYQ0xVU0lPTjogICAgICAxMixcclxuICAgICAgICBIVUU6ICAgICAgICAgICAgMTMsXHJcbiAgICAgICAgU0FUVVJBVElPTjogICAgIDE0LFxyXG4gICAgICAgIENPTE9SOiAgICAgICAgICAxNSxcclxuICAgICAgICBMVU1JTk9TSVRZOiAgICAgMTZcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYXJpb3VzIHdlYmdsIGRyYXcgbW9kZXMuIFRoZXNlIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgd2hpY2ggR0wgZHJhd01vZGUgdG8gdXNlXHJcbiAgICAgKiB1bmRlciBjZXJ0YWluIHNpdHVhdGlvbnMgYW5kIHJlbmRlcmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBEUkFXX01PREVTXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRFJBV19NT0RFUy5QT0lOVFNcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLkxJTkVTXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRFJBV19NT0RFUy5MSU5FX0xPT1BcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLkxJTkVfU1RSSVBcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLlRSSUFOR0xFU1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERSQVdfTU9ERVMuVFJJQU5HTEVfU1RSSVBcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLlRSSUFOR0xFX0ZBTlxyXG4gICAgICovXHJcbiAgICBEUkFXX01PREVTOiB7XHJcbiAgICAgICAgUE9JTlRTOiAgICAgICAgIDAsXHJcbiAgICAgICAgTElORVM6ICAgICAgICAgIDEsXHJcbiAgICAgICAgTElORV9MT09QOiAgICAgIDIsXHJcbiAgICAgICAgTElORV9TVFJJUDogICAgIDMsXHJcbiAgICAgICAgVFJJQU5HTEVTOiAgICAgIDQsXHJcbiAgICAgICAgVFJJQU5HTEVfU1RSSVA6IDUsXHJcbiAgICAgICAgVFJJQU5HTEVfRkFOOiAgIDZcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2NhbGUgbW9kZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHBpeGkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIERFRkFVTFQgc2NhbGUgbW9kZSBhZmZlY3RzIHRoZSBkZWZhdWx0IHNjYWxpbmcgbW9kZSBvZiBmdXR1cmUgb3BlcmF0aW9ucy5cclxuICAgICAqIEl0IGNhbiBiZSByZS1hc3NpZ25lZCB0byBlaXRoZXIgTElORUFSIG9yIE5FQVJFU1QsIGRlcGVuZGluZyB1cG9uIHN1aXRhYmlsaXR5LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFNDQUxFX01PREVTXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gU0NBTEVfTU9ERVMuREVGQVVMVD1MSU5FQVJcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTQ0FMRV9NT0RFUy5MSU5FQVIgU21vb3RoIHNjYWxpbmdcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTQ0FMRV9NT0RFUy5ORUFSRVNUIFBpeGVsYXRpbmcgc2NhbGluZ1xyXG4gICAgICovXHJcbiAgICBTQ0FMRV9NT0RFUzoge1xyXG4gICAgICAgIERFRkFVTFQ6ICAgIDAsXHJcbiAgICAgICAgTElORUFSOiAgICAgMCxcclxuICAgICAgICBORUFSRVNUOiAgICAxXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHByZWZpeCB0aGF0IGRlbm90ZXMgYSBVUkwgaXMgZm9yIGEgcmV0aW5hIGFzc2V0XHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gUkVUSU5BX1BSRUZJWFxyXG4gICAgICovXHJcbiAgICAvL2V4YW1wbGU6ICdAMngnLFxyXG4gICAgUkVUSU5BX1BSRUZJWDogL0AoLispeC8sXHJcblxyXG4gICAgUkVTT0xVVElPTjoxLFxyXG5cclxuICAgIEZJTFRFUl9SRVNPTFVUSU9OOjEsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCByZW5kZXIgb3B0aW9ucyBpZiBub25lIGFyZSBzdXBwbGllZCB0byB7QGxpbmsgUElYSS5XZWJHTFJlbmRlcmVyfVxyXG4gICAgICogb3Ige0BsaW5rIFBJWEkuQ2FudmFzUmVuZGVyZXJ9LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IERFRkFVTFRfUkVOREVSX09QVElPTlNcclxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTENhbnZhc0VsZW1lbnR9IERFRkFVTFRfUkVOREVSX09QVElPTlMudmlldz1udWxsXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IERFRkFVTFRfUkVOREVSX09QVElPTlMudHJhbnNwYXJlbnQ9ZmFsc2VcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gREVGQVVMVF9SRU5ERVJfT1BUSU9OUy5hbnRpYWxpYXM9ZmFsc2VcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gREVGQVVMVF9SRU5ERVJfT1BUSU9OUy5mb3JjZUZYQUE9ZmFsc2VcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gREVGQVVMVF9SRU5ERVJfT1BUSU9OUy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBERUZBVUxUX1JFTkRFUl9PUFRJT05TLnJlc29sdXRpb249MVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERFRkFVTFRfUkVOREVSX09QVElPTlMuYmFja2dyb3VuZENvbG9yPTB4MDAwMDAwXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IERFRkFVTFRfUkVOREVSX09QVElPTlMuY2xlYXJCZWZvcmVSZW5kZXI9dHJ1ZVxyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBERUZBVUxUX1JFTkRFUl9PUFRJT05TLmF1dG9SZXNpemU9ZmFsc2VcclxuICAgICAqL1xyXG4gICAgREVGQVVMVF9SRU5ERVJfT1BUSU9OUzoge1xyXG4gICAgICAgIHZpZXc6IG51bGwsXHJcbiAgICAgICAgcmVzb2x1dGlvbjogMSxcclxuICAgICAgICBhbnRpYWxpYXM6IGZhbHNlLFxyXG4gICAgICAgIGZvcmNlRlhBQTogZmFsc2UsXHJcbiAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogMHgwMDAwMDAsXHJcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcclxuICAgICAgICByb3VuZFBpeGVsczogZmFsc2VcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdGFudHMgdGhhdCBpZGVudGlmeSBzaGFwZXMsIG1haW5seSB0byBwcmV2ZW50IGBpbnN0YW5jZW9mYCBjYWxscy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBTSEFQRVNcclxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBTSEFQRVMuUE9MWT0wXHJcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gU0hBUEVTLlJFQ1Q9MVxyXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFNIQVBFUy5DSVJDPTJcclxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBTSEFQRVMuRUxJUD0zXHJcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gU0hBUEVTLlJSRUM9NFxyXG4gICAgICovXHJcbiAgICBTSEFQRVM6IHtcclxuICAgICAgICBQT0xZOiAwLFxyXG4gICAgICAgIFJFQ1Q6IDEsXHJcbiAgICAgICAgQ0lSQzogMixcclxuICAgICAgICBFTElQOiAzLFxyXG4gICAgICAgIFJSRUM6IDRcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVE9ETzogbWF5YmUgY2hhbmdlIHRvIFNQUklURS5CQVRDSF9TSVpFOiAyMDAwXHJcbiAgICAvLyBUT0RPOiBtYXliZSBhZGQgUEFSVElDTEUuQkFUQ0hfU0laRTogMTUwMDBcclxuICAgIFNQUklURV9CQVRDSF9TSVpFOiAyMDAwIC8vbmljZSBiYWxhbmNlIGJldHdlZW4gbW9iaWxlIGFuZCBkZXNrdG9wIG1hY2hpbmVzXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG4iLCJ2YXIgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcclxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKSxcclxuICAgIERpc3BsYXlPYmplY3QgPSByZXF1aXJlKCcuL0Rpc3BsYXlPYmplY3QnKSxcclxuICAgIFJlbmRlclRleHR1cmUgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9SZW5kZXJUZXh0dXJlJyksXHJcbiAgICBfdGVtcE1hdHJpeCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xyXG5cclxuLyoqXHJcbiAqIEEgQ29udGFpbmVyIHJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGRpc3BsYXkgb2JqZWN0cy5cclxuICogSXQgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXkgb2JqZWN0cyB0aGF0IGFjdCBhcyBhIGNvbnRhaW5lciBmb3Igb3RoZXIgb2JqZWN0cy5cclxuICpcclxuICpgYGBqc1xyXG4gKiB2YXIgY29udGFpbmVyID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XHJcbiAqIGNvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xyXG4gKiBgYGBcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuRGlzcGxheU9iamVjdFxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKi9cclxuZnVuY3Rpb24gQ29udGFpbmVyKClcclxue1xyXG4gICAgRGlzcGxheU9iamVjdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFycmF5IG9mIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdFtdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxufVxyXG5cclxuLy8gY29uc3RydWN0b3JcclxuQ29udGFpbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGlzcGxheU9iamVjdC5wcm90b3R5cGUpO1xyXG5Db250YWluZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udGFpbmVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5lcjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnRhaW5lci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuQ29udGFpbmVyI1xyXG4gICAgICovXHJcbiAgICB3aWR0aDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XHJcblxyXG4gICAgICAgICAgICBpZiAod2lkdGggIT09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gd2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnggPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgQ29udGFpbmVyLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkNvbnRhaW5lciNcclxuICAgICAqL1xyXG4gICAgaGVpZ2h0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICB0aGlzLnNjYWxlLnkgKiB0aGlzLmdldExvY2FsQm91bmRzKCkuaGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGVpZ2h0ICE9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIGhlaWdodCA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIE92ZXJyaWRhYmxlIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIGJ5IENvbnRhaW5lciBzdWJjbGFzc2VzIHdoZW5ldmVyIHRoZSBjaGlsZHJlbiBhcnJheSBpcyBtb2RpZmllZFxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQ29udGFpbmVyLnByb3RvdHlwZS5vbkNoaWxkcmVuQ2hhbmdlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4vKipcclxuICogQWRkcyBhIGNoaWxkIHRvIHRoZSBjb250YWluZXIuXHJcbiAqIFxyXG4gKiBZb3UgY2FuIGFsc28gYWRkIG11bHRwbGUgaXRlbXMgbGlrZSBzbzogbXlDb250YWluZXIuYWRkQ2hpbGQodGhpbmtPbmUsIHRoaW5nVHdvLCB0aGluZ1RocmVlKVxyXG4gKiBAcGFyYW0gY2hpbGQge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIERpc3BsYXlPYmplY3QgdG8gYWRkIHRvIHRoZSBjb250YWluZXJcclxuICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXHJcbiAqL1xyXG5Db250YWluZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKVxyXG57IFxyXG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblxyXG4gICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgYXJndW1lbnQgd2UgY2FuIGJ5cGFzcyBsb29waW5nIHRocm91Z2ggdGhlIHRoZW1cclxuICAgIGlmKGFyZ3VtZW50c0xlbmd0aCA+IDEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBhcmd1bWVudHMgcHJvcGVydHkgYW5kIGFkZCBhbGwgY2hpbGRyZW5cclxuICAgICAgICAvLyB1c2UgaXQgdGhlIHJpZ2h0IHdheSAoLmxlbmd0aCBhbmQgW2ldKSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIHN0aWxsIGJlIG9wdGltaXNlZCBieSBKUyBydW50aW1lc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzTGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKCBhcmd1bWVudHNbaV0gKTtcclxuICAgICAgICB9XHJcbiAgICB9ICAgICBcclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyBpZiB0aGUgY2hpbGQgaGFzIGEgcGFyZW50IHRoZW4gbGV0cyByZW1vdmUgaXQgYXMgUGl4aSBvYmplY3RzIGNhbiBvbmx5IGV4aXN0IGluIG9uZSBwbGFjZVxyXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cclxuICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXHJcbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKHRoaXMuY2hpbGRyZW4ubGVuZ3RoLTEpO1xyXG4gICAgICAgIGNoaWxkLmVtaXQoJ2FkZGVkJywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNoaWxkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSBjaGlsZCB0byB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkIGluZGV4LiBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcyBhbiBlcnJvciB3aWxsIGJlIHRocm93blxyXG4gKlxyXG4gKiBAcGFyYW0gY2hpbGQge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRvIGFkZFxyXG4gKiBAcGFyYW0gaW5kZXgge251bWJlcn0gVGhlIGluZGV4IHRvIHBsYWNlIHRoZSBjaGlsZCBpblxyXG4gKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cclxuICovXHJcbkNvbnRhaW5lci5wcm90b3R5cGUuYWRkQ2hpbGRBdCA9IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpXHJcbntcclxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDw9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxyXG4gICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XHJcbiAgICAgICAgY2hpbGQuZW1pdCgnYWRkZWQnLCB0aGlzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjaGlsZCArICdhZGRDaGlsZEF0OiBUaGUgaW5kZXggJysgaW5kZXggKycgc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAnICsgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN3YXBzIHRoZSBwb3NpdGlvbiBvZiAyIERpc3BsYXkgT2JqZWN0cyB3aXRoaW4gdGhpcyBjb250YWluZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGlsZCB7UElYSS5EaXNwbGF5T2JqZWN0fVxyXG4gKiBAcGFyYW0gY2hpbGQyIHtQSVhJLkRpc3BsYXlPYmplY3R9XHJcbiAqL1xyXG5Db250YWluZXIucHJvdG90eXBlLnN3YXBDaGlsZHJlbiA9IGZ1bmN0aW9uIChjaGlsZCwgY2hpbGQyKVxyXG57XHJcbiAgICBpZiAoY2hpbGQgPT09IGNoaWxkMilcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluZGV4MSA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZCk7XHJcbiAgICB2YXIgaW5kZXgyID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkMik7XHJcblxyXG4gICAgaWYgKGluZGV4MSA8IDAgfHwgaW5kZXgyIDwgMClcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N3YXBDaGlsZHJlbjogQm90aCB0aGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdHMgbXVzdCBiZSBjaGlsZHJlbiBvZiB0aGUgY2FsbGVyLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMjtcclxuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgyXSA9IGNoaWxkO1xyXG4gICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4MSA8IGluZGV4MiA/IGluZGV4MSA6IGluZGV4Mik7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5kZXggcG9zaXRpb24gb2YgYSBjaGlsZCBEaXNwbGF5T2JqZWN0IGluc3RhbmNlXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGlsZCB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZSB0byBpZGVudGlmeVxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBwb3NpdGlvbiBvZiB0aGUgY2hpbGQgZGlzcGxheSBvYmplY3QgdG8gaWRlbnRpZnlcclxuICovXHJcbkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChjaGlsZClcclxue1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcclxuXHJcbiAgICBpZiAoaW5kZXggPT09IC0xKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3QgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXInKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgYW4gZXhpc3RpbmcgY2hpbGQgaW4gdGhlIGRpc3BsYXkgb2JqZWN0IGNvbnRhaW5lclxyXG4gKlxyXG4gKiBAcGFyYW0gY2hpbGQge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgZm9yIHdoaWNoIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgaW5kZXggbnVtYmVyXHJcbiAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBUaGUgcmVzdWx0aW5nIGluZGV4IG51bWJlciBmb3IgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0XHJcbiAqL1xyXG5Db250YWluZXIucHJvdG90eXBlLnNldENoaWxkSW5kZXggPSBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KVxyXG57XHJcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1cHBsaWVkIGluZGV4IGlzIG91dCBvZiBib3VuZHMnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcclxuXHJcbiAgICB1dGlscy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBjdXJyZW50SW5kZXgsIDEpOyAvLyByZW1vdmUgZnJvbSBvbGQgcG9zaXRpb25cclxuICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7IC8vYWRkIGF0IG5ldyBwb3NpdGlvblxyXG4gICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAqXHJcbiAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBhdFxyXG4gKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGFueS5cclxuICovXHJcbkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRBdCA9IGZ1bmN0aW9uIChpbmRleClcclxue1xyXG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldENoaWxkQXQ6IFN1cHBsaWVkIGluZGV4ICcgKyBpbmRleCArICcgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNoaWxkIGxpc3QsIG9yIHRoZSBzdXBwbGllZCBEaXNwbGF5T2JqZWN0IGlzIG5vdCBhIGNoaWxkIG9mIHRoZSBjYWxsZXInKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpbmRleF07XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhIGNoaWxkIGZyb20gdGhlIGNvbnRhaW5lci5cclxuICpcclxuICogQHBhcmFtIGNoaWxkIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIHJlbW92ZVxyXG4gKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyByZW1vdmVkLlxyXG4gKi9cclxuQ29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZClcclxue1xyXG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblxyXG4gICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgYXJndW1lbnQgd2UgY2FuIGJ5cGFzcyBsb29waW5nIHRocm91Z2ggdGhlIHRoZW1cclxuICAgIGlmKGFyZ3VtZW50c0xlbmd0aCA+IDEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBhcmd1bWVudHMgcHJvcGVydHkgYW5kIGFkZCBhbGwgY2hpbGRyZW5cclxuICAgICAgICAvLyB1c2UgaXQgdGhlIHJpZ2h0IHdheSAoLmxlbmd0aCBhbmQgW2ldKSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIHN0aWxsIGJlIG9wdGltaXNlZCBieSBKUyBydW50aW1lc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzTGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKCBhcmd1bWVudHNbaV0gKTtcclxuICAgICAgICB9XHJcbiAgICB9ICAgICBcclxuICAgIGVsc2VcclxuICAgIHsgICBcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB1dGlscy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XHJcblxyXG4gICAgICAgIC8vIFRPRE8gLSBsZXRzIGVpdGhlciBkbyBhbGwgY2FsbGJhY2tzIG9yIGFsbCBldmVudHMuLiBub3QgYm90aCFcclxuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xyXG4gICAgICAgIGNoaWxkLmVtaXQoJ3JlbW92ZWQnLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2hpbGQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhIGNoaWxkIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleCBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGZyb21cclxuICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgcmVtb3ZlZC5cclxuICovXHJcbkNvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGRBdCA9IGZ1bmN0aW9uIChpbmRleClcclxue1xyXG4gICAgdmFyIGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KGluZGV4KTtcclxuXHJcbiAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xyXG4gICAgdXRpbHMucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaW5kZXgsIDEpO1xyXG5cclxuICAgIC8vIFRPRE8gLSBsZXRzIGVpdGhlciBkbyBhbGwgY2FsbGJhY2tzIG9yIGFsbCBldmVudHMuLiBub3QgYm90aCFcclxuICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XHJcbiAgICBjaGlsZC5lbWl0KCdyZW1vdmVkJywgdGhpcyk7XHJcblxyXG4gICAgcmV0dXJuIGNoaWxkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBjb250YWluZXIgdGhhdCBhcmUgd2l0aGluIHRoZSBiZWdpbiBhbmQgZW5kIGluZGV4ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBiZWdpbkluZGV4IHtudW1iZXJ9IFRoZSBiZWdpbm5pbmcgcG9zaXRpb24uIERlZmF1bHQgdmFsdWUgaXMgMC5cclxuICogQHBhcmFtIGVuZEluZGV4IHtudW1iZXJ9IFRoZSBlbmRpbmcgcG9zaXRpb24uIERlZmF1bHQgdmFsdWUgaXMgc2l6ZSBvZiB0aGUgY29udGFpbmVyLlxyXG4gKi9cclxuQ29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uIChiZWdpbkluZGV4LCBlbmRJbmRleClcclxue1xyXG4gICAgdmFyIGJlZ2luID0gYmVnaW5JbmRleCB8fCAwO1xyXG4gICAgdmFyIGVuZCA9IHR5cGVvZiBlbmRJbmRleCA9PT0gJ251bWJlcicgPyBlbmRJbmRleCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgdmFyIHJhbmdlID0gZW5kIC0gYmVnaW47XHJcbiAgICB2YXIgcmVtb3ZlZCwgaTtcclxuXHJcbiAgICBpZiAocmFuZ2UgPiAwICYmIHJhbmdlIDw9IGVuZClcclxuICAgIHtcclxuICAgICAgICByZW1vdmVkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoYmVnaW4sIHJhbmdlKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW1vdmVkW2ldLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoYmVnaW5JbmRleCk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVtb3ZlZFtpXS5lbWl0KCdyZW1vdmVkJywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJhbmdlID09PSAwICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVtb3ZlQ2hpbGRyZW46IG51bWVyaWMgdmFsdWVzIGFyZSBvdXRzaWRlIHRoZSBhY2NlcHRhYmxlIHJhbmdlLicpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVzZWZ1bCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0ZXh0dXJlIG9mIHRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY3JlYXRlIHNwcml0ZXNcclxuICogVGhpcyBjYW4gYmUgcXVpdGUgdXNlZnVsIGlmIHlvdXIgZGlzcGxheU9iamVjdCBpcyBzdGF0aWMgLyBjb21wbGljYXRlZCBhbmQgbmVlZHMgdG8gYmUgcmV1c2VkIG11bHRpcGxlIHRpbWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGV4dHVyZS5cclxuICogQHBhcmFtIHJlc29sdXRpb24ge251bWJlcn0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgYmVpbmcgZ2VuZXJhdGVkXHJcbiAqIEBwYXJhbSBzY2FsZU1vZGUge251bWJlcn0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXHJcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gYSB0ZXh0dXJlIG9mIHRoZSBkaXNwbGF5IG9iamVjdFxyXG4gKi9cclxuQ29udGFpbmVyLnByb3RvdHlwZS5nZW5lcmF0ZVRleHR1cmUgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHJlc29sdXRpb24sIHNjYWxlTW9kZSlcclxue1xyXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcclxuXHJcbiAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBSZW5kZXJUZXh0dXJlKHJlbmRlcmVyLCBib3VuZHMud2lkdGggfCAwLCBib3VuZHMuaGVpZ2h0IHwgMCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKTtcclxuXHJcbiAgICBfdGVtcE1hdHJpeC50eCA9IC1ib3VuZHMueDtcclxuICAgIF90ZW1wTWF0cml4LnR5ID0gLWJvdW5kcy55O1xyXG5cclxuICAgIHJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMsIF90ZW1wTWF0cml4KTtcclxuXHJcbiAgICByZXR1cm4gcmVuZGVyVGV4dHVyZTtcclxufTtcclxuXHJcbi8qXHJcbiAqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybSBvbiBhbGwgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIgZm9yIHJlbmRlcmluZ1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICBpZiAoIXRoaXMudmlzaWJsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gcGVyZm9ybWFuY2UgaW5jcmVhc2UgdG8gYXZvaWQgdXNpbmcgY2FsbC4uICgxMHggZmFzdGVyKVxyXG5Db250YWluZXIucHJvdG90eXBlLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSA9IENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBDb250YWluZXIgYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgYWxsIHZpc2libGUgY2hpbGRyZW4gaW50byBjb25zaWRlcmF0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcclxuICovXHJcbkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYoIXRoaXMuX2N1cnJlbnRCb3VuZHMpXHJcbiAgICB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRoLlJlY3RhbmdsZS5FTVBUWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE8gdGhlIGJvdW5kcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxjdWxhdGVkIHRoaXMgcmVuZGVyIHNlc3Npb24gc28gcmV0dXJuIHdoYXQgd2UgaGF2ZVxyXG5cclxuICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xyXG4gICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xyXG5cclxuICAgICAgICB2YXIgY2hpbGRCb3VuZHM7XHJcbiAgICAgICAgdmFyIGNoaWxkTWF4WDtcclxuICAgICAgICB2YXIgY2hpbGRNYXhZO1xyXG5cclxuICAgICAgICB2YXIgY2hpbGRWaXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFjaGlsZC52aXNpYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hpbGRWaXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkQm91bmRzID0gdGhpcy5jaGlsZHJlbltpXS5nZXRCb3VuZHMoKTtcclxuXHJcbiAgICAgICAgICAgIG1pblggPSBtaW5YIDwgY2hpbGRCb3VuZHMueCA/IG1pblggOiBjaGlsZEJvdW5kcy54O1xyXG4gICAgICAgICAgICBtaW5ZID0gbWluWSA8IGNoaWxkQm91bmRzLnkgPyBtaW5ZIDogY2hpbGRCb3VuZHMueTtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkTWF4WCA9IGNoaWxkQm91bmRzLndpZHRoICsgY2hpbGRCb3VuZHMueDtcclxuICAgICAgICAgICAgY2hpbGRNYXhZID0gY2hpbGRCb3VuZHMuaGVpZ2h0ICsgY2hpbGRCb3VuZHMueTtcclxuXHJcbiAgICAgICAgICAgIG1heFggPSBtYXhYID4gY2hpbGRNYXhYID8gbWF4WCA6IGNoaWxkTWF4WDtcclxuICAgICAgICAgICAgbWF4WSA9IG1heFkgPiBjaGlsZE1heFkgPyBtYXhZIDogY2hpbGRNYXhZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjaGlsZFZpc2libGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0aC5SZWN0YW5nbGUuRU1QVFk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xyXG5cclxuICAgICAgICBib3VuZHMueCA9IG1pblg7XHJcbiAgICAgICAgYm91bmRzLnkgPSBtaW5ZO1xyXG4gICAgICAgIGJvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xyXG4gICAgICAgIGJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuXHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IGJvdW5kcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJvdW5kcztcclxufTtcclxuXHJcbkNvbnRhaW5lci5wcm90b3R5cGUuY29udGFpbmVyR2V0Qm91bmRzID0gQ29udGFpbmVyLnByb3RvdHlwZS5nZXRCb3VuZHM7XHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIHRoZSBub24tZ2xvYmFsIGxvY2FsIGJvdW5kcyBvZiB0aGUgQ29udGFpbmVyIGFzIGEgcmVjdGFuZ2xlLlxyXG4gKiBUaGUgY2FsY3VsYXRpb24gdGFrZXMgYWxsIHZpc2libGUgY2hpbGRyZW4gaW50byBjb25zaWRlcmF0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcclxuICovXHJcbkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgbWF0cml4Q2FjaGUgPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xyXG5cclxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBtYXRoLk1hdHJpeC5JREVOVElUWTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG1hdHJpeENhY2hlO1xyXG5cclxuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmdldEJvdW5kcyggbWF0aC5NYXRyaXguSURFTlRJVFkgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXHJcbiAqXHJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXJcclxuICovXHJcbkNvbnRhaW5lci5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpXHJcbntcclxuXHJcbiAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIG5vdCB2aXNpYmxlIG9yIHRoZSBhbHBoYSBpcyAwIHRoZW4gbm8gbmVlZCB0byByZW5kZXIgdGhpcyBlbGVtZW50XHJcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaSwgajtcclxuXHJcbiAgICAvLyBkbyBhIHF1aWNrIGNoZWNrIHRvIHNlZSBpZiB0aGlzIGVsZW1lbnQgaGFzIGEgbWFzayBvciBhIGZpbHRlci5cclxuICAgIGlmICh0aGlzLl9tYXNrIHx8IHRoaXMuX2ZpbHRlcnMpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XHJcblxyXG4gICAgICAgIC8vIHB1c2ggZmlsdGVyIGZpcnN0IGFzIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBzdGVuY2lsIGJ1ZmZlciBpcyBjb3JyZWN0IGZvciBhbnkgbWFza2luZ1xyXG4gICAgICAgIGlmICh0aGlzLl9maWx0ZXJzICYmIHRoaXMuX2ZpbHRlcnMubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5wdXNoRmlsdGVyKHRoaXMsIHRoaXMuX2ZpbHRlcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX21hc2spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW5kZXJlci5tYXNrTWFuYWdlci5wdXNoTWFzayh0aGlzLCB0aGlzLl9tYXNrKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpO1xyXG5cclxuICAgICAgICAvLyBhZGQgdGhpcyBvYmplY3QgdG8gdGhlIGJhdGNoLCBvbmx5IHJlbmRlcmVkIGlmIGl0IGhhcyBhIHRleHR1cmUuXHJcbiAgICAgICAgdGhpcy5fcmVuZGVyV2ViR0wocmVuZGVyZXIpO1xyXG5cclxuICAgICAgICAvLyBub3cgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBhbmQgbWFrZSBzdXJlIHRoZXkgZ2V0IHJlbmRlcmVkXHJcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXJXZWJHTChyZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXJlci5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX21hc2spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW5kZXJlci5tYXNrTWFuYWdlci5wb3BNYXNrKHRoaXMsIHRoaXMuX21hc2spO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpbHRlcnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLnBvcEZpbHRlcigpO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyV2ViR0wocmVuZGVyZXIpO1xyXG5cclxuICAgICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxyXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVuZGVyV2ViR0wocmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUbyBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc1xyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Db250YWluZXIucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChyZW5kZXJlcikgLy8ganNoaW50IHVudXNlZDpmYWxzZVxyXG57XHJcbiAgICAvLyB0aGlzIGlzIHdoZXJlIGNvbnRlbnQgaXRzZWxmIGdldHMgcmVuZGVyZWQuLi5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUbyBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc1xyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IFRoZSByZW5kZXJlclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQ29udGFpbmVyLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKSAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXHJcbntcclxuICAgIC8vIHRoaXMgaXMgd2hlcmUgY29udGVudCBpdHNlbGYgZ2V0cyByZW5kZXJlZC4uLlxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IFRoZSByZW5kZXJlclxyXG4gKi9cclxuQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiAocmVuZGVyZXIpXHJcbntcclxuICAgIC8vIGlmIG5vdCB2aXNpYmxlIG9yIHRoZSBhbHBoYSBpcyAwIHRoZW4gbm8gbmVlZCB0byByZW5kZXIgdGhpc1xyXG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy5hbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9tYXNrKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMuX21hc2ssIHJlbmRlcmVyKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9yZW5kZXJDYW52YXMocmVuZGVyZXIpO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbmRlckNhbnZhcyhyZW5kZXJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX21hc2spXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIubWFza01hbmFnZXIucG9wTWFzayhyZW5kZXJlcik7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRGVzdHJveXMgdGhlIGNvbnRhaW5lclxyXG4gKiBAcGFyYW0gW2Rlc3Ryb3lDaGlsZHJlbj1mYWxzZV0ge2Jvb2xlYW59IGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95IG1ldGhvZCBjYWxsZWQgYXMgd2VsbFxyXG4gKi9cclxuQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGRlc3Ryb3lDaGlsZHJlbilcclxue1xyXG4gICAgRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIGlmIChkZXN0cm95Q2hpbGRyZW4pXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveShkZXN0cm95Q2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XHJcblxyXG4gICAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XHJcbn07XHJcbiIsInZhciBtYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpLFxyXG4gICAgUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1JlbmRlclRleHR1cmUnKSxcclxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKSxcclxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcclxuICAgIF90ZW1wTWF0cml4ID0gbmV3IG1hdGguTWF0cml4KCksXHJcbiAgICBfdGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSB7d29ybGRUcmFuc2Zvcm06bmV3IG1hdGguTWF0cml4KCksIHdvcmxkQWxwaGE6MSwgY2hpbGRyZW46W119O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIG9iamVjdHMgdGhhdCBhcmUgcmVuZGVyZWQgb24gdGhlIHNjcmVlbi5cclxuICogVGhpcyBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIG9uIGl0cyBvd24gcmF0aGVyIGl0IHNob3VsZCBiZSBleHRlbmRlZC5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKi9cclxuZnVuY3Rpb24gRGlzcGxheU9iamVjdCgpXHJcbntcclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IG1hdGguUG9pbnQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzY2FsZSBmYWN0b3Igb2YgdGhlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjYWxlID0gbmV3IG1hdGguUG9pbnQoMSwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGl2b3QgcG9pbnQgb2YgdGhlIGRpc3BsYXlPYmplY3QgdGhhdCBpdCByb3RhdGVzIGFyb3VuZFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGl2b3QgPSBuZXcgbWF0aC5Qb2ludCgwLCAwKTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2tldyBmYWN0b3IgZm9yIHRoZSBvYmplY3QgaW4gcmFkaWFucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNrZXcgPSBuZXcgbWF0aC5Qb2ludCgwLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByb3RhdGlvbiBvZiB0aGUgb2JqZWN0IGluIHJhZGlhbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFscGhhID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBvYmplY3QuIElmIGZhbHNlIHRoZSBvYmplY3Qgd2lsbCBub3QgYmUgZHJhd24sIGFuZFxyXG4gICAgICogdGhlIHVwZGF0ZVRyYW5zZm9ybSBmdW5jdGlvbiB3aWxsIG5vdCBiZSBjYWxsZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbiB0aGlzIG9iamVjdCBiZSByZW5kZXJlZCwgaWYgZmFsc2UgdGhlIG9iamVjdCB3aWxsIG5vdCBiZSBkcmF3biBidXQgdGhlIHVwZGF0ZVRyYW5zZm9ybVxyXG4gICAgICogbWV0aG9kcyB3aWxsIHN0aWxsIGJlIGNhbGxlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRpc3BsYXkgb2JqZWN0IGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5Db250YWluZXJ9XHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG11bHRpcGxpZWQgYWxwaGEgb2YgdGhlIGRpc3BsYXlPYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xyXG4gICAgdGhpcy53b3JsZEFscGhhID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gd29ybGQgKHBhcmVudCkgZmFjdG9yc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKi9cclxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgbWF0aC5NYXRyaXgoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhcmVhIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCB0by4gVGhpcyBpcyB1c2VkIGFzIG1vcmUgb2YgYW4gb3B0aW1pc2F0aW9uXHJcbiAgICAgKiByYXRoZXIgdGhhbiBmaWd1cmluZyBvdXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGRpc3BsYXlPYmplY3QgZWFjaCBmcmFtZSB5b3UgY2FuIHNldCB0aGlzIHJlY3RhbmdsZVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogY2FjaGVkIHNpbiByb3RhdGlvblxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3NyID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNhY2hlZCBjb3Mgcm90YXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9jciA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwsIGNhY2hlZCBib3VuZHMgb2YgdGhlIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fYm91bmRzID0gbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgdXAtdG8tZGF0ZSBib3VuZHMgb2YgdGhlIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3JpZ2luYWwsIGNhY2hlZCBtYXNrIG9mIHRoZSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX21hc2sgPSBudWxsO1xyXG59XHJcblxyXG4vLyBjb25zdHJ1Y3RvclxyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlzcGxheU9iamVjdDtcclxubW9kdWxlLmV4cG9ydHMgPSBEaXNwbGF5T2JqZWN0O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGlzcGxheU9iamVjdC5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB4IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAqL1xyXG4gICAgeDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHkgYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICovXHJcbiAgICB5OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgc3ByaXRlIGlzIGdsb2JhbGx5IHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgd29ybGRWaXNpYmxlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLnZpc2libGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnBhcmVudDtcclxuICAgICAgICAgICAgfSB3aGlsZSAoaXRlbSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIG1hc2sgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LiBBIG1hc2sgaXMgYW4gb2JqZWN0IHRoYXQgbGltaXRzIHRoZSB2aXNpYmlsaXR5IG9mIGFuIG9iamVjdCB0byB0aGUgc2hhcGUgb2YgdGhlIG1hc2sgYXBwbGllZCB0byBpdC5cclxuICAgICAqIEluIFBJWEkgYSByZWd1bGFyIG1hc2sgbXVzdCBiZSBhIFBJWEkuR3JhcGhpY3Mgb3IgYSBQSVhJLlNwcml0ZSBvYmplY3QuIFRoaXMgYWxsb3dzIGZvciBtdWNoIGZhc3RlciBtYXNraW5nIGluIGNhbnZhcyBhcyBpdCB1dGlsaXNlcyBzaGFwZSBjbGlwcGluZy5cclxuICAgICAqIFRvIHJlbW92ZSBhIG1hc2ssIHNldCB0aGlzIHByb3BlcnR5IHRvIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc3xQSVhJLlNwcml0ZX1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgKi9cclxuICAgIG1hc2s6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFzaztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX21hc2spXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hc2sucmVuZGVyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX21hc2sgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXNrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXNrLnJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBmaWx0ZXJzIGZvciB0aGUgZGlzcGxheU9iamVjdC5cclxuICAgICAqICogSU1QT1JUQU5UOiBUaGlzIGlzIGEgd2ViR0wgb25seSBmZWF0dXJlIGFuZCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlci5cclxuICAgICAqIFRvIHJlbW92ZSBmaWx0ZXJzIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byAnbnVsbCdcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkFic3RyYWN0RmlsdGVyW119XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICovXHJcbiAgICBmaWx0ZXJzOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnMgJiYgdGhpcy5fZmlsdGVycy5zbGljZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJzID0gdmFsdWUgJiYgdmFsdWUuc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbi8qXHJcbiAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xyXG4gKlxyXG4gKiBUT0RPIC0gT3B0aW1pemF0aW9uIHBhc3MhXHJcbiAqL1xyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvLyBjcmVhdGUgc29tZSBtYXRyaXggcmVmcyBmb3IgZWFzeSBhY2Nlc3NcclxuICAgIHZhciBwdCA9IHRoaXMucGFyZW50LndvcmxkVHJhbnNmb3JtO1xyXG4gICAgdmFyIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcclxuXHJcbiAgICAvLyB0ZW1wb3JhcnkgbWF0cml4IHZhcmlhYmxlc1xyXG4gICAgdmFyIGEsIGIsIGMsIGQsIHR4LCB0eTtcclxuXHJcbiAgICAvLyBsb29rcyBsaWtlIHdlIGFyZSBza2V3aW5nXHJcbiAgICBpZih0aGlzLnNrZXcueCB8fCB0aGlzLnNrZXcueSlcclxuICAgIHtcclxuICAgICAgICAvLyBJJ20gYXNzdW1pbmcgdGhhdCBza2V3aW5nIGlzIG5vdCBnb2luZyB0byBiZSB2ZXJ5IGNvbW1vblxyXG4gICAgICAgIC8vIFdpdGggdGhhdCBpbiBtaW5kLCB3ZSBjYW4gZG8gYSBmdWxsIHNldFRyYW5zZm9ybSB1c2luZyB0aGUgdGVtcCBtYXRyaXhcclxuICAgICAgICBfdGVtcE1hdHJpeC5zZXRUcmFuc2Zvcm0oXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueCxcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55LFxyXG4gICAgICAgICAgICB0aGlzLnBpdm90LngsXHJcbiAgICAgICAgICAgIHRoaXMucGl2b3QueSxcclxuICAgICAgICAgICAgdGhpcy5zY2FsZS54LFxyXG4gICAgICAgICAgICB0aGlzLnNjYWxlLnksXHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24sXHJcbiAgICAgICAgICAgIHRoaXMuc2tldy54LFxyXG4gICAgICAgICAgICB0aGlzLnNrZXcueVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIG5vdyBjb25jYXQgdGhlIG1hdHJpeCAoaW5saW5lZCBzbyB0aGF0IHdlIGNhbiBhdm9pZCB1c2luZyBjb3B5KVxyXG4gICAgICAgIHd0LmEgID0gX3RlbXBNYXRyaXguYSAgKiBwdC5hICsgX3RlbXBNYXRyaXguYiAgKiBwdC5jO1xyXG4gICAgICAgIHd0LmIgID0gX3RlbXBNYXRyaXguYSAgKiBwdC5iICsgX3RlbXBNYXRyaXguYiAgKiBwdC5kO1xyXG4gICAgICAgIHd0LmMgID0gX3RlbXBNYXRyaXguYyAgKiBwdC5hICsgX3RlbXBNYXRyaXguZCAgKiBwdC5jO1xyXG4gICAgICAgIHd0LmQgID0gX3RlbXBNYXRyaXguYyAgKiBwdC5iICsgX3RlbXBNYXRyaXguZCAgKiBwdC5kO1xyXG4gICAgICAgIHd0LnR4ID0gX3RlbXBNYXRyaXgudHggKiBwdC5hICsgX3RlbXBNYXRyaXgudHkgKiBwdC5jICsgcHQudHg7XHJcbiAgICAgICAgd3QudHkgPSBfdGVtcE1hdHJpeC50eCAqIHB0LmIgKyBfdGVtcE1hdHJpeC50eSAqIHB0LmQgKyBwdC50eTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyBzbyBpZiByb3RhdGlvbiBpcyBiZXR3ZWVuIDAgdGhlbiB3ZSBjYW4gc2ltcGxpZnkgdGhlIG11bHRpcGxpY2F0aW9uIHByb2Nlc3MuLi5cclxuICAgICAgICBpZiAodGhpcy5yb3RhdGlvbiAlIENPTlNULlBJXzIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHJvdGF0aW9uIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyByZW5kZXIuIFRoaXMgbWVhbnMgd2Ugb25seSBuZWVkIHRvIHVzZSBzaW4gYW5kIGNvcyB3aGVuIHJvdGF0aW9uIGFjdHVhbGx5IGNoYW5nZXNcclxuICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpb24gIT09IHRoaXMucm90YXRpb25DYWNoZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbkNhY2hlID0gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NyID0gTWF0aC5zaW4odGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jciA9IE1hdGguY29zKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG1hdHJpeCB2YWx1ZXMgb2YgdGhlIGRpc3BsYXlvYmplY3QgYmFzZWQgb24gaXRzIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLi5cclxuICAgICAgICAgICAgYSAgPSAgdGhpcy5fY3IgKiB0aGlzLnNjYWxlLng7XHJcbiAgICAgICAgICAgIGIgID0gIHRoaXMuX3NyICogdGhpcy5zY2FsZS54O1xyXG4gICAgICAgICAgICBjICA9IC10aGlzLl9zciAqIHRoaXMuc2NhbGUueTtcclxuICAgICAgICAgICAgZCAgPSAgdGhpcy5fY3IgKiB0aGlzLnNjYWxlLnk7XHJcbiAgICAgICAgICAgIHR4ID0gIHRoaXMucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgdHkgPSAgdGhpcy5wb3NpdGlvbi55O1xyXG5cclxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHBpdm90Li4gbm90IG9mdGVuIHVzZWQgc28gZ2VhcmVkIHRvd2FyZHMgdGhhdCBmYWN0IVxyXG4gICAgICAgICAgICBpZiAodGhpcy5waXZvdC54IHx8IHRoaXMucGl2b3QueSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHggLT0gdGhpcy5waXZvdC54ICogYSArIHRoaXMucGl2b3QueSAqIGM7XHJcbiAgICAgICAgICAgICAgICB0eSAtPSB0aGlzLnBpdm90LnggKiBiICsgdGhpcy5waXZvdC55ICogZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY29uY2F0IHRoZSBwYXJlbnQgbWF0cml4IHdpdGggdGhlIG9iamVjdHMgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICB3dC5hICA9IGEgICogcHQuYSArIGIgICogcHQuYztcclxuICAgICAgICAgICAgd3QuYiAgPSBhICAqIHB0LmIgKyBiICAqIHB0LmQ7XHJcbiAgICAgICAgICAgIHd0LmMgID0gYyAgKiBwdC5hICsgZCAgKiBwdC5jO1xyXG4gICAgICAgICAgICB3dC5kICA9IGMgICogcHQuYiArIGQgICogcHQuZDtcclxuICAgICAgICAgICAgd3QudHggPSB0eCAqIHB0LmEgKyB0eSAqIHB0LmMgKyBwdC50eDtcclxuICAgICAgICAgICAgd3QudHkgPSB0eCAqIHB0LmIgKyB0eSAqIHB0LmQgKyBwdC50eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gbGV0cyBkbyB0aGUgZmFzdCB2ZXJzaW9uIGFzIHdlIGtub3cgdGhlcmUgaXMgbm8gcm90YXRpb24uLlxyXG4gICAgICAgICAgICBhICA9IHRoaXMuc2NhbGUueDtcclxuICAgICAgICAgICAgZCAgPSB0aGlzLnNjYWxlLnk7XHJcblxyXG4gICAgICAgICAgICB0eCA9IHRoaXMucG9zaXRpb24ueCAtIHRoaXMucGl2b3QueCAqIGE7XHJcbiAgICAgICAgICAgIHR5ID0gdGhpcy5wb3NpdGlvbi55IC0gdGhpcy5waXZvdC55ICogZDtcclxuXHJcbiAgICAgICAgICAgIHd0LmEgID0gYSAgKiBwdC5hO1xyXG4gICAgICAgICAgICB3dC5iICA9IGEgICogcHQuYjtcclxuICAgICAgICAgICAgd3QuYyAgPSBkICAqIHB0LmM7XHJcbiAgICAgICAgICAgIHd0LmQgID0gZCAgKiBwdC5kO1xyXG4gICAgICAgICAgICB3dC50eCA9IHR4ICogcHQuYSArIHR5ICogcHQuYyArIHB0LnR4O1xyXG4gICAgICAgICAgICB3dC50eSA9IHR4ICogcHQuYiArIHR5ICogcHQuZCArIHB0LnR5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBtdWx0aXBseSB0aGUgYWxwaGFzLi5cclxuICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xyXG5cclxuICAgIC8vIHJlc2V0IHRoZSBib3VuZHMgZWFjaCB0aW1lIHRoaXMgaXMgY2FsbGVkIVxyXG4gICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IG51bGw7XHJcbn07XHJcblxyXG4vLyBwZXJmb3JtYW5jZSBpbmNyZWFzZSB0byBhdm9pZCB1c2luZyBjYWxsLi4gKDEweCBmYXN0ZXIpXHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0gPSBEaXNwbGF5T2JqZWN0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm07XHJcblxyXG4vKipcclxuICpcclxuICpcclxuICogUmV0cmlldmVzIHRoZSBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QgYXMgYSByZWN0YW5nbGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSBtYXRyaXgge1BJWEkuTWF0cml4fVxyXG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcclxuICovXHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChtYXRyaXgpIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2Vcclxue1xyXG4gICAgcmV0dXJuIG1hdGguUmVjdGFuZ2xlLkVNUFRZO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcclxuICovXHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmdldExvY2FsQm91bmRzID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKG1hdGguTWF0cml4LklERU5USVRZKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSBwb3NpdGlvbiB7UElYSS5Qb2ludH0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbVxyXG4gKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBBIHBvaW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoaXMgb2JqZWN0XHJcbiAqL1xyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS50b0dsb2JhbCA9IGZ1bmN0aW9uIChwb3NpdGlvbilcclxue1xyXG4gICAgLy8gdGhpcyBwYXJlbnQgY2hlY2sgaXMgZm9yIGp1c3QgaW4gY2FzZSB0aGUgaXRlbSBpcyBhIHJvb3Qgb2JqZWN0LlxyXG4gICAgLy8gSWYgaXQgaXMgd2UgbmVlZCB0byBnaXZlIGl0IGEgdGVtcG9yYXJ5IHBhcmVudCBzbyB0aGF0IGRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0gd29ya3MgY29ycmVjdGx5XHJcbiAgICAvLyB0aGlzIGlzIG1haW5seSB0byBhdm9pZCBhIHBhcmVudCBjaGVjayBpbiB0aGUgbWFpbiBsb29wLiBFdmVyeSBsaXR0bGUgaGVscHMgZm9yIHBlcmZvcm1hbmNlIDopXHJcbiAgICBpZighdGhpcy5wYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBfdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSBsb3RcclxuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvc2l0aW9uKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QgcmVsYXRpdmUgdG8gYW5vdGhlciBwb2ludFxyXG4gKlxyXG4gKiBAcGFyYW0gcG9zaXRpb24ge1BJWEkuUG9pbnR9IFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb21cclxuICogQHBhcmFtIFtmcm9tXSB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCB0byBjYWxjdWxhdGUgdGhlIGdsb2JhbCBwb3NpdGlvbiBmcm9tXHJcbiAqIEBwYXJhbSBbcG9pbnRdIHtQSVhJLlBvaW50fSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsIChvdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSBuZXcgUG9pbnQpXHJcbiAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3RcclxuICovXHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnRvTG9jYWwgPSBmdW5jdGlvbiAocG9zaXRpb24sIGZyb20sIHBvaW50KVxyXG57XHJcbiAgICBpZiAoZnJvbSlcclxuICAgIHtcclxuICAgICAgICBwb3NpdGlvbiA9IGZyb20udG9HbG9iYWwocG9zaXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRoaXMgcGFyZW50IGNoZWNrIGlzIGZvciBqdXN0IGluIGNhc2UgdGhlIGl0ZW0gaXMgYSByb290IG9iamVjdC5cclxuICAgIC8vIElmIGl0IGlzIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHRlbXBvcmFyeSBwYXJlbnQgc28gdGhhdCBkaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtIHdvcmtzIGNvcnJlY3RseVxyXG4gICAgLy8gdGhpcyBpcyBtYWlubHkgdG8gYXZvaWQgYSBwYXJlbnQgY2hlY2sgaW4gdGhlIG1haW4gbG9vcC4gRXZlcnkgbGl0dGxlIGhlbHBzIGZvciBwZXJmb3JtYW5jZSA6KVxyXG4gICAgaWYoIXRoaXMucGFyZW50KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xyXG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzaW1wbHkgYXBwbHkgdGhlIG1hdHJpeC4uXHJcbiAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9zaXRpb24sIHBvaW50KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXHJcbiAqXHJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXJcclxuICogQHByaXZhdGVcclxuICovXHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnJlbmRlcldlYkdMID0gZnVuY3Rpb24gKHJlbmRlcmVyKSAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXHJcbntcclxuICAgIC8vIE9WRVJXUklURTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IFRoZSByZW5kZXJlclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUucmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKSAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXHJcbntcclxuICAgIC8vIE9WRVJXUklURTtcclxufTtcclxuLyoqXHJcbiAqIFVzZWZ1bCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0ZXh0dXJlIG9mIHRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY3JlYXRlIHNwcml0ZXNcclxuICogVGhpcyBjYW4gYmUgcXVpdGUgdXNlZnVsIGlmIHlvdXIgZGlzcGxheU9iamVjdCBpcyBzdGF0aWMgLyBjb21wbGljYXRlZCBhbmQgbmVlZHMgdG8gYmUgcmV1c2VkIG11bHRpcGxlIHRpbWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGV4dHVyZS5cclxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcclxuICogQHBhcmFtIHJlc29sdXRpb24ge251bWJlcn0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgYmVpbmcgZ2VuZXJhdGVkXHJcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gYSB0ZXh0dXJlIG9mIHRoZSBkaXNwbGF5IG9iamVjdFxyXG4gKi9cclxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZ2VuZXJhdGVUZXh0dXJlID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzY2FsZU1vZGUsIHJlc29sdXRpb24pXHJcbntcclxuICAgIHZhciBib3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzKCk7XHJcblxyXG4gICAgdmFyIHJlbmRlclRleHR1cmUgPSBuZXcgUmVuZGVyVGV4dHVyZShyZW5kZXJlciwgYm91bmRzLndpZHRoIHwgMCwgYm91bmRzLmhlaWdodCB8IDAsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbik7XHJcblxyXG4gICAgX3RlbXBNYXRyaXgudHggPSAtYm91bmRzLng7XHJcbiAgICBfdGVtcE1hdHJpeC50eSA9IC1ib3VuZHMueTtcclxuXHJcbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLCBfdGVtcE1hdHJpeCk7XHJcblxyXG4gICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBwYXJlbnQgQ29udGFpbmVyIG9mIHRoaXMgRGlzcGxheU9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0gY29udGFpbmVyIHtDb250YWluZXJ9IFRoZSBDb250YWluZXIgdG8gYWRkIHRoaXMgRGlzcGxheU9iamVjdCB0b1xyXG4gKiBAcmV0dXJuIHtDb250YWluZXJ9IFRoZSBDb250YWluZXIgdGhhdCB0aGlzIERpc3BsYXlPYmplY3Qgd2FzIGFkZGVkIHRvXHJcbiAqL1xyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbiAoY29udGFpbmVyKVxyXG57XHJcbiAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLmFkZENoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0UGFyZW50OiBBcmd1bWVudCBtdXN0IGJlIGEgQ29udGFpbmVyJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbmVyLmFkZENoaWxkKHRoaXMpO1xyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzZXQgdGhlIHBvc3Rpb24sIHNjYWxlLCBza2V3IGFuZCBwaXZvdCBhdCBvbmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gW3g9MF0ge251bWJlcn0gVGhlIFggcG9zaXRpb25cclxuICogQHBhcmFtIFt5PTBdIHtudW1iZXJ9IFRoZSBZIHBvc2l0aW9uXHJcbiAqIEBwYXJhbSBbc2NhbGVYPTFdIHtudW1iZXJ9IFRoZSBYIHNjYWxlIHZhbHVlXHJcbiAqIEBwYXJhbSBbc2NhbGVZPTFdIHtudW1iZXJ9IFRoZSBZIHNjYWxlIHZhbHVlXHJcbiAqIEBwYXJhbSBbcm90YXRpb249MF0ge251bWJlcn0gVGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSBbc2tld1g9MF0ge251bWJlcn0gVGhlIFggc2tldyB2YWx1ZVxyXG4gKiBAcGFyYW0gW3NrZXdZPTBdIHtudW1iZXJ9IFRoZSBZIHNrZXcgdmFsdWVcclxuICogQHBhcmFtIFtwaXZvdFg9MF0ge251bWJlcn0gVGhlIFggcGl2b3QgdmFsdWVcclxuICogQHBhcmFtIFtwaXZvdFk9MF0ge251bWJlcn0gVGhlIFkgcGl2b3QgdmFsdWVcclxuICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fVxyXG4gKi9cclxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1ksIHBpdm90WCwgcGl2b3RZKSAvL2pzaGludCBpZ25vcmU6bGluZVxyXG57XHJcbiAgICB0aGlzLnBvc2l0aW9uLnggPSB4IHx8IDA7XHJcbiAgICB0aGlzLnBvc2l0aW9uLnkgPSB5IHx8IDA7XHJcbiAgICB0aGlzLnNjYWxlLnggPSAhc2NhbGVYID8gMSA6IHNjYWxlWDtcclxuICAgIHRoaXMuc2NhbGUueSA9ICFzY2FsZVkgPyAxIDogc2NhbGVZO1xyXG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uIHx8IDA7XHJcbiAgICB0aGlzLnNrZXcueCA9IHNrZXdYIHx8IDA7XHJcbiAgICB0aGlzLnNrZXcueSA9IHNrZXdZIHx8IDA7XHJcbiAgICB0aGlzLnBpdm90LnggPSBwaXZvdFggfHwgMDtcclxuICAgIHRoaXMucGl2b3QueSA9IHBpdm90WSB8fCAwO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQmFzZSBkZXN0cm95IG1ldGhvZCBmb3IgZ2VuZXJpYyBkaXNwbGF5IG9iamVjdHNcclxuICpcclxuICovXHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxyXG57XHJcblxyXG4gICAgdGhpcy5wb3NpdGlvbiA9IG51bGw7XHJcbiAgICB0aGlzLnNjYWxlID0gbnVsbDtcclxuICAgIHRoaXMucGl2b3QgPSBudWxsO1xyXG4gICAgdGhpcy5za2V3ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fYm91bmRzID0gbnVsbDtcclxuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xyXG4gICAgdGhpcy5fbWFzayA9IG51bGw7XHJcblxyXG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG51bGw7XHJcbiAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xyXG59O1xyXG4iLCJ2YXIgQ29udGFpbmVyID0gcmVxdWlyZSgnLi4vZGlzcGxheS9Db250YWluZXInKSxcclxuICAgIFRleHR1cmUgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9UZXh0dXJlJyksXHJcbiAgICBDYW52YXNCdWZmZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0J1ZmZlcicpLFxyXG4gICAgQ2FudmFzR3JhcGhpY3MgPSByZXF1aXJlKCcuLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0dyYXBoaWNzJyksXHJcbiAgICBHcmFwaGljc0RhdGEgPSByZXF1aXJlKCcuL0dyYXBoaWNzRGF0YScpLFxyXG4gICAgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcclxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcclxuICAgIHRlbXBQb2ludCA9IG5ldyBtYXRoLlBvaW50KCk7XHJcblxyXG4vKipcclxuICogVGhlIEdyYXBoaWNzIGNsYXNzIGNvbnRhaW5zIG1ldGhvZHMgdXNlZCB0byBkcmF3IHByaW1pdGl2ZSBzaGFwZXMgc3VjaCBhcyBsaW5lcywgY2lyY2xlcyBhbmRcclxuICogcmVjdGFuZ2xlcyB0byB0aGUgZGlzcGxheSwgYW5kIHRvIGNvbG9yIGFuZCBmaWxsIHRoZW0uXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkNvbnRhaW5lclxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKi9cclxuZnVuY3Rpb24gR3JhcGhpY3MoKVxyXG57XHJcbiAgICBDb250YWluZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbHBoYSB2YWx1ZSB1c2VkIHdoZW4gZmlsbGluZyB0aGUgR3JhcGhpY3Mgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqL1xyXG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoICh0aGlja25lc3MpIG9mIGFueSBsaW5lcyBkcmF3bi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZVdpZHRoID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb2xvciBvZiBhbnkgbGluZXMgZHJhd24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLmxpbmVDb2xvciA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmFwaGljcyBkYXRhXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc0RhdGFbXX1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBncmFwaGljIHNoYXBlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBcHBseSBhIHZhbHVlIG9mIDB4RkZGRkZGIHRvIHJlc2V0IHRoZSB0aW50LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXHJcbiAgICAgKi9cclxuICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHByZXZpb3VzIHRpbnQgYXBwbGllZCB0byB0aGUgZ3JhcGhpYyBzaGFwZS4gVXNlZCB0byBjb21wYXJlIHRvIHRoZSBjdXJyZW50IHRpbnQgYW5kIGNoZWNrIGlmIHRoZXJlcyBjaGFuZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3ByZXZUaW50ID0gMHhGRkZGRkY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBncmFwaGljIHNoYXBlLiBBcHBseSBhIHZhbHVlIG9mIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUw7XHJcbiAgICAgKiBAc2VlIFBJWEkuQkxFTkRfTU9ERVNcclxuICAgICAqL1xyXG4gICAgdGhpcy5ibGVuZE1vZGUgPSBDT05TVC5CTEVORF9NT0RFUy5OT1JNQUw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHBhdGhcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzRGF0YX1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgY29udGFpbmluZyBzb21lIFdlYkdMLXJlbGF0ZWQgcHJvcGVydGllcyB1c2VkIGJ5IHRoZSBXZWJHTCByZW5kZXJlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3Q8bnVtYmVyLCBvYmplY3Q+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETyAtIF93ZWJnbCBzaG91bGQgdXNlIGEgcHJvdG90eXBlIG9iamVjdCwgbm90IGEgcmFuZG9tIHVuZG9jdW1lbnRlZCBvYmplY3QuLi5cclxuICAgIHRoaXMuX3dlYkdMID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgc2hhcGUgaXMgYmVpbmcgdXNlZCBhcyBhIG1hc2suXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pc01hc2sgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBib3VuZHMnIHBhZGRpbmcgdXNlZCBmb3IgYm91bmRzIGNhbGN1bGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ib3VuZHNQYWRkaW5nID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY2FjaGUgb2YgdGhlIGxvY2FsIGJvdW5kcyB0byBwcmV2ZW50IHJlY2FsY3VsYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9sb2NhbEJvdW5kcyA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLDAsMSwxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHRoZSBncmFwaGljcyBvYmplY3QgaGFzIGNoYW5nZWQuIElmIHRoaXMgaXMgc2V0IHRvIHRydWUgdGhlbiB0aGUgZ3JhcGhpY3NcclxuICAgICAqIG9iamVjdCB3aWxsIGJlIHJlY2FsY3VsYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGRldGVjdCBpZiB0aGUgV2ViR0wgZ3JhcGhpY3Mgb2JqZWN0IGhhcyBjaGFuZ2VkLiBJZiB0aGlzIGlzIHNldCB0byB0cnVlIHRoZW4gdGhlXHJcbiAgICAgKiBncmFwaGljcyBvYmplY3Qgd2lsbCBiZSByZWNhbGN1bGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2xEaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuYm91bmRzRGlydHkgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBkZXRlY3QgaWYgdGhlIGNhY2hlZCBzcHJpdGUgb2JqZWN0IG5lZWRzIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2FjaGVkU3ByaXRlRGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gY2FjaGVBc0JpdG1hcCBpcyBzZXQgdG8gdHJ1ZSB0aGUgZ3JhcGhpY3Mgb2JqZWN0IHdpbGwgYmUgcmVuZGVyZWQgYXMgaWYgaXQgd2FzIGEgc3ByaXRlLlxyXG4gICAgICogVGhpcyBpcyB1c2VmdWwgaWYgeW91ciBncmFwaGljcyBlbGVtZW50IGRvZXMgbm90IGNoYW5nZSBvZnRlbiwgYXMgaXQgd2lsbCBzcGVlZCB1cCB0aGUgcmVuZGVyaW5nXHJcbiAgICAgKiBvZiB0aGUgb2JqZWN0IGluIGV4Y2hhbmdlIGZvciB0YWtpbmcgdXAgdGV4dHVyZSBtZW1vcnkuIEl0IGlzIGFsc28gdXNlZnVsIGlmIHlvdSBuZWVkIHRoZSBncmFwaGljc1xyXG4gICAgICogb2JqZWN0IHRvIGJlIGFudGktYWxpYXNlZCwgYmVjYXVzZSBpdCB3aWxsIGJlIHJlbmRlcmVkIHVzaW5nIGNhbnZhcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQgaWZcclxuICAgICAqIHlvdSBhcmUgY29uc3RhbnRseSByZWRyYXdpbmcgdGhlIGdyYXBoaWNzIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgY2FjaGVBc0JpdG1hcFxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkdyYXBoaWNzI1xyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG59XHJcblxyXG4vLyBjb25zdHJ1Y3RvclxyXG5HcmFwaGljcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnRhaW5lci5wcm90b3R5cGUpO1xyXG5HcmFwaGljcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmFwaGljcztcclxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaGljcztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IEdyYXBoaWNzIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cclxuICogTm90ZSB0aGF0IHRoZSBvbmx5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYXJlIGNsb25lZCwgbm90IGl0cyB0cmFuc2Zvcm0gKHBvc2l0aW9uLHNjYWxlLGV0YylcclxuICpcclxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cclxuICovXHJcbkdyYXBoaWNzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBjbG9uZSA9IG5ldyBHcmFwaGljcygpO1xyXG5cclxuICAgIGNsb25lLnJlbmRlcmFibGUgICAgPSB0aGlzLnJlbmRlcmFibGU7XHJcbiAgICBjbG9uZS5maWxsQWxwaGEgICAgID0gdGhpcy5maWxsQWxwaGE7XHJcbiAgICBjbG9uZS5saW5lV2lkdGggICAgID0gdGhpcy5saW5lV2lkdGg7XHJcbiAgICBjbG9uZS5saW5lQ29sb3IgICAgID0gdGhpcy5saW5lQ29sb3I7XHJcbiAgICBjbG9uZS50aW50ICAgICAgICAgID0gdGhpcy50aW50O1xyXG4gICAgY2xvbmUuYmxlbmRNb2RlICAgICA9IHRoaXMuYmxlbmRNb2RlO1xyXG4gICAgY2xvbmUuaXNNYXNrICAgICAgICA9IHRoaXMuaXNNYXNrO1xyXG4gICAgY2xvbmUuYm91bmRzUGFkZGluZyA9IHRoaXMuYm91bmRzUGFkZGluZztcclxuICAgIGNsb25lLmRpcnR5ICAgICAgICAgPSB0cnVlO1xyXG4gICAgY2xvbmUuZ2xEaXJ0eSAgICAgICA9IHRydWU7XHJcbiAgICBjbG9uZS5jYWNoZWRTcHJpdGVEaXJ0eSA9IHRoaXMuY2FjaGVkU3ByaXRlRGlydHk7XHJcblxyXG4gICAgLy8gY29weSBncmFwaGljcyBkYXRhXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKVxyXG4gICAge1xyXG4gICAgICAgIGNsb25lLmdyYXBoaWNzRGF0YS5wdXNoKHRoaXMuZ3JhcGhpY3NEYXRhW2ldLmNsb25lKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb25lLmN1cnJlbnRQYXRoID0gY2xvbmUuZ3JhcGhpY3NEYXRhW2Nsb25lLmdyYXBoaWNzRGF0YS5sZW5ndGggLSAxXTtcclxuXHJcbiAgICBjbG9uZS51cGRhdGVMb2NhbEJvdW5kcygpO1xyXG5cclxuICAgIHJldHVybiBjbG9uZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTcGVjaWZpZXMgdGhlIGxpbmUgc3R5bGUgdXNlZCBmb3Igc3Vic2VxdWVudCBjYWxscyB0byBHcmFwaGljcyBtZXRob2RzIHN1Y2ggYXMgdGhlIGxpbmVUbygpIG1ldGhvZCBvciB0aGUgZHJhd0NpcmNsZSgpIG1ldGhvZC5cclxuICpcclxuICogQHBhcmFtIGxpbmVXaWR0aCB7bnVtYmVyfSB3aWR0aCBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcclxuICogQHBhcmFtIGNvbG9yIHtudW1iZXJ9IGNvbG9yIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxyXG4gKiBAcGFyYW0gYWxwaGEge251bWJlcn0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXHJcbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XHJcbiAqL1xyXG5HcmFwaGljcy5wcm90b3R5cGUubGluZVN0eWxlID0gZnVuY3Rpb24gKGxpbmVXaWR0aCwgY29sb3IsIGFscGhhKVxyXG57XHJcbiAgICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aCB8fCAwO1xyXG4gICAgdGhpcy5saW5lQ29sb3IgPSBjb2xvciB8fCAwO1xyXG4gICAgdGhpcy5saW5lQWxwaGEgPSAoYWxwaGEgPT09IHVuZGVmaW5lZCkgPyAxIDogYWxwaGE7XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGhhbGZ3YXkgdGhyb3VnaCBhIGxpbmU/IHN0YXJ0IGEgbmV3IG9uZSFcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbmV3IG1hdGguUG9seWdvbih0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5zbGljZSgtMikpO1xyXG4gICAgICAgICAgICBzaGFwZS5jbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3U2hhcGUoc2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaXRzIGVtcHR5IHNvIGxldHMganVzdCBzZXQgdGhlIGxpbmUgcHJvcGVydGllc1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmxpbmVDb2xvciA9IHRoaXMubGluZUNvbG9yO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmxpbmVBbHBoYSA9IHRoaXMubGluZUFscGhhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNb3ZlcyB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIHRvIHgsIHkuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IHRoZSBYIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xyXG4gKiBAcGFyYW0geSB7bnVtYmVyfSB0aGUgWSBjb29yZGluYXRlIHRvIG1vdmUgdG9cclxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cclxuICAqL1xyXG5HcmFwaGljcy5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpXHJcbntcclxuICAgIHZhciBzaGFwZSA9IG5ldyBtYXRoLlBvbHlnb24oW3gseV0pO1xyXG4gICAgc2hhcGUuY2xvc2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLmRyYXdTaGFwZShzaGFwZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRHJhd3MgYSBsaW5lIHVzaW5nIHRoZSBjdXJyZW50IGxpbmUgc3R5bGUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIHRvICh4LCB5KTtcclxuICogVGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiBpcyB0aGVuIHNldCB0byAoeCwgeSkuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IHRoZSBYIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xyXG4gKiBAcGFyYW0geSB7bnVtYmVyfSB0aGUgWSBjb29yZGluYXRlIHRvIGRyYXcgdG9cclxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cclxuICovXHJcbkdyYXBoaWNzLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSlcclxue1xyXG4gICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMucHVzaCh4LCB5KTtcclxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXHJcbiAqIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODUwOTcvaG93LWRvLWktaW1wbGVtZW50LWEtYmV6aWVyLWN1cnZlLWluLWNcclxuICpcclxuICogQHBhcmFtIGNwWCB7bnVtYmVyfSBDb250cm9sIHBvaW50IHhcclxuICogQHBhcmFtIGNwWSB7bnVtYmVyfSBDb250cm9sIHBvaW50IHlcclxuICogQHBhcmFtIHRvWCB7bnVtYmVyfSBEZXN0aW5hdGlvbiBwb2ludCB4XHJcbiAqIEBwYXJhbSB0b1kge251bWJlcn0gRGVzdGluYXRpb24gcG9pbnQgeVxyXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxyXG4gKi9cclxuR3JhcGhpY3MucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiAoY3BYLCBjcFksIHRvWCwgdG9ZKVxyXG57XHJcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMgPSBbMCwgMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubW92ZVRvKDAsMCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhhLFxyXG4gICAgICAgIHlhLFxyXG4gICAgICAgIG4gPSAyMCxcclxuICAgICAgICBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcclxuXHJcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXTtcclxuICAgIHZhciBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdO1xyXG5cclxuICAgIHZhciBqID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47ICsraSlcclxuICAgIHtcclxuICAgICAgICBqID0gaSAvIG47XHJcblxyXG4gICAgICAgIHhhID0gZnJvbVggKyAoIChjcFggLSBmcm9tWCkgKiBqICk7XHJcbiAgICAgICAgeWEgPSBmcm9tWSArICggKGNwWSAtIGZyb21ZKSAqIGogKTtcclxuXHJcbiAgICAgICAgcG9pbnRzLnB1c2goIHhhICsgKCAoKGNwWCArICggKHRvWCAtIGNwWCkgKiBqICkpIC0geGEpICogaiApLFxyXG4gICAgICAgICAgICAgICAgICAgICB5YSArICggKChjcFkgKyAoICh0b1kgLSBjcFkpICogaiApKSAtIHlhKSAqIGogKSApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGlydHkgPSB0aGlzLmJvdW5kc0RpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjcFgge251bWJlcn0gQ29udHJvbCBwb2ludCB4XHJcbiAqIEBwYXJhbSBjcFkge251bWJlcn0gQ29udHJvbCBwb2ludCB5XHJcbiAqIEBwYXJhbSBjcFgyIHtudW1iZXJ9IFNlY29uZCBDb250cm9sIHBvaW50IHhcclxuICogQHBhcmFtIGNwWTIge251bWJlcn0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxyXG4gKiBAcGFyYW0gdG9YIHtudW1iZXJ9IERlc3RpbmF0aW9uIHBvaW50IHhcclxuICogQHBhcmFtIHRvWSB7bnVtYmVyfSBEZXN0aW5hdGlvbiBwb2ludCB5XHJcbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XHJcbiAqL1xyXG5HcmFwaGljcy5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIChjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpXHJcbntcclxuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cyA9IFswLCAwXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tb3ZlVG8oMCwwKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbiA9IDIwLFxyXG4gICAgICAgIGR0LFxyXG4gICAgICAgIGR0MixcclxuICAgICAgICBkdDMsXHJcbiAgICAgICAgdDIsXHJcbiAgICAgICAgdDMsXHJcbiAgICAgICAgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHM7XHJcblxyXG4gICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl07XHJcbiAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXTtcclxuXHJcbiAgICB2YXIgaiA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbjsgKytpKVxyXG4gICAge1xyXG4gICAgICAgIGogPSBpIC8gbjtcclxuXHJcbiAgICAgICAgZHQgPSAoMSAtIGopO1xyXG4gICAgICAgIGR0MiA9IGR0ICogZHQ7XHJcbiAgICAgICAgZHQzID0gZHQyICogZHQ7XHJcblxyXG4gICAgICAgIHQyID0gaiAqIGo7XHJcbiAgICAgICAgdDMgPSB0MiAqIGo7XHJcblxyXG4gICAgICAgIHBvaW50cy5wdXNoKCBkdDMgKiBmcm9tWCArIDMgKiBkdDIgKiBqICogY3BYICsgMyAqIGR0ICogdDIgKiBjcFgyICsgdDMgKiB0b1gsXHJcbiAgICAgICAgICAgICAgICAgICAgIGR0MyAqIGZyb21ZICsgMyAqIGR0MiAqIGogKiBjcFkgKyAzICogZHQgKiB0MiAqIGNwWTIgKyB0MyAqIHRvWSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXJ0eSA9IHRoaXMuYm91bmRzRGlydHkgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBhcmNUbygpIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSBiZXR3ZWVuIHR3byB0YW5nZW50cyBvbiB0aGUgY2FudmFzLlxyXG4gKlxyXG4gKiBcImJvcnJvd2VkXCIgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Z4Y2FudmFzLyAtIHRoYW5rcyBnb29nbGUhXHJcbiAqXHJcbiAqIEBwYXJhbSB4MSB7bnVtYmVyfSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyY1xyXG4gKiBAcGFyYW0geTEge251bWJlcn0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmNcclxuICogQHBhcmFtIHgyIHtudW1iZXJ9IFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgYXJjXHJcbiAqIEBwYXJhbSB5MiB7bnVtYmVyfSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGFyY1xyXG4gKiBAcGFyYW0gcmFkaXVzIHtudW1iZXJ9IFRoZSByYWRpdXMgb2YgdGhlIGFyY1xyXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxyXG4gKi9cclxuR3JhcGhpY3MucHJvdG90eXBlLmFyY1RvID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpXHJcbntcclxuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5wdXNoKHgxLCB5MSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubW92ZVRvKHgxLCB5MSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLFxyXG4gICAgICAgIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl0sXHJcbiAgICAgICAgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXSxcclxuICAgICAgICBhMSA9IGZyb21ZIC0geTEsXHJcbiAgICAgICAgYjEgPSBmcm9tWCAtIHgxLFxyXG4gICAgICAgIGEyID0geTIgICAtIHkxLFxyXG4gICAgICAgIGIyID0geDIgICAtIHgxLFxyXG4gICAgICAgIG1tID0gTWF0aC5hYnMoYTEgKiBiMiAtIGIxICogYTIpO1xyXG5cclxuICAgIGlmIChtbSA8IDEuMGUtOCB8fCByYWRpdXMgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHBvaW50c1twb2ludHMubGVuZ3RoLTJdICE9PSB4MSB8fCBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXSAhPT0geTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh4MSwgeTEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgZGQgPSBhMSAqIGExICsgYjEgKiBiMSxcclxuICAgICAgICAgICAgY2MgPSBhMiAqIGEyICsgYjIgKiBiMixcclxuICAgICAgICAgICAgdHQgPSBhMSAqIGEyICsgYjEgKiBiMixcclxuICAgICAgICAgICAgazEgPSByYWRpdXMgKiBNYXRoLnNxcnQoZGQpIC8gbW0sXHJcbiAgICAgICAgICAgIGsyID0gcmFkaXVzICogTWF0aC5zcXJ0KGNjKSAvIG1tLFxyXG4gICAgICAgICAgICBqMSA9IGsxICogdHQgLyBkZCxcclxuICAgICAgICAgICAgajIgPSBrMiAqIHR0IC8gY2MsXHJcbiAgICAgICAgICAgIGN4ID0gazEgKiBiMiArIGsyICogYjEsXHJcbiAgICAgICAgICAgIGN5ID0gazEgKiBhMiArIGsyICogYTEsXHJcbiAgICAgICAgICAgIHB4ID0gYjEgKiAoazIgKyBqMSksXHJcbiAgICAgICAgICAgIHB5ID0gYTEgKiAoazIgKyBqMSksXHJcbiAgICAgICAgICAgIHF4ID0gYjIgKiAoazEgKyBqMiksXHJcbiAgICAgICAgICAgIHF5ID0gYTIgKiAoazEgKyBqMiksXHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHB5IC0gY3ksIHB4IC0gY3gpLFxyXG4gICAgICAgICAgICBlbmRBbmdsZSAgID0gTWF0aC5hdGFuMihxeSAtIGN5LCBxeCAtIGN4KTtcclxuXHJcbiAgICAgICAgdGhpcy5hcmMoY3ggKyB4MSwgY3kgKyB5MSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYjEgKiBhMiA+IGIyICogYTEpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGlydHkgPSB0aGlzLmJvdW5kc0RpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYXJjIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSAodXNlZCB0byBjcmVhdGUgY2lyY2xlcywgb3IgcGFydHMgb2YgY2lyY2xlcykuXHJcbiAqXHJcbiAqIEBwYXJhbSBjeCB7bnVtYmVyfSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gKiBAcGFyYW0gY3kge251bWJlcn0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcclxuICogQHBhcmFtIHJhZGl1cyB7bnVtYmVyfSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcclxuICogQHBhcmFtIHN0YXJ0QW5nbGUge251bWJlcn0gVGhlIHN0YXJ0aW5nIGFuZ2xlLCBpbiByYWRpYW5zICgwIGlzIGF0IHRoZSAzIG8nY2xvY2sgcG9zaXRpb24gb2YgdGhlIGFyYydzIGNpcmNsZSlcclxuICogQHBhcmFtIGVuZEFuZ2xlIHtudW1iZXJ9IFRoZSBlbmRpbmcgYW5nbGUsIGluIHJhZGlhbnNcclxuICogQHBhcmFtIGFudGljbG9ja3dpc2Uge2Jvb2xlYW59IE9wdGlvbmFsLiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZHJhd2luZyBzaG91bGQgYmUgY291bnRlcmNsb2Nrd2lzZSBvciBjbG9ja3dpc2UuIEZhbHNlIGlzIGRlZmF1bHQsIGFuZCBpbmRpY2F0ZXMgY2xvY2t3aXNlLCB3aGlsZSB0cnVlIGluZGljYXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cclxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cclxuICovXHJcbkdyYXBoaWNzLnByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbihjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpXHJcbntcclxuICAgIGFudGljbG9ja3dpc2UgPSBhbnRpY2xvY2t3aXNlIHx8IGZhbHNlO1xyXG5cclxuICAgIGlmIChzdGFydEFuZ2xlID09PSBlbmRBbmdsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBpZiggIWFudGljbG9ja3dpc2UgJiYgZW5kQW5nbGUgPD0gc3RhcnRBbmdsZSApXHJcbiAgICB7XHJcbiAgICAgICAgZW5kQW5nbGUgKz0gTWF0aC5QSSAqIDI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKCBhbnRpY2xvY2t3aXNlICYmIHN0YXJ0QW5nbGUgPD0gZW5kQW5nbGUgKVxyXG4gICAge1xyXG4gICAgICAgIHN0YXJ0QW5nbGUgKz0gTWF0aC5QSSAqIDI7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN3ZWVwID0gYW50aWNsb2Nrd2lzZSA/IChzdGFydEFuZ2xlIC0gZW5kQW5nbGUpICogLTEgOiAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcclxuICAgIHZhciBzZWdzID0gIE1hdGguY2VpbChNYXRoLmFicyhzd2VlcCkgLyAoTWF0aC5QSSAqIDIpKSAqIDQwO1xyXG5cclxuICAgIGlmKHN3ZWVwID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xyXG4gICAgdmFyIHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMucHVzaChzdGFydFgsIHN0YXJ0WSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tb3ZlVG8oc3RhcnRYLCBzdGFydFkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcclxuXHJcbiAgICB2YXIgdGhldGEgPSBzd2VlcC8oc2VncyoyKTtcclxuICAgIHZhciB0aGV0YTIgPSB0aGV0YSoyO1xyXG5cclxuICAgIHZhciBjVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XHJcbiAgICB2YXIgc1RoZXRhID0gTWF0aC5zaW4odGhldGEpO1xyXG5cclxuICAgIHZhciBzZWdNaW51cyA9IHNlZ3MgLSAxO1xyXG5cclxuICAgIHZhciByZW1haW5kZXIgPSAoIHNlZ01pbnVzICUgMSApIC8gc2VnTWludXM7XHJcblxyXG4gICAgZm9yKHZhciBpPTA7IGk8PXNlZ01pbnVzOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlYWwgPSAgaSArIHJlbWFpbmRlciAqIGk7XHJcblxyXG5cclxuICAgICAgICB2YXIgYW5nbGUgPSAoKHRoZXRhKSArIHN0YXJ0QW5nbGUgKyAodGhldGEyICogcmVhbCkpO1xyXG5cclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICB2YXIgcyA9IC1NYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgICAgIHBvaW50cy5wdXNoKCggKGNUaGV0YSAqICBjKSArIChzVGhldGEgKiBzKSApICogcmFkaXVzICsgY3gsXHJcbiAgICAgICAgICAgICAgICAgICAgKCAoY1RoZXRhICogLXMpICsgKHNUaGV0YSAqIGMpICkgKiByYWRpdXMgKyBjeSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXJ0eSA9IHRoaXMuYm91bmRzRGlydHkgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNwZWNpZmllcyBhIHNpbXBsZSBvbmUtY29sb3IgZmlsbCB0aGF0IHN1YnNlcXVlbnQgY2FsbHMgdG8gb3RoZXIgR3JhcGhpY3MgbWV0aG9kc1xyXG4gKiAoc3VjaCBhcyBsaW5lVG8oKSBvciBkcmF3Q2lyY2xlKCkpIHVzZSB3aGVuIGRyYXdpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcclxuICogQHBhcmFtIGFscGhhIHtudW1iZXJ9IHRoZSBhbHBoYSBvZiB0aGUgZmlsbFxyXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxyXG4gKi9cclxuR3JhcGhpY3MucHJvdG90eXBlLmJlZ2luRmlsbCA9IGZ1bmN0aW9uIChjb2xvciwgYWxwaGEpXHJcbntcclxuICAgIHRoaXMuZmlsbGluZyA9IHRydWU7XHJcbiAgICB0aGlzLmZpbGxDb2xvciA9IGNvbG9yIHx8IDA7XHJcbiAgICB0aGlzLmZpbGxBbHBoYSA9IChhbHBoYSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBhbHBoYTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoIDw9IDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmZpbGwgPSB0aGlzLmZpbGxpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguZmlsbENvbG9yID0gdGhpcy5maWxsQ29sb3I7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguZmlsbEFscGhhID0gdGhpcy5maWxsQWxwaGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbGllcyBhIGZpbGwgdG8gdGhlIGxpbmVzIGFuZCBzaGFwZXMgdGhhdCB3ZXJlIGFkZGVkIHNpbmNlIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGJlZ2luRmlsbCgpIG1ldGhvZC5cclxuICpcclxuICogQHJldHVybiB7R3JhcGhpY3N9XHJcbiAqL1xyXG5HcmFwaGljcy5wcm90b3R5cGUuZW5kRmlsbCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuZmlsbGluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5maWxsQ29sb3IgPSBudWxsO1xyXG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxyXG4gKi9cclxuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdSZWN0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0IClcclxue1xyXG4gICAgdGhpcy5kcmF3U2hhcGUobmV3IG1hdGguUmVjdGFuZ2xlKHgseSwgd2lkdGgsIGhlaWdodCkpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcGFyYW0gcmFkaXVzIHtudW1iZXJ9IFJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlIGNvcm5lcnNcclxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cclxuICovXHJcbkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3Um91bmRlZFJlY3QgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyApXHJcbntcclxuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBtYXRoLlJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRHJhd3MgYSBjaXJjbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcbiAqIEBwYXJhbSByYWRpdXMge251bWJlcn0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXHJcbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XHJcbiAqL1xyXG5HcmFwaGljcy5wcm90b3R5cGUuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMpXHJcbntcclxuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBtYXRoLkNpcmNsZSh4LHksIHJhZGl1cykpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERyYXdzIGFuIGVsbGlwc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxyXG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcclxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IFRoZSBoYWxmIHdpZHRoIG9mIHRoZSBlbGxpcHNlXHJcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gVGhlIGhhbGYgaGVpZ2h0IG9mIHRoZSBlbGxpcHNlXHJcbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XHJcbiAqL1xyXG5HcmFwaGljcy5wcm90b3R5cGUuZHJhd0VsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgdGhpcy5kcmF3U2hhcGUobmV3IG1hdGguRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRHJhd3MgYSBwb2x5Z29uIHVzaW5nIHRoZSBnaXZlbiBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCB7bnVtYmVyW118UElYSS5Qb2ludFtdfSBUaGUgcGF0aCBkYXRhIHVzZWQgdG8gY29uc3RydWN0IHRoZSBwb2x5Z29uLlxyXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxyXG4gKi9cclxuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdQb2x5Z29uID0gZnVuY3Rpb24gKHBhdGgpXHJcbntcclxuICAgIC8vIHByZXZlbnRzIGFuIGFyZ3VtZW50IGFzc2lnbm1lbnQgZGVvcHRcclxuICAgIC8vIHNlZSBzZWN0aW9uIDMuMTogaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMtbWFuYWdpbmctYXJndW1lbnRzXHJcbiAgICB2YXIgcG9pbnRzID0gcGF0aDtcclxuXHJcbiAgICB2YXIgY2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAocG9pbnRzIGluc3RhbmNlb2YgbWF0aC5Qb2x5Z29uKVxyXG4gICAge1xyXG4gICAgICAgIGNsb3NlZCA9IHBvaW50cy5jbG9zZWQ7XHJcbiAgICAgICAgcG9pbnRzID0gcG9pbnRzLnBvaW50cztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcclxuICAgIHtcclxuICAgICAgICAvLyBwcmV2ZW50cyBhbiBhcmd1bWVudCBsZWFrIGRlb3B0XHJcbiAgICAgICAgLy8gc2VlIHNlY3Rpb24gMy4yOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcclxuICAgICAgICBwb2ludHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcG9pbnRzW2ldID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2hhcGUgPSBuZXcgbWF0aC5Qb2x5Z29uKHBvaW50cyk7XHJcbiAgICBzaGFwZS5jbG9zZWQgPSBjbG9zZWQ7XHJcblxyXG4gICAgdGhpcy5kcmF3U2hhcGUoc2hhcGUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LCBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGUgc2V0dGluZ3MuXHJcbiAqXHJcbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XHJcbiAqL1xyXG5HcmFwaGljcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLmxpbmVXaWR0aCA9IDA7XHJcbiAgICB0aGlzLmZpbGxpbmcgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIHRoaXMuY2xlYXJEaXJ0eSA9IHRydWU7XHJcbiAgICB0aGlzLmdyYXBoaWNzRGF0YSA9IFtdO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVzZWZ1bCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0ZXh0dXJlIG9mIHRoZSBncmFwaGljcyBvYmplY3QgdGhhdCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZSBzcHJpdGVzXHJcbiAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGdlb21ldHJ5IGlzIGNvbXBsaWNhdGVkIGFuZCBuZWVkcyB0byBiZSByZXVzZWQgbXVsdGlwbGUgdGltZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSByZXNvbHV0aW9uIHtudW1iZXJ9IFRoZSByZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlIGJlaW5nIGdlbmVyYXRlZFxyXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtudW1iZXJ9IFNob3VsZCBiZSBvbmUgb2YgdGhlIHNjYWxlTW9kZSBjb25zdHNcclxuICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBhIHRleHR1cmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdFxyXG4gKi9cclxuR3JhcGhpY3MucHJvdG90eXBlLmdlbmVyYXRlVGV4dHVyZSA9IGZ1bmN0aW9uIChyZW5kZXJlciwgcmVzb2x1dGlvbiwgc2NhbGVNb2RlKVxyXG57XHJcblxyXG4gICAgcmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgMTtcclxuXHJcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xyXG5cclxuICAgIHZhciBjYW52YXNCdWZmZXIgPSBuZXcgQ2FudmFzQnVmZmVyKGJvdW5kcy53aWR0aCAqIHJlc29sdXRpb24sIGJvdW5kcy5oZWlnaHQgKiByZXNvbHV0aW9uKTtcclxuXHJcbiAgICB2YXIgdGV4dHVyZSA9IFRleHR1cmUuZnJvbUNhbnZhcyhjYW52YXNCdWZmZXIuY2FudmFzLCBzY2FsZU1vZGUpO1xyXG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuXHJcbiAgICBjYW52YXNCdWZmZXIuY29udGV4dC5zY2FsZShyZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcclxuXHJcbiAgICBjYW52YXNCdWZmZXIuY29udGV4dC50cmFuc2xhdGUoLWJvdW5kcy54LC1ib3VuZHMueSk7XHJcblxyXG4gICAgQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3ModGhpcywgY2FudmFzQnVmZmVyLmNvbnRleHQpO1xyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICpcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5HcmFwaGljcy5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxyXG57XHJcbiAgICAvLyBpZiB0aGUgc3ByaXRlIGlzIG5vdCB2aXNpYmxlIG9yIHRoZSBhbHBoYSBpcyAwIHRoZW4gbm8gbmVlZCB0byByZW5kZXIgdGhpcyBlbGVtZW50XHJcblxyXG4gICAgLy8gdGhpcyBjb2RlIG1heSBzdGlsbCBiZSBuZWVkZWQgc28gbGVhdmluZyBmb3Igbm93Li5cclxuICAgIC8vXHJcbiAgICAvKlxyXG4gICAgaWYgKHRoaXMuX2NhY2hlQXNCaXRtYXApXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgfHwgdGhpcy5jYWNoZWRTcHJpdGVEaXJ0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlQ2FjaGVkU3ByaXRlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyB3ZSB3aWxsIGFsc28gbmVlZCB0byB1cGRhdGUgdGhlIHRleHR1cmUgb24gdGhlIGdwdSB0b28hXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkU3ByaXRlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jYWNoZWRTcHJpdGVEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcclxuXHJcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5yZW5kZXJXZWJHTC5jYWxsKHRoaXMuX2NhY2hlZFNwcml0ZSwgcmVuZGVyZXIpO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgKi9cclxuXHJcbiAgICBpZiAodGhpcy5nbERpcnR5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZ2xEaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MpO1xyXG4gICAgcmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcy5yZW5kZXIodGhpcyk7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXHJcbiAqXHJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5DYW52YXNSZW5kZXJlcn1cclxuICogQHByaXZhdGVcclxuICovXHJcbkdyYXBoaWNzLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxyXG57XHJcbiAgICBpZiAodGhpcy5pc01hc2sgPT09IHRydWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHRoZSB0aW50IGhhcyBjaGFuZ2VkLCBzZXQgdGhlIGdyYXBoaWNzIG9iamVjdCB0byBkaXJ0eS5cclxuICAgIGlmICh0aGlzLl9wcmV2VGludCAhPT0gdGhpcy50aW50KSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhpcyBjb2RlIG1heSBzdGlsbCBiZSBuZWVkZWQgc28gbGVhdmluZyBmb3Igbm93Li5cclxuICAgIC8vXHJcbiAgICAvKlxyXG4gICAgaWYgKHRoaXMuX2NhY2hlQXNCaXRtYXApXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgfHwgdGhpcy5jYWNoZWRTcHJpdGVEaXJ0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlQ2FjaGVkU3ByaXRlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyB3ZSB3aWxsIGFsc28gbmVlZCB0byB1cGRhdGUgdGhlIHRleHR1cmVcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRTcHJpdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNhY2hlZFNwcml0ZURpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbHBoYSA9IHRoaXMuYWxwaGE7XHJcblxyXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuX3JlbmRlckNhbnZhcy5jYWxsKHRoaXMuX2NhY2hlZFNwcml0ZSwgcmVuZGVyZXIpO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5jb250ZXh0O1xyXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XHJcblxyXG4gICAgdmFyIGNvbXBvc2l0ZU9wZXJhdGlvbiA9IHJlbmRlcmVyLmJsZW5kTW9kZXNbdGhpcy5ibGVuZE1vZGVdO1xyXG4gICAgaWYgKGNvbXBvc2l0ZU9wZXJhdGlvbiAhPT0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xyXG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oXHJcbiAgICAgICAgdHJhbnNmb3JtLmEgKiByZXNvbHV0aW9uLFxyXG4gICAgICAgIHRyYW5zZm9ybS5iICogcmVzb2x1dGlvbixcclxuICAgICAgICB0cmFuc2Zvcm0uYyAqIHJlc29sdXRpb24sXHJcbiAgICAgICAgdHJhbnNmb3JtLmQgKiByZXNvbHV0aW9uLFxyXG4gICAgICAgIHRyYW5zZm9ybS50eCAqIHJlc29sdXRpb24sXHJcbiAgICAgICAgdHJhbnNmb3JtLnR5ICogcmVzb2x1dGlvblxyXG4gICAgKTtcclxuXHJcbiAgICBDYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljcyh0aGlzLCBjb250ZXh0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBzaGFwZSBhcyBhIHJlY3RhbmdsZSBvYmplY3RcclxuICpcclxuICogQHBhcmFtIFttYXRyaXhdIHtQSVhJLk1hdHJpeH0gVGhlIHdvcmxkIHRyYW5zZm9ybSBtYXRyaXggdG8gdXNlLCBkZWZhdWx0cyB0byB0aGlzXHJcbiAqICBvYmplY3QncyB3b3JsZFRyYW5zZm9ybS5cclxuICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXHJcbiAqL1xyXG5HcmFwaGljcy5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKG1hdHJpeClcclxue1xyXG4gICAgaWYoIXRoaXMuX2N1cnJlbnRCb3VuZHMpXHJcbiAgICB7XHJcblxyXG4gICAgICAgIC8vIHJldHVybiBhbiBlbXB0eSBvYmplY3QgaWYgdGhlIGl0ZW0gaXMgYSBtYXNrIVxyXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJhYmxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGguUmVjdGFuZ2xlLkVNUFRZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYm91bmRzRGlydHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxvY2FsQm91bmRzKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdsRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlZFNwcml0ZURpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZHNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX2xvY2FsQm91bmRzO1xyXG5cclxuICAgICAgICB2YXIgdzAgPSBib3VuZHMueDtcclxuICAgICAgICB2YXIgdzEgPSBib3VuZHMud2lkdGggKyBib3VuZHMueDtcclxuXHJcbiAgICAgICAgdmFyIGgwID0gYm91bmRzLnk7XHJcbiAgICAgICAgdmFyIGgxID0gYm91bmRzLmhlaWdodCArIGJvdW5kcy55O1xyXG5cclxuICAgICAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXggfHwgdGhpcy53b3JsZFRyYW5zZm9ybTtcclxuXHJcbiAgICAgICAgdmFyIGEgPSB3b3JsZFRyYW5zZm9ybS5hO1xyXG4gICAgICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYjtcclxuICAgICAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmM7XHJcbiAgICAgICAgdmFyIGQgPSB3b3JsZFRyYW5zZm9ybS5kO1xyXG4gICAgICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4O1xyXG4gICAgICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5O1xyXG5cclxuICAgICAgICB2YXIgeDEgPSBhICogdzEgKyBjICogaDEgKyB0eDtcclxuICAgICAgICB2YXIgeTEgPSBkICogaDEgKyBiICogdzEgKyB0eTtcclxuXHJcbiAgICAgICAgdmFyIHgyID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XHJcbiAgICAgICAgdmFyIHkyID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XHJcblxyXG4gICAgICAgIHZhciB4MyA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xyXG4gICAgICAgIHZhciB5MyA9IGQgKiBoMCArIGIgKiB3MCArIHR5O1xyXG5cclxuICAgICAgICB2YXIgeDQgPSAgYSAqIHcxICsgYyAqIGgwICsgdHg7XHJcbiAgICAgICAgdmFyIHk0ID0gIGQgKiBoMCArIGIgKiB3MSArIHR5O1xyXG5cclxuICAgICAgICB2YXIgbWF4WCA9IHgxO1xyXG4gICAgICAgIHZhciBtYXhZID0geTE7XHJcblxyXG4gICAgICAgIHZhciBtaW5YID0geDE7XHJcbiAgICAgICAgdmFyIG1pblkgPSB5MTtcclxuXHJcbiAgICAgICAgbWluWCA9IHgyIDwgbWluWCA/IHgyIDogbWluWDtcclxuICAgICAgICBtaW5YID0geDMgPCBtaW5YID8geDMgOiBtaW5YO1xyXG4gICAgICAgIG1pblggPSB4NCA8IG1pblggPyB4NCA6IG1pblg7XHJcblxyXG4gICAgICAgIG1pblkgPSB5MiA8IG1pblkgPyB5MiA6IG1pblk7XHJcbiAgICAgICAgbWluWSA9IHkzIDwgbWluWSA/IHkzIDogbWluWTtcclxuICAgICAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xyXG5cclxuICAgICAgICBtYXhYID0geDIgPiBtYXhYID8geDIgOiBtYXhYO1xyXG4gICAgICAgIG1heFggPSB4MyA+IG1heFggPyB4MyA6IG1heFg7XHJcbiAgICAgICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcclxuXHJcbiAgICAgICAgbWF4WSA9IHkyID4gbWF4WSA/IHkyIDogbWF4WTtcclxuICAgICAgICBtYXhZID0geTMgPiBtYXhZID8geTMgOiBtYXhZO1xyXG4gICAgICAgIG1heFkgPSB5NCA+IG1heFkgPyB5NCA6IG1heFk7XHJcblxyXG4gICAgICAgIHRoaXMuX2JvdW5kcy54ID0gbWluWDtcclxuICAgICAgICB0aGlzLl9ib3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcclxuXHJcbiAgICAgICAgdGhpcy5fYm91bmRzLnkgPSBtaW5ZO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuXHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IHRoaXMuX2JvdW5kcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJvdW5kcztcclxufTtcclxuXHJcbi8qKlxyXG4qIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgZ3JhcGhpY3Mgb2JqZWN0XHJcbipcclxuKiBAcGFyYW0gcG9pbnQge1BJWEkuUG9pbnR9IHRoZSBwb2ludCB0byB0ZXN0XHJcbiogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxyXG4qL1xyXG5HcmFwaGljcy5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKCBwb2ludCApXHJcbntcclxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCAgdGVtcFBvaW50KTtcclxuXHJcbiAgICB2YXIgZ3JhcGhpY3NEYXRhID0gdGhpcy5ncmFwaGljc0RhdGE7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljc0RhdGFbaV07XHJcblxyXG4gICAgICAgIGlmICghZGF0YS5maWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBvbmx5IGRlYWwgd2l0aCBmaWxscy4uXHJcbiAgICAgICAgaWYgKGRhdGEuc2hhcGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIGRhdGEuc2hhcGUuY29udGFpbnMoIHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSApIClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3RcclxuICpcclxuICovXHJcbkdyYXBoaWNzLnByb3RvdHlwZS51cGRhdGVMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XHJcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcclxuXHJcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xyXG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XHJcblxyXG4gICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICB2YXIgc2hhcGUsIHBvaW50cywgeCwgeSwgdywgaDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5ncmFwaGljc0RhdGFbaV07XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xyXG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gZGF0YS5saW5lV2lkdGg7XHJcbiAgICAgICAgICAgIHNoYXBlID0gZGF0YS5zaGFwZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBDT05TVC5TSEFQRVMuUkVDVCB8fCB0eXBlID09PSBDT05TVC5TSEFQRVMuUlJFQylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgeCA9IHNoYXBlLnggLSBsaW5lV2lkdGgvMjtcclxuICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55IC0gbGluZVdpZHRoLzI7XHJcbiAgICAgICAgICAgICAgICB3ID0gc2hhcGUud2lkdGggKyBsaW5lV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBoID0gc2hhcGUuaGVpZ2h0ICsgbGluZVdpZHRoO1xyXG5cclxuICAgICAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xyXG4gICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcclxuXHJcbiAgICAgICAgICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcclxuICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gQ09OU1QuU0hBUEVTLkNJUkMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICAgICAgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgICAgICB3ID0gc2hhcGUucmFkaXVzICsgbGluZVdpZHRoLzI7XHJcbiAgICAgICAgICAgICAgICBoID0gc2hhcGUucmFkaXVzICsgbGluZVdpZHRoLzI7XHJcblxyXG4gICAgICAgICAgICAgICAgbWluWCA9IHggLSB3IDwgbWluWCA/IHggLSB3IDogbWluWDtcclxuICAgICAgICAgICAgICAgIG1heFggPSB4ICsgdyA+IG1heFggPyB4ICsgdyA6IG1heFg7XHJcblxyXG4gICAgICAgICAgICAgICAgbWluWSA9IHkgLSBoIDwgbWluWSA/IHkgLSBoIDogbWluWTtcclxuICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gQ09OU1QuU0hBUEVTLkVMSVApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICAgICAgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgICAgICB3ID0gc2hhcGUud2lkdGggKyBsaW5lV2lkdGgvMjtcclxuICAgICAgICAgICAgICAgIGggPSBzaGFwZS5oZWlnaHQgKyBsaW5lV2lkdGgvMjtcclxuXHJcbiAgICAgICAgICAgICAgICBtaW5YID0geCAtIHcgPCBtaW5YID8geCAtIHcgOiBtaW5YO1xyXG4gICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcclxuXHJcbiAgICAgICAgICAgICAgICBtaW5ZID0geSAtIGggPCBtaW5ZID8geSAtIGggOiBtaW5ZO1xyXG4gICAgICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFBPTFlcclxuICAgICAgICAgICAgICAgIHBvaW50cyA9IHNoYXBlLnBvaW50cztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGogKz0gMilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaisxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHgtbGluZVdpZHRoIDwgbWluWCA/IHgtbGluZVdpZHRoIDogbWluWDtcclxuICAgICAgICAgICAgICAgICAgICBtYXhYID0geCtsaW5lV2lkdGggPiBtYXhYID8geCtsaW5lV2lkdGggOiBtYXhYO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geS1saW5lV2lkdGggPCBtaW5ZID8geS1saW5lV2lkdGggOiBtaW5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5K2xpbmVXaWR0aCA+IG1heFkgPyB5K2xpbmVXaWR0aCA6IG1heFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgbWluWCA9IDA7XHJcbiAgICAgICAgbWF4WCA9IDA7XHJcbiAgICAgICAgbWluWSA9IDA7XHJcbiAgICAgICAgbWF4WSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhZGRpbmcgPSB0aGlzLmJvdW5kc1BhZGRpbmc7XHJcblxyXG4gICAgdGhpcy5fbG9jYWxCb3VuZHMueCA9IG1pblggLSBwYWRkaW5nO1xyXG4gICAgdGhpcy5fbG9jYWxCb3VuZHMud2lkdGggPSAobWF4WCAtIG1pblgpICsgcGFkZGluZyAqIDI7XHJcblxyXG4gICAgdGhpcy5fbG9jYWxCb3VuZHMueSA9IG1pblkgLSBwYWRkaW5nO1xyXG4gICAgdGhpcy5fbG9jYWxCb3VuZHMuaGVpZ2h0ID0gKG1heFkgLSBtaW5ZKSArIHBhZGRpbmcgKiAyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyB0aGUgY2FjaGVkIHNwcml0ZSB3aGVuIHRoZSBzcHJpdGUgaGFzIGNhY2hlQXNCaXRtYXAgPSB0cnVlXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG4vKlxyXG5HcmFwaGljcy5wcm90b3R5cGUuX2dlbmVyYXRlQ2FjaGVkU3ByaXRlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2NhY2hlZFNwcml0ZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgY2FudmFzQnVmZmVyID0gbmV3IENhbnZhc0J1ZmZlcihib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZS5mcm9tQ2FudmFzKGNhbnZhc0J1ZmZlci5jYW52YXMpO1xyXG5cclxuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUgPSBuZXcgU3ByaXRlKHRleHR1cmUpO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIgPSBjYW52YXNCdWZmZXI7XHJcblxyXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS53b3JsZFRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlci5yZXNpemUoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBsZXZlcmFnZSB0aGUgYW5jaG9yIHRvIGFjY291bnQgZm9yIHRoZSBvZmZzZXQgb2YgdGhlIGVsZW1lbnRcclxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oIGJvdW5kcy54IC8gYm91bmRzLndpZHRoICk7XHJcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKCBib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQgKTtcclxuXHJcbiAgICAvLyB0aGlzLl9jYWNoZWRTcHJpdGUuYnVmZmVyLmNvbnRleHQuc2F2ZSgpO1xyXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlci5jb250ZXh0LnRyYW5zbGF0ZSgtYm91bmRzLngsLWJvdW5kcy55KTtcclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBhbHBoYSBvZiB0aGUgZ3JhcGhpY3MgdG8gMSBmb3IgdGhlIHJlbmRlci4uXHJcbiAgICB0aGlzLndvcmxkQWxwaGEgPSAxO1xyXG5cclxuICAgIC8vIG5vdyByZW5kZXIgdGhlIGdyYXBoaWMuLlxyXG4gICAgQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3ModGhpcywgdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlci5jb250ZXh0KTtcclxuXHJcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYWxwaGEgPSB0aGlzLmFscGhhO1xyXG59O1xyXG4qL1xyXG4vKipcclxuICogVXBkYXRlcyB0ZXh0dXJlIHNpemUgYmFzZWQgb24gY2FudmFzIHNpemVcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbi8qXHJcbkdyYXBoaWNzLnByb3RvdHlwZS51cGRhdGVDYWNoZWRTcHJpdGVUZXh0dXJlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIGNhY2hlZFNwcml0ZSA9IHRoaXMuX2NhY2hlZFNwcml0ZTtcclxuICAgIHZhciB0ZXh0dXJlID0gY2FjaGVkU3ByaXRlLnRleHR1cmU7XHJcbiAgICB2YXIgY2FudmFzID0gY2FjaGVkU3ByaXRlLmJ1ZmZlci5jYW52YXM7XHJcblxyXG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aCA9IGNhbnZhcy53aWR0aDtcclxuICAgIHRleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcclxuICAgIHRleHR1cmUuY3JvcC53aWR0aCA9IHRleHR1cmUuZnJhbWUud2lkdGggPSBjYW52YXMud2lkdGg7XHJcbiAgICB0ZXh0dXJlLmNyb3AuaGVpZ2h0ID0gdGV4dHVyZS5mcmFtZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xyXG5cclxuICAgIGNhY2hlZFNwcml0ZS5fd2lkdGggPSBjYW52YXMud2lkdGg7XHJcbiAgICBjYWNoZWRTcHJpdGUuX2hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XHJcblxyXG4gICAgLy8gdXBkYXRlIHRoZSBkaXJ0eSBiYXNlIHRleHR1cmVzXHJcbiAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLmRpcnR5KCk7XHJcbn07Ki9cclxuXHJcbi8qKlxyXG4gKiBEZXN0cm95cyBhIHByZXZpb3VzIGNhY2hlZCBzcHJpdGUuXHJcbiAqXHJcbiAqL1xyXG4vKlxyXG5HcmFwaGljcy5wcm90b3R5cGUuZGVzdHJveUNhY2hlZFNwcml0ZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS50ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XHJcblxyXG4gICAgLy8gbGV0IHRoZSBnYyBjb2xsZWN0IHRoZSB1bnVzZWQgc3ByaXRlXHJcbiAgICAvLyBUT0RPIGNvdWxkIGJlIG9iamVjdCBwb29sZWQhXHJcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUgPSBudWxsO1xyXG59OyovXHJcblxyXG4vKipcclxuICogRHJhd3MgdGhlIGdpdmVuIHNoYXBlIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBDYW4gYmUgYW55IG9mIENpcmNsZSwgUmVjdGFuZ2xlLCBFbGxpcHNlLCBMaW5lIG9yIFBvbHlnb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBzaGFwZSB7UElYSS5DaXJjbGV8UElYSS5SZWN0YW5nbGV8UElYSS5FbGxpcHNlfFBJWEkuTGluZXxQSVhJLlBvbHlnb259IFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cclxuICogQHJldHVybiB7UElYSS5HcmFwaGljc0RhdGF9IFRoZSBnZW5lcmF0ZWQgR3JhcGhpY3NEYXRhIG9iamVjdC5cclxuICovXHJcbkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3U2hhcGUgPSBmdW5jdGlvbiAoc2hhcGUpXHJcbntcclxuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNoZWNrIGN1cnJlbnQgcGF0aCFcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoIDw9IDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YS5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XHJcblxyXG4gICAgdmFyIGRhdGEgPSBuZXcgR3JhcGhpY3NEYXRhKHRoaXMubGluZVdpZHRoLCB0aGlzLmxpbmVDb2xvciwgdGhpcy5saW5lQWxwaGEsIHRoaXMuZmlsbENvbG9yLCB0aGlzLmZpbGxBbHBoYSwgdGhpcy5maWxsaW5nLCBzaGFwZSk7XHJcblxyXG4gICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaChkYXRhKTtcclxuXHJcbiAgICBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUE9MWSlcclxuICAgIHtcclxuICAgICAgICBkYXRhLnNoYXBlLmNsb3NlZCA9IGRhdGEuc2hhcGUuY2xvc2VkIHx8IHRoaXMuZmlsbGluZztcclxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5ib3VuZHNEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVzdHJveXMgdGhlIEdyYXBoaWNzIG9iamVjdC5cclxuICovXHJcbkdyYXBoaWNzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgLy8gZGVzdHJveSBlYWNoIG9mIHRoZSBHcmFwaGljc0RhdGEgb2JqZWN0c1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhW2ldLmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3IgZWFjaCB3ZWJnbCBkYXRhIGVudHJ5LCBkZXN0cm95IHRoZSBXZWJHTEdyYXBoaWNzRGF0YVxyXG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fd2ViZ2wpIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3dlYmdsW2lkXS5kYXRhLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlYmdsW2lkXS5kYXRhW2pdLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5ncmFwaGljc0RhdGEgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xyXG4gICAgdGhpcy5fd2ViZ2wgPSBudWxsO1xyXG4gICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBudWxsO1xyXG59O1xyXG4iLCIvKipcclxuICogQSBHcmFwaGljc0RhdGEgb2JqZWN0LlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIGxpbmVXaWR0aCB7bnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhd1xyXG4gKiBAcGFyYW0gbGluZUNvbG9yIHtudW1iZXJ9IHRoZSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3XHJcbiAqIEBwYXJhbSBsaW5lQWxwaGEge251bWJlcn0gdGhlIGFscGhhIG9mIHRoZSBsaW5lIHRvIGRyYXdcclxuICogQHBhcmFtIGZpbGxDb2xvciB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcclxuICogQHBhcmFtIGZpbGxBbHBoYSB7bnVtYmVyfSB0aGUgYWxwaGEgb2YgdGhlIGZpbGxcclxuICogQHBhcmFtIGZpbGwgICAgICB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIHNoYXBlIGlzIGZpbGxlZCB3aXRoIGEgY29sb3VyXHJcbiAqIEBwYXJhbSBzaGFwZSAgICAge0NpcmNsZXxSZWN0YW5nbGV8RWxsaXBzZXxMaW5lfFBvbHlnb259IFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cclxuICovXHJcbmZ1bmN0aW9uIEdyYXBoaWNzRGF0YShsaW5lV2lkdGgsIGxpbmVDb2xvciwgbGluZUFscGhhLCBmaWxsQ29sb3IsIGZpbGxBbHBoYSwgZmlsbCwgc2hhcGUpXHJcbntcclxuICAgIC8qXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgbGluZSB0byBkcmF3XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRoZSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZUNvbG9yID0gbGluZUNvbG9yO1xyXG4gICAgLypcclxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIGFscGhhIG9mIHRoZSBsaW5lIHRvIGRyYXdcclxuICAgICAqL1xyXG4gICAgdGhpcy5saW5lQWxwaGEgPSBsaW5lQWxwaGE7XHJcbiAgICAvKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBjYWNoZWQgdGludCBvZiB0aGUgbGluZSB0byBkcmF3XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xpbmVUaW50ID0gbGluZUNvbG9yO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRoZSBjb2xvciBvZiB0aGUgZmlsbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbGxDb2xvciA9IGZpbGxDb2xvcjtcclxuXHJcbiAgICAvKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0aGUgYWxwaGEgb2YgdGhlIGZpbGxcclxuICAgICAqL1xyXG4gICAgdGhpcy5maWxsQWxwaGEgPSBmaWxsQWxwaGE7XHJcblxyXG4gICAgLypcclxuICAgICAqIEBtZW1iZXIge251bWJlcn0gY2FjaGVkIHRpbnQgb2YgdGhlIGZpbGxcclxuICAgICAqL1xyXG4gICAgdGhpcy5fZmlsbFRpbnQgPSBmaWxsQ29sb3I7XHJcblxyXG4gICAgLypcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBzaGFwZSBpcyBmaWxsZWQgd2l0aCBhIGNvbG91clxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbGwgPSBmaWxsO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkNpcmNsZXxQSVhJLlJlY3RhbmdsZXxQSVhJLkVsbGlwc2V8UElYSS5MaW5lfFBJWEkuUG9seWdvbn0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNoYXBlID0gc2hhcGU7XHJcblxyXG4gICAgLypcclxuICAgICAqIEBtZW1iZXIge251bWJlcn0gVGhlIHR5cGUgb2YgdGhlIHNoYXBlLCBzZWUgdGhlIENvbnN0LlNoYXBlcyBmaWxlIGZvciBhbGwgdGhlIGV4aXN0aW5nIHR5cGVzLFxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGUgPSBzaGFwZS50eXBlO1xyXG59XHJcblxyXG5HcmFwaGljc0RhdGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JhcGhpY3NEYXRhO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoaWNzRGF0YTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IEdyYXBoaWNzRGF0YSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3NEYXRhfVxyXG4gKi9cclxuR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiBuZXcgR3JhcGhpY3NEYXRhKFxyXG4gICAgICAgIHRoaXMubGluZVdpZHRoLFxyXG4gICAgICAgIHRoaXMubGluZUNvbG9yLFxyXG4gICAgICAgIHRoaXMubGluZUFscGhhLFxyXG4gICAgICAgIHRoaXMuZmlsbENvbG9yLFxyXG4gICAgICAgIHRoaXMuZmlsbEFscGhhLFxyXG4gICAgICAgIHRoaXMuZmlsbCxcclxuICAgICAgICB0aGlzLnNoYXBlXHJcbiAgICApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBkYXRhLlxyXG4gKi9cclxuR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5zaGFwZSA9IG51bGw7XHJcbn07XHJcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyksXHJcbiAgICBtYXRoID0gcmVxdWlyZSgnLi4vLi4vbWF0aCcpLFxyXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpLFxyXG4gICAgT2JqZWN0UmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvT2JqZWN0UmVuZGVyZXInKSxcclxuICAgIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xSZW5kZXJlcicpLFxyXG4gICAgV2ViR0xHcmFwaGljc0RhdGEgPSByZXF1aXJlKCcuL1dlYkdMR3JhcGhpY3NEYXRhJyksXHJcbiAgICBlYXJjdXQgPSByZXF1aXJlKCdlYXJjdXQnKTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBncmFwaGljcyBvYmplY3QuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAZXh0ZW5kcyBQSVhJLk9iamVjdFJlbmRlcmVyXHJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBvYmplY3QgcmVuZGVyZXIgd29ya3MgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gR3JhcGhpY3NSZW5kZXJlcihyZW5kZXJlcilcclxue1xyXG4gICAgT2JqZWN0UmVuZGVyZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XHJcblxyXG4gICAgdGhpcy5ncmFwaGljc0RhdGFQb29sID0gW107XHJcblxyXG4gICAgdGhpcy5wcmltaXRpdmVTaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy5jb21wbGV4UHJpbWl0aXZlU2hhZGVyID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHBvaW50cyBhIHBvbHkgY2FuIGNvbnRhaW4gYmVmb3JlIGl0IGlzIHJlbmRlcmVkIGFzIGEgY29tcGxleCBwb2x5Z29uICh1c2luZyB0aGUgc3RlbmNpbCBidWZmZXIpXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1heGltdW1TaW1wbGVQb2x5U2l6ZSA9IDIwMDtcclxufVxyXG5cclxuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdFJlbmRlcmVyLnByb3RvdHlwZSk7XHJcbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JhcGhpY3NSZW5kZXJlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaGljc1JlbmRlcmVyO1xyXG5cclxuV2ViR0xSZW5kZXJlci5yZWdpc3RlclBsdWdpbignZ3JhcGhpY3MnLCBHcmFwaGljc1JlbmRlcmVyKTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsZWQgd2hlbiB0aGVyZSBpcyBhIFdlYkdMIGNvbnRleHQgY2hhbmdlXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqXHJcbiAqL1xyXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5vbkNvbnRleHRDaGFuZ2UgPSBmdW5jdGlvbigpXHJcbntcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogRGVzdHJveXMgdGhpcyByZW5kZXJlci5cclxuICpcclxuICovXHJcbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBPYmplY3RSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGFQb29sLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFQb29sW2ldLmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmdyYXBoaWNzRGF0YVBvb2wgPSBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgYSBncmFwaGljcyBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBncmFwaGljcyB7UElYSS5HcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCB0byByZW5kZXIuXHJcbiAqL1xyXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihncmFwaGljcylcclxue1xyXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG5cclxuICAgIHZhciBzaGFkZXIgPSByZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnBsdWdpbnMucHJpbWl0aXZlU2hhZGVyLFxyXG4gICAgICAgIHdlYkdMRGF0YTtcclxuXHJcbiAgICBpZiAoZ3JhcGhpY3MuZGlydHkgfHwgIWdyYXBoaWNzLl93ZWJHTFtnbC5pZF0pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVHcmFwaGljcyhncmFwaGljcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW2dsLmlkXTtcclxuXHJcbiAgICAvLyBUaGlzICBjb3VsZCBiZSBzcGVlZGVkIHVwIGZvciBzdXJlIVxyXG5cclxuICAgIHJlbmRlcmVyLmJsZW5kTW9kZU1hbmFnZXIuc2V0QmxlbmRNb2RlKCBncmFwaGljcy5ibGVuZE1vZGUgKTtcclxuXHJcbi8vICAgIHZhciBtYXRyaXggPSAgZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0uY2xvbmUoKTtcclxuLy8gICAgdmFyIG1hdHJpeCA9ICByZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXguY2xvbmUoKTtcclxuLy8gICAgbWF0cml4LmFwcGVuZChncmFwaGljcy53b3JsZFRyYW5zZm9ybSk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB3ZWJHTC5kYXRhLmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgIHtcclxuICAgICAgICB3ZWJHTERhdGEgPSB3ZWJHTC5kYXRhW2ldO1xyXG5cclxuICAgICAgICBpZiAod2ViR0wuZGF0YVtpXS5tb2RlID09PSAxKVxyXG4gICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnN0ZW5jaWxNYW5hZ2VyLnB1c2hTdGVuY2lsKGdyYXBoaWNzLCB3ZWJHTERhdGEpO1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHJlbmRlcmVyLnNoYWRlck1hbmFnZXIuY29tcGxleFByaW1pdGl2ZVNoYWRlci51bmlmb3Jtcy5hbHBoYS5fbG9jYXRpb24sIGdyYXBoaWNzLndvcmxkQWxwaGEgKiB3ZWJHTERhdGEuYWxwaGEpO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVuZGVyIHF1YWQuLlxyXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfRkFOLCA0LCBnbC5VTlNJR05FRF9TSE9SVCwgKCB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGggLSA0ICkgKiAyICk7XHJcblxyXG4gICAgICAgICAgICByZW5kZXJlci5zdGVuY2lsTWFuYWdlci5wb3BTdGVuY2lsKGdyYXBoaWNzLCB3ZWJHTERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgc2hhZGVyID0gcmVuZGVyZXIuc2hhZGVyTWFuYWdlci5wcmltaXRpdmVTaGFkZXI7XHJcblxyXG4gICAgICAgICAgICByZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlciggc2hhZGVyICk7Ly9hY3RpdmF0ZVByaW1pdGl2ZVNoYWRlcigpO1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKSk7XHJcblxyXG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4Ll9sb2NhdGlvbiwgZmFsc2UsIHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpKTtcclxuXHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLnVuaWZvcm1zLnRpbnQuX2xvY2F0aW9uLCB1dGlscy5oZXgycmdiKGdyYXBoaWNzLnRpbnQpKTtcclxuXHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybXMuYWxwaGEuX2xvY2F0aW9uLCBncmFwaGljcy53b3JsZEFscGhhKTtcclxuXHJcblxyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmJ1ZmZlcik7XHJcblxyXG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogNiwgMCk7XHJcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCA0LCBnbC5GTE9BVCwgZmFsc2UsNCAqIDYsIDIgKiA0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNldCB0aGUgaW5kZXggYnVmZmVyIVxyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuaW5kZXhCdWZmZXIpO1xyXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfU1RSSVAsICB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXJlci5kcmF3Q291bnQrKztcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBncmFwaGljcyBvYmplY3RcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIGdyYXBoaWNzIHtQSVhJLkdyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIHVwZGF0ZVxyXG4gKi9cclxuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlR3JhcGhpY3MgPSBmdW5jdGlvbihncmFwaGljcylcclxue1xyXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuXHJcbiAgICAgLy8gZ2V0IHRoZSBjb250ZXh0cyBncmFwaGljcyBvYmplY3RcclxuICAgIHZhciB3ZWJHTCA9IGdyYXBoaWNzLl93ZWJHTFtnbC5pZF07XHJcblxyXG4gICAgLy8gaWYgdGhlIGdyYXBoaWNzIG9iamVjdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgd2ViR0wgY29udGV4dCB0aW1lIHRvIGNyZWF0ZSBpdCFcclxuICAgIGlmICghd2ViR0wpXHJcbiAgICB7XHJcbiAgICAgICAgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbZ2wuaWRdID0ge2xhc3RJbmRleDowLCBkYXRhOltdLCBnbDpnbH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmxhZyB0aGUgZ3JhcGhpY3MgYXMgbm90IGRpcnR5IGFzIHdlIGFyZSBhYm91dCB0byB1cGRhdGUgaXQuLi5cclxuICAgIGdyYXBoaWNzLmRpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgLy8gaWYgdGhlIHVzZXIgY2xlYXJlZCB0aGUgZ3JhcGhpY3Mgb2JqZWN0IHdlIHdpbGwgbmVlZCB0byBjbGVhciBldmVyeSBvYmplY3RcclxuICAgIGlmIChncmFwaGljcy5jbGVhckRpcnR5KVxyXG4gICAge1xyXG4gICAgICAgIGdyYXBoaWNzLmNsZWFyRGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFuZCByZXR1cm4gYWxsIHRoZSB3ZWJHTERhdGFzIHRvIHRoZSBvYmplY3QgcG9vbCBzbyB0aGFuIGNhbiBiZSByZXVzZWQgbGF0ZXIgb25cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgd2ViR0wuZGF0YS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBncmFwaGljc0RhdGEgPSB3ZWJHTC5kYXRhW2ldO1xyXG4gICAgICAgICAgICBncmFwaGljc0RhdGEucmVzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFQb29sLnB1c2goIGdyYXBoaWNzRGF0YSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2xlYXIgdGhlIGFycmF5IGFuZCByZXNldCB0aGUgaW5kZXguLlxyXG4gICAgICAgIHdlYkdMLmRhdGEgPSBbXTtcclxuICAgICAgICB3ZWJHTC5sYXN0SW5kZXggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB3ZWJHTERhdGE7XHJcblxyXG4gICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBncmFwaGljcyBkYXRhcyBhbmQgY29uc3RydWN0IGVhY2ggb25lLi5cclxuICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgYSBjb21wbGV4IGZpbGwgdGhlbiB0aGUgbmV3IHN0ZW5jaWwgYnVmZmVyIHRlY2huaXF1ZSB3aWxsIGJlIHVzZWRcclxuICAgIC8vIG90aGVyIHdpc2UgZ3JhcGhpY3Mgb2JqZWN0cyB3aWxsIGJlIHB1c2hlZCBpbnRvIGEgYmF0Y2guLlxyXG4gICAgZm9yIChpID0gd2ViR0wubGFzdEluZGV4OyBpIDwgZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xyXG5cclxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUE9MWSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gYWRkIHRoZSBwb2ludHMgdGhlIHRoZSBncmFwaGljcyBvYmplY3QuLlxyXG4gICAgICAgICAgICBkYXRhLnBvaW50cyA9IGRhdGEuc2hhcGUucG9pbnRzLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnNoYXBlLmNsb3NlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xvc2UgdGhlIHBvbHkgaWYgdGhlIHZhbHVlIGlzIHRydWUhXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb2ludHNbMF0gIT09IGRhdGEucG9pbnRzW2RhdGEucG9pbnRzLmxlbmd0aC0yXSB8fCBkYXRhLnBvaW50c1sxXSAhPT0gZGF0YS5wb2ludHNbZGF0YS5wb2ludHMubGVuZ3RoLTFdKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucG9pbnRzLnB1c2goZGF0YS5wb2ludHNbMF0sIGRhdGEucG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTUFLRSBTVVJFIFdFIEhBVkUgVEhFIENPUlJFQ1QgVFlQRS4uXHJcbiAgICAgICAgICAgIGlmIChkYXRhLmZpbGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnBvaW50cy5sZW5ndGggPj0gNilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb2ludHMubGVuZ3RoIDwgdGhpcy5tYXhpbXVtU2ltcGxlUG9seVNpemUgKiAyKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2ViR0xEYXRhID0gdGhpcy5zd2l0Y2hNb2RlKHdlYkdMLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5EcmF3VXNpbmdTaW1wbGUgPSB0aGlzLmJ1aWxkUG9seShkYXRhLCB3ZWJHTERhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5EcmF3VXNpbmdTaW1wbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYkdMRGF0YSA9IHRoaXMuc3dpdGNoTW9kZSh3ZWJHTCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkQ29tcGxleFBvbHkoZGF0YSwgd2ViR0xEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2ViR0xEYXRhID0gdGhpcy5zd2l0Y2hNb2RlKHdlYkdMLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZENvbXBsZXhQb2x5KGRhdGEsIHdlYkdMRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5saW5lV2lkdGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLnN3aXRjaE1vZGUod2ViR0wsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZExpbmUoZGF0YSwgd2ViR0xEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLnN3aXRjaE1vZGUod2ViR0wsIDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLlJFQ1QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRSZWN0YW5nbGUoZGF0YSwgd2ViR0xEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5DSVJDIHx8IGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLkVMSVApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRDaXJjbGUoZGF0YSwgd2ViR0xEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5SUkVDKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUm91bmRlZFJlY3RhbmdsZShkYXRhLCB3ZWJHTERhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3ZWJHTC5sYXN0SW5kZXgrKztcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGxvYWQgYWxsIHRoZSBkaXJ0eSBkYXRhLi4uXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2ViR0wuZGF0YS5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB3ZWJHTERhdGEgPSB3ZWJHTC5kYXRhW2ldO1xyXG5cclxuICAgICAgICBpZiAod2ViR0xEYXRhLmRpcnR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgd2ViR0xEYXRhLnVwbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gd2ViR0wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XHJcbiAqIEBwYXJhbSB0eXBlIHtudW1iZXJ9IFRPRE8gQEFsdmluXHJcbiAqL1xyXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5zd2l0Y2hNb2RlID0gZnVuY3Rpb24gKHdlYkdMLCB0eXBlKVxyXG57XHJcbiAgICB2YXIgd2ViR0xEYXRhO1xyXG5cclxuICAgIGlmICghd2ViR0wuZGF0YS5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgd2ViR0xEYXRhID0gdGhpcy5ncmFwaGljc0RhdGFQb29sLnBvcCgpIHx8IG5ldyBXZWJHTEdyYXBoaWNzRGF0YSh3ZWJHTC5nbCk7XHJcbiAgICAgICAgd2ViR0xEYXRhLm1vZGUgPSB0eXBlO1xyXG4gICAgICAgIHdlYkdMLmRhdGEucHVzaCh3ZWJHTERhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHdlYkdMRGF0YSA9IHdlYkdMLmRhdGFbd2ViR0wuZGF0YS5sZW5ndGgtMV07XHJcblxyXG4gICAgICAgIGlmICgod2ViR0xEYXRhLnBvaW50cy5sZW5ndGggPiAzMjAwMDApIHx8IHdlYkdMRGF0YS5tb2RlICE9PSB0eXBlIHx8IHR5cGUgPT09IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YVBvb2wucG9wKCkgfHwgbmV3IFdlYkdMR3JhcGhpY3NEYXRhKHdlYkdMLmdsKTtcclxuICAgICAgICAgICAgd2ViR0xEYXRhLm1vZGUgPSB0eXBlO1xyXG4gICAgICAgICAgICB3ZWJHTC5kYXRhLnB1c2god2ViR0xEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgd2ViR0xEYXRhLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gd2ViR0xEYXRhO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIHJlY3RhbmdsZSB0byBkcmF3XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSBncmFwaGljc0RhdGEge1BJWEkuR3JhcGhpY3N9IFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXHJcbiAqIEBwYXJhbSB3ZWJHTERhdGEge29iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxyXG4gKi9cclxuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXHJcbntcclxuICAgIC8vIC0tLSAvL1xyXG4gICAgLy8gbmVlZCB0byBjb252ZXJ0IHBvaW50cyB0byBhIG5pY2UgcmVndWxhciBkYXRhXHJcbiAgICAvL1xyXG4gICAgdmFyIHJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xyXG4gICAgdmFyIHggPSByZWN0RGF0YS54O1xyXG4gICAgdmFyIHkgPSByZWN0RGF0YS55O1xyXG4gICAgdmFyIHdpZHRoID0gcmVjdERhdGEud2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdERhdGEuaGVpZ2h0O1xyXG5cclxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbClcclxuICAgIHtcclxuICAgICAgICB2YXIgY29sb3IgPSB1dGlscy5oZXgycmdiKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xyXG4gICAgICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XHJcblxyXG4gICAgICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcclxuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XHJcbiAgICAgICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xyXG5cclxuICAgICAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xyXG4gICAgICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoLzY7XHJcblxyXG4gICAgICAgIC8vIHN0YXJ0XHJcbiAgICAgICAgdmVydHMucHVzaCh4LCB5KTtcclxuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcclxuXHJcbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkpO1xyXG4gICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xyXG5cclxuICAgICAgICB2ZXJ0cy5wdXNoKHggLCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcclxuXHJcbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xyXG5cclxuICAgICAgICAvLyBpbnNlcnQgMiBkZWFkIHRyaWFuZ2xlcy4uXHJcbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlcnRQb3MsIHZlcnRQb3MsIHZlcnRQb3MrMSwgdmVydFBvcysyLCB2ZXJ0UG9zKzMsIHZlcnRQb3MrMyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xyXG5cclxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gW3gsIHksXHJcbiAgICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSxcclxuICAgICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICB4LCB5ICsgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICB4LCB5XTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcclxuXHJcbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHRlbXBQb2ludHM7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQnVpbGRzIGEgcm91bmRlZCByZWN0YW5nbGUgdG8gZHJhd1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtQSVhJLkdyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xyXG4gKiBAcGFyYW0gd2ViR0xEYXRhIHtvYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcclxuICovXHJcbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkUm91bmRlZFJlY3RhbmdsZSA9IGZ1bmN0aW9uIChncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcclxue1xyXG4gICAgdmFyIHJyZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcclxuICAgIHZhciB4ID0gcnJlY3REYXRhLng7XHJcbiAgICB2YXIgeSA9IHJyZWN0RGF0YS55O1xyXG4gICAgdmFyIHdpZHRoID0gcnJlY3REYXRhLndpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IHJyZWN0RGF0YS5oZWlnaHQ7XHJcblxyXG4gICAgdmFyIHJhZGl1cyA9IHJyZWN0RGF0YS5yYWRpdXM7XHJcblxyXG4gICAgdmFyIHJlY1BvaW50cyA9IFtdO1xyXG4gICAgcmVjUG9pbnRzLnB1c2goeCwgeSArIHJhZGl1cyk7XHJcbiAgICB0aGlzLnF1YWRyYXRpY0JlemllckN1cnZlKHgsIHkgKyBoZWlnaHQgLSByYWRpdXMsIHgsIHkgKyBoZWlnaHQsIHggKyByYWRpdXMsIHkgKyBoZWlnaHQsIHJlY1BvaW50cyk7XHJcbiAgICB0aGlzLnF1YWRyYXRpY0JlemllckN1cnZlKHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMsIHJlY1BvaW50cyk7XHJcbiAgICB0aGlzLnF1YWRyYXRpY0JlemllckN1cnZlKHggKyB3aWR0aCwgeSArIHJhZGl1cywgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGggLSByYWRpdXMsIHksIHJlY1BvaW50cyk7XHJcbiAgICB0aGlzLnF1YWRyYXRpY0JlemllckN1cnZlKHggKyByYWRpdXMsIHksIHgsIHksIHgsIHkgKyByYWRpdXMgKyAwLjAwMDAwMDAwMDEsIHJlY1BvaW50cyk7XHJcblxyXG4gICAgLy8gdGhpcyB0aW55IG51bWJlciBkZWFscyB3aXRoIHRoZSBpc3N1ZSB0aGF0IG9jY3VycyB3aGVuIHBvaW50cyBvdmVybGFwIGFuZCBlYXJjdXQgZmFpbHMgdG8gdHJpYW5ndWxhdGUgdGhlIGl0ZW0uXHJcbiAgICAvLyBUT0RPIC0gZml4IHRoaXMgcHJvcGVybHksIHRoaXMgaXMgbm90IHZlcnkgZWxlZ2FudC4uIGJ1dCBpdCB3b3JrcyBmb3Igbm93LlxyXG5cclxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbClcclxuICAgIHtcclxuICAgICAgICB2YXIgY29sb3IgPSB1dGlscy5oZXgycmdiKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xyXG4gICAgICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XHJcblxyXG4gICAgICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcclxuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XHJcbiAgICAgICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xyXG5cclxuICAgICAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xyXG4gICAgICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XHJcblxyXG4gICAgICAgIHZhciB2ZWNQb3MgPSB2ZXJ0cy5sZW5ndGgvNjtcclxuXHJcbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IGVhcmN1dChyZWNQb2ludHMsIG51bGwsIDIpO1xyXG5cclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkrPTMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVjUG9zKTtcclxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlY1Bvcyk7XHJcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsxXSArIHZlY1Bvcyk7XHJcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsyXSArIHZlY1Bvcyk7XHJcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsyXSArIHZlY1Bvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVjUG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmVydHMucHVzaChyZWNQb2ludHNbaV0sIHJlY1BvaW50c1srK2ldLCByLCBnLCBiLCBhbHBoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZW1wUG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcclxuXHJcbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHJlY1BvaW50cztcclxuXHJcbiAgICAgICAgdGhpcy5idWlsZExpbmUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpO1xyXG5cclxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlLiAoaGVscGVyIGZ1bmN0aW9uLi4pXHJcbiAqIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODUwOTcvaG93LWRvLWktaW1wbGVtZW50LWEtYmV6aWVyLWN1cnZlLWluLWNcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIGZyb21YIHtudW1iZXJ9IE9yaWdpbiBwb2ludCB4XHJcbiAqIEBwYXJhbSBmcm9tWSB7bnVtYmVyfSBPcmlnaW4gcG9pbnQgeFxyXG4gKiBAcGFyYW0gY3BYIHtudW1iZXJ9IENvbnRyb2wgcG9pbnQgeFxyXG4gKiBAcGFyYW0gY3BZIHtudW1iZXJ9IENvbnRyb2wgcG9pbnQgeVxyXG4gKiBAcGFyYW0gdG9YIHtudW1iZXJ9IERlc3RpbmF0aW9uIHBvaW50IHhcclxuICogQHBhcmFtIHRvWSB7bnVtYmVyfSBEZXN0aW5hdGlvbiBwb2ludCB5XHJcbiAqIEBwYXJhbSBbb3V0XSB7bnVtYmVyW119IFRoZSBvdXRwdXQgYXJyYXkgdG8gYWRkIHBvaW50cyBpbnRvLiBJZiBub3QgcGFzc2VkLCBhIG5ldyBhcnJheSBpcyBjcmVhdGVkLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gYW4gYXJyYXkgb2YgcG9pbnRzXHJcbiAqL1xyXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5xdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uIChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSwgb3V0KVxyXG57XHJcbiAgICB2YXIgeGEsXHJcbiAgICAgICAgeWEsXHJcbiAgICAgICAgeGIsXHJcbiAgICAgICAgeWIsXHJcbiAgICAgICAgeCxcclxuICAgICAgICB5LFxyXG4gICAgICAgIG4gPSAyMCxcclxuICAgICAgICBwb2ludHMgPSBvdXQgfHwgW107XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UHQobjEgLCBuMiwgcGVyYykge1xyXG4gICAgICAgIHZhciBkaWZmID0gbjIgLSBuMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG4xICsgKCBkaWZmICogcGVyYyApO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBqID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkrKyApIHtcclxuICAgICAgICBqID0gaSAvIG47XHJcblxyXG4gICAgICAgIC8vIFRoZSBHcmVlbiBMaW5lXHJcbiAgICAgICAgeGEgPSBnZXRQdCggZnJvbVggLCBjcFggLCBqICk7XHJcbiAgICAgICAgeWEgPSBnZXRQdCggZnJvbVkgLCBjcFkgLCBqICk7XHJcbiAgICAgICAgeGIgPSBnZXRQdCggY3BYICwgdG9YICwgaiApO1xyXG4gICAgICAgIHliID0gZ2V0UHQoIGNwWSAsIHRvWSAsIGogKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIEJsYWNrIERvdFxyXG4gICAgICAgIHggPSBnZXRQdCggeGEgLCB4YiAsIGogKTtcclxuICAgICAgICB5ID0gZ2V0UHQoIHlhICwgeWIgLCBqICk7XHJcblxyXG4gICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2ludHM7XHJcbn07XHJcblxyXG4vKipcclxuICogQnVpbGRzIGEgY2lyY2xlIHRvIGRyYXdcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7UElYSS5HcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCB0byBkcmF3XHJcbiAqIEBwYXJhbSB3ZWJHTERhdGEge29iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxyXG4gKi9cclxuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRDaXJjbGUgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXHJcbntcclxuICAgIC8vIG5lZWQgdG8gY29udmVydCBwb2ludHMgdG8gYSBuaWNlIHJlZ3VsYXIgZGF0YVxyXG4gICAgdmFyIGNpcmNsZURhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XHJcbiAgICB2YXIgeCA9IGNpcmNsZURhdGEueDtcclxuICAgIHZhciB5ID0gY2lyY2xlRGF0YS55O1xyXG4gICAgdmFyIHdpZHRoO1xyXG4gICAgdmFyIGhlaWdodDtcclxuXHJcbiAgICAvLyBUT0RPIC0gYml0IGhhY2t5Pz9cclxuICAgIGlmIChncmFwaGljc0RhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLkNJUkMpXHJcbiAgICB7XHJcbiAgICAgICAgd2lkdGggPSBjaXJjbGVEYXRhLnJhZGl1cztcclxuICAgICAgICBoZWlnaHQgPSBjaXJjbGVEYXRhLnJhZGl1cztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB3aWR0aCA9IGNpcmNsZURhdGEud2lkdGg7XHJcbiAgICAgICAgaGVpZ2h0ID0gY2lyY2xlRGF0YS5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRvdGFsU2VncyA9IE1hdGguZmxvb3IoMzAgKiBNYXRoLnNxcnQoY2lyY2xlRGF0YS5yYWRpdXMpKSB8fCBNYXRoLmZsb29yKDE1ICogTWF0aC5zcXJ0KGNpcmNsZURhdGEud2lkdGggKyBjaXJjbGVEYXRhLmhlaWdodCkpO1xyXG4gICAgdmFyIHNlZyA9IChNYXRoLlBJICogMikgLyB0b3RhbFNlZ3MgO1xyXG5cclxuICAgIHZhciBpID0gMDtcclxuXHJcbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmZpbGwpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gdXRpbHMuaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcclxuICAgICAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XHJcbiAgICAgICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xyXG4gICAgICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xyXG5cclxuICAgICAgICB2YXIgdmVjUG9zID0gdmVydHMubGVuZ3RoLzY7XHJcblxyXG4gICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxTZWdzICsgMSA7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZlcnRzLnB1c2goeCx5LCByLCBnLCBiLCBhbHBoYSk7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHggKyBNYXRoLnNpbihzZWcgKiBpKSAqIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHkgKyBNYXRoLmNvcyhzZWcgKiBpKSAqIGhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYSk7XHJcblxyXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godmVjUG9zKyssIHZlY1BvcysrKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MtMSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xyXG5cclxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gW107XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbFNlZ3MgKyAxOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzLnB1c2goeCArIE1hdGguc2luKHNlZyAqIGkpICogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICsgTWF0aC5jb3Moc2VnICogaSkgKiBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5idWlsZExpbmUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpO1xyXG5cclxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgYSBsaW5lIHRvIGRyYXdcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7UElYSS5HcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcclxuICogQHBhcmFtIHdlYkdMRGF0YSB7b2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXHJcbiAqL1xyXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZExpbmUgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXHJcbntcclxuICAgIC8vIFRPRE8gT1BUSU1JU0UhXHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcclxuXHJcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBpZiB0aGUgbGluZSB3aWR0aCBpcyBhbiBvZGQgbnVtYmVyIGFkZCAwLjUgdG8gYWxpZ24gdG8gYSB3aG9sZSBwaXhlbFxyXG4gICAgLy8gY29tbWVudGluZyB0aGlzIG91dCBmaXhlcyAjNzExIGFuZCAjMTYyMFxyXG4gICAgLy8gaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGglMilcclxuICAgIC8vIHtcclxuICAgIC8vICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgLy8gICAgIHtcclxuICAgIC8vICAgICAgICAgcG9pbnRzW2ldICs9IDAuNTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxyXG4gICAgdmFyIGZpcnN0UG9pbnQgPSBuZXcgbWF0aC5Qb2ludChwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICB2YXIgbGFzdFBvaW50ID0gbmV3IG1hdGguUG9pbnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XHJcblxyXG4gICAgLy8gaWYgdGhlIGZpcnN0IHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IC0gZ29ubmEgaGF2ZSBpc3N1ZXMgOilcclxuICAgIGlmIChmaXJzdFBvaW50LnggPT09IGxhc3RQb2ludC54ICYmIGZpcnN0UG9pbnQueSA9PT0gbGFzdFBvaW50LnkpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gbmVlZCB0byBjbG9uZSBhcyB3ZSBhcmUgZ29pbmcgdG8gc2xpZ2h0bHkgbW9kaWZ5IHRoZSBzaGFwZS4uXHJcbiAgICAgICAgcG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XHJcblxyXG4gICAgICAgIHBvaW50cy5wb3AoKTtcclxuICAgICAgICBwb2ludHMucG9wKCk7XHJcblxyXG4gICAgICAgIGxhc3RQb2ludCA9IG5ldyBtYXRoLlBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xyXG5cclxuICAgICAgICB2YXIgbWlkUG9pbnRYID0gbGFzdFBvaW50LnggKyAoZmlyc3RQb2ludC54IC0gbGFzdFBvaW50LngpICowLjU7XHJcbiAgICAgICAgdmFyIG1pZFBvaW50WSA9IGxhc3RQb2ludC55ICsgKGZpcnN0UG9pbnQueSAtIGxhc3RQb2ludC55KSAqMC41O1xyXG5cclxuICAgICAgICBwb2ludHMudW5zaGlmdChtaWRQb2ludFgsIG1pZFBvaW50WSk7XHJcbiAgICAgICAgcG9pbnRzLnB1c2gobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XHJcbiAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xyXG4gICAgdmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xyXG4gICAgdmFyIGluZGV4Q291bnQgPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgdmFyIGluZGV4U3RhcnQgPSB2ZXJ0cy5sZW5ndGgvNjtcclxuXHJcbiAgICAvLyBEUkFXIHRoZSBMaW5lXHJcbiAgICB2YXIgd2lkdGggPSBncmFwaGljc0RhdGEubGluZVdpZHRoIC8gMjtcclxuXHJcbiAgICAvLyBzb3J0IGNvbG9yXHJcbiAgICB2YXIgY29sb3IgPSB1dGlscy5oZXgycmdiKGdyYXBoaWNzRGF0YS5saW5lQ29sb3IpO1xyXG4gICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmxpbmVBbHBoYTtcclxuICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcclxuICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcclxuICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcclxuXHJcbiAgICB2YXIgcHgsIHB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5O1xyXG4gICAgdmFyIHBlcnB4LCBwZXJweSwgcGVycDJ4LCBwZXJwMnksIHBlcnAzeCwgcGVycDN5O1xyXG4gICAgdmFyIGExLCBiMSwgYzEsIGEyLCBiMiwgYzI7XHJcbiAgICB2YXIgZGVub20sIHBkaXN0LCBkaXN0O1xyXG5cclxuICAgIHAxeCA9IHBvaW50c1swXTtcclxuICAgIHAxeSA9IHBvaW50c1sxXTtcclxuXHJcbiAgICBwMnggPSBwb2ludHNbMl07XHJcbiAgICBwMnkgPSBwb2ludHNbM107XHJcblxyXG4gICAgcGVycHggPSAtKHAxeSAtIHAyeSk7XHJcbiAgICBwZXJweSA9ICBwMXggLSBwMng7XHJcblxyXG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJweCpwZXJweCArIHBlcnB5KnBlcnB5KTtcclxuXHJcbiAgICBwZXJweCAvPSBkaXN0O1xyXG4gICAgcGVycHkgLz0gZGlzdDtcclxuICAgIHBlcnB4ICo9IHdpZHRoO1xyXG4gICAgcGVycHkgKj0gd2lkdGg7XHJcblxyXG4gICAgLy8gc3RhcnRcclxuICAgIHZlcnRzLnB1c2gocDF4IC0gcGVycHggLCBwMXkgLSBwZXJweSxcclxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcclxuXHJcbiAgICB2ZXJ0cy5wdXNoKHAxeCArIHBlcnB4ICwgcDF5ICsgcGVycHksXHJcbiAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYSk7XHJcblxyXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aC0xOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgcDF4ID0gcG9pbnRzWyhpLTEpKjJdO1xyXG4gICAgICAgIHAxeSA9IHBvaW50c1soaS0xKSoyICsgMV07XHJcblxyXG4gICAgICAgIHAyeCA9IHBvaW50c1soaSkqMl07XHJcbiAgICAgICAgcDJ5ID0gcG9pbnRzWyhpKSoyICsgMV07XHJcblxyXG4gICAgICAgIHAzeCA9IHBvaW50c1soaSsxKSoyXTtcclxuICAgICAgICBwM3kgPSBwb2ludHNbKGkrMSkqMiArIDFdO1xyXG5cclxuICAgICAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcclxuICAgICAgICBwZXJweSA9IHAxeCAtIHAyeDtcclxuXHJcbiAgICAgICAgZGlzdCA9IE1hdGguc3FydChwZXJweCpwZXJweCArIHBlcnB5KnBlcnB5KTtcclxuICAgICAgICBwZXJweCAvPSBkaXN0O1xyXG4gICAgICAgIHBlcnB5IC89IGRpc3Q7XHJcbiAgICAgICAgcGVycHggKj0gd2lkdGg7XHJcbiAgICAgICAgcGVycHkgKj0gd2lkdGg7XHJcblxyXG4gICAgICAgIHBlcnAyeCA9IC0ocDJ5IC0gcDN5KTtcclxuICAgICAgICBwZXJwMnkgPSBwMnggLSBwM3g7XHJcblxyXG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycDJ4KnBlcnAyeCArIHBlcnAyeSpwZXJwMnkpO1xyXG4gICAgICAgIHBlcnAyeCAvPSBkaXN0O1xyXG4gICAgICAgIHBlcnAyeSAvPSBkaXN0O1xyXG4gICAgICAgIHBlcnAyeCAqPSB3aWR0aDtcclxuICAgICAgICBwZXJwMnkgKj0gd2lkdGg7XHJcblxyXG4gICAgICAgIGExID0gKC1wZXJweSArIHAxeSkgLSAoLXBlcnB5ICsgcDJ5KTtcclxuICAgICAgICBiMSA9ICgtcGVycHggKyBwMngpIC0gKC1wZXJweCArIHAxeCk7XHJcbiAgICAgICAgYzEgPSAoLXBlcnB4ICsgcDF4KSAqICgtcGVycHkgKyBwMnkpIC0gKC1wZXJweCArIHAyeCkgKiAoLXBlcnB5ICsgcDF5KTtcclxuICAgICAgICBhMiA9ICgtcGVycDJ5ICsgcDN5KSAtICgtcGVycDJ5ICsgcDJ5KTtcclxuICAgICAgICBiMiA9ICgtcGVycDJ4ICsgcDJ4KSAtICgtcGVycDJ4ICsgcDN4KTtcclxuICAgICAgICBjMiA9ICgtcGVycDJ4ICsgcDN4KSAqICgtcGVycDJ5ICsgcDJ5KSAtICgtcGVycDJ4ICsgcDJ4KSAqICgtcGVycDJ5ICsgcDN5KTtcclxuXHJcbiAgICAgICAgZGVub20gPSBhMSpiMiAtIGEyKmIxO1xyXG5cclxuICAgICAgICBpZiAoTWF0aC5hYnMoZGVub20pIDwgMC4xIClcclxuICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICBkZW5vbSs9MTAuMTtcclxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSBwZXJweCAsIHAyeSAtIHBlcnB5LFxyXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xyXG5cclxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyBwZXJweCAsIHAyeSArIHBlcnB5LFxyXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xyXG5cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBweCA9IChiMSpjMiAtIGIyKmMxKS9kZW5vbTtcclxuICAgICAgICBweSA9IChhMipjMSAtIGExKmMyKS9kZW5vbTtcclxuXHJcblxyXG4gICAgICAgIHBkaXN0ID0gKHB4IC1wMngpICogKHB4IC1wMngpICsgKHB5IC1wMnkpICogKHB5IC1wMnkpO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKHBkaXN0ID4gMTQwICogMTQwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcGVycDN4ID0gcGVycHggLSBwZXJwMng7XHJcbiAgICAgICAgICAgIHBlcnAzeSA9IHBlcnB5IC0gcGVycDJ5O1xyXG5cclxuICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChwZXJwM3gqcGVycDN4ICsgcGVycDN5KnBlcnAzeSk7XHJcbiAgICAgICAgICAgIHBlcnAzeCAvPSBkaXN0O1xyXG4gICAgICAgICAgICBwZXJwM3kgLz0gZGlzdDtcclxuICAgICAgICAgICAgcGVycDN4ICo9IHdpZHRoO1xyXG4gICAgICAgICAgICBwZXJwM3kgKj0gd2lkdGg7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnAzeCwgcDJ5IC1wZXJwM3kpO1xyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4ICsgcGVycDN4LCBwMnkgK3BlcnAzeSk7XHJcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xyXG5cclxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSBwZXJwM3gsIHAyeSAtcGVycDN5KTtcclxuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XHJcblxyXG4gICAgICAgICAgICBpbmRleENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHB4ICwgcHkpO1xyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gKHB4LXAyeCksIHAyeSAtIChweSAtIHAyeSkpO1xyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcDF4ID0gcG9pbnRzWyhsZW5ndGgtMikqMl07XHJcbiAgICBwMXkgPSBwb2ludHNbKGxlbmd0aC0yKSoyICsgMV07XHJcblxyXG4gICAgcDJ4ID0gcG9pbnRzWyhsZW5ndGgtMSkqMl07XHJcbiAgICBwMnkgPSBwb2ludHNbKGxlbmd0aC0xKSoyICsgMV07XHJcblxyXG4gICAgcGVycHggPSAtKHAxeSAtIHAyeSk7XHJcbiAgICBwZXJweSA9IHAxeCAtIHAyeDtcclxuXHJcbiAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4KnBlcnB4ICsgcGVycHkqcGVycHkpO1xyXG4gICAgcGVycHggLz0gZGlzdDtcclxuICAgIHBlcnB5IC89IGRpc3Q7XHJcbiAgICBwZXJweCAqPSB3aWR0aDtcclxuICAgIHBlcnB5ICo9IHdpZHRoO1xyXG5cclxuICAgIHZlcnRzLnB1c2gocDJ4IC0gcGVycHggLCBwMnkgLSBwZXJweSk7XHJcbiAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcclxuXHJcbiAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnB4ICwgcDJ5ICsgcGVycHkpO1xyXG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XHJcblxyXG4gICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleENvdW50OyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQrKyk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQtMSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQnVpbGRzIGEgY29tcGxleCBwb2x5Z29uIHRvIGRyYXdcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7UElYSS5HcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcclxuICogQHBhcmFtIHdlYkdMRGF0YSB7b2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXHJcbiAqL1xyXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZENvbXBsZXhQb2x5ID0gZnVuY3Rpb24gKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxyXG57XHJcbiAgICAvL1RPRE8gLSBubyBuZWVkIHRvIGNvcHkgdGhpcyBhcyBpdCBnZXRzIHR1cm5lZCBpbnRvIGEgRkxvYXQzMkFycmF5IGFueXdheXMuLlxyXG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMuc2xpY2UoKTtcclxuXHJcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDYpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldCBmaXJzdCBhbmQgbGFzdCBwb2ludC4uIGZpZ3VyZSBvdXQgdGhlIG1pZGRsZSFcclxuICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XHJcbiAgICB3ZWJHTERhdGEucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgd2ViR0xEYXRhLmFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcclxuICAgIHdlYkdMRGF0YS5jb2xvciA9IHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XHJcblxyXG4gICAgLy8gY2FsY2xhdGUgdGhlIGJvdW5kcy4uXHJcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XHJcblxyXG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcclxuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xyXG5cclxuICAgIHZhciB4LHk7XHJcblxyXG4gICAgLy8gZ2V0IHNpemUuLlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKz0yKVxyXG4gICAge1xyXG4gICAgICAgIHggPSBwb2ludHNbaV07XHJcbiAgICAgICAgeSA9IHBvaW50c1tpKzFdO1xyXG5cclxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcclxuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcclxuXHJcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XHJcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIGEgcXVhZCB0byB0aGUgZW5kIGNvcyB0aGVyZSBpcyBubyBwb2ludCBtYWtpbmcgYW5vdGhlciBidWZmZXIhXHJcbiAgICBwb2ludHMucHVzaChtaW5YLCBtaW5ZLFxyXG4gICAgICAgICAgICAgICAgbWF4WCwgbWluWSxcclxuICAgICAgICAgICAgICAgIG1heFgsIG1heFksXHJcbiAgICAgICAgICAgICAgICBtaW5YLCBtYXhZKTtcclxuXHJcbiAgICAvLyBwdXNoIGEgcXVhZCBvbnRvIHRoZSBlbmQuLlxyXG5cclxuICAgIC8vVE9ETyAtIHRoaXMgYWludCBuZWVkZWQhXHJcbiAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaW5kaWNlcy5wdXNoKCBpICk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIHBvbHlnb24gdG8gZHJhd1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xyXG4gKiBAcGFyYW0gd2ViR0xEYXRhIHtvYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcclxuICovXHJcbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkUG9seSA9IGZ1bmN0aW9uIChncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcclxue1xyXG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XHJcblxyXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCA2KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBnZXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQuLiBmaWd1cmUgb3V0IHRoZSBtaWRkbGUhXHJcbiAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xyXG4gICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcclxuXHJcbiAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XHJcblxyXG4gICAgLy8gc29ydCBjb2xvclxyXG4gICAgdmFyIGNvbG9yID0gdXRpbHMuaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcclxuICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XHJcbiAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XHJcbiAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XHJcbiAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XHJcblxyXG4gICAgdmFyIHRyaWFuZ2xlcyA9IGVhcmN1dChwb2ludHMsIG51bGwsIDIpO1xyXG5cclxuICAgIGlmICghdHJpYW5nbGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gNjtcclxuXHJcbiAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkrPTMpXHJcbiAgICB7XHJcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlcnRQb3MpO1xyXG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZXJ0UG9zKTtcclxuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2krMV0gKyB2ZXJ0UG9zKTtcclxuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2krMl0gK3ZlcnRQb3MpO1xyXG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsyXSArIHZlcnRQb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4iLCIvKipcclxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgV2ViR0wgc3BlY2lmaWMgcHJvcGVydGllcyB0byBiZSB1c2VkIGJ5IHRoZSBXZWJHTCByZW5kZXJlclxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gV2ViR0xHcmFwaGljc0RhdGEoZ2wpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5nbCA9IGdsO1xyXG5cclxuICAgIC8vVE9ETyBkb2VzIHRoaXMgbmVlZCB0byBiZSBzcGxpdCBiZWZvcmUgdXBsb2Rpbmc/P1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBjb2xvciBjb21wb25lbnRzIChyLGcsYilcclxuICAgICAqIEBtZW1iZXIge251bWJlcltdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbG9yID0gWzAsMCwwXTsgLy8gY29sb3Igc3BsaXQhXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBwb2ludHMgdG8gZHJhd1xyXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludFtdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRpY2VzID0gW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYWluIGJ1ZmZlclxyXG4gICAgICogQG1lbWJlciB7V2ViR0xCdWZmZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggYnVmZmVyXHJcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogdG9kbyBAYWx2aW5cclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb2RlID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbHBoYSBvZiB0aGUgZ3JhcGhpY3NcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5hbHBoYSA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgZ3JhcGhpY3MgaXMgZGlydHkgb3Igbm90XHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLmdsUG9pbnRzID0gbnVsbDtcclxuICAgIHRoaXMuZ2xJbmRpY2VzID0gbnVsbDtcclxufVxyXG5cclxuV2ViR0xHcmFwaGljc0RhdGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2ViR0xHcmFwaGljc0RhdGE7XHJcbm1vZHVsZS5leHBvcnRzID0gV2ViR0xHcmFwaGljc0RhdGE7XHJcblxyXG4vKipcclxuICogUmVzZXRzIHRoZSB2ZXJ0aWNlcyBhbmQgdGhlIGluZGljZXNcclxuICovXHJcbldlYkdMR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCaW5kcyB0aGUgYnVmZmVycyBhbmQgdXBsb2FkcyB0aGUgZGF0YVxyXG4gKi9cclxuV2ViR0xHcmFwaGljc0RhdGEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4vLyAgICB0aGlzLmxhc3RJbmRleCA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7XHJcbiAgICB0aGlzLmdsUG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBvaW50cyk7XHJcblxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmdsUG9pbnRzLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgdGhpcy5nbEluZGljZXMgPSBuZXcgVWludDE2QXJyYXkodGhpcy5pbmRpY2VzKTtcclxuXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuZ2xJbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG59O1xyXG5cclxuV2ViR0xHcmFwaGljc0RhdGEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmNvbG9yID0gbnVsbDtcclxuICAgIHRoaXMucG9pbnRzID0gbnVsbDtcclxuICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xyXG4gICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlcik7XHJcbiAgICBcclxuICAgIHRoaXMuZ2wgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcclxuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuZ2xQb2ludHMgPSBudWxsO1xyXG4gICAgdGhpcy5nbEluZGljZXMgPSBudWxsO1xyXG59O1xyXG4iLCIvKipcclxuICogQGZpbGUgICAgICAgIE1haW4gZXhwb3J0IG9mIHRoZSBQSVhJIGNvcmUgbGlicmFyeVxyXG4gKiBAYXV0aG9yICAgICAgTWF0IEdyb3ZlcyA8bWF0QGdvb2Rib3lkaWdpdGFsLmNvbT5cclxuICogQGNvcHlyaWdodCAgIDIwMTMtMjAxNSBHb29kQm95RGlnaXRhbFxyXG4gKiBAbGljZW5zZSAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS5qcy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVCBMaWNlbnNlfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIFBJWElcclxuICovXHJcbi8vIGV4cG9ydCBjb3JlIGFuZCBjb25zdC4gV2UgYXNzaWduIGNvcmUgdG8gY29uc3Qgc28gdGhhdCB0aGUgbm9uLXJlZmVyZW5jZSB0eXBlcyBpbiBjb25zdCByZW1haW4gaW4tdGFjdFxyXG52YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbihyZXF1aXJlKCcuL2NvbnN0JyksIHJlcXVpcmUoJy4vbWF0aCcpLCB7XHJcbiAgICAvLyB1dGlsc1xyXG4gICAgdXRpbHM6IHJlcXVpcmUoJy4vdXRpbHMnKSxcclxuICAgIHRpY2tlcjogcmVxdWlyZSgnLi90aWNrZXInKSxcclxuXHJcbiAgICAvLyBkaXNwbGF5XHJcbiAgICBEaXNwbGF5T2JqZWN0OiAgICAgICAgICByZXF1aXJlKCcuL2Rpc3BsYXkvRGlzcGxheU9iamVjdCcpLFxyXG4gICAgQ29udGFpbmVyOiAgICAgICAgICAgICAgcmVxdWlyZSgnLi9kaXNwbGF5L0NvbnRhaW5lcicpLFxyXG5cclxuICAgIC8vIHNwcml0ZXNcclxuICAgIFNwcml0ZTogICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc3ByaXRlcy9TcHJpdGUnKSxcclxuICAgIFBhcnRpY2xlQ29udGFpbmVyOiAgICAgIHJlcXVpcmUoJy4vcGFydGljbGVzL1BhcnRpY2xlQ29udGFpbmVyJyksXHJcbiAgICBTcHJpdGVSZW5kZXJlcjogICAgICAgICByZXF1aXJlKCcuL3Nwcml0ZXMvd2ViZ2wvU3ByaXRlUmVuZGVyZXInKSxcclxuICAgIFBhcnRpY2xlUmVuZGVyZXI6ICAgICAgIHJlcXVpcmUoJy4vcGFydGljbGVzL3dlYmdsL1BhcnRpY2xlUmVuZGVyZXInKSxcclxuXHJcbiAgICAvLyB0ZXh0XHJcbiAgICBUZXh0OiAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3RleHQvVGV4dCcpLFxyXG5cclxuICAgIC8vIHByaW1pdGl2ZXNcclxuICAgIEdyYXBoaWNzOiAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vZ3JhcGhpY3MvR3JhcGhpY3MnKSxcclxuICAgIEdyYXBoaWNzRGF0YTogICAgICAgICAgIHJlcXVpcmUoJy4vZ3JhcGhpY3MvR3JhcGhpY3NEYXRhJyksXHJcbiAgICBHcmFwaGljc1JlbmRlcmVyOiAgICAgICByZXF1aXJlKCcuL2dyYXBoaWNzL3dlYmdsL0dyYXBoaWNzUmVuZGVyZXInKSxcclxuXHJcbiAgICAvLyB0ZXh0dXJlc1xyXG4gICAgVGV4dHVyZTogICAgICAgICAgICAgICAgcmVxdWlyZSgnLi90ZXh0dXJlcy9UZXh0dXJlJyksXHJcbiAgICBCYXNlVGV4dHVyZTogICAgICAgICAgICByZXF1aXJlKCcuL3RleHR1cmVzL0Jhc2VUZXh0dXJlJyksXHJcbiAgICBSZW5kZXJUZXh0dXJlOiAgICAgICAgICByZXF1aXJlKCcuL3RleHR1cmVzL1JlbmRlclRleHR1cmUnKSxcclxuICAgIFZpZGVvQmFzZVRleHR1cmU6ICAgICAgIHJlcXVpcmUoJy4vdGV4dHVyZXMvVmlkZW9CYXNlVGV4dHVyZScpLFxyXG4gICAgVGV4dHVyZVV2czogICAgICAgICAgICAgcmVxdWlyZSgnLi90ZXh0dXJlcy9UZXh0dXJlVXZzJyksXHJcblxyXG4gICAgLy8gcmVuZGVyZXJzIC0gY2FudmFzXHJcbiAgICBDYW52YXNSZW5kZXJlcjogICAgICAgICByZXF1aXJlKCcuL3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXInKSxcclxuICAgIENhbnZhc0dyYXBoaWNzOiAgICAgICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNHcmFwaGljcycpLFxyXG4gICAgQ2FudmFzQnVmZmVyOiAgICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0J1ZmZlcicpLFxyXG5cclxuICAgIC8vIHJlbmRlcmVycyAtIHdlYmdsXHJcbiAgICBXZWJHTFJlbmRlcmVyOiAgICAgICAgICByZXF1aXJlKCcuL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyJyksXHJcbiAgICBXZWJHTE1hbmFnZXI6ICAgICAgICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL1dlYkdMTWFuYWdlcicpLFxyXG4gICAgU2hhZGVyTWFuYWdlcjogICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvU2hhZGVyTWFuYWdlcicpLFxyXG4gICAgU2hhZGVyOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvc2hhZGVycy9TaGFkZXInKSxcclxuICAgIE9iamVjdFJlbmRlcmVyOiAgICAgICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL3V0aWxzL09iamVjdFJlbmRlcmVyJyksXHJcbiAgICBSZW5kZXJUYXJnZXQ6ICAgICAgICAgICByZXF1aXJlKCcuL3JlbmRlcmVycy93ZWJnbC91dGlscy9SZW5kZXJUYXJnZXQnKSxcclxuXHJcbiAgICAvLyBmaWx0ZXJzIC0gd2ViZ2xcclxuICAgIEFic3RyYWN0RmlsdGVyOiAgICAgICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvQWJzdHJhY3RGaWx0ZXInKSxcclxuICAgIEZYQUFGaWx0ZXI6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvRlhBQUZpbHRlcicpLFxyXG4gICAgU3ByaXRlTWFza0ZpbHRlcjogICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvZmlsdGVycy9TcHJpdGVNYXNrRmlsdGVyJyksXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGhlbHBlciBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHdoaWNoIHJlbmRlcmVyIHlvdSBzaG91bGQgYmUgdXNpbmcuXHJcbiAgICAgKiBXZWJHTCBpcyB0aGUgcHJlZmVycmVkIHJlbmRlcmVyIGFzIGl0IGlzIGEgbG90IGZhc3Rlci4gSWYgd2ViR0wgaXMgbm90IHN1cHBvcnRlZCBieVxyXG4gICAgICogdGhlIGJyb3dzZXIgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgY2FudmFzIHJlbmRlcmVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBJWElcclxuICAgICAqIEBwYXJhbSB3aWR0aD04MDAge251bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSByZW5kZXJlcnMgdmlld1xyXG4gICAgICogQHBhcmFtIGhlaWdodD02MDAge251bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyZXJzIHZpZXdcclxuICAgICAqIEBwYXJhbSBbb3B0aW9uc10ge29iamVjdH0gVGhlIG9wdGlvbmFsIHJlbmRlcmVyIHBhcmFtZXRlcnNcclxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy52aWV3XSB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcclxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy50cmFuc3BhcmVudD1mYWxzZV0ge2Jvb2xlYW59IElmIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudCwgZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHBhcmFtIFtvcHRpb25zLmFudGlhbGlhcz1mYWxzZV0ge2Jvb2xlYW59IHNldHMgYW50aWFsaWFzIChvbmx5IGFwcGxpY2FibGUgaW4gY2hyb21lIGF0IHRoZSBtb21lbnQpXHJcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyPWZhbHNlXSB7Ym9vbGVhbn0gZW5hYmxlcyBkcmF3aW5nIGJ1ZmZlciBwcmVzZXJ2YXRpb24sIGVuYWJsZSB0aGlzIGlmIHlvdVxyXG4gICAgICogICAgICBuZWVkIHRvIGNhbGwgdG9EYXRhVXJsIG9uIHRoZSB3ZWJnbCBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMucmVzb2x1dGlvbj0xXSB7bnVtYmVyfSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyZXIsIHJldGluYSB3b3VsZCBiZSAyXHJcbiAgICAgKiBAcGFyYW0gW25vV2ViR0w9ZmFsc2VdIHtib29sZWFufSBwcmV2ZW50cyBzZWxlY3Rpb24gb2YgV2ViR0wgcmVuZGVyZXIsIGV2ZW4gaWYgc3VjaCBpcyBwcmVzZW50XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7V2ViR0xSZW5kZXJlcnxDYW52YXNSZW5kZXJlcn0gUmV0dXJucyBXZWJHTCByZW5kZXJlciBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBDYW52YXNSZW5kZXJlclxyXG4gICAgICovXHJcbiAgICBhdXRvRGV0ZWN0UmVuZGVyZXI6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zLCBub1dlYkdMKVxyXG4gICAge1xyXG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgODAwO1xyXG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCA2MDA7XHJcblxyXG4gICAgICAgIGlmICghbm9XZWJHTCAmJiBjb3JlLnV0aWxzLmlzV2ViR0xTdXBwb3J0ZWQoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29yZS5XZWJHTFJlbmRlcmVyKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlLkNhbnZhc1JlbmRlcmVyKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG59KTtcclxuIiwiLy8gQHRvZG8gLSBpZ25vcmUgdGhlIHRvbyBtYW55IHBhcmFtZXRlcnMgd2FybmluZyBmb3Igbm93XHJcbi8vIHNob3VsZCBlaXRoZXIgZml4IGl0IG9yIGNoYW5nZSB0aGUganNoaW50IGNvbmZpZ1xyXG4vLyBqc2hpbnQgLVcwNzJcclxuXHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcGl4aSBNYXRyaXggY2xhc3MgYXMgYW4gb2JqZWN0LCB3aGljaCBtYWtlcyBpdCBhIGxvdCBmYXN0ZXIsXHJcbiAqIGhlcmUgaXMgYSByZXByZXNlbnRhdGlvbiBvZiBpdCA6XHJcbiAqIHwgYSB8IGIgfCB0eHxcclxuICogfCBjIHwgZCB8IHR5fFxyXG4gKiB8IDAgfCAwIHwgMSB8XHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKi9cclxuZnVuY3Rpb24gTWF0cml4KClcclxue1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYSA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYiA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYyA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZCA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMudHggPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5ID0gMDtcclxufVxyXG5cclxuTWF0cml4LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hdHJpeDtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRyaXg7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIE1hdHJpeCBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGFycmF5LiBUaGUgRWxlbWVudCB0byBNYXRyaXggbWFwcGluZyBvcmRlciBpcyBhcyBmb2xsb3dzOlxyXG4gKlxyXG4gKiBhID0gYXJyYXlbMF1cclxuICogYiA9IGFycmF5WzFdXHJcbiAqIGMgPSBhcnJheVszXVxyXG4gKiBkID0gYXJyYXlbNF1cclxuICogdHggPSBhcnJheVsyXVxyXG4gKiB0eSA9IGFycmF5WzVdXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSB7bnVtYmVyW119IFRoZSBhcnJheSB0aGF0IHRoZSBtYXRyaXggd2lsbCBiZSBwb3B1bGF0ZWQgZnJvbS5cclxuICovXHJcbk1hdHJpeC5wcm90b3R5cGUuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGFycmF5KVxyXG57XHJcbiAgICB0aGlzLmEgPSBhcnJheVswXTtcclxuICAgIHRoaXMuYiA9IGFycmF5WzFdO1xyXG4gICAgdGhpcy5jID0gYXJyYXlbM107XHJcbiAgICB0aGlzLmQgPSBhcnJheVs0XTtcclxuICAgIHRoaXMudHggPSBhcnJheVsyXTtcclxuICAgIHRoaXMudHkgPSBhcnJheVs1XTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogc2V0cyB0aGUgbWF0cml4IHByb3BlcnRpZXNcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGFcclxuICogQHBhcmFtIHtudW1iZXJ9IGJcclxuICogQHBhcmFtIHtudW1iZXJ9IGNcclxuICogQHBhcmFtIHtudW1iZXJ9IGRcclxuICogQHBhcmFtIHtudW1iZXJ9IHR4XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICovXHJcbk1hdHJpeC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHR4LCB0eSlcclxue1xyXG4gICAgdGhpcy5hID0gYTtcclxuICAgIHRoaXMuYiA9IGI7XHJcbiAgICB0aGlzLmMgPSBjO1xyXG4gICAgdGhpcy5kID0gZDtcclxuICAgIHRoaXMudHggPSB0eDtcclxuICAgIHRoaXMudHkgPSB0eTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBhcnJheSBmcm9tIHRoZSBjdXJyZW50IE1hdHJpeCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB0cmFuc3Bvc2Uge2Jvb2xlYW59IFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcclxuICogQHBhcmFtIFtvdXRdIHtBcnJheX0gSWYgcHJvdmlkZWQgdGhlIGFycmF5IHdpbGwgYmUgYXNzaWduZWQgdG8gb3V0XHJcbiAqIEByZXR1cm4ge251bWJlcltdfSB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheSB3aGljaCBjb250YWlucyB0aGUgbWF0cml4XHJcbiAqL1xyXG5NYXRyaXgucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAodHJhbnNwb3NlLCBvdXQpXHJcbntcclxuICAgIGlmICghdGhpcy5hcnJheSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXJyYXkgPSBvdXQgfHwgdGhpcy5hcnJheTtcclxuXHJcbiAgICBpZiAodHJhbnNwb3NlKVxyXG4gICAge1xyXG4gICAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xyXG4gICAgICAgIGFycmF5WzFdID0gdGhpcy5iO1xyXG4gICAgICAgIGFycmF5WzJdID0gMDtcclxuICAgICAgICBhcnJheVszXSA9IHRoaXMuYztcclxuICAgICAgICBhcnJheVs0XSA9IHRoaXMuZDtcclxuICAgICAgICBhcnJheVs1XSA9IDA7XHJcbiAgICAgICAgYXJyYXlbNl0gPSB0aGlzLnR4O1xyXG4gICAgICAgIGFycmF5WzddID0gdGhpcy50eTtcclxuICAgICAgICBhcnJheVs4XSA9IDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XHJcbiAgICAgICAgYXJyYXlbMV0gPSB0aGlzLmM7XHJcbiAgICAgICAgYXJyYXlbMl0gPSB0aGlzLnR4O1xyXG4gICAgICAgIGFycmF5WzNdID0gdGhpcy5iO1xyXG4gICAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xyXG4gICAgICAgIGFycmF5WzVdID0gdGhpcy50eTtcclxuICAgICAgICBhcnJheVs2XSA9IDA7XHJcbiAgICAgICAgYXJyYXlbN10gPSAwO1xyXG4gICAgICAgIGFycmF5WzhdID0gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGEgbmV3IHBvc2l0aW9uIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXBwbGllZC5cclxuICogQ2FuIGJlIHVzZWQgdG8gZ28gZnJvbSBhIGNoaWxkJ3MgY29vcmRpbmF0ZSBzcGFjZSB0byB0aGUgd29ybGQgY29vcmRpbmF0ZSBzcGFjZS4gKGUuZy4gcmVuZGVyaW5nKVxyXG4gKlxyXG4gKiBAcGFyYW0gcG9zIHtQSVhJLlBvaW50fSBUaGUgb3JpZ2luXHJcbiAqIEBwYXJhbSBbbmV3UG9zXSB7UElYSS5Qb2ludH0gVGhlIHBvaW50IHRoYXQgdGhlIG5ldyBwb3NpdGlvbiBpcyBhc3NpZ25lZCB0byAoYWxsb3dlZCB0byBiZSBzYW1lIGFzIGlucHV0KVxyXG4gKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBUaGUgbmV3IHBvaW50LCB0cmFuc2Zvcm1lZCB0aHJvdWdoIHRoaXMgbWF0cml4XHJcbiAqL1xyXG5NYXRyaXgucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHBvcywgbmV3UG9zKVxyXG57XHJcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XHJcblxyXG4gICAgdmFyIHggPSBwb3MueDtcclxuICAgIHZhciB5ID0gcG9zLnk7XHJcblxyXG4gICAgbmV3UG9zLnggPSB0aGlzLmEgKiB4ICsgdGhpcy5jICogeSArIHRoaXMudHg7XHJcbiAgICBuZXdQb3MueSA9IHRoaXMuYiAqIHggKyB0aGlzLmQgKiB5ICsgdGhpcy50eTtcclxuXHJcbiAgICByZXR1cm4gbmV3UG9zO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBpbnZlcnNlIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXHJcbiAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UgdG8gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIGlucHV0KVxyXG4gKlxyXG4gKiBAcGFyYW0gcG9zIHtQSVhJLlBvaW50fSBUaGUgb3JpZ2luXHJcbiAqIEBwYXJhbSBbbmV3UG9zXSB7UElYSS5Qb2ludH0gVGhlIHBvaW50IHRoYXQgdGhlIG5ldyBwb3NpdGlvbiBpcyBhc3NpZ25lZCB0byAoYWxsb3dlZCB0byBiZSBzYW1lIGFzIGlucHV0KVxyXG4gKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBUaGUgbmV3IHBvaW50LCBpbnZlcnNlLXRyYW5zZm9ybWVkIHRocm91Z2ggdGhpcyBtYXRyaXhcclxuICovXHJcbk1hdHJpeC5wcm90b3R5cGUuYXBwbHlJbnZlcnNlID0gZnVuY3Rpb24gKHBvcywgbmV3UG9zKVxyXG57XHJcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XHJcblxyXG4gICAgdmFyIGlkID0gMSAvICh0aGlzLmEgKiB0aGlzLmQgKyB0aGlzLmMgKiAtdGhpcy5iKTtcclxuXHJcbiAgICB2YXIgeCA9IHBvcy54O1xyXG4gICAgdmFyIHkgPSBwb3MueTtcclxuXHJcbiAgICBuZXdQb3MueCA9IHRoaXMuZCAqIGlkICogeCArIC10aGlzLmMgKiBpZCAqIHkgKyAodGhpcy50eSAqIHRoaXMuYyAtIHRoaXMudHggKiB0aGlzLmQpICogaWQ7XHJcbiAgICBuZXdQb3MueSA9IHRoaXMuYSAqIGlkICogeSArIC10aGlzLmIgKiBpZCAqIHggKyAoLXRoaXMudHkgKiB0aGlzLmEgKyB0aGlzLnR4ICogdGhpcy5iKSAqIGlkO1xyXG5cclxuICAgIHJldHVybiBuZXdQb3M7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IG9uIHRoZSB4IGFuZCB5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geFxyXG4gKiBAcGFyYW0ge251bWJlcn0geVxyXG4gKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICovXHJcbk1hdHJpeC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKHgsIHkpXHJcbntcclxuICAgIHRoaXMudHggKz0geDtcclxuICAgIHRoaXMudHkgKz0geTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgc2NhbGUgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGFtb3VudCB0byBzY2FsZSBob3Jpem9udGFsbHlcclxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIGFtb3VudCB0byBzY2FsZSB2ZXJ0aWNhbGx5XHJcbiAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gKi9cclxuTWF0cml4LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uICh4LCB5KVxyXG57XHJcbiAgICB0aGlzLmEgKj0geDtcclxuICAgIHRoaXMuZCAqPSB5O1xyXG4gICAgdGhpcy5jICo9IHg7XHJcbiAgICB0aGlzLmIgKj0geTtcclxuICAgIHRoaXMudHggKj0geDtcclxuICAgIHRoaXMudHkgKj0geTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQXBwbGllcyBhIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxyXG4gKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICovXHJcbk1hdHJpeC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICB2YXIgY29zID0gTWF0aC5jb3MoIGFuZ2xlICk7XHJcbiAgICB2YXIgc2luID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG4gICAgdmFyIGExID0gdGhpcy5hO1xyXG4gICAgdmFyIGMxID0gdGhpcy5jO1xyXG4gICAgdmFyIHR4MSA9IHRoaXMudHg7XHJcblxyXG4gICAgdGhpcy5hID0gYTEgKiBjb3MtdGhpcy5iICogc2luO1xyXG4gICAgdGhpcy5iID0gYTEgKiBzaW4rdGhpcy5iICogY29zO1xyXG4gICAgdGhpcy5jID0gYzEgKiBjb3MtdGhpcy5kICogc2luO1xyXG4gICAgdGhpcy5kID0gYzEgKiBzaW4rdGhpcy5kICogY29zO1xyXG4gICAgdGhpcy50eCA9IHR4MSAqIGNvcyAtIHRoaXMudHkgKiBzaW47XHJcbiAgICB0aGlzLnR5ID0gdHgxICogc2luICsgdGhpcy50eSAqIGNvcztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBlbmRzIHRoZSBnaXZlbiBNYXRyaXggdG8gdGhpcyBNYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeFxyXG4gKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICovXHJcbk1hdHJpeC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKG1hdHJpeClcclxue1xyXG4gICAgdmFyIGExID0gdGhpcy5hO1xyXG4gICAgdmFyIGIxID0gdGhpcy5iO1xyXG4gICAgdmFyIGMxID0gdGhpcy5jO1xyXG4gICAgdmFyIGQxID0gdGhpcy5kO1xyXG5cclxuICAgIHRoaXMuYSAgPSBtYXRyaXguYSAqIGExICsgbWF0cml4LmIgKiBjMTtcclxuICAgIHRoaXMuYiAgPSBtYXRyaXguYSAqIGIxICsgbWF0cml4LmIgKiBkMTtcclxuICAgIHRoaXMuYyAgPSBtYXRyaXguYyAqIGExICsgbWF0cml4LmQgKiBjMTtcclxuICAgIHRoaXMuZCAgPSBtYXRyaXguYyAqIGIxICsgbWF0cml4LmQgKiBkMTtcclxuXHJcbiAgICB0aGlzLnR4ID0gbWF0cml4LnR4ICogYTEgKyBtYXRyaXgudHkgKiBjMSArIHRoaXMudHg7XHJcbiAgICB0aGlzLnR5ID0gbWF0cml4LnR4ICogYjEgKyBtYXRyaXgudHkgKiBkMSArIHRoaXMudHk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgbWF0cml4IGJhc2VkIG9uIGFsbCB0aGUgYXZhaWxhYmxlIHByb3BlcnRpZXNcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICogQHBhcmFtIHtudW1iZXJ9IHBpdm90WFxyXG4gKiBAcGFyYW0ge251bWJlcn0gcGl2b3RZXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVhcclxuICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHNrZXdYXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBza2V3WVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICovXHJcbk1hdHJpeC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKHgsIHksIHBpdm90WCwgcGl2b3RZLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSlcclxue1xyXG4gICAgdmFyIGEsIGIsIGMsIGQsIHNyLCBjciwgY3ksIHN5LCBuc3gsIGN4O1xyXG5cclxuICAgIHNyICA9IE1hdGguc2luKHJvdGF0aW9uKTtcclxuICAgIGNyICA9IE1hdGguY29zKHJvdGF0aW9uKTtcclxuICAgIGN5ICA9IE1hdGguY29zKHNrZXdZKTtcclxuICAgIHN5ICA9IE1hdGguc2luKHNrZXdZKTtcclxuICAgIG5zeCA9IC1NYXRoLnNpbihza2V3WCk7XHJcbiAgICBjeCAgPSAgTWF0aC5jb3Moc2tld1gpO1xyXG5cclxuICAgIGEgID0gIGNyICogc2NhbGVYO1xyXG4gICAgYiAgPSAgc3IgKiBzY2FsZVg7XHJcbiAgICBjICA9IC1zciAqIHNjYWxlWTtcclxuICAgIGQgID0gIGNyICogc2NhbGVZO1xyXG5cclxuICAgIHRoaXMuYSAgPSBjeSAqIGEgKyBzeSAqIGM7XHJcbiAgICB0aGlzLmIgID0gY3kgKiBiICsgc3kgKiBkO1xyXG4gICAgdGhpcy5jICA9IG5zeCAqIGEgKyBjeCAqIGM7XHJcbiAgICB0aGlzLmQgID0gbnN4ICogYiArIGN4ICogZDtcclxuXHJcbiAgICB0aGlzLnR4ID0geCArICggcGl2b3RYICogYSArIHBpdm90WSAqIGMgKTtcclxuICAgIHRoaXMudHkgPSB5ICsgKCBwaXZvdFggKiBiICsgcGl2b3RZICogZCApO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByZXBlbmRzIHRoZSBnaXZlbiBNYXRyaXggdG8gdGhpcyBNYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeFxyXG4gKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICovXHJcbk1hdHJpeC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKG1hdHJpeClcclxue1xyXG4gICAgdmFyIHR4MSA9IHRoaXMudHg7XHJcblxyXG4gICAgaWYgKG1hdHJpeC5hICE9PSAxIHx8IG1hdHJpeC5iICE9PSAwIHx8IG1hdHJpeC5jICE9PSAwIHx8IG1hdHJpeC5kICE9PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhMSA9IHRoaXMuYTtcclxuICAgICAgICB2YXIgYzEgPSB0aGlzLmM7XHJcbiAgICAgICAgdGhpcy5hICA9IGExKm1hdHJpeC5hK3RoaXMuYiptYXRyaXguYztcclxuICAgICAgICB0aGlzLmIgID0gYTEqbWF0cml4LmIrdGhpcy5iKm1hdHJpeC5kO1xyXG4gICAgICAgIHRoaXMuYyAgPSBjMSptYXRyaXguYSt0aGlzLmQqbWF0cml4LmM7XHJcbiAgICAgICAgdGhpcy5kICA9IGMxKm1hdHJpeC5iK3RoaXMuZCptYXRyaXguZDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnR4ID0gdHgxKm1hdHJpeC5hK3RoaXMudHkqbWF0cml4LmMrbWF0cml4LnR4O1xyXG4gICAgdGhpcy50eSA9IHR4MSptYXRyaXguYit0aGlzLnR5Km1hdHJpeC5kK21hdHJpeC50eTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnZlcnRzIHRoaXMgbWF0cml4XHJcbiAqXHJcbiAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gKi9cclxuTWF0cml4LnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpXHJcbntcclxuICAgIHZhciBhMSA9IHRoaXMuYTtcclxuICAgIHZhciBiMSA9IHRoaXMuYjtcclxuICAgIHZhciBjMSA9IHRoaXMuYztcclxuICAgIHZhciBkMSA9IHRoaXMuZDtcclxuICAgIHZhciB0eDEgPSB0aGlzLnR4O1xyXG4gICAgdmFyIG4gPSBhMSpkMS1iMSpjMTtcclxuXHJcbiAgICB0aGlzLmEgPSBkMS9uO1xyXG4gICAgdGhpcy5iID0gLWIxL247XHJcbiAgICB0aGlzLmMgPSAtYzEvbjtcclxuICAgIHRoaXMuZCA9IGExL247XHJcbiAgICB0aGlzLnR4ID0gKGMxKnRoaXMudHktZDEqdHgxKS9uO1xyXG4gICAgdGhpcy50eSA9IC0oYTEqdGhpcy50eS1iMSp0eDEpL247XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlc2V0cyB0aGlzIE1hdGl4IHRvIGFuIGlkZW50aXR5IChkZWZhdWx0KSBtYXRyaXguXHJcbiAqXHJcbiAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gKi9cclxuTWF0cml4LnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuYSA9IDE7XHJcbiAgICB0aGlzLmIgPSAwO1xyXG4gICAgdGhpcy5jID0gMDtcclxuICAgIHRoaXMuZCA9IDE7XHJcbiAgICB0aGlzLnR4ID0gMDtcclxuICAgIHRoaXMudHkgPSAwO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgTWF0cml4IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cclxuICpcclxuICogQHJldHVybiB7UElYSS5NYXRyaXh9IEEgY29weSBvZiB0aGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gKi9cclxuTWF0cml4LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KCk7XHJcbiAgICBtYXRyaXguYSA9IHRoaXMuYTtcclxuICAgIG1hdHJpeC5iID0gdGhpcy5iO1xyXG4gICAgbWF0cml4LmMgPSB0aGlzLmM7XHJcbiAgICBtYXRyaXguZCA9IHRoaXMuZDtcclxuICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XHJcbiAgICBtYXRyaXgudHkgPSB0aGlzLnR5O1xyXG5cclxuICAgIHJldHVybiBtYXRyaXg7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBtYXRyaXggdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG9uZXMgaW4gdGhpcyBtYXRyaXhcclxuICpcclxuICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoZSBtYXRyaXggZ2l2ZW4gaW4gcGFyYW1ldGVyIHdpdGggaXRzIHZhbHVlcyB1cGRhdGVkLlxyXG4gKi9cclxuTWF0cml4LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKG1hdHJpeClcclxue1xyXG4gICAgbWF0cml4LmEgPSB0aGlzLmE7XHJcbiAgICBtYXRyaXguYiA9IHRoaXMuYjtcclxuICAgIG1hdHJpeC5jID0gdGhpcy5jO1xyXG4gICAgbWF0cml4LmQgPSB0aGlzLmQ7XHJcbiAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xyXG4gICAgbWF0cml4LnR5ID0gdGhpcy50eTtcclxuXHJcbiAgICByZXR1cm4gbWF0cml4O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgZGVmYXVsdCAoaWRlbnRpdHkpIG1hdHJpeFxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBjb25zdFxyXG4gKi9cclxuTWF0cml4LklERU5USVRZID0gbmV3IE1hdHJpeCgpO1xyXG5cclxuLyoqXHJcbiAqIEEgdGVtcCBtYXRyaXhcclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RcclxuICovXHJcbk1hdHJpeC5URU1QX01BVFJJWCA9IG5ldyBNYXRyaXgoKTtcclxuIiwiLyoqXHJcbiAqIFRoZSBQb2ludCBvYmplY3QgcmVwcmVzZW50cyBhIGxvY2F0aW9uIGluIGEgdHdvLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGUgc3lzdGVtLCB3aGVyZSB4IHJlcHJlc2VudHNcclxuICogdGhlIGhvcml6b250YWwgYXhpcyBhbmQgeSByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBheGlzLlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIFt4PTBdIHtudW1iZXJ9IHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXHJcbiAqIEBwYXJhbSBbeT0wXSB7bnVtYmVyfSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xyXG4gKi9cclxuZnVuY3Rpb24gUG9pbnQoeCwgeSlcclxue1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMueCA9IHggfHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG4gICAgdGhpcy55ID0geSB8fCAwO1xyXG59XHJcblxyXG5Qb2ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludDtcclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2ludFxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBhIGNvcHkgb2YgdGhlIHBvaW50XHJcbiAqL1xyXG5Qb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3BpZXMgeCBhbmQgeSBmcm9tIHRoZSBnaXZlbiBwb2ludFxyXG4gKlxyXG4gKiBAcGFyYW0gcCB7UElYSS5Qb2ludH1cclxuICovXHJcblBvaW50LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHApIHtcclxuICAgIHRoaXMuc2V0KHAueCwgcC55KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGVxdWFsIHRvIHRoaXMgcG9pbnRcclxuICpcclxuICogQHBhcmFtIHAge1BJWEkuUG9pbnR9XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuUG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChwKSB7XHJcbiAgICByZXR1cm4gKHAueCA9PT0gdGhpcy54KSAmJiAocC55ID09PSB0aGlzLnkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IHggYW5kIHkgcG9zaXRpb24uXHJcbiAqIElmIHkgaXMgb21pdHRlZCwgYm90aCB4IGFuZCB5IHdpbGwgYmUgc2V0IHRvIHguXHJcbiAqXHJcbiAqIEBwYXJhbSBbeD0wXSB7bnVtYmVyfSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xyXG4gKiBAcGFyYW0gW3k9MF0ge251bWJlcn0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcclxuICovXHJcblBvaW50LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoeCwgeSlcclxue1xyXG4gICAgdGhpcy54ID0geCB8fCAwO1xyXG4gICAgdGhpcy55ID0geSB8fCAoICh5ICE9PSAwKSA/IHRoaXMueCA6IDAgKSA7XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBNYXRoIGNsYXNzZXMgYW5kIHV0aWxpdGllcyBtaXhlZCBpbnRvIFBJWEkgbmFtZXNwYWNlLlxyXG4gKlxyXG4gKiBAbGVuZHMgUElYSVxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAvLyBUaGVzZSB3aWxsIGJlIG1peGVkIHRvIGJlIG1hZGUgcHVibGljbHkgYXZhaWxhYmxlLFxyXG4gICAgLy8gd2hpbGUgdGhpcyBtb2R1bGUgaXMgdXNlZCBpbnRlcm5hbGx5IGluIGNvcmVcclxuICAgIC8vIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgY3V0IGRvd24gb25cclxuICAgIC8vIGludGVybmFsIG1vZHVsZSByZXF1aXJlcy5cclxuXHJcbiAgICBQb2ludDogICAgICByZXF1aXJlKCcuL1BvaW50JyksXHJcbiAgICBNYXRyaXg6ICAgICByZXF1aXJlKCcuL01hdHJpeCcpLFxyXG5cclxuICAgIENpcmNsZTogICAgIHJlcXVpcmUoJy4vc2hhcGVzL0NpcmNsZScpLFxyXG4gICAgRWxsaXBzZTogICAgcmVxdWlyZSgnLi9zaGFwZXMvRWxsaXBzZScpLFxyXG4gICAgUG9seWdvbjogICAgcmVxdWlyZSgnLi9zaGFwZXMvUG9seWdvbicpLFxyXG4gICAgUmVjdGFuZ2xlOiAgcmVxdWlyZSgnLi9zaGFwZXMvUmVjdGFuZ2xlJyksXHJcbiAgICBSb3VuZGVkUmVjdGFuZ2xlOiByZXF1aXJlKCcuL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlJylcclxufTtcclxuIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyksXHJcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XHJcblxyXG4vKipcclxuICogVGhlIENpcmNsZSBvYmplY3QgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhIGhpdCBhcmVhIGZvciBkaXNwbGF5T2JqZWN0c1xyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXHJcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxyXG4gKiBAcGFyYW0gcmFkaXVzIHtudW1iZXJ9IFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxyXG4gKi9cclxuZnVuY3Rpb24gQ2lyY2xlKHgsIHksIHJhZGl1cylcclxue1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMueCA9IHggfHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG4gICAgdGhpcy55ID0geSB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50eXBlID0gQ09OU1QuU0hBUEVTLkNJUkM7XHJcbn1cclxuXHJcbkNpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGU7XHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIENpcmNsZSBpbnN0YW5jZVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQSVhJLkNpcmNsZX0gYSBjb3B5IG9mIHRoZSBDaXJjbGVcclxuICovXHJcbkNpcmNsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgY2lyY2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcclxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIENpcmNsZVxyXG4gKi9cclxuQ2lyY2xlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5KVxyXG57XHJcbiAgICBpZiAodGhpcy5yYWRpdXMgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGR4ID0gKHRoaXMueCAtIHgpLFxyXG4gICAgICAgIGR5ID0gKHRoaXMueSAtIHkpLFxyXG4gICAgICAgIHIyID0gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcclxuXHJcbiAgICBkeCAqPSBkeDtcclxuICAgIGR5ICo9IGR5O1xyXG5cclxuICAgIHJldHVybiAoZHggKyBkeSA8PSByMik7XHJcbn07XHJcblxyXG4vKipcclxuKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgY2lyY2xlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxyXG4qXHJcbiogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxyXG4qL1xyXG5DaXJjbGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMucmFkaXVzLCB0aGlzLnkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xyXG59O1xyXG4iLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKSxcclxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgRWxsaXBzZSBvYmplY3QgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhIGhpdCBhcmVhIGZvciBkaXNwbGF5T2JqZWN0c1xyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXHJcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxyXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gVGhlIGhhbGYgd2lkdGggb2YgdGhpcyBlbGxpcHNlXHJcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gVGhlIGhhbGYgaGVpZ2h0IG9mIHRoaXMgZWxsaXBzZVxyXG4gKi9cclxuZnVuY3Rpb24gRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLnkgPSB5IHx8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50eXBlID0gQ09OU1QuU0hBUEVTLkVMSVA7XHJcbn1cclxuXHJcbkVsbGlwc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWxsaXBzZTtcclxubW9kdWxlLmV4cG9ydHMgPSBFbGxpcHNlO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIEVsbGlwc2UgaW5zdGFuY2VcclxuICpcclxuICogQHJldHVybiB7UElYSS5FbGxpcHNlfSBhIGNvcHkgb2YgdGhlIGVsbGlwc2VcclxuICovXHJcbkVsbGlwc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBlbGxpcHNlXHJcbiAqXHJcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcclxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRzIGFyZSB3aXRoaW4gdGhpcyBlbGxpcHNlXHJcbiAqL1xyXG5FbGxpcHNlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5KVxyXG57XHJcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vbm9ybWFsaXplIHRoZSBjb29yZHMgdG8gYW4gZWxsaXBzZSB3aXRoIGNlbnRlciAwLDBcclxuICAgIHZhciBub3JteCA9ICgoeCAtIHRoaXMueCkgLyB0aGlzLndpZHRoKSxcclxuICAgICAgICBub3JteSA9ICgoeSAtIHRoaXMueSkgLyB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgbm9ybXggKj0gbm9ybXg7XHJcbiAgICBub3JteSAqPSBub3JteTtcclxuXHJcbiAgICByZXR1cm4gKG5vcm14ICsgbm9ybXkgPD0gMSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGVsbGlwc2UgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XHJcbiAqXHJcbiAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcclxuICovXHJcbkVsbGlwc2UucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMud2lkdGgsIHRoaXMueSAtIHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbn07XHJcbiIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL1BvaW50JyksXHJcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqIEBwYXJhbSBwb2ludHMge1BJWEkuUG9pbnRbXXxudW1iZXJbXXwuLi5QSVhJLlBvaW50fC4uLm51bWJlcn0gVGhpcyBjYW4gYmUgYW4gYXJyYXkgb2YgUG9pbnRzIHRoYXQgZm9ybSB0aGUgcG9seWdvbixcclxuICogICAgICBhIGZsYXQgYXJyYXkgb2YgbnVtYmVycyB0aGF0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgW3gseSwgeCx5LCAuLi5dLCBvciB0aGUgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmVcclxuICogICAgICBhbGwgdGhlIHBvaW50cyBvZiB0aGUgcG9seWdvbiBlLmcuIGBuZXcgUElYSS5Qb2x5Z29uKG5ldyBQSVhJLlBvaW50KCksIG5ldyBQSVhJLlBvaW50KCksIC4uLilgLCBvciB0aGVcclxuICogICAgICBhcmd1bWVudHMgcGFzc2VkIGNhbiBiZSBmbGF0IHgseSB2YWx1ZXMgZS5nLiBgbmV3IFBvbHlnb24oeCx5LCB4LHksIHgseSwgLi4uKWAgd2hlcmUgYHhgIGFuZCBgeWAgYXJlXHJcbiAqICAgICAgTnVtYmVycy5cclxuICovXHJcbmZ1bmN0aW9uIFBvbHlnb24ocG9pbnRzXylcclxue1xyXG4gICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgYXNzaWdubWVudCBkZW9wdFxyXG4gICAgLy8gc2VlIHNlY3Rpb24gMy4xOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcclxuICAgIHZhciBwb2ludHMgPSBwb2ludHNfO1xyXG5cclxuICAgIC8vaWYgcG9pbnRzIGlzbid0IGFuIGFycmF5LCB1c2UgYXJndW1lbnRzIGFzIHRoZSBhcnJheVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgbGVhayBkZW9wdFxyXG4gICAgICAgIC8vIHNlZSBzZWN0aW9uIDMuMjogaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMtbWFuYWdpbmctYXJndW1lbnRzXHJcbiAgICAgICAgcG9pbnRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHBvaW50cy5sZW5ndGg7ICsrYSkge1xyXG4gICAgICAgICAgICBwb2ludHNbYV0gPSBhcmd1bWVudHNbYV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHRoaXMgaXMgYW4gYXJyYXkgb2YgcG9pbnRzLCBjb252ZXJ0IGl0IHRvIGEgZmxhdCBhcnJheSBvZiBudW1iZXJzXHJcbiAgICBpZiAocG9pbnRzWzBdIGluc3RhbmNlb2YgUG9pbnQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHAgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHAucHVzaChwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcG9pbnRzID0gcDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiB0aGUgcG9pbnRzIG9mIHRoaXMgcG9seWdvblxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcltdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZSA9IENPTlNULlNIQVBFUy5QT0xZO1xyXG59XHJcblxyXG5Qb2x5Z29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbHlnb247XHJcbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2x5Z29uXHJcbiAqXHJcbiAqIEByZXR1cm4ge1BJWEkuUG9seWdvbn0gYSBjb3B5IG9mIHRoZSBwb2x5Z29uXHJcbiAqL1xyXG5Qb2x5Z29uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiBuZXcgUG9seWdvbih0aGlzLnBvaW50cy5zbGljZSgpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb25cclxuICpcclxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvblxyXG4gKi9cclxuUG9seWdvbi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoeCwgeSlcclxue1xyXG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xyXG5cclxuICAgIC8vIHVzZSBzb21lIHJheWNhc3RpbmcgdG8gdGVzdCBoaXRzXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xyXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDI7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBqID0gaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4aSA9IHRoaXMucG9pbnRzW2kgKiAyXSwgeWkgPSB0aGlzLnBvaW50c1tpICogMiArIDFdLFxyXG4gICAgICAgICAgICB4aiA9IHRoaXMucG9pbnRzW2ogKiAyXSwgeWogPSB0aGlzLnBvaW50c1tqICogMiArIDFdLFxyXG4gICAgICAgICAgICBpbnRlcnNlY3QgPSAoKHlpID4geSkgIT09ICh5aiA+IHkpKSAmJiAoeCA8ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGkpO1xyXG5cclxuICAgICAgICBpZiAoaW50ZXJzZWN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluc2lkZTtcclxufTtcclxuIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcclxuXHJcbi8qKlxyXG4gKiB0aGUgUmVjdGFuZ2xlIG9iamVjdCBpcyBhbiBhcmVhIGRlZmluZWQgYnkgaXRzIHBvc2l0aW9uLCBhcyBpbmRpY2F0ZWQgYnkgaXRzIHRvcC1sZWZ0IGNvcm5lciBwb2ludCAoeCwgeSkgYW5kIGJ5IGl0cyB3aWR0aCBhbmQgaXRzIGhlaWdodC5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcclxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gVGhlIG92ZXJhbGwgd2lkdGggb2YgdGhpcyByZWN0YW5nbGVcclxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBUaGUgb3ZlcmFsbCBoZWlnaHQgb2YgdGhpcyByZWN0YW5nbGVcclxuICovXHJcbmZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLnkgPSB5IHx8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50eXBlID0gQ09OU1QuU0hBUEVTLlJFQ1Q7XHJcbn1cclxuXHJcblJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWN0YW5nbGU7XHJcbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlO1xyXG5cclxuLyoqXHJcbiAqIEEgY29uc3RhbnQgZW1wdHkgcmVjdGFuZ2xlLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBjb25zdGFudFxyXG4gKi9cclxuUmVjdGFuZ2xlLkVNUFRZID0gbmV3IFJlY3RhbmdsZSgwLCAwLCAwLCAwKTtcclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUmVjdGFuZ2xlXHJcbiAqXHJcbiAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBhIGNvcHkgb2YgdGhlIHJlY3RhbmdsZVxyXG4gKi9cclxuUmVjdGFuZ2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcclxuICpcclxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgUmVjdGFuZ2xlXHJcbiAqL1xyXG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHkpXHJcbntcclxuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHggPj0gdGhpcy54ICYmIHggPCB0aGlzLnggKyB0aGlzLndpZHRoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG4iLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBSb3VuZGVkIFJlY3RhbmdsZSBvYmplY3QgaXMgYW4gYXJlYSB0aGF0IGhhcyBuaWNlIHJvdW5kZWQgY29ybmVycywgYXMgaW5kaWNhdGVkIGJ5IGl0cyB0b3AtbGVmdCBjb3JuZXIgcG9pbnQgKHgsIHkpIGFuZCBieSBpdHMgd2lkdGggYW5kIGl0cyBoZWlnaHQgYW5kIGl0cyByYWRpdXMuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcclxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXHJcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgb3ZlcmFsbCB3aWR0aCBvZiB0aGlzIHJvdW5kZWQgcmVjdGFuZ2xlXHJcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gVGhlIG92ZXJhbGwgaGVpZ2h0IG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcclxuICogQHBhcmFtIHJhZGl1cyB7bnVtYmVyfSBDb250cm9scyB0aGUgcmFkaXVzIG9mIHRoZSByb3VuZGVkIGNvcm5lcnNcclxuICovXHJcbmZ1bmN0aW9uIFJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKVxyXG57XHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLnkgPSB5IHx8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMjBcclxuICAgICAqL1xyXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgMjA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGUgPSBDT05TVC5TSEFQRVMuUlJFQztcclxufVxyXG5cclxuUm91bmRlZFJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3VuZGVkUmVjdGFuZ2xlO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kZWRSZWN0YW5nbGU7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUm91bmRlZCBSZWN0YW5nbGVcclxuICpcclxuICogQHJldHVybiB7UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBhIGNvcHkgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXHJcbiAqL1xyXG5Sb3VuZGVkUmVjdGFuZ2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcclxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXHJcbiAqL1xyXG5Sb3VuZGVkUmVjdGFuZ2xlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5KVxyXG57XHJcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG4iLCJ2YXIgQ29udGFpbmVyID0gcmVxdWlyZSgnLi4vZGlzcGxheS9Db250YWluZXInKSxcclxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgUGFydGljbGVDb250YWluZXIgY2xhc3MgaXMgYSByZWFsbHkgZmFzdCB2ZXJzaW9uIG9mIHRoZSBDb250YWluZXIgYnVpbHQgc29sZWx5IGZvciBzcGVlZCxcclxuICogc28gdXNlIHdoZW4geW91IG5lZWQgYSBsb3Qgb2Ygc3ByaXRlcyBvciBwYXJ0aWNsZXMuIFRoZSB0cmFkZW9mZiBvZiB0aGUgUGFydGljbGVDb250YWluZXIgaXMgdGhhdCBhZHZhbmNlZFxyXG4gKiBmdW5jdGlvbmFsaXR5IHdpbGwgbm90IHdvcmsuIFBhcnRpY2xlQ29udGFpbmVyIGltcGxlbWVudHMgb25seSB0aGUgYmFzaWMgb2JqZWN0IHRyYW5zZm9ybSAocG9zaXRpb24sIHNjYWxlLCByb3RhdGlvbikuXHJcbiAqIEFueSBvdGhlciBmdW5jdGlvbmFsaXR5IGxpa2UgdGludGluZywgbWFza2luZywgZXRjIHdpbGwgbm90IHdvcmsgb24gc3ByaXRlcyBpbiB0aGlzIGJhdGNoLlxyXG4gKlxyXG4gKiBJdCdzIGV4dHJlbWVseSBlYXN5IHRvIHVzZSA6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBjb250YWluZXIgPSBuZXcgUGFydGljbGVDb250YWluZXIoKTtcclxuICpcclxuICogZm9yICh2YXIgaSA9IDA7IGkgPCAxMDA7ICsraSlcclxuICoge1xyXG4gKiAgICAgdmFyIHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoXCJteUltYWdlLnBuZ1wiKTtcclxuICogICAgIGNvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbmQgaGVyZSB5b3UgaGF2ZSBhIGh1bmRyZWQgc3ByaXRlcyB0aGF0IHdpbGwgYmUgcmVuZGVyZXIgYXQgdGhlIHNwZWVkIG9mIGxpZ2h0LlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5Db250YWluZXJcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIFttYXhTaXplPTE1MDAwXSB7bnVtYmVyfSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcGFydGljbGVzIHRoYXQgY2FuIGJlIHJlbmRlcmVyIGJ5IHRoZSBjb250YWluZXIuXHJcbiAqIEBwYXJhbSBbcHJvcGVydGllc10ge29iamVjdH0gVGhlIHByb3BlcnRpZXMgb2YgY2hpbGRyZW4gdGhhdCBzaG91bGQgYmUgdXBsb2FkZWQgdG8gdGhlIGdwdSBhbmQgYXBwbGllZC5cclxuICogQHBhcmFtIFtwcm9wZXJ0aWVzLnNjYWxlPWZhbHNlXSB7Ym9vbGVhbn0gV2hlbiB0cnVlLCBzY2FsZSBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cclxuICogQHBhcmFtIFtwcm9wZXJ0aWVzLnBvc2l0aW9uPXRydWVdIHtib29sZWFufSBXaGVuIHRydWUsIHBvc2l0aW9uIGJlIHVwbG9hZGVkIGFuZCBhcHBsaWVkLlxyXG4gKiBAcGFyYW0gW3Byb3BlcnRpZXMucm90YXRpb249ZmFsc2VdIHtib29sZWFufSBXaGVuIHRydWUsIHJvdGF0aW9uIGJlIHVwbG9hZGVkIGFuZCBhcHBsaWVkLlxyXG4gKiBAcGFyYW0gW3Byb3BlcnRpZXMudXZzPWZhbHNlXSB7Ym9vbGVhbn0gV2hlbiB0cnVlLCB1dnMgYmUgdXBsb2FkZWQgYW5kIGFwcGxpZWQuXHJcbiAqIEBwYXJhbSBbcHJvcGVydGllcy5hbHBoYT1mYWxzZV0ge2Jvb2xlYW59IFdoZW4gdHJ1ZSwgYWxwaGEgYmUgdXBsb2FkZWQgYW5kIGFwcGxpZWQuXHJcbiAqIEBwYXJhbSBbYmF0Y2hTaXplPTE1MDAwXSB7bnVtYmVyfSBOdW1iZXIgb2YgcGFydGljbGVzIHBlciBiYXRjaC5cclxuICovXHJcbmZ1bmN0aW9uIFBhcnRpY2xlQ29udGFpbmVyKG1heFNpemUsIHByb3BlcnRpZXMsIGJhdGNoU2l6ZSlcclxue1xyXG4gICAgQ29udGFpbmVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgYmF0Y2hTaXplID0gYmF0Y2hTaXplIHx8IDE1MDAwOyAvL0NPTlNULlNQUklURV9CQVRDSF9TSVpFOyAvLyAyMDAwIGlzIGEgbmljZSBiYWxhbmNlIGJldHdlZW4gbW9iaWxlIC8gZGVza3RvcFxyXG4gICAgbWF4U2l6ZSA9IG1heFNpemUgfHwgMTUwMDA7XHJcblxyXG4gICAgLy8gTWFraW5nIHN1cmUgdGhlIGJhdGNoIHNpemUgaXMgdmFsaWRcclxuICAgIC8vIDY1NTM1IGlzIG1heCB2ZXJ0ZXggaW5kZXggaW4gdGhlIGluZGV4IGJ1ZmZlciAoc2VlIFBhcnRpY2xlUmVuZGVyZXIpXHJcbiAgICAvLyBzbyBtYXggbnVtYmVyIG9mIHBhcnRpY2xlcyBpcyA2NTUzNiAvIDQgPSAxNjM4NFxyXG4gICAgdmFyIG1heEJhdGNoU2l6ZSA9IDE2Mzg0O1xyXG4gICAgaWYgKGJhdGNoU2l6ZSA+IG1heEJhdGNoU2l6ZSkge1xyXG4gICAgICAgIGJhdGNoU2l6ZSA9IG1heEJhdGNoU2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYmF0Y2hTaXplID4gbWF4U2l6ZSkge1xyXG4gICAgICAgIGJhdGNoU2l6ZSA9IG1heFNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgcHJvcGVydGllcyB0byBiZSBkeW5hbWljICh0cnVlKSAvIHN0YXRpYyAoZmFsc2UpXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbltdfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fcHJvcGVydGllcyA9IFtmYWxzZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2JhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge1dlYkdMQnVmZmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9idWZmZXJUb1VwZGF0ZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIEFwcGx5IGEgdmFsdWUgb2YgYFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMYCB0byByZXNldCB0aGUgYmxlbmQgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxyXG4gICAgICogQHNlZSBQSVhJLkJMRU5EX01PREVTXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYmxlbmRNb2RlID0gQ09OU1QuQkxFTkRfTU9ERVMuTk9STUFMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBmb3IgY2FudmFzIHJlbmRlcmVyaW5nLiBJZiB0cnVlIHRoZW4gdGhlIGVsZW1lbnRzIHdpbGwgYmUgcG9zaXRpb25lZCBhdCB0aGUgbmVhcmVzdCBwaXhlbC4gVGhpcyBwcm92aWRlcyBhIG5pY2Ugc3BlZWQgYm9vc3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWU7XHJcbiAgICAgKi9cclxuICAgIHRoaXMucm91bmRQaXhlbHMgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcclxufVxyXG5cclxuUGFydGljbGVDb250YWluZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb250YWluZXIucHJvdG90eXBlKTtcclxuUGFydGljbGVDb250YWluZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGVDb250YWluZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGVDb250YWluZXI7XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgcHJpdmF0ZSBwcm9wZXJ0aWVzIGFycmF5IHRvIGR5bmFtaWMgLyBzdGF0aWMgYmFzZWQgb24gdGhlIHBhc3NlZCBwcm9wZXJ0aWVzIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0gcHJvcGVydGllcyB7b2JqZWN0fSBUaGUgcHJvcGVydGllcyB0byBiZSB1cGxvYWRlZFxyXG4gKi9cclxuUGFydGljbGVDb250YWluZXIucHJvdG90eXBlLnNldFByb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKVxyXG57XHJcbiAgICBpZiAoIHByb3BlcnRpZXMgKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc1swXSA9ICdzY2FsZScgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy5zY2FsZSA6IHRoaXMuX3Byb3BlcnRpZXNbMF07XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc1sxXSA9ICdwb3NpdGlvbicgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy5wb3NpdGlvbiA6IHRoaXMuX3Byb3BlcnRpZXNbMV07XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc1syXSA9ICdyb3RhdGlvbicgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy5yb3RhdGlvbiA6IHRoaXMuX3Byb3BlcnRpZXNbMl07XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc1szXSA9ICd1dnMnIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudXZzIDogdGhpcy5fcHJvcGVydGllc1szXTtcclxuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzWzRdID0gJ2FscGhhJyBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLmFscGhhIDogdGhpcy5fcHJvcGVydGllc1s0XTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcblBhcnRpY2xlQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKVxyXG57XHJcblxyXG4gICAgLy8gVE9ETyBkb24ndCBuZWVkIHRvIVxyXG4gICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAvLyAgUElYSS5Db250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVuZGVycyB0aGUgY29udGFpbmVyIHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHdlYmdsIHJlbmRlcmVyXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5QYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpXHJcbntcclxuICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5yZW5kZXJhYmxlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlciggcmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZSApO1xyXG4gICAgcmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZS5yZW5kZXIoIHRoaXMgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGZsYWcgdGhhdCBzdGF0aWMgZGF0YSBzaG91bGQgYmUgdXBkYXRlZCB0byB0cnVlXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5QYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUub25DaGlsZHJlbkNoYW5nZSA9IGZ1bmN0aW9uIChzbWFsbGVzdENoaWxkSW5kZXgpXHJcbntcclxuICAgIHZhciBidWZmZXJJbmRleCA9IE1hdGguZmxvb3Ioc21hbGxlc3RDaGlsZEluZGV4IC8gdGhpcy5fYmF0Y2hTaXplKTtcclxuICAgIGlmIChidWZmZXJJbmRleCA8IHRoaXMuX2J1ZmZlclRvVXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyVG9VcGRhdGUgPSBidWZmZXJJbmRleDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IFRoZSBjYW52YXMgcmVuZGVyZXJcclxuICogQHByaXZhdGVcclxuICovXHJcblBhcnRpY2xlQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiAocmVuZGVyZXIpXHJcbntcclxuICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5yZW5kZXJhYmxlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcclxuICAgIHZhciBpc1JvdGF0ZWQgPSB0cnVlO1xyXG5cclxuICAgIHZhciBwb3NpdGlvblggPSAwO1xyXG4gICAgdmFyIHBvc2l0aW9uWSA9IDA7XHJcblxyXG4gICAgdmFyIGZpbmFsV2lkdGggPSAwO1xyXG4gICAgdmFyIGZpbmFsSGVpZ2h0ID0gMDtcclxuXHJcbiAgICB2YXIgY29tcG9zaXRlT3BlcmF0aW9uID0gcmVuZGVyZXIuYmxlbmRNb2Rlc1t0aGlzLmJsZW5kTW9kZV07XHJcbiAgICBpZiAoY29tcG9zaXRlT3BlcmF0aW9uICE9PSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbilcclxuICAgIHtcclxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xyXG5cclxuICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSlcclxuICAgIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG5cclxuICAgICAgICBpZiAoIWNoaWxkLnZpc2libGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmcmFtZSA9IGNoaWxkLnRleHR1cmUuZnJhbWU7XHJcblxyXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGEgKiBjaGlsZC5hbHBoYTtcclxuXHJcbiAgICAgICAgaWYgKGNoaWxkLnJvdGF0aW9uICUgKE1hdGguUEkgKiAyKSA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGZhc3Rlc3QgIHdheSB0byBvcHRpbWlzZSEgLSBpZiByb3RhdGlvbiBpcyAwIHRoZW4gd2UgY2FuIGF2b2lkIGFueSBraW5kIG9mIHNldFRyYW5zZm9ybSBjYWxsXHJcbiAgICAgICAgICAgIGlmIChpc1JvdGF0ZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5hLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5iLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5jLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5kLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS50eCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udHlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaXNSb3RhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBvc2l0aW9uWCA9ICgoY2hpbGQuYW5jaG9yLngpICogKC1mcmFtZS53aWR0aCAqIGNoaWxkLnNjYWxlLngpICsgY2hpbGQucG9zaXRpb24ueCAgKyAwLjUpO1xyXG4gICAgICAgICAgICBwb3NpdGlvblkgPSAoKGNoaWxkLmFuY2hvci55KSAqICgtZnJhbWUuaGVpZ2h0ICogY2hpbGQuc2NhbGUueSkgKyBjaGlsZC5wb3NpdGlvbi55ICArIDAuNSk7XHJcblxyXG4gICAgICAgICAgICBmaW5hbFdpZHRoID0gZnJhbWUud2lkdGggKiBjaGlsZC5zY2FsZS54O1xyXG4gICAgICAgICAgICBmaW5hbEhlaWdodCA9IGZyYW1lLmhlaWdodCAqIGNoaWxkLnNjYWxlLnk7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIWlzUm90YXRlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaXNSb3RhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hpbGQuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoaWxkVHJhbnNmb3JtID0gY2hpbGQud29ybGRUcmFuc2Zvcm07XHJcblxyXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIucm91bmRQaXhlbHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmEsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0uYixcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZFRyYW5zZm9ybS5jLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0udHggfCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLnR5IHwgMFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmEsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0uYixcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZFRyYW5zZm9ybS5jLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0udHgsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0udHlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBvc2l0aW9uWCA9ICgoY2hpbGQuYW5jaG9yLngpICogKC1mcmFtZS53aWR0aCkgKyAwLjUpO1xyXG4gICAgICAgICAgICBwb3NpdGlvblkgPSAoKGNoaWxkLmFuY2hvci55KSAqICgtZnJhbWUuaGVpZ2h0KSArIDAuNSk7XHJcblxyXG4gICAgICAgICAgICBmaW5hbFdpZHRoID0gZnJhbWUud2lkdGg7XHJcbiAgICAgICAgICAgIGZpbmFsSGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgIGNoaWxkLnRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxyXG4gICAgICAgICAgICBmcmFtZS54LFxyXG4gICAgICAgICAgICBmcmFtZS55LFxyXG4gICAgICAgICAgICBmcmFtZS53aWR0aCxcclxuICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxyXG4gICAgICAgICAgICBwb3NpdGlvblgsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uWSxcclxuICAgICAgICAgICAgZmluYWxXaWR0aCxcclxuICAgICAgICAgICAgZmluYWxIZWlnaHRcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc3Ryb3lzIHRoZSBjb250YWluZXJcclxuICpcclxuICogQHBhcmFtIFtkZXN0cm95Q2hpbGRyZW49ZmFsc2VdIHtib29sZWFufSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGxcclxuICovXHJcblBhcnRpY2xlQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2J1ZmZlcnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlcnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1tpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBudWxsO1xyXG4gICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XHJcbn07XHJcbiIsIlxyXG4vKipcclxuICogQGF1dGhvciBNYXQgR3JvdmVzXHJcbiAqXHJcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXHJcbiAqIGZvciBjcmVhdGluZyB0aGUgb3JpZ2luYWwgcGl4aSB2ZXJzaW9uIVxyXG4gKiBBbHNvIGEgdGhhbmtzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9iY2hldmFsaWVyIGZvciB0d2Vha2luZyB0aGUgdGludCBhbmQgYWxwaGEgc28gdGhhdCB0aGV5IG5vdyBzaGFyZSA0IGJ5dGVzIG9uIHRoZSB2ZXJ0ZXggYnVmZmVyXHJcbiAqXHJcbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnkgTGliR0RYJ3MgUGFydGljbGVCdWZmZXI6XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvUGFydGljbGVCdWZmZXIuamF2YVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgcGFydGljbGUgYnVmZmVyIG1hbmFnZXMgdGhlIHN0YXRpYyBhbmQgZHluYW1pYyBidWZmZXJzIGZvciBhIHBhcnRpY2xlIGNvbnRhaW5lci5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqL1xyXG5mdW5jdGlvbiBQYXJ0aWNsZUJ1ZmZlcihnbCwgcHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIHNpemUpXHJcbntcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5nbCA9IGdsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2l6ZSBvZiBhIHNpbmdsZSB2ZXJ0ZXguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZlcnRTaXplID0gMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpemUgb2YgYSBzaW5nbGUgdmVydGV4IGluIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy52ZXJ0Qnl0ZVNpemUgPSB0aGlzLnZlcnRTaXplICogNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgcGFydGljbGVzIHRoZSBidWZmZXIgY2FuIGhvbGRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGxpc3Qgb2YgdGhlIHByb3BlcnRpZXMgdGhhdCBhcmUgZHluYW1pYy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3RbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHN0YXRpYy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3RbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XHJcblxyXG4gICAgICAgIGlmKGR5bmFtaWNQcm9wZXJ0eUZsYWdzW2ldKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XHJcbiAgICB0aGlzLnN0YXRpY0J1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLnN0YXRpY0RhdGEgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuZHluYW1pY1N0cmlkZSA9IDA7XHJcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5keW5hbWljRGF0YSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5pbml0QnVmZmVycygpO1xyXG5cclxufVxyXG5cclxuUGFydGljbGVCdWZmZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGVCdWZmZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGVCdWZmZXI7XHJcblxyXG4vKipcclxuICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5QYXJ0aWNsZUJ1ZmZlci5wcm90b3R5cGUuaW5pdEJ1ZmZlcnMgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgcHJvcGVydHk7XHJcblxyXG4gICAgdmFyIGR5bmFtaWNPZmZzZXQgPSAwO1xyXG4gICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XHJcblxyXG4gICAgICAgIHByb3BlcnR5Lm9mZnNldCA9IGR5bmFtaWNPZmZzZXQ7XHJcbiAgICAgICAgZHluYW1pY09mZnNldCArPSBwcm9wZXJ0eS5zaXplO1xyXG4gICAgICAgIHRoaXMuZHluYW1pY1N0cmlkZSArPSBwcm9wZXJ0eS5zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHluYW1pY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLnNpemUgKiB0aGlzLmR5bmFtaWNTdHJpZGUgKiA0KTtcclxuICAgIHRoaXMuZHluYW1pY0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmR5bmFtaWNCdWZmZXIpO1xyXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMuZHluYW1pY0RhdGEsIGdsLkRZTkFNSUNfRFJBVyk7XHJcblxyXG5cclxuICAgIC8vIHN0YXRpYyAvL1xyXG4gICAgdmFyIHN0YXRpY09mZnNldCA9IDA7XHJcbiAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3RhdGljUHJvcGVydGllcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcclxuXHJcbiAgICAgICAgcHJvcGVydHkub2Zmc2V0ID0gc3RhdGljT2Zmc2V0O1xyXG4gICAgICAgIHN0YXRpY09mZnNldCArPSBwcm9wZXJ0eS5zaXplO1xyXG4gICAgICAgIHRoaXMuc3RhdGljU3RyaWRlICs9IHByb3BlcnR5LnNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGF0aWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5zaXplICogdGhpcy5zdGF0aWNTdHJpZGUgKiA0KTtcclxuICAgIHRoaXMuc3RhdGljQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuc3RhdGljQnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnN0YXRpY0RhdGEsIGdsLkRZTkFNSUNfRFJBVyk7XHJcbn07XHJcblxyXG4vKipcclxuICogVXBsb2FkcyB0aGUgZHluYW1pYyBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKi9cclxuUGFydGljbGVCdWZmZXIucHJvdG90eXBlLnVwbG9hZER5bmFtaWMgPSBmdW5jdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50KVxyXG57XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgIHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIHRoaXMuZHluYW1pY0RhdGEsIHRoaXMuZHluYW1pY1N0cmlkZSwgcHJvcGVydHkub2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5keW5hbWljQnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLmR5bmFtaWNEYXRhKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGxvYWRzIHRoZSBzdGF0aWMgcHJvcGVydGllcy5cclxuICpcclxuICovXHJcblBhcnRpY2xlQnVmZmVyLnByb3RvdHlwZS51cGxvYWRTdGF0aWMgPSBmdW5jdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50KVxyXG57XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcclxuICAgICAgICBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCB0aGlzLnN0YXRpY0RhdGEsIHRoaXMuc3RhdGljU3RyaWRlLCBwcm9wZXJ0eS5vZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnN0YXRpY0J1ZmZlcik7XHJcbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy5zdGF0aWNEYXRhKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCaW5kcyB0aGUgYnVmZmVycyB0byB0aGUgR1BVXHJcbiAqXHJcbiAqL1xyXG5QYXJ0aWNsZUJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICB2YXIgaSwgcHJvcGVydHk7XHJcblxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuZHluYW1pY0J1ZmZlcik7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgcHJvcGVydHkgPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvcGVydHkuYXR0cmlidXRlLCBwcm9wZXJ0eS5zaXplLCBnbC5GTE9BVCwgZmFsc2UsIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQsIHByb3BlcnR5Lm9mZnNldCAqIDQpO1xyXG4gICAgfVxyXG5cclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnN0YXRpY0J1ZmZlcik7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3RhdGljUHJvcGVydGllcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb3BlcnR5LmF0dHJpYnV0ZSwgcHJvcGVydHkuc2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCB0aGlzLnN0YXRpY1N0cmlkZSAqIDQsIHByb3BlcnR5Lm9mZnNldCAqIDQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc3Ryb3lzIHRoZSBQYXJ0aWNsZUJ1ZmZlci5cclxuICpcclxuICovXHJcblBhcnRpY2xlQnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IG51bGw7XHJcbiAgICB0aGlzLmR5bmFtaWNEYXRhID0gbnVsbDtcclxuICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuZHluYW1pY0J1ZmZlcik7XHJcblxyXG4gICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gbnVsbDtcclxuICAgIHRoaXMuc3RhdGljRGF0YSA9IG51bGw7XHJcbiAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnN0YXRpY0J1ZmZlcik7XHJcbn07XHJcbiIsInZhciBPYmplY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlcicpLFxyXG4gICAgV2ViR0xSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyJyksXHJcbiAgICBQYXJ0aWNsZVNoYWRlciA9IHJlcXVpcmUoJy4vUGFydGljbGVTaGFkZXInKSxcclxuICAgIFBhcnRpY2xlQnVmZmVyID0gcmVxdWlyZSgnLi9QYXJ0aWNsZUJ1ZmZlcicpLFxyXG4gICAgbWF0aCAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aCcpO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xyXG4gKlxyXG4gKiBCaWcgdGhhbmtzIHRvIHRoZSB2ZXJ5IGNsZXZlciBNYXR0IERlc0xhdXJpZXJzIDxtYXR0ZGVzbD4gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL1xyXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcclxuICogQWxzbyBhIHRoYW5rcyB0byBodHRwczovL2dpdGh1Yi5jb20vYmNoZXZhbGllciBmb3IgdHdlYWtpbmcgdGhlIHRpbnQgYW5kIGFscGhhIHNvIHRoYXQgdGhleSBub3cgc2hhcmUgNCBieXRlcyBvbiB0aGUgdmVydGV4IGJ1ZmZlclxyXG4gKlxyXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIFBhcnRpY2xlUmVuZGVyZXI6XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvUGFydGljbGVSZW5kZXJlci5qYXZhXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRoaXMgc3ByaXRlIGJhdGNoIHdvcmtzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIFBhcnRpY2xlUmVuZGVyZXIocmVuZGVyZXIpXHJcbntcclxuICAgIE9iamVjdFJlbmRlcmVyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xyXG5cclxuICAgIC8vIDY1NTM1IGlzIG1heCB2ZXJ0ZXggaW5kZXggaW4gdGhlIGluZGV4IGJ1ZmZlciAoc2VlIFBhcnRpY2xlUmVuZGVyZXIpXHJcbiAgICAvLyBzbyBtYXggbnVtYmVyIG9mIHBhcnRpY2xlcyBpcyA2NTUzNiAvIDQgPSAxNjM4NFxyXG4gICAgLy8gYW5kIG1heCBudW1iZXIgb2YgZWxlbWVudCBpbiB0aGUgaW5kZXggYnVmZmVyIGlzIDE2Mzg0ICogNiA9IDk4MzA0XHJcbiAgICAvLyBDcmVhdGluZyBhIGZ1bGwgaW5kZXggYnVmZmVyLCBvdmVyaGVhZCBpcyA5ODMwNCAqIDIgPSAxOTZLb1xyXG4gICAgdmFyIG51bUluZGljZXMgPSA5ODMwNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIHRoZSBpbmRpY2VzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShudW1JbmRpY2VzKTtcclxuXHJcbiAgICBmb3IgKHZhciBpPTAsIGo9MDsgaSA8IG51bUluZGljZXM7IGkgKz0gNiwgaiArPSA0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMF0gPSBqICsgMDtcclxuICAgICAgICB0aGlzLmluZGljZXNbaSArIDFdID0gaiArIDE7XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAyXSA9IGogKyAyO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgM10gPSBqICsgMDtcclxuICAgICAgICB0aGlzLmluZGljZXNbaSArIDRdID0gaiArIDI7XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA1XSA9IGogKyAzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgc2hhZGVyIHRoYXQgaXMgdXNlZCBpZiBhIHNwcml0ZSBkb2Vzbid0IGhhdmUgYSBtb3JlIHNwZWNpZmljIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMucHJvcGVydGllcyA9IG51bGw7XHJcblxyXG4gICAgdGhpcy50ZW1wTWF0cml4ID0gbmV3IG1hdGguTWF0cml4KCk7XHJcbn1cclxuXHJcblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3RSZW5kZXJlci5wcm90b3R5cGUpO1xyXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnRpY2xlUmVuZGVyZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGVSZW5kZXJlcjtcclxuXHJcbldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3BhcnRpY2xlJywgUGFydGljbGVSZW5kZXJlcik7XHJcblxyXG4vKipcclxuICogV2hlbiB0aGVyZSBpcyBhIFdlYkdMIGNvbnRleHQgY2hhbmdlXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5vbkNvbnRleHRDaGFuZ2UgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgIC8vIHNldHVwIGRlZmF1bHQgc2hhZGVyXHJcbiAgICB0aGlzLnNoYWRlciA9IG5ldyBQYXJ0aWNsZVNoYWRlcih0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIpO1xyXG5cclxuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcbiAgICAvLyA2NTUzNSBpcyBtYXggaW5kZXgsIHNvIDY1NTM1IC8gNiA9IDEwOTIyLlxyXG5cclxuICAgIC8vdXBsb2FkIHRoZSBpbmRleCBkYXRhXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgIHRoaXMucHJvcGVydGllcyA9IFtcclxuICAgICAgICAvLyB2ZXJ0aWNlc0RhdGFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZTp0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbixcclxuICAgICAgICAgICAgc2l6ZToyLFxyXG4gICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjp0aGlzLnVwbG9hZFZlcnRpY2VzLFxyXG4gICAgICAgICAgICBvZmZzZXQ6MFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gcG9zaXRpb25EYXRhXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGU6dGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hUG9zaXRpb25Db29yZCxcclxuICAgICAgICAgICAgc2l6ZToyLFxyXG4gICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjp0aGlzLnVwbG9hZFBvc2l0aW9uLFxyXG4gICAgICAgICAgICBvZmZzZXQ6MFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gcm90YXRpb25EYXRhXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGU6dGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hUm90YXRpb24sXHJcbiAgICAgICAgICAgIHNpemU6MSxcclxuICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246dGhpcy51cGxvYWRSb3RhdGlvbixcclxuICAgICAgICAgICAgb2Zmc2V0OjBcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIHV2c0RhdGFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZTp0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFUZXh0dXJlQ29vcmQsXHJcbiAgICAgICAgICAgIHNpemU6MixcclxuICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246dGhpcy51cGxvYWRVdnMsXHJcbiAgICAgICAgICAgIG9mZnNldDowXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBhbHBoYURhdGFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZTp0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFDb2xvcixcclxuICAgICAgICAgICAgc2l6ZToxLFxyXG4gICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjp0aGlzLnVwbG9hZEFscGhhLFxyXG4gICAgICAgICAgICBvZmZzZXQ6MFxyXG4gICAgICAgIH1cclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogU3RhcnRzIGEgbmV3IHBhcnRpY2xlIGJhdGNoLlxyXG4gKlxyXG4gKi9cclxuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgIC8vIGJpbmQgdGhlIG1haW4gdGV4dHVyZVxyXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XHJcblxyXG4gICAgLy8gYmluZCB0aGUgYnVmZmVyc1xyXG5cclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xyXG5cclxuICAgIHZhciBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcclxuXHJcbiAgICB0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHNoYWRlcik7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIHBhcnRpY2xlIGNvbnRhaW5lciBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250YWluZXIge1BJWEkuUGFydGljbGVDb250YWluZXJ9IFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxyXG4gKi9cclxuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNvbnRhaW5lcilcclxue1xyXG4gICAgdmFyIGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuLFxyXG4gICAgICAgIHRvdGFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGgsXHJcbiAgICAgICAgbWF4U2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZSxcclxuICAgICAgICBiYXRjaFNpemUgPSBjb250YWluZXIuX2JhdGNoU2l6ZTtcclxuXHJcbiAgICBpZih0b3RhbENoaWxkcmVuID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYodG90YWxDaGlsZHJlbiA+IG1heFNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgdG90YWxDaGlsZHJlbiA9IG1heFNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIWNvbnRhaW5lci5fYnVmZmVycylcclxuICAgIHtcclxuICAgICAgICBjb250YWluZXIuX2J1ZmZlcnMgPSB0aGlzLmdlbmVyYXRlQnVmZmVycyggY29udGFpbmVyICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxyXG4gICAgdGhpcy5yZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZShjb250YWluZXIuYmxlbmRNb2RlKTtcclxuXHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgIHZhciBtID0gIGNvbnRhaW5lci53b3JsZFRyYW5zZm9ybS5jb3B5KCB0aGlzLnRlbXBNYXRyaXggKTtcclxuICAgIG0ucHJlcGVuZCggdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXggKTtcclxuICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodGhpcy5zaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC5fbG9jYXRpb24sIGZhbHNlLCBtLnRvQXJyYXkodHJ1ZSkpO1xyXG4gICAgZ2wudW5pZm9ybTFmKHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVBbHBoYS5fbG9jYXRpb24sIGNvbnRhaW5lci53b3JsZEFscGhhKTtcclxuXHJcblxyXG4gICAgLy8gbWFrZSBzdXJlIHRoZSB0ZXh0dXJlIGlzIGJvdW5kLi5cclxuICAgIHZhciBiYXNlVGV4dHVyZSA9IGNoaWxkcmVuWzBdLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG5cclxuICAgIGlmICghYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGlmIHRoZSB0ZXh0dXJlIGhhcyBub3QgdXBkYXRlZCB0aGVuIGxldHMgbm90IHVwbG9hZCBhbnkgc3RhdGljIHByb3BlcnRpZXNcclxuICAgICAgICBpZighdGhpcy5yZW5kZXJlci51cGRhdGVUZXh0dXJlKGJhc2VUZXh0dXJlKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFjb250YWluZXIuX3Byb3BlcnRpZXNbMF0gfHwgIWNvbnRhaW5lci5fcHJvcGVydGllc1szXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5fYnVmZmVyVG9VcGRhdGUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG5vdyBsZXRzIHVwbG9hZCBhbmQgcmVuZGVyIHRoZSBidWZmZXJzLi5cclxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsQ2hpbGRyZW47IGkgKz0gYmF0Y2hTaXplLCBqICs9IDEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFtb3VudCA9ICggdG90YWxDaGlsZHJlbiAtIGkpO1xyXG4gICAgICAgIGlmKGFtb3VudCA+IGJhdGNoU2l6ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFtb3VudCA9IGJhdGNoU2l6ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBidWZmZXIgPSBjb250YWluZXIuX2J1ZmZlcnNbal07XHJcblxyXG4gICAgICAgIC8vIHdlIGFsd2F5cyB1cGxvYWQgdGhlIGR5bmFtaWNcclxuICAgICAgICBidWZmZXIudXBsb2FkRHluYW1pYyhjaGlsZHJlbiwgaSwgYW1vdW50KTtcclxuXHJcbiAgICAgICAgLy8gd2Ugb25seSB1cGxvYWQgdGhlIHN0YXRpYyBjb250ZW50IHdoZW4gd2UgaGF2ZSB0byFcclxuICAgICAgICBpZihjb250YWluZXIuX2J1ZmZlclRvVXBkYXRlID09PSBqKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYnVmZmVyLnVwbG9hZFN0YXRpYyhjaGlsZHJlbiwgaSwgYW1vdW50KTtcclxuICAgICAgICAgICAgY29udGFpbmVyLl9idWZmZXJUb1VwZGF0ZSA9IGogKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYmluZCB0aGUgYnVmZmVyXHJcbiAgICAgICAgYnVmZmVyLmJpbmQoIHRoaXMuc2hhZGVyICk7XHJcblxyXG4gICAgICAgICAvLyBub3cgZHJhdyB0aG9zZSBzdWNrYXMhXHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgYW1vdW50ICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZHJhd0NvdW50Kys7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBvbmUgcGFydGljbGUgYnVmZmVyIGZvciBlYWNoIGNoaWxkIGluIHRoZSBjb250YWluZXIgd2Ugd2FudCB0byByZW5kZXIgYW5kIHVwZGF0ZXMgaW50ZXJuYWwgcHJvcGVydGllc1xyXG4gKlxyXG4gKiBAcGFyYW0gY29udGFpbmVyIHtQSVhJLlBhcnRpY2xlQ29udGFpbmVyfSBUaGUgY29udGFpbmVyIHRvIHJlbmRlciB1c2luZyB0aGlzIFBhcnRpY2xlUmVuZGVyZXJcclxuICovXHJcblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlQnVmZmVycyA9IGZ1bmN0aW9uIChjb250YWluZXIpXHJcbntcclxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2wsXHJcbiAgICAgICAgYnVmZmVycyA9IFtdLFxyXG4gICAgICAgIHNpemUgPSBjb250YWluZXIuX21heFNpemUsXHJcbiAgICAgICAgYmF0Y2hTaXplID0gY29udGFpbmVyLl9iYXRjaFNpemUsXHJcbiAgICAgICAgZHluYW1pY1Byb3BlcnR5RmxhZ3MgPSBjb250YWluZXIuX3Byb3BlcnRpZXMsXHJcbiAgICAgICAgaTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSArPSBiYXRjaFNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgYnVmZmVycy5wdXNoKG5ldyBQYXJ0aWNsZUJ1ZmZlcihnbCwgdGhpcy5wcm9wZXJ0aWVzLCBkeW5hbWljUHJvcGVydHlGbGFncywgYmF0Y2hTaXplKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJ1ZmZlcnM7XHJcbn07XHJcblxyXG4vKipcclxuICogVXBsb2FkcyB0aGUgdmVydGljaWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gY2hpbGRyZW4ge1BJWEkuRGlzcGxheU9iamVjdFtdfSB0aGUgYXJyYXkgb2YgZGlzcGxheSBvYmplY3RzIHRvIHJlbmRlclxyXG4gKiBAcGFyYW0gc3RhcnRJbmRleCB7bnVtYmVyfSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcclxuICogQHBhcmFtIGFtb3VudCB7bnVtYmVyfSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHZlcnRpY2VzIHVwbG9hZGVkXHJcbiAqIEBwYXJhbSBhcnJheSB7bnVtYmVyW119XHJcbiAqIEBwYXJhbSBzdHJpZGUge251bWJlcn1cclxuICogQHBhcmFtIG9mZnNldCB7bnVtYmVyfVxyXG4gKi9cclxuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUudXBsb2FkVmVydGljZXMgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KVxyXG57XHJcbiAgICB2YXIgc3ByaXRlLFxyXG4gICAgICAgIHRleHR1cmUsXHJcbiAgICAgICAgdHJpbSxcclxuICAgICAgICBzeCxcclxuICAgICAgICBzeSxcclxuICAgICAgICB3MCwgdzEsIGgwLCBoMTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XHJcblxyXG4gICAgICAgIHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXTtcclxuICAgICAgICB0ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xyXG4gICAgICAgIHN4ID0gc3ByaXRlLnNjYWxlLng7XHJcbiAgICAgICAgc3kgPSBzcHJpdGUuc2NhbGUueTtcclxuXHJcbiAgICAgICAgaWYgKHRleHR1cmUudHJpbSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZCB0aGVuIHdlIG5lZWQgdG8gYWRkIHRoZSBleHRyYSBzcGFjZSBiZWZvcmUgdHJhbnNmb3JtaW5nIHRoZSBzcHJpdGUgY29vcmRzLi5cclxuICAgICAgICAgICAgdHJpbSA9IHRleHR1cmUudHJpbTtcclxuXHJcbiAgICAgICAgICAgIHcxID0gdHJpbS54IC0gc3ByaXRlLmFuY2hvci54ICogdHJpbS53aWR0aDtcclxuICAgICAgICAgICAgdzAgPSB3MSArIHRleHR1cmUuY3JvcC53aWR0aDtcclxuXHJcbiAgICAgICAgICAgIGgxID0gdHJpbS55IC0gc3ByaXRlLmFuY2hvci55ICogdHJpbS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGgwID0gaDEgKyB0ZXh0dXJlLmNyb3AuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3MCA9ICh0ZXh0dXJlLl9mcmFtZS53aWR0aCApICogKDEtc3ByaXRlLmFuY2hvci54KTtcclxuICAgICAgICAgICAgdzEgPSAodGV4dHVyZS5fZnJhbWUud2lkdGggKSAqIC1zcHJpdGUuYW5jaG9yLng7XHJcblxyXG4gICAgICAgICAgICBoMCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAqICgxLXNwcml0ZS5hbmNob3IueSk7XHJcbiAgICAgICAgICAgIGgxID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ICogLXNwcml0ZS5hbmNob3IueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFycmF5W29mZnNldF0gPSB3MSAqIHN4O1xyXG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gaDEgKiBzeTtcclxuXHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHcwICogc3g7XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBoMSAqIHN5O1xyXG5cclxuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHcwICogc3g7XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gaDAgKiBzeTtcclxuXHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSB3MSAqIHN4O1xyXG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDMgKyAxXSA9IGgwICogc3k7XHJcblxyXG4gICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gY2hpbGRyZW4ge1BJWEkuRGlzcGxheU9iamVjdFtdfSB0aGUgYXJyYXkgb2YgZGlzcGxheSBvYmplY3RzIHRvIHJlbmRlclxyXG4gKiBAcGFyYW0gc3RhcnRJbmRleCB7bnVtYmVyfSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcclxuICogQHBhcmFtIGFtb3VudCB7bnVtYmVyfSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHBvc2l0aW9ucyB1cGxvYWRlZFxyXG4gKiBAcGFyYW0gYXJyYXkge251bWJlcltdfVxyXG4gKiBAcGFyYW0gc3RyaWRlIHtudW1iZXJ9XHJcbiAqIEBwYXJhbSBvZmZzZXQge251bWJlcn1cclxuICovXHJcblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnVwbG9hZFBvc2l0aW9uID0gZnVuY3Rpb24gKGNoaWxkcmVuLHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzcHJpdGVQb3NpdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5wb3NpdGlvbjtcclxuXHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHNwcml0ZVBvc2l0aW9uLng7XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xyXG5cclxuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gc3ByaXRlUG9zaXRpb24ueDtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IHNwcml0ZVBvc2l0aW9uLnk7XHJcblxyXG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gc3ByaXRlUG9zaXRpb24ueDtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xyXG5cclxuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHNwcml0ZVBvc2l0aW9uLng7XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcclxuXHJcbiAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGlsZHJlbiB7UElYSS5EaXNwbGF5T2JqZWN0W119IHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXHJcbiAqIEBwYXJhbSBzdGFydEluZGV4IHtudW1iZXJ9IHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxyXG4gKiBAcGFyYW0gYW1vdW50IHtudW1iZXJ9IHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgcm90YXRpb24gdXBsb2FkZWRcclxuICogQHBhcmFtIGFycmF5IHtudW1iZXJbXX1cclxuICogQHBhcmFtIHN0cmlkZSB7bnVtYmVyfVxyXG4gKiBAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9XHJcbiAqL1xyXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS51cGxvYWRSb3RhdGlvbiA9IGZ1bmN0aW9uIChjaGlsZHJlbixzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldClcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3ByaXRlUm90YXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucm90YXRpb247XHJcblxyXG5cclxuICAgICAgICBhcnJheVtvZmZzZXRdID0gc3ByaXRlUm90YXRpb247XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHNwcml0ZVJvdGF0aW9uO1xyXG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gc3ByaXRlUm90YXRpb247XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSBzcHJpdGVSb3RhdGlvbjtcclxuXHJcbiAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGNoaWxkcmVuIHtQSVhJLkRpc3BsYXlPYmplY3RbXX0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcclxuICogQHBhcmFtIHN0YXJ0SW5kZXgge251bWJlcn0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XHJcbiAqIEBwYXJhbSBhbW91bnQge251bWJlcn0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciBVdnMgdXBsb2FkZWRcclxuICogQHBhcmFtIGFycmF5IHtudW1iZXJbXX1cclxuICogQHBhcmFtIHN0cmlkZSB7bnVtYmVyfVxyXG4gKiBAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9XHJcbiAqL1xyXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS51cGxvYWRVdnMgPSBmdW5jdGlvbiAoY2hpbGRyZW4sc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmVVdnMgPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0uX3RleHR1cmUuX3V2cztcclxuXHJcbiAgICAgICAgaWYgKHRleHR1cmVVdnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gdGV4dHVyZVV2cy54MDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0ZXh0dXJlVXZzLnkwO1xyXG5cclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHRleHR1cmVVdnMueDE7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gdGV4dHVyZVV2cy55MTtcclxuXHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gdGV4dHVyZVV2cy54MjtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gdGV4dHVyZVV2cy55MjtcclxuXHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gdGV4dHVyZVV2cy54MztcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gdGV4dHVyZVV2cy55MztcclxuXHJcbiAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1RPRE8geW91IGtub3cgdGhpcyBjYW4gYmUgZWFzaWVyIVxyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gMDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAwO1xyXG5cclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IDA7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gMDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gMDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gMDtcclxuXHJcbiAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gY2hpbGRyZW4ge1BJWEkuRGlzcGxheU9iamVjdFtdfSB0aGUgYXJyYXkgb2YgZGlzcGxheSBvYmplY3RzIHRvIHJlbmRlclxyXG4gKiBAcGFyYW0gc3RhcnRJbmRleCB7bnVtYmVyfSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcclxuICogQHBhcmFtIGFtb3VudCB7bnVtYmVyfSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIGFscGhhIHVwbG9hZGVkXHJcbiAqIEBwYXJhbSBhcnJheSB7bnVtYmVyW119XHJcbiAqIEBwYXJhbSBzdHJpZGUge251bWJlcn1cclxuICogQHBhcmFtIG9mZnNldCB7bnVtYmVyfVxyXG4gKi9cclxuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUudXBsb2FkQWxwaGEgPSBmdW5jdGlvbiAoY2hpbGRyZW4sc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpXHJcbntcclxuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKVxyXG4gICAgIHtcclxuICAgICAgICB2YXIgc3ByaXRlQWxwaGEgPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0uYWxwaGE7XHJcblxyXG4gICAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVBbHBoYTtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gc3ByaXRlQWxwaGE7XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSBzcHJpdGVBbHBoYTtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHNwcml0ZUFscGhhO1xyXG5cclxuICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogRGVzdHJveXMgdGhlIFBhcnRpY2xlUmVuZGVyZXIuXHJcbiAqXHJcbiAqL1xyXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKHRoaXMucmVuZGVyZXIuZ2wpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3RSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuc2hhZGVyLmRlc3Ryb3koKTtcclxuXHJcbiAgICB0aGlzLmluZGljZXMgPSBudWxsO1xyXG4gICAgdGhpcy50ZW1wTWF0cml4ID0gbnVsbDtcclxufTtcclxuIiwidmFyIFRleHR1cmVTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvc2hhZGVycy9UZXh0dXJlU2hhZGVyJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuVGV4dHVyZVNoYWRlclxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gc2hhZGVyTWFuYWdlciB7U2hhZGVyTWFuYWdlcn0gVGhlIHdlYmdsIHNoYWRlciBtYW5hZ2VyIHRoaXMgc2hhZGVyIHdvcmtzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIFBhcnRpY2xlU2hhZGVyKHNoYWRlck1hbmFnZXIpXHJcbntcclxuICAgIFRleHR1cmVTaGFkZXIuY2FsbCh0aGlzLFxyXG4gICAgICAgIHNoYWRlck1hbmFnZXIsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxyXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsnLFxyXG4gICAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFDb2xvcjsnLFxyXG5cclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbkNvb3JkOycsXHJcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhU2NhbGU7JyxcclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhUm90YXRpb247JyxcclxuXHJcbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxyXG4gICAgICAgICAgICAnICAgdmVjMiB2ID0gYVZlcnRleFBvc2l0aW9uOycsXHJcblxyXG4gICAgICAgICAgICAnICAgdi54ID0gKGFWZXJ0ZXhQb3NpdGlvbi54KSAqIGNvcyhhUm90YXRpb24pIC0gKGFWZXJ0ZXhQb3NpdGlvbi55KSAqIHNpbihhUm90YXRpb24pOycsXHJcbiAgICAgICAgICAgICcgICB2LnkgPSAoYVZlcnRleFBvc2l0aW9uLngpICogc2luKGFSb3RhdGlvbikgKyAoYVZlcnRleFBvc2l0aW9uLnkpICogY29zKGFSb3RhdGlvbik7JyxcclxuICAgICAgICAgICAgJyAgIHYgPSB2ICsgYVBvc2l0aW9uQ29vcmQ7JyxcclxuXHJcbiAgICAgICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHYsIDEuMCkpLnh5LCAwLjAsIDEuMCk7JyxcclxuXHJcbiAgICAgICAgICAgICcgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDsnLFxyXG4gICAgICAgICAgICAnICAgdkNvbG9yID0gYUNvbG9yOycsXHJcbiAgICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgLy8gaGVsbG9cclxuICAgICAgICAgW1xyXG4gICAgICAgICAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcclxuXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxyXG4gICAgICAgICAgICAndmFyeWluZyBmbG9hdCB2Q29sb3I7JyxcclxuXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1QWxwaGE7JyxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcclxuICAgICAgICAgICAgJyAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3IgKiB1QWxwaGE7JyxcclxuICAgICAgICAgICAgJyAgaWYgKGNvbG9yLmEgPT0gMC4wKSBkaXNjYXJkOycsXHJcbiAgICAgICAgICAgICcgIGdsX0ZyYWdDb2xvciA9IGNvbG9yOycsXHJcbiAgICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB1QWxwaGE6ICB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGN1c3RvbSBhdHRyaWJ1dGVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhUG9zaXRpb25Db29yZDogMCxcclxuICAgICAgICAgICAvLyBhU2NhbGU6ICAgICAgICAgMCxcclxuICAgICAgICAgICAgYVJvdGF0aW9uOiAgICAgIDBcclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIFRFTVAgSEFDS1xyXG5cclxufVxyXG5cclxuUGFydGljbGVTaGFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUZXh0dXJlU2hhZGVyLnByb3RvdHlwZSk7XHJcblBhcnRpY2xlU2hhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnRpY2xlU2hhZGVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWNsZVNoYWRlcjtcclxuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKSxcclxuICAgIG1hdGggPSByZXF1aXJlKCcuLi9tYXRoJyksXHJcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXHJcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XHJcblxyXG4vKipcclxuICogVGhlIENhbnZhc1JlbmRlcmVyIGRyYXdzIHRoZSBzY2VuZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSAyZCBjYW52YXMuIFRoaXMgcmVuZGVyZXIgc2hvdWxkIGJlIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgd2ViR0wuXHJcbiAqIERvbid0IGZvcmdldCB0byBhZGQgdGhlIENhbnZhc1JlbmRlcmVyLnZpZXcgdG8geW91ciBET00gb3IgeW91IHdpbGwgbm90IHNlZSBhbnl0aGluZyA6KVxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIHN5c3RlbSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgc3lzdGVtIHRoaXMgcmVuZGVyZXIgaXMgZm9yLlxyXG4gKiBAcGFyYW0gW3dpZHRoPTgwMF0ge251bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgdmlld1xyXG4gKiBAcGFyYW0gW2hlaWdodD02MDBdIHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XHJcbiAqIEBwYXJhbSBbb3B0aW9uc10ge29iamVjdH0gVGhlIG9wdGlvbmFsIHJlbmRlcmVyIHBhcmFtZXRlcnNcclxuICogQHBhcmFtIFtvcHRpb25zLnZpZXddIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxyXG4gKiBAcGFyYW0gW29wdGlvbnMudHJhbnNwYXJlbnQ9ZmFsc2VdIHtib29sZWFufSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnQsIGRlZmF1bHQgZmFsc2VcclxuICogQHBhcmFtIFtvcHRpb25zLmF1dG9SZXNpemU9ZmFsc2VdIHtib29sZWFufSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgYXV0b21hdGljYWxseSByZXNpemVkLCBkZWZhdWx0IGZhbHNlXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5hbnRpYWxpYXM9ZmFsc2VdIHtib29sZWFufSBzZXRzIGFudGlhbGlhcyAob25seSBhcHBsaWNhYmxlIGluIGNocm9tZSBhdCB0aGUgbW9tZW50KVxyXG4gKiBAcGFyYW0gW29wdGlvbnMucmVzb2x1dGlvbj0xXSB7bnVtYmVyfSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyZXIgcmV0aW5hIHdvdWxkIGJlIDJcclxuICogQHBhcmFtIFtvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyPXRydWVdIHtib29sZWFufSBUaGlzIHNldHMgaWYgdGhlIENhbnZhc1JlbmRlcmVyIHdpbGwgY2xlYXIgdGhlIGNhbnZhcyBvclxyXG4gKiAgICAgIG5vdCBiZWZvcmUgdGhlIG5ldyByZW5kZXIgcGFzcy5cclxuICogQHBhcmFtIFtvcHRpb25zLmJhY2tncm91bmRDb2xvcj0weDAwMDAwMF0ge251bWJlcn0gVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIHJlbmRlcmVkIGFyZWEgKHNob3duIGlmIG5vdCB0cmFuc3BhcmVudCkuXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5yb3VuZFBpeGVscz1mYWxzZV0ge2Jvb2xlYW59IElmIHRydWUgUGl4aSB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gU3lzdGVtUmVuZGVyZXIoc3lzdGVtLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKVxyXG57XHJcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB1dGlscy5zYXlIZWxsbyhzeXN0ZW0pO1xyXG5cclxuICAgIC8vIHByZXBhcmUgb3B0aW9uc1xyXG4gICAgaWYgKG9wdGlvbnMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiBDT05TVC5ERUZBVUxUX1JFTkRFUl9PUFRJT05TKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW2ldID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1tpXSA9IENPTlNULkRFRkFVTFRfUkVOREVSX09QVElPTlNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgb3B0aW9ucyA9IENPTlNULkRFRkFVTFRfUkVOREVSX09QVElPTlM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgUElYSS5SRU5ERVJFUl9UWVBFLlVOS05PV05cclxuICAgICAqIEBzZWUgUElYSS5SRU5ERVJFUl9UWVBFXHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZSA9IENPTlNULlJFTkRFUkVSX1RZUEUuVU5LTk9XTjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCA4MDBcclxuICAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDgwMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgNjAwXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDYwMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG9cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy52aWV3ID0gb3B0aW9ucy52aWV3IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlcmVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJhbnNwYXJlbnQgPSBvcHRpb25zLnRyYW5zcGFyZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgcmVuZGVyIHZpZXcgc2hvdWxkIGJlIHJlc2l6ZWQgYXV0b21hdGljYWxseVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IG9wdGlvbnMuYXV0b1Jlc2l6ZSB8fCBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYWNrcyB0aGUgYmxlbmQgbW9kZXMgdXNlZnVsIGZvciB0aGlzIHJlbmRlcmVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge29iamVjdDxzdHJpbmcsIG1peGVkPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ibGVuZE1vZGVzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgcHJlc2VydmVEcmF3aW5nQnVmZmVyIGZsYWcgYWZmZWN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgY29udGVudHMgb2YgdGhlIHN0ZW5jaWwgYnVmZmVyIGlzIHJldGFpbmVkIGFmdGVyIHJlbmRlcmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBzZXRzIGlmIHRoZSBDYW52YXNSZW5kZXJlciB3aWxsIGNsZWFyIHRoZSBjYW52YXMgb3Igbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxyXG4gICAgICogSWYgdGhlIHNjZW5lIGlzIE5PVCB0cmFuc3BhcmVudCBQaXhpIHdpbGwgdXNlIGEgY2FudmFzIHNpemVkIGZpbGxSZWN0IG9wZXJhdGlvbiBldmVyeSBmcmFtZSB0byBzZXQgdGhlIGNhbnZhcyBiYWNrZ3JvdW5kIGNvbG9yLlxyXG4gICAgICogSWYgdGhlIHNjZW5lIGlzIHRyYW5zcGFyZW50IFBpeGkgd2lsbCB1c2UgY2xlYXJSZWN0IHRvIGNsZWFyIHRoZSBjYW52YXMgZXZlcnkgZnJhbWUuXHJcbiAgICAgKiBEaXNhYmxlIHRoaXMgYnkgc2V0dGluZyB0aGlzIHRvIGZhbHNlLiBGb3IgZXhhbXBsZSBpZiB5b3VyIGdhbWUgaGFzIGEgY2FudmFzIGZpbGxpbmcgYmFja2dyb3VuZCBpbWFnZSB5b3Ugb2Z0ZW4gZG9uJ3QgbmVlZCB0aGlzIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHRcclxuICAgICAqL1xyXG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IG9wdGlvbnMuY2xlYXJCZWZvcmVSZW5kZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0cnVlIFBpeGkgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuIHJlbmRlcmluZywgc3RvcHBpbmcgcGl4ZWwgaW50ZXJwb2xhdGlvbi5cclxuICAgICAqIEhhbmR5IGZvciBjcmlzcCBwaXhlbCBhcnQgYW5kIHNwZWVkIG9uIGxlZ2FjeSBkZXZpY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucm91bmRQaXhlbHMgPSBvcHRpb25zLnJvdW5kUGl4ZWxzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3IgYXMgYSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gMHgwMDAwMDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFja2dyb3VuZCBjb2xvciBhcyBhbiBbUiwgRywgQl0gYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2IgPSBbMCwgMCwgMF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFja2dyb3VuZCBjb2xvciBhcyBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmcgPSAnIzAwMDAwMCc7XHJcblxyXG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7IC8vIHJ1biBiZyBjb2xvciBzZXR0ZXJcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgdGVtcG9yYXJ5IGRpc3BsYXkgb2JqZWN0IHVzZWQgYXMgdGhlIHBhcmVudCBvZiB0aGUgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkIGl0ZW1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkRpc3BsYXlPYmplY3R9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IHt3b3JsZFRyYW5zZm9ybTpuZXcgbWF0aC5NYXRyaXgoKSwgd29ybGRBbHBoYToxLCBjaGlsZHJlbjpbXX07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGFzdCByb290IG9iamVjdCB0aGF0IHRoZSByZW5kZXJlciB0cmllZCB0byByZW5kZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XHJcbn1cclxuXHJcbi8vIGNvbnN0cnVjdG9yXHJcblN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XHJcblN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5c3RlbVJlbmRlcmVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFN5c3RlbVJlbmRlcmVyO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIHRvIGZpbGwgaWYgbm90IHRyYW5zcGFyZW50XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuU3lzdGVtUmVuZGVyZXIjXHJcbiAgICAgKi9cclxuICAgIGJhY2tncm91bmRDb2xvcjpcclxuICAgIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gdmFsO1xyXG4gICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmcgPSB1dGlscy5oZXgyc3RyaW5nKHZhbCk7XHJcbiAgICAgICAgICAgIHV0aWxzLmhleDJyZ2IodmFsLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogUmVzaXplcyB0aGUgY2FudmFzIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAqXHJcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSB0aGUgbmV3IHdpZHRoIG9mIHRoZSBjYW52YXMgdmlld1xyXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXMgdmlld1xyXG4gKi9cclxuU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGggKiB0aGlzLnJlc29sdXRpb247XHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbjtcclxuXHJcbiAgICB0aGlzLnZpZXcud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgIGlmICh0aGlzLmF1dG9SZXNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy52aWV3LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCAvIHRoaXMucmVzb2x1dGlvbiArICdweCc7XHJcbiAgICAgICAgdGhpcy52aWV3LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uICsgJ3B4JztcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgYW5kIG9wdGlvbmFsbHkgcmVtb3ZlcyB0aGUgQ2FudmFzIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gW3JlbW92ZVZpZXc9ZmFsc2VdIHtib29sZWFufSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXHJcbiAqL1xyXG5TeXN0ZW1SZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmVWaWV3KSB7XHJcbiAgICBpZiAocmVtb3ZlVmlldyAmJiB0aGlzLnZpZXcucGFyZW50Tm9kZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnZpZXcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnZpZXcpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHlwZSA9IENPTlNULlJFTkRFUkVSX1RZUEUuVU5LTk9XTjtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gMDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuXHJcbiAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG5cclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IDA7XHJcblxyXG4gICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuYmxlbmRNb2RlcyA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBmYWxzZTtcclxuICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gMDtcclxuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclJnYiA9IG51bGw7XHJcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmcgPSBudWxsO1xyXG59O1xyXG4iLCJ2YXIgU3lzdGVtUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9TeXN0ZW1SZW5kZXJlcicpLFxyXG4gICAgQ2FudmFzTWFza01hbmFnZXIgPSByZXF1aXJlKCcuL3V0aWxzL0NhbnZhc01hc2tNYW5hZ2VyJyksXHJcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyksXHJcbiAgICBtYXRoID0gcmVxdWlyZSgnLi4vLi4vbWF0aCcpLFxyXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBDYW52YXNSZW5kZXJlciBkcmF3cyB0aGUgc2NlbmUgYW5kIGFsbCBpdHMgY29udGVudCBvbnRvIGEgMmQgY2FudmFzLiBUaGlzIHJlbmRlcmVyIHNob3VsZCBiZSB1c2VkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHdlYkdMLlxyXG4gKiBEb24ndCBmb3JnZXQgdG8gYWRkIHRoZSBDYW52YXNSZW5kZXJlci52aWV3IHRvIHlvdXIgRE9NIG9yIHlvdSB3aWxsIG5vdCBzZWUgYW55dGhpbmcgOilcclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqIEBleHRlbmRzIFBJWEkuU3lzdGVtUmVuZGVyZXJcclxuICogQHBhcmFtIFt3aWR0aD04MDBdIHtudW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcclxuICogQHBhcmFtIFtoZWlnaHQ9NjAwXSB7bnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgdmlld1xyXG4gKiBAcGFyYW0gW29wdGlvbnNdIHtvYmplY3R9IFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy52aWV3XSB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcclxuICogQHBhcmFtIFtvcHRpb25zLnRyYW5zcGFyZW50PWZhbHNlXSB7Ym9vbGVhbn0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50LCBkZWZhdWx0IGZhbHNlXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5hdXRvUmVzaXplPWZhbHNlXSB7Ym9vbGVhbn0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIGF1dG9tYXRpY2FsbHkgcmVzaXplZCwgZGVmYXVsdCBmYWxzZVxyXG4gKiBAcGFyYW0gW29wdGlvbnMuYW50aWFsaWFzPWZhbHNlXSB7Ym9vbGVhbn0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiBjaHJvbWUgYXQgdGhlIG1vbWVudClcclxuICogQHBhcmFtIFtvcHRpb25zLnJlc29sdXRpb249MV0ge251bWJlcn0gdGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlcmVyIHJldGluYSB3b3VsZCBiZSAyXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcj10cnVlXSB7Ym9vbGVhbn0gVGhpcyBzZXRzIGlmIHRoZSBDYW52YXNSZW5kZXJlciB3aWxsIGNsZWFyIHRoZSBjYW52YXMgb3JcclxuICogICAgICBub3QgYmVmb3JlIHRoZSBuZXcgcmVuZGVyIHBhc3MuXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5yb3VuZFBpeGVscz1mYWxzZV0ge2Jvb2xlYW59IElmIHRydWUgUGl4aSB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIod2lkdGgsIGhlaWdodCwgb3B0aW9ucylcclxue1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgU3lzdGVtUmVuZGVyZXIuY2FsbCh0aGlzLCAnQ2FudmFzJywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gQ09OU1QuUkVOREVSRVJfVFlQRS5DQU5WQVM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FudmFzIDJkIGNvbnRleHQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHdpdGguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiB0aGlzLnRyYW5zcGFyZW50IH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQm9vbGVhbiBmbGFnIGNvbnRyb2xsaW5nIGNhbnZhcyByZWZyZXNoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVmcmVzaCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW5jZSBvZiBhIENhbnZhc01hc2tNYW5hZ2VyLCBoYW5kbGVzIG1hc2tpbmcgd2hlbiB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuQ2FudmFzTWFza01hbmFnZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgQ2FudmFzTWFza01hbmFnZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjYW52YXMgcHJvcGVydHkgdXNlZCB0byBzZXQgdGhlIGNhbnZhcyBzbW9vdGhpbmcgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNtb290aFByb3BlcnR5ID0gJ2ltYWdlU21vb3RoaW5nRW5hYmxlZCc7XHJcblxyXG4gICAgaWYgKCF0aGlzLmNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zbW9vdGhQcm9wZXJ0eSA9ICd3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zbW9vdGhQcm9wZXJ0eSA9ICdtb3pJbWFnZVNtb290aGluZ0VuYWJsZWQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQub0ltYWdlU21vb3RoaW5nRW5hYmxlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc21vb3RoUHJvcGVydHkgPSAnb0ltYWdlU21vb3RoaW5nRW5hYmxlZCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc21vb3RoUHJvcGVydHkgPSAnbXNJbWFnZVNtb290aGluZ0VuYWJsZWQnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRQbHVnaW5zKCk7XHJcblxyXG4gICAgdGhpcy5fbWFwQmxlbmRNb2RlcygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyB0ZW1wb3JhcnkgZGlzcGxheSBvYmplY3QgdXNlZCBhcyB0aGUgcGFyZW50IG9mIHRoZSBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWQgaXRlbVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0ge1xyXG4gICAgICAgIHdvcmxkVHJhbnNmb3JtOiBuZXcgbWF0aC5NYXRyaXgoKSxcclxuICAgICAgICB3b3JsZEFscGhhOiAxXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG5cclxuLy8gY29uc3RydWN0b3JcclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTeXN0ZW1SZW5kZXJlci5wcm90b3R5cGUpO1xyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNSZW5kZXJlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNSZW5kZXJlcjtcclxudXRpbHMucGx1Z2luVGFyZ2V0Lm1peGluKENhbnZhc1JlbmRlcmVyKTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gdGhpcyBjYW52YXMgdmlld1xyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0IHtQSVhJLkRpc3BsYXlPYmplY3R9IHRoZSBvYmplY3QgdG8gYmUgcmVuZGVyZWRcclxuICovXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAob2JqZWN0KVxyXG57XHJcbiAgICB0aGlzLmVtaXQoJ3ByZXJlbmRlcicpO1xyXG5cclxuICAgIHZhciBjYWNoZVBhcmVudCA9IG9iamVjdC5wYXJlbnQ7XHJcblxyXG4gICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gb2JqZWN0O1xyXG5cclxuICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcclxuXHJcbiAgICAvLyB1cGRhdGUgdGhlIHNjZW5lIGdyYXBoXHJcbiAgICBvYmplY3QudXBkYXRlVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgb2JqZWN0LnBhcmVudCA9IGNhY2hlUGFyZW50O1xyXG5cclxuICAgIHRoaXMuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcblxyXG4gICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gMTtcclxuXHJcbiAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk5PUk1BTF07XHJcblxyXG4gICAgaWYgKG5hdmlnYXRvci5pc0NvY29vbkpTICYmIHRoaXMudmlldy5zY3JlZW5jYW52YXMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9ICdibGFjayc7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwYXJlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZztcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGggLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVuZGVyRGlzcGxheU9iamVjdChvYmplY3QsIHRoaXMuY29udGV4dCk7XHJcblxyXG4gICAgdGhpcy5lbWl0KCdwb3N0cmVuZGVyJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIENhbnZhcyBET00gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIFtyZW1vdmVWaWV3PWZhbHNlXSB7Ym9vbGVhbn0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxyXG4gKi9cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlVmlldylcclxue1xyXG4gICAgdGhpcy5kZXN0cm95UGx1Z2lucygpO1xyXG5cclxuICAgIC8vIGNhbGwgdGhlIGJhc2UgZGVzdHJveVxyXG4gICAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCByZW1vdmVWaWV3KTtcclxuXHJcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMucmVmcmVzaCA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5tYXNrTWFuYWdlci5kZXN0cm95KCk7XHJcbiAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnNtb290aFByb3BlcnR5ID0gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIGEgZGlzcGxheSBvYmplY3RcclxuICpcclxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGRpc3BsYXlPYmplY3QgdG8gcmVuZGVyXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uIChkaXNwbGF5T2JqZWN0LCBjb250ZXh0KVxyXG57XHJcbiAgICB2YXIgdGVtcENvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcblxyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIGRpc3BsYXlPYmplY3QucmVuZGVyQ2FudmFzKHRoaXMpO1xyXG4gICAgdGhpcy5jb250ZXh0ID0gdGVtcENvbnRleHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQGV4dGVuZHMgUElYSS5TeXN0ZW1SZW5kZXJlciNyZXNpemVcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHdcclxuICogQHBhcmFtIHtudW1iZXJ9IGhcclxuICovXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAodywgaClcclxue1xyXG4gICAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZS5jYWxsKHRoaXMsIHcsIGgpO1xyXG5cclxuICAgIC8vcmVzZXQgdGhlIHNjYWxlIG1vZGUuLiBvZGRseSB0aGlzIHNlZW1zIHRvIGJlIHJlc2V0IHdoZW4gdGhlIGNhbnZhcyBpcyByZXNpemVkLlxyXG4gICAgLy9zdXJlbHkgYSBicm93c2VyIGJ1Zz8/IExldCBwaXhpIGZpeCB0aGF0IGZvciB5b3UuLlxyXG4gICAgaWYodGhpcy5zbW9vdGhQcm9wZXJ0eSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbnRleHRbdGhpcy5zbW9vdGhQcm9wZXJ0eV0gPSAoQ09OU1QuU0NBTEVfTU9ERVMuREVGQVVMVCA9PT0gQ09OU1QuU0NBTEVfTU9ERVMuTElORUFSKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogTWFwcyBQaXhpIGJsZW5kIG1vZGVzIHRvIGNhbnZhcyBibGVuZCBtb2Rlcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5fbWFwQmxlbmRNb2RlcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIGlmICghdGhpcy5ibGVuZE1vZGVzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlcyA9IHt9O1xyXG5cclxuICAgICAgICBpZiAodXRpbHMuY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlcygpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk5PUk1BTF0gICAgICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkFERF0gICAgICAgICAgID0gJ2xpZ2h0ZXInOyAvL0lTIFRISVMgT0s/Pz9cclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk1VTFRJUExZXSAgICAgID0gJ211bHRpcGx5JztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNDUkVFTl0gICAgICAgID0gJ3NjcmVlbic7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5PVkVSTEFZXSAgICAgICA9ICdvdmVybGF5JztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkRBUktFTl0gICAgICAgID0gJ2Rhcmtlbic7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5MSUdIVEVOXSAgICAgICA9ICdsaWdodGVuJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkNPTE9SX0RPREdFXSAgID0gJ2NvbG9yLWRvZGdlJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkNPTE9SX0JVUk5dICAgID0gJ2NvbG9yLWJ1cm4nO1xyXG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuSEFSRF9MSUdIVF0gICAgPSAnaGFyZC1saWdodCc7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5TT0ZUX0xJR0hUXSAgICA9ICdzb2Z0LWxpZ2h0JztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkRJRkZFUkVOQ0VdICAgID0gJ2RpZmZlcmVuY2UnO1xyXG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuRVhDTFVTSU9OXSAgICAgPSAnZXhjbHVzaW9uJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkhVRV0gICAgICAgICAgID0gJ2h1ZSc7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5TQVRVUkFUSU9OXSAgICA9ICdzYXR1cmF0ZSc7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5DT0xPUl0gICAgICAgICA9ICdjb2xvcic7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5MVU1JTk9TSVRZXSAgICA9ICdsdW1pbm9zaXR5JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIGNvb2wgbmV3IGJsZW5kIG1vZGVzIGluIGNhbnZhcyAnY291Z2gnIGllICdjb3VnaCdcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk5PUk1BTF0gICAgICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkFERF0gICAgICAgICAgID0gJ2xpZ2h0ZXInOyAvL0lTIFRISVMgT0s/Pz9cclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk1VTFRJUExZXSAgICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNDUkVFTl0gICAgICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk9WRVJMQVldICAgICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkRBUktFTl0gICAgICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkxJR0hURU5dICAgICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkNPTE9SX0RPREdFXSAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkNPTE9SX0JVUk5dICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkhBUkRfTElHSFRdICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNPRlRfTElHSFRdICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkRJRkZFUkVOQ0VdICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkVYQ0xVU0lPTl0gICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkhVRV0gICAgICAgICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNBVFVSQVRJT05dICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkNPTE9SXSAgICAgICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkxVTUlOT1NJVFldICAgID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVzIGEgQ2FudmFzIGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNpemUuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIHdpZHRoIGZvciB0aGUgbmV3bHkgY3JlYXRlZCBjYW52YXNcclxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgaGVpZ2h0IGZvciB0aGUgbmV3bHkgY3JlYXRlZCBjYW52YXNcclxuICovXHJcbmZ1bmN0aW9uIENhbnZhc0J1ZmZlcih3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBDYW52YXMgb2JqZWN0IHRoYXQgYmVsb25ncyB0byB0aGlzIENhbnZhc0J1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIG9iamVjdCByZXByZXNlbnRpbmcgYSB0d28tZGltZW5zaW9uYWwgcmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbn1cclxuXHJcbkNhbnZhc0J1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNCdWZmZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzQnVmZmVyO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FudmFzQnVmZmVyLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcyBidWZmZXIgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkNhbnZhc0J1ZmZlciNcclxuICAgICAqL1xyXG4gICAgd2lkdGg6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5DYW52YXNCdWZmZXIjXHJcbiAgICAgKi9cclxuICAgIGhlaWdodDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBDbGVhcnMgdGhlIGNhbnZhcyB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoZSBDYW52YXNCdWZmZXIgY2xhc3MuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5DYW52YXNCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXNpemVzIHRoZSBjYW52YXMgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxyXG4gKlxyXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzXHJcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNhbnZhc1xyXG4gKi9cclxuQ2FudmFzQnVmZmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXN0cm95cyB0aGlzIGNhbnZhcy5cclxuICpcclxuICovXHJcbkNhbnZhc0J1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XHJcbn07XHJcbiIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbnN0Jyk7XHJcblxyXG4vKipcclxuICogQSBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlciB0byBkcmF3IHRoZSBwcmltaXRpdmUgZ3JhcGhpY3MgZGF0YS5cclxuICogQHN0YXRpY1xyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICovXHJcbnZhciBDYW52YXNHcmFwaGljcyA9IHt9O1xyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc0dyYXBoaWNzO1xyXG5cclxuLypcclxuICogUmVuZGVycyBhIEdyYXBoaWNzIG9iamVjdCB0byBhIGNhbnZhcy5cclxuICpcclxuICogQHBhcmFtIGdyYXBoaWNzIHtQSVhJLkdyYXBoaWNzfSB0aGUgYWN0dWFsIGdyYXBoaWNzIG9iamVjdCB0byByZW5kZXJcclxuICogQHBhcmFtIGNvbnRleHQge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gdGhlIDJkIGRyYXdpbmcgbWV0aG9kIG9mIHRoZSBjYW52YXNcclxuICovXHJcbkNhbnZhc0dyYXBoaWNzLnJlbmRlckdyYXBoaWNzID0gZnVuY3Rpb24gKGdyYXBoaWNzLCBjb250ZXh0KVxyXG57XHJcbiAgICB2YXIgd29ybGRBbHBoYSA9IGdyYXBoaWNzLndvcmxkQWxwaGE7XHJcblxyXG4gICAgaWYgKGdyYXBoaWNzLmRpcnR5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudXBkYXRlR3JhcGhpY3NUaW50KGdyYXBoaWNzKTtcclxuICAgICAgICBncmFwaGljcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IGRhdGEuc2hhcGU7XHJcblxyXG4gICAgICAgIHZhciBmaWxsQ29sb3IgPSBkYXRhLl9maWxsVGludDtcclxuICAgICAgICB2YXIgbGluZUNvbG9yID0gZGF0YS5fbGluZVRpbnQ7XHJcblxyXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZGF0YS5saW5lV2lkdGg7XHJcblxyXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5QT0xZKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XHJcblxyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqPTE7IGogPCBwb2ludHMubGVuZ3RoLzI7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2ogKiAyXSwgcG9pbnRzW2ogKiAyICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2hhcGUuY2xvc2VkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludCBhcmUgdGhlIHNhbWUgY2xvc2UgdGhlIHBhdGggLSBtdWNoIG5lYXRlciA6KVxyXG4gICAgICAgICAgICBpZiAocG9pbnRzWzBdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXSAmJiBwb2ludHNbMV0gPT09IHBvaW50c1twb2ludHMubGVuZ3RoLTFdKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5maWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEubGluZVdpZHRoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBsaW5lQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLlJFQ1QpXHJcbiAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsbENvbG9yIHx8IGRhdGEuZmlsbENvbG9yID09PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdChzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEubGluZVdpZHRoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBsaW5lQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3Qoc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuQ0lSQylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGJlIFVuZGVmaW5lZCFcclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5hcmMoc2hhcGUueCwgc2hhcGUueSwgc2hhcGUucmFkaXVzLDAsMipNYXRoLlBJKTtcclxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLmZpbGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmZpbGxBbHBoYSAqIHdvcmxkQWxwaGE7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBmaWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGF0YS5saW5lV2lkdGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmxpbmVBbHBoYSAqIHdvcmxkQWxwaGE7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGxpbmVDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuRUxJUClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGVsbGlwc2UgY29kZSB0YWtlbiBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcclxuXHJcbiAgICAgICAgICAgIHZhciB3ID0gc2hhcGUud2lkdGggKiAyO1xyXG4gICAgICAgICAgICB2YXIgaCA9IHNoYXBlLmhlaWdodCAqIDI7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLnggLSB3LzI7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueSAtIGgvMjtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXHJcbiAgICAgICAgICAgICAgICBveCA9ICh3IC8gMikgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgb3kgPSAoaCAvIDIpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICB4ZSA9IHggKyB3LCAgICAgICAgICAgLy8geC1lbmRcclxuICAgICAgICAgICAgICAgIHllID0geSArIGgsICAgICAgICAgICAvLyB5LWVuZFxyXG4gICAgICAgICAgICAgICAgeG0gPSB4ICsgdyAvIDIsICAgICAgIC8vIHgtbWlkZGxlXHJcbiAgICAgICAgICAgICAgICB5bSA9IHkgKyBoIC8gMjsgICAgICAgLy8geS1taWRkbGVcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHltKTtcclxuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcclxuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xyXG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5maWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEubGluZVdpZHRoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBsaW5lQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLlJSRUMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcnggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgcnkgPSBzaGFwZS55O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHNoYXBlLnJhZGl1cztcclxuXHJcbiAgICAgICAgICAgIHZhciBtYXhSYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDIgfCAwO1xyXG4gICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgPiBtYXhSYWRpdXMgPyBtYXhSYWRpdXMgOiByYWRpdXM7XHJcblxyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhyeCwgcnkgKyByYWRpdXMpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocngsIHJ5ICsgaGVpZ2h0LCByeCArIHJhZGl1cywgcnkgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHdpZHRoIC0gcmFkaXVzLCByeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSArIGhlaWdodCwgcnggKyB3aWR0aCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHdpZHRoLCByeSArIHJhZGl1cyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSwgcnggKyB3aWR0aCAtIHJhZGl1cywgcnkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHJhZGl1cywgcnkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocngsIHJ5LCByeCwgcnkgKyByYWRpdXMpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsbENvbG9yIHx8IGRhdGEuZmlsbENvbG9yID09PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhLmxpbmVXaWR0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggbGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qXHJcbiAqIFJlbmRlcnMgYSBncmFwaGljcyBtYXNrXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSBncmFwaGljcyB7UElYSS5HcmFwaGljc30gdGhlIGdyYXBoaWNzIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIG1hc2tcclxuICogQHBhcmFtIGNvbnRleHQge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gdGhlIGNvbnRleHQgMmQgbWV0aG9kIG9mIHRoZSBjYW52YXNcclxuICovXHJcbkNhbnZhc0dyYXBoaWNzLnJlbmRlckdyYXBoaWNzTWFzayA9IGZ1bmN0aW9uIChncmFwaGljcywgY29udGV4dClcclxue1xyXG4gICAgdmFyIGxlbiA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGxlbiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IGRhdGEuc2hhcGU7XHJcblxyXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5QT0xZKVxyXG4gICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XHJcblxyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqPTE7IGogPCBwb2ludHMubGVuZ3RoLzI7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2ogKiAyXSwgcG9pbnRzW2ogKiAyICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXJlIHRoZSBzYW1lIGNsb3NlIHRoZSBwYXRoIC0gbXVjaCBuZWF0ZXIgOilcclxuICAgICAgICAgICAgaWYgKHBvaW50c1swXSA9PT0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl0gJiYgcG9pbnRzWzFdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUkVDVClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRleHQucmVjdChzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuQ0lSQylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGJlIFVuZGVmaW5lZCFcclxuICAgICAgICAgICAgY29udGV4dC5hcmMoc2hhcGUueCwgc2hhcGUueSwgc2hhcGUucmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLkVMSVApXHJcbiAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgLy8gZWxsaXBzZSBjb2RlIHRha2VuIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xyXG5cclxuICAgICAgICAgICAgdmFyIHcgPSBzaGFwZS53aWR0aCAqIDI7XHJcbiAgICAgICAgICAgIHZhciBoID0gc2hhcGUuaGVpZ2h0ICogMjtcclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueCAtIHcvMjtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55IC0gaC8yO1xyXG5cclxuICAgICAgICAgICAgdmFyIGthcHBhID0gMC41NTIyODQ4LFxyXG4gICAgICAgICAgICAgICAgb3ggPSAodyAvIDIpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIG95ID0gKGggLyAyKSAqIGthcHBhLCAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgeGUgPSB4ICsgdywgICAgICAgICAgIC8vIHgtZW5kXHJcbiAgICAgICAgICAgICAgICB5ZSA9IHkgKyBoLCAgICAgICAgICAgLy8geS1lbmRcclxuICAgICAgICAgICAgICAgIHhtID0geCArIHcgLyAyLCAgICAgICAvLyB4LW1pZGRsZVxyXG4gICAgICAgICAgICAgICAgeW0gPSB5ICsgaCAvIDI7ICAgICAgIC8vIHktbWlkZGxlXHJcblxyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5bSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcclxuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcclxuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLlJSRUMpXHJcbiAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgdmFyIHJ4ID0gc2hhcGUueDtcclxuICAgICAgICAgICAgdmFyIHJ5ID0gc2hhcGUueTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBzaGFwZS5yYWRpdXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWF4UmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyIHwgMDtcclxuICAgICAgICAgICAgcmFkaXVzID0gcmFkaXVzID4gbWF4UmFkaXVzID8gbWF4UmFkaXVzIDogcmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocngsIHJ5ICsgcmFkaXVzKTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocngsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcclxuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSArIGhlaWdodCwgcnggKyByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyB3aWR0aCAtIHJhZGl1cywgcnkgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocnggKyB3aWR0aCwgcnkgKyBoZWlnaHQsIHJ4ICsgd2lkdGgsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyB3aWR0aCwgcnkgKyByYWRpdXMpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocnggKyB3aWR0aCwgcnksIHJ4ICsgd2lkdGggLSByYWRpdXMsIHJ5KTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyByYWRpdXMsIHJ5KTtcclxuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSwgcngsIHJ5ICsgcmFkaXVzKTtcclxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKlxyXG4gKiBVcGRhdGVzIHRoZSB0aW50IG9mIGEgZ3JhcGhpY3Mgb2JqZWN0XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSBncmFwaGljcyB7UElYSS5HcmFwaGljc30gdGhlIGdyYXBoaWNzIHRoYXQgd2lsbCBoYXZlIGl0cyB0aW50IHVwZGF0ZWRcclxuICpcclxuICovXHJcbkNhbnZhc0dyYXBoaWNzLnVwZGF0ZUdyYXBoaWNzVGludCA9IGZ1bmN0aW9uIChncmFwaGljcylcclxue1xyXG4gICAgaWYgKGdyYXBoaWNzLnRpbnQgPT09IDB4RkZGRkZGICYmIGdyYXBoaWNzLl9wcmV2VGludCA9PT0gZ3JhcGhpY3MudGludClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBncmFwaGljcy5fcHJldlRpbnQgPSBncmFwaGljcy50aW50O1xyXG5cclxuICAgIHZhciB0aW50UiA9IChncmFwaGljcy50aW50ID4+IDE2ICYgMHhGRikgLyAyNTU7XHJcbiAgICB2YXIgdGludEcgPSAoZ3JhcGhpY3MudGludCA+PiA4ICYgMHhGRikgLyAyNTU7XHJcbiAgICB2YXIgdGludEIgPSAoZ3JhcGhpY3MudGludCAmIDB4RkYpLyAyNTU7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XHJcblxyXG4gICAgICAgIHZhciBmaWxsQ29sb3IgPSBkYXRhLmZpbGxDb2xvciB8IDA7XHJcbiAgICAgICAgdmFyIGxpbmVDb2xvciA9IGRhdGEubGluZUNvbG9yIHwgMDtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICB2YXIgY29sb3JSID0gKGZpbGxDb2xvciA+PiAxNiAmIDB4RkYpIC8gMjU1O1xyXG4gICAgICAgIHZhciBjb2xvckcgPSAoZmlsbENvbG9yID4+IDggJiAweEZGKSAvIDI1NTtcclxuICAgICAgICB2YXIgY29sb3JCID0gKGZpbGxDb2xvciAmIDB4RkYpIC8gMjU1O1xyXG5cclxuICAgICAgICBjb2xvclIgKj0gdGludFI7XHJcbiAgICAgICAgY29sb3JHICo9IHRpbnRHO1xyXG4gICAgICAgIGNvbG9yQiAqPSB0aW50QjtcclxuXHJcbiAgICAgICAgZmlsbENvbG9yID0gKChjb2xvclIqMjU1IDw8IDE2KSArIChjb2xvckcqMjU1IDw8IDgpICsgY29sb3JCKjI1NSk7XHJcblxyXG4gICAgICAgIGNvbG9yUiA9IChsaW5lQ29sb3IgPj4gMTYgJiAweEZGKSAvIDI1NTtcclxuICAgICAgICBjb2xvckcgPSAobGluZUNvbG9yID4+IDggJiAweEZGKSAvIDI1NTtcclxuICAgICAgICBjb2xvckIgPSAobGluZUNvbG9yICYgMHhGRikgLyAyNTU7XHJcblxyXG4gICAgICAgIGNvbG9yUiAqPSB0aW50UjtcclxuICAgICAgICBjb2xvckcgKj0gdGludEc7XHJcbiAgICAgICAgY29sb3JCICo9IHRpbnRCO1xyXG5cclxuICAgICAgICBsaW5lQ29sb3IgPSAoKGNvbG9yUioyNTUgPDwgMTYpICsgKGNvbG9yRyoyNTUgPDwgOCkgKyBjb2xvckIqMjU1KTtcclxuICAgICAgICAqL1xyXG5cclxuICAgICAgICAvLyBzdXBlciBpbmxpbmUgY29zIGltIGFuIG9wdGltaXphdGlvbiBOQVpJIDopXHJcbiAgICAgICAgZGF0YS5fZmlsbFRpbnQgPSAoKChmaWxsQ29sb3IgPj4gMTYgJiAweEZGKSAvIDI1NSAqIHRpbnRSKjI1NSA8PCAxNikgKyAoKGZpbGxDb2xvciA+PiA4ICYgMHhGRikgLyAyNTUgKiB0aW50RyoyNTUgPDwgOCkgKyAgKGZpbGxDb2xvciAmIDB4RkYpIC8gMjU1ICogdGludEIqMjU1KTtcclxuICAgICAgICBkYXRhLl9saW5lVGludCA9ICgoKGxpbmVDb2xvciA+PiAxNiAmIDB4RkYpIC8gMjU1ICogdGludFIqMjU1IDw8IDE2KSArICgobGluZUNvbG9yID4+IDggJiAweEZGKSAvIDI1NSAqIHRpbnRHKjI1NSA8PCA4KSArICAobGluZUNvbG9yICYgMHhGRikgLyAyNTUgKiB0aW50QioyNTUpO1xyXG5cclxuICAgIH1cclxufTtcclxuXHJcbiIsInZhciBDYW52YXNHcmFwaGljcyA9IHJlcXVpcmUoJy4vQ2FudmFzR3JhcGhpY3MnKTtcclxuXHJcbi8qKlxyXG4gKiBBIHNldCBvZiBmdW5jdGlvbnMgdXNlZCB0byBoYW5kbGUgbWFza2luZy5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqL1xyXG5mdW5jdGlvbiBDYW52YXNNYXNrTWFuYWdlcigpXHJcbnt9XHJcblxyXG5DYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNNYXNrTWFuYWdlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNNYXNrTWFuYWdlcjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hc2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWFza0RhdGEge29iamVjdH0gdGhlIG1hc2tEYXRhIHRoYXQgd2lsbCBiZSBwdXNoZWRcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ8UElYSS5DYW52YXNSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIGNvbnRleHQgdG8gdXNlLlxyXG4gKi9cclxuQ2FudmFzTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hNYXNrID0gZnVuY3Rpb24gKG1hc2tEYXRhLCByZW5kZXJlcilcclxue1xyXG5cclxuICAgIHJlbmRlcmVyLmNvbnRleHQuc2F2ZSgpO1xyXG5cclxuICAgIHZhciBjYWNoZUFscGhhID0gbWFza0RhdGEuYWxwaGE7XHJcbiAgICB2YXIgdHJhbnNmb3JtID0gbWFza0RhdGEud29ybGRUcmFuc2Zvcm07XHJcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XHJcblxyXG4gICAgcmVuZGVyZXIuY29udGV4dC5zZXRUcmFuc2Zvcm0oXHJcbiAgICAgICAgdHJhbnNmb3JtLmEgKiByZXNvbHV0aW9uLFxyXG4gICAgICAgIHRyYW5zZm9ybS5iICogcmVzb2x1dGlvbixcclxuICAgICAgICB0cmFuc2Zvcm0uYyAqIHJlc29sdXRpb24sXHJcbiAgICAgICAgdHJhbnNmb3JtLmQgKiByZXNvbHV0aW9uLFxyXG4gICAgICAgIHRyYW5zZm9ybS50eCAqIHJlc29sdXRpb24sXHJcbiAgICAgICAgdHJhbnNmb3JtLnR5ICogcmVzb2x1dGlvblxyXG4gICAgKTtcclxuXHJcbiAgICAvL1RPRE8gc3Vwb3J0IHNwcml0ZSBhbHBoYSBtYXNrcz8/XHJcbiAgICAvL2xvdHMgb2YgZWZmb3J0IHJlcXVpcmVkLiBJZiBkZW1hbmQgaXMgZ3JlYXQgZW5vdWdoLi5cclxuICAgIGlmKCFtYXNrRGF0YS50ZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIENhbnZhc0dyYXBoaWNzLnJlbmRlckdyYXBoaWNzTWFzayhtYXNrRGF0YSwgcmVuZGVyZXIuY29udGV4dCk7XHJcbiAgICAgICAgcmVuZGVyZXIuY29udGV4dC5jbGlwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWFza0RhdGEud29ybGRBbHBoYSA9IGNhY2hlQWxwaGE7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVzdG9yZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBjb250ZXh0IHRvIHRoZSBzdGF0ZSBpdCB3YXMgYmVmb3JlIHRoZSBtYXNrIHdhcyBhcHBsaWVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcnxQSVhJLkNhbnZhc1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgY29udGV4dCB0byB1c2UuXHJcbiAqL1xyXG5DYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wTWFzayA9IGZ1bmN0aW9uIChyZW5kZXJlcilcclxue1xyXG4gICAgcmVuZGVyZXIuY29udGV4dC5yZXN0b3JlKCk7XHJcbn07XHJcblxyXG5DYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9O1xyXG4iLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xyXG5cclxuLyoqXHJcbiAqIFV0aWxpdHkgbWV0aG9kcyBmb3IgU3ByaXRlL1RleHR1cmUgdGludGluZy5cclxuICogQHN0YXRpY1xyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICovXHJcbnZhciBDYW52YXNUaW50ZXIgPSB7fTtcclxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNUaW50ZXI7XHJcblxyXG4vKipcclxuICogQmFzaWNhbGx5IHRoaXMgbWV0aG9kIGp1c3QgbmVlZHMgYSBzcHJpdGUgYW5kIGEgY29sb3IgYW5kIHRpbnRzIHRoZSBzcHJpdGUgd2l0aCB0aGUgZ2l2ZW4gY29sb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcHJpdGUge1BJWEkuU3ByaXRlfSB0aGUgc3ByaXRlIHRvIHRpbnRcclxuICogQHBhcmFtIGNvbG9yIHtudW1iZXJ9IHRoZSBjb2xvciB0byB1c2UgdG8gdGludCB0aGUgc3ByaXRlIHdpdGhcclxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IFRoZSB0aW50ZWQgY2FudmFzXHJcbiAqL1xyXG5DYW52YXNUaW50ZXIuZ2V0VGludGVkVGV4dHVyZSA9IGZ1bmN0aW9uIChzcHJpdGUsIGNvbG9yKVxyXG57XHJcbiAgICB2YXIgdGV4dHVyZSA9IHNwcml0ZS50ZXh0dXJlO1xyXG5cclxuICAgIGNvbG9yID0gQ2FudmFzVGludGVyLnJvdW5kQ29sb3IoY29sb3IpO1xyXG5cclxuICAgIHZhciBzdHJpbmdDb2xvciA9ICcjJyArICgnMDAwMDAnICsgKCBjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcclxuXHJcbiAgICB0ZXh0dXJlLnRpbnRDYWNoZSA9IHRleHR1cmUudGludENhY2hlIHx8IHt9O1xyXG5cclxuICAgIGlmICh0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl0pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmUudGludENhY2hlW3N0cmluZ0NvbG9yXTtcclxuICAgIH1cclxuXHJcbiAgICAgLy8gY2xvbmUgdGV4dHVyZS4uXHJcbiAgICB2YXIgY2FudmFzID0gQ2FudmFzVGludGVyLmNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuXHJcbiAgICAvL0NhbnZhc1RpbnRlci50aW50V2l0aFBlclBpeGVsKHRleHR1cmUsIHN0cmluZ0NvbG9yLCBjYW52YXMpO1xyXG4gICAgQ2FudmFzVGludGVyLnRpbnRNZXRob2QodGV4dHVyZSwgY29sb3IsIGNhbnZhcyk7XHJcblxyXG4gICAgaWYgKENhbnZhc1RpbnRlci5jb252ZXJ0VGludFRvSW1hZ2UpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gaXMgdGhpcyBiZXR0ZXI/XHJcbiAgICAgICAgdmFyIHRpbnRJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIHRpbnRJbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XHJcblxyXG4gICAgICAgIHRleHR1cmUudGludENhY2hlW3N0cmluZ0NvbG9yXSA9IHRpbnRJbWFnZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl0gPSBjYW52YXM7XHJcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBjb252ZXJ0aW5nIHRoZSB0ZXh0dXJlIHRvIGFuIGltYWdlIHRoZW4gd2UgbmVlZCB0byBsb3NlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhc1xyXG4gICAgICAgIENhbnZhc1RpbnRlci5jYW52YXMgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYW52YXM7XHJcbn07XHJcblxyXG4vKipcclxuICogVGludCBhIHRleHR1cmUgdXNpbmcgdGhlICdtdWx0aXBseScgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5UZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB0aW50XHJcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXHJcbiAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY3VycmVudCBjYW52YXNcclxuICovXHJcbkNhbnZhc1RpbnRlci50aW50V2l0aE11bHRpcGx5ID0gZnVuY3Rpb24gKHRleHR1cmUsIGNvbG9yLCBjYW52YXMpXHJcbntcclxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuXHJcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcclxuXHJcbiAgICB2YXIgY3JvcCA9IHRleHR1cmUuY3JvcC5jbG9uZSgpO1xyXG4gICAgY3JvcC54ICo9IHJlc29sdXRpb247XHJcbiAgICBjcm9wLnkgKj0gcmVzb2x1dGlvbjtcclxuICAgIGNyb3Aud2lkdGggKj0gcmVzb2x1dGlvbjtcclxuICAgIGNyb3AuaGVpZ2h0ICo9IHJlc29sdXRpb247XHJcblxyXG4gICAgY2FudmFzLndpZHRoID0gY3JvcC53aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBjcm9wLmhlaWdodDtcclxuXHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcclxuXHJcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcclxuXHJcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XHJcblxyXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXHJcbiAgICAgICAgY3JvcC54LFxyXG4gICAgICAgIGNyb3AueSxcclxuICAgICAgICBjcm9wLndpZHRoLFxyXG4gICAgICAgIGNyb3AuaGVpZ2h0LFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgMCxcclxuICAgICAgICBjcm9wLndpZHRoLFxyXG4gICAgICAgIGNyb3AuaGVpZ2h0XHJcbiAgICApO1xyXG5cclxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWF0b3AnO1xyXG5cclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxyXG4gICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxyXG4gICAgICAgIGNyb3AueCxcclxuICAgICAgICBjcm9wLnksXHJcbiAgICAgICAgY3JvcC53aWR0aCxcclxuICAgICAgICBjcm9wLmhlaWdodCxcclxuICAgICAgICAwLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgY3JvcC53aWR0aCxcclxuICAgICAgICBjcm9wLmhlaWdodFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaW50IGEgdGV4dHVyZSB1c2luZyB0aGUgJ292ZXJsYXknIG9wZXJhdGlvbi5cclxuICpcclxuICogQHBhcmFtIHRleHR1cmUge1BJWEkuVGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gdGludFxyXG4gKiBAcGFyYW0gY29sb3Ige251bWJlcn0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxyXG4gKiBAcGFyYW0gY2FudmFzIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGN1cnJlbnQgY2FudmFzXHJcbiAqL1xyXG5DYW52YXNUaW50ZXIudGludFdpdGhPdmVybGF5ID0gZnVuY3Rpb24gKHRleHR1cmUsIGNvbG9yLCBjYW52YXMpXHJcbntcclxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuXHJcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcclxuXHJcbiAgICB2YXIgY3JvcCA9IHRleHR1cmUuY3JvcC5jbG9uZSgpO1xyXG4gICAgY3JvcC54ICo9IHJlc29sdXRpb247XHJcbiAgICBjcm9wLnkgKj0gcmVzb2x1dGlvbjtcclxuICAgIGNyb3Aud2lkdGggKj0gcmVzb2x1dGlvbjtcclxuICAgIGNyb3AuaGVpZ2h0ICo9IHJlc29sdXRpb247XHJcblxyXG4gICAgY2FudmFzLndpZHRoID0gY3JvcC53aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBjcm9wLmhlaWdodDtcclxuXHJcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xyXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjcm9wLndpZHRoLCBjcm9wLmhlaWdodCk7XHJcblxyXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tYXRvcCc7XHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZShcclxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcclxuICAgICAgICBjcm9wLngsXHJcbiAgICAgICAgY3JvcC55LFxyXG4gICAgICAgIGNyb3Aud2lkdGgsXHJcbiAgICAgICAgY3JvcC5oZWlnaHQsXHJcbiAgICAgICAgMCxcclxuICAgICAgICAwLFxyXG4gICAgICAgIGNyb3Aud2lkdGgsXHJcbiAgICAgICAgY3JvcC5oZWlnaHRcclxuICAgICk7XHJcblxyXG4gICAgLy8gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XHJcbn07XHJcblxyXG4vKipcclxuICogVGludCBhIHRleHR1cmUgcGl4ZWwgcGVyIHBpeGVsLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5UZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB0aW50XHJcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXHJcbiAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY3VycmVudCBjYW52YXNcclxuICovXHJcbkNhbnZhc1RpbnRlci50aW50V2l0aFBlclBpeGVsID0gZnVuY3Rpb24gKHRleHR1cmUsIGNvbG9yLCBjYW52YXMpXHJcbntcclxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuXHJcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcclxuXHJcbiAgICB2YXIgY3JvcCA9IHRleHR1cmUuY3JvcC5jbG9uZSgpO1xyXG4gICAgY3JvcC54ICo9IHJlc29sdXRpb247XHJcbiAgICBjcm9wLnkgKj0gcmVzb2x1dGlvbjtcclxuICAgIGNyb3Aud2lkdGggKj0gcmVzb2x1dGlvbjtcclxuICAgIGNyb3AuaGVpZ2h0ICo9IHJlc29sdXRpb247XHJcblxyXG4gICAgY2FudmFzLndpZHRoID0gY3JvcC53aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBjcm9wLmhlaWdodDtcclxuXHJcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxyXG4gICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxyXG4gICAgICAgIGNyb3AueCxcclxuICAgICAgICBjcm9wLnksXHJcbiAgICAgICAgY3JvcC53aWR0aCxcclxuICAgICAgICBjcm9wLmhlaWdodCxcclxuICAgICAgICAwLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgY3JvcC53aWR0aCxcclxuICAgICAgICBjcm9wLmhlaWdodFxyXG4gICAgKTtcclxuXHJcbiAgICB2YXIgcmdiVmFsdWVzID0gdXRpbHMuaGV4MnJnYihjb2xvcik7XHJcbiAgICB2YXIgciA9IHJnYlZhbHVlc1swXSwgZyA9IHJnYlZhbHVlc1sxXSwgYiA9IHJnYlZhbHVlc1syXTtcclxuXHJcbiAgICB2YXIgcGl4ZWxEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY3JvcC53aWR0aCwgY3JvcC5oZWlnaHQpO1xyXG5cclxuICAgIHZhciBwaXhlbHMgPSBwaXhlbERhdGEuZGF0YTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBpeGVscy5sZW5ndGg7IGkgKz0gNClcclxuICAgIHtcclxuICAgICAgICBwaXhlbHNbaSswXSAqPSByO1xyXG4gICAgICAgIHBpeGVsc1tpKzFdICo9IGc7XHJcbiAgICAgICAgcGl4ZWxzW2krMl0gKj0gYjtcclxuICAgIH1cclxuXHJcbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShwaXhlbERhdGEsIDAsIDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJvdW5kcyB0aGUgc3BlY2lmaWVkIGNvbG9yIGFjY29yZGluZyB0byB0aGUgQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWwuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gcm91bmQsIHNob3VsZCBiZSBhIGhleCBjb2xvclxyXG4gKi9cclxuQ2FudmFzVGludGVyLnJvdW5kQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IpXHJcbntcclxuICAgIHZhciBzdGVwID0gQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWw7XHJcblxyXG4gICAgdmFyIHJnYlZhbHVlcyA9IHV0aWxzLmhleDJyZ2IoY29sb3IpO1xyXG5cclxuICAgIHJnYlZhbHVlc1swXSA9IE1hdGgubWluKDI1NSwgKHJnYlZhbHVlc1swXSAvIHN0ZXApICogc3RlcCk7XHJcbiAgICByZ2JWYWx1ZXNbMV0gPSBNYXRoLm1pbigyNTUsIChyZ2JWYWx1ZXNbMV0gLyBzdGVwKSAqIHN0ZXApO1xyXG4gICAgcmdiVmFsdWVzWzJdID0gTWF0aC5taW4oMjU1LCAocmdiVmFsdWVzWzJdIC8gc3RlcCkgKiBzdGVwKTtcclxuXHJcbiAgICByZXR1cm4gdXRpbHMucmdiMmhleChyZ2JWYWx1ZXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE51bWJlciBvZiBzdGVwcyB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBjYXAgd2hlbiByb3VuZGluZyBjb2xvcnMuXHJcbiAqXHJcbiAqIEBtZW1iZXJcclxuICovXHJcbkNhbnZhc1RpbnRlci5jYWNoZVN0ZXBzUGVyQ29sb3JDaGFubmVsID0gODtcclxuXHJcbi8qKlxyXG4gKiBUaW50IGNhY2hlIGJvb2xlYW4gZmxhZy5cclxuICpcclxuICogQG1lbWJlclxyXG4gKi9cclxuQ2FudmFzVGludGVyLmNvbnZlcnRUaW50VG9JbWFnZSA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBDYW52YXMgQmxlbmRNb2RlcyBhcmUgc3VwcG9ydGVkLCBjb25zZXF1ZW50bHkgdGhlIGFiaWxpdHkgdG8gdGludCB1c2luZyB0aGUgbXVsdGlwbHkgbWV0aG9kLlxyXG4gKlxyXG4gKiBAbWVtYmVyXHJcbiAqL1xyXG5DYW52YXNUaW50ZXIuY2FuVXNlTXVsdGlwbHkgPSB1dGlscy5jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzKCk7XHJcblxyXG4vKipcclxuICogVGhlIHRpbnRpbmcgbWV0aG9kIHRoYXQgd2lsbCBiZSB1c2VkLlxyXG4gKlxyXG4gKi9cclxuQ2FudmFzVGludGVyLnRpbnRNZXRob2QgPSBDYW52YXNUaW50ZXIuY2FuVXNlTXVsdGlwbHkgPyBDYW52YXNUaW50ZXIudGludFdpdGhNdWx0aXBseSA6ICBDYW52YXNUaW50ZXIudGludFdpdGhQZXJQaXhlbDtcclxuIiwidmFyIFN5c3RlbVJlbmRlcmVyID0gcmVxdWlyZSgnLi4vU3lzdGVtUmVuZGVyZXInKSxcclxuICAgIFNoYWRlck1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXJzL1NoYWRlck1hbmFnZXInKSxcclxuICAgIE1hc2tNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9NYXNrTWFuYWdlcicpLFxyXG4gICAgU3RlbmNpbE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXJzL1N0ZW5jaWxNYW5hZ2VyJyksXHJcbiAgICBGaWx0ZXJNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9GaWx0ZXJNYW5hZ2VyJyksXHJcbiAgICBCbGVuZE1vZGVNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9CbGVuZE1vZGVNYW5hZ2VyJyksXHJcbiAgICBSZW5kZXJUYXJnZXQgPSByZXF1aXJlKCcuL3V0aWxzL1JlbmRlclRhcmdldCcpLFxyXG4gICAgT2JqZWN0UmVuZGVyZXIgPSByZXF1aXJlKCcuL3V0aWxzL09iamVjdFJlbmRlcmVyJyksXHJcbiAgICBGWEFBRmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXJzL0ZYQUFGaWx0ZXInKSxcclxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKSxcclxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgV2ViR0xSZW5kZXJlciBkcmF3cyB0aGUgc2NlbmUgYW5kIGFsbCBpdHMgY29udGVudCBvbnRvIGEgd2ViR0wgZW5hYmxlZCBjYW52YXMuIFRoaXMgcmVuZGVyZXJcclxuICogc2hvdWxkIGJlIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB3ZWJHTC4gVGhpcyBSZW5kZXIgd29ya3MgYnkgYXV0b21hdGljYWxseSBtYW5hZ2luZyB3ZWJHTEJhdGNocy5cclxuICogU28gbm8gbmVlZCBmb3IgU3ByaXRlIEJhdGNoZXMgb3IgU3ByaXRlIENsb3Vkcy5cclxuICogRG9uJ3QgZm9yZ2V0IHRvIGFkZCB0aGUgdmlldyB0byB5b3VyIERPTSBvciB5b3Ugd2lsbCBub3Qgc2VlIGFueXRoaW5nIDopXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAZXh0ZW5kcyBQSVhJLlN5c3RlbVJlbmRlcmVyXHJcbiAqIEBwYXJhbSBbd2lkdGg9MF0ge251bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgdmlld1xyXG4gKiBAcGFyYW0gW2hlaWdodD0wXSB7bnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgdmlld1xyXG4gKiBAcGFyYW0gW29wdGlvbnNdIHtvYmplY3R9IFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy52aWV3XSB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcclxuICogQHBhcmFtIFtvcHRpb25zLnRyYW5zcGFyZW50PWZhbHNlXSB7Ym9vbGVhbn0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50LCBkZWZhdWx0IGZhbHNlXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5hdXRvUmVzaXplPWZhbHNlXSB7Ym9vbGVhbn0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIGF1dG9tYXRpY2FsbHkgcmVzaXplZCwgZGVmYXVsdCBmYWxzZVxyXG4gKiBAcGFyYW0gW29wdGlvbnMuYW50aWFsaWFzPWZhbHNlXSB7Ym9vbGVhbn0gc2V0cyBhbnRpYWxpYXMuIElmIG5vdCBhdmFpbGFibGUgbmF0aXZlbHkgdGhlbiBGWEFBIGFudGlhbGlhc2luZyBpcyB1c2VkXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5mb3JjZUZYQUE9ZmFsc2VdIHtib29sZWFufSBmb3JjZXMgRlhBQSBhbnRpYWxpYXNpbmcgdG8gYmUgdXNlZCBvdmVyIG5hdGl2ZS4gRlhBQSBpcyBmYXN0ZXIsIGJ1dCBtYXkgbm90IGFsd2F5cyBsb29rIGFzIGdyZWF0XHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5yZXNvbHV0aW9uPTFdIHtudW1iZXJ9IHRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJlciByZXRpbmEgd291bGQgYmUgMlxyXG4gKiBAcGFyYW0gW29wdGlvbnMuY2xlYXJCZWZvcmVSZW5kZXI9dHJ1ZV0ge2Jvb2xlYW59IFRoaXMgc2V0cyBpZiB0aGUgQ2FudmFzUmVuZGVyZXIgd2lsbCBjbGVhciB0aGUgY2FudmFzIG9yXHJcbiAqICAgICAgbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLiBJZiB5b3Ugd2lzaCB0byBzZXQgdGhpcyB0byBmYWxzZSwgeW91ICptdXN0KiBzZXQgcHJlc2VydmVEcmF3aW5nQnVmZmVyIHRvIGB0cnVlYC5cclxuICogQHBhcmFtIFtvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV0ge2Jvb2xlYW59IGVuYWJsZXMgZHJhd2luZyBidWZmZXIgcHJlc2VydmF0aW9uLCBlbmFibGUgdGhpcyBpZlxyXG4gKiAgICAgIHlvdSBuZWVkIHRvIGNhbGwgdG9EYXRhVXJsIG9uIHRoZSB3ZWJnbCBjb250ZXh0LlxyXG4gKiBAcGFyYW0gW29wdGlvbnMucm91bmRQaXhlbHM9ZmFsc2VdIHtib29sZWFufSBJZiB0cnVlIFBpeGkgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuIHJlbmRlcmluZywgc3RvcHBpbmcgcGl4ZWwgaW50ZXJwb2xhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIod2lkdGgsIGhlaWdodCwgb3B0aW9ucylcclxue1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgU3lzdGVtUmVuZGVyZXIuY2FsbCh0aGlzLCAnV2ViR0wnLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgcmVuZGVyZXIgYXMgYSBzdGFuZGFyZGlzZWQgY29uc3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGUgPSBDT05TVC5SRU5ERVJFUl9UWVBFLldFQkdMO1xyXG5cclxuICAgIHRoaXMuaGFuZGxlQ29udGV4dExvc3QgPSB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy52aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LCBmYWxzZSk7XHJcbiAgICB0aGlzLnZpZXcuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCwgZmFsc2UpO1xyXG5cclxuICAgIC8vVE9ETyBwb3NzaWJpbGl0eSB0byBmb3JjZSBGWEFBIGFzIGl0IG1heSBvZmZlciBiZXR0ZXIgcGVyZm9ybWFuY2U/XHJcbiAgICAvKipcclxuICAgICAqIERvZXMgaXQgdXNlIEZYQUEgP1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl91c2VGWEFBID0gISFvcHRpb25zLmZvcmNlRlhBQSAmJiBvcHRpb25zLmFudGlhbGlhcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmeGFhIGZpbHRlclxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuRlhBQUZpbHRlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX0ZYQUFGaWx0ZXIgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGluIHRvIGNyZWF0ZSBhIG5ldyB3ZWJnbCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge29iamVjdH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2NvbnRleHRPcHRpb25zID0ge1xyXG4gICAgICAgIGFscGhhOiB0aGlzLnRyYW5zcGFyZW50LFxyXG4gICAgICAgIGFudGlhbGlhczogb3B0aW9ucy5hbnRpYWxpYXMsXHJcbiAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0aGlzLnRyYW5zcGFyZW50ICYmIHRoaXMudHJhbnNwYXJlbnQgIT09ICdub3RNdWx0aXBsaWVkJyxcclxuICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXJcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3VudGVyIGZvciB0aGUgbnVtYmVyIG9mIGRyYXdzIG1hZGUgZWFjaCBmcmFtZVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmF3Q291bnQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVhbHMgd2l0aCBtYW5hZ2luZyB0aGUgc2hhZGVyIHByb2dyYW1zIGFuZCB0aGVpciBhdHRyaWJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuU2hhZGVyTWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaGFkZXJNYW5hZ2VyID0gbmV3IFNoYWRlck1hbmFnZXIodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYW5hZ2VzIHRoZSBtYXNrcyB1c2luZyB0aGUgc3RlbmNpbCBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5NYXNrTWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBNYXNrTWFuYWdlcih0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hbmFnZXMgdGhlIHN0ZW5jaWwgYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuU3RlbmNpbE1hbmFnZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RlbmNpbE1hbmFnZXIgPSBuZXcgU3RlbmNpbE1hbmFnZXIodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYW5hZ2VzIHRoZSBmaWx0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuRmlsdGVyTWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gbmV3IEZpbHRlck1hbmFnZXIodGhpcyk7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFuYWdlcyB0aGUgYmxlbmRNb2Rlc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuQmxlbmRNb2RlTWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ibGVuZE1vZGVNYW5hZ2VyID0gbmV3IEJsZW5kTW9kZU1hbmFnZXIodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5SZW5kZXJUYXJnZXR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBPYmplY3RSZW5kZXJlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk9iamVjdFJlbmRlcmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IG5ldyBPYmplY3RSZW5kZXJlcih0aGlzKTtcclxuXHJcbiAgICB0aGlzLmluaXRQbHVnaW5zKCk7XHJcblxyXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgY29udGV4dCBzbyBpdCBpcyByZWFkeSBmb3IgdGhlIG1hbmFnZXJzLlxyXG4gICAgdGhpcy5fY3JlYXRlQ29udGV4dCgpO1xyXG4gICAgdGhpcy5faW5pdENvbnRleHQoKTtcclxuXHJcbiAgICAvLyBtYXAgc29tZSB3ZWJHTCBibGVuZCBtb2Rlcy4uXHJcbiAgICB0aGlzLl9tYXBHbE1vZGVzKCk7XHJcblxyXG4gICAgLy8gdHJhY2sgdGV4dHVyZXMgaW4gdGhlIHJlbmRlcmVyIHNvIHdlIGNhbiBubyBsb25nZXIgbGlzdGVuIHRvIHRoZW0gb24gZGVzdHJ1Y3Rpb24uXHJcbiAgICB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHJlbmRlciB0YXJnZXRzXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlbmRlclRhcmdldFtdfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0U3RhY2sgPSBbXTtcclxufVxyXG5cclxuLy8gY29uc3RydWN0b3JcclxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZSk7XHJcbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2ViR0xSZW5kZXJlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBXZWJHTFJlbmRlcmVyO1xyXG51dGlscy5wbHVnaW5UYXJnZXQubWl4aW4oV2ViR0xSZW5kZXJlcik7XHJcblxyXG5XZWJHTFJlbmRlcmVyLmdsQ29udGV4dElkID0gMDtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHRoZSBnbCBjb250ZXh0LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuX2NyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnd2ViZ2wnLCB0aGlzLl9jb250ZXh0T3B0aW9ucykgfHwgdGhpcy52aWV3LmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHRoaXMuX2NvbnRleHRPcHRpb25zKTtcclxuICAgIHRoaXMuZ2wgPSBnbDtcclxuXHJcbiAgICBpZiAoIWdsKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGZhaWwsIG5vdCBhYmxlIHRvIGdldCBhIGNvbnRleHRcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ2xDb250ZXh0SWQgPSBXZWJHTFJlbmRlcmVyLmdsQ29udGV4dElkKys7XHJcbiAgICBnbC5pZCA9IHRoaXMuZ2xDb250ZXh0SWQ7XHJcbiAgICBnbC5yZW5kZXJlciA9IHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyB0aGUgV2ViR0wgY29udGV4dFxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuX2luaXRDb250ZXh0ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAvLyBzZXQgdXAgdGhlIGRlZmF1bHQgcGl4aSBzZXR0aW5ncy4uXHJcbiAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoZ2wsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBudWxsLCB0aGlzLnJlc29sdXRpb24sIHRydWUpO1xyXG5cclxuICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVGFyZ2V0KTtcclxuXHJcbiAgICB0aGlzLmVtaXQoJ2NvbnRleHQnLCBnbCk7XHJcblxyXG4gICAgLy8gc2V0dXAgdGhlIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzIGFuZCBnbCB2aWV3cG9ydFxyXG4gICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgIGlmKCF0aGlzLl91c2VGWEFBKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3VzZUZYQUEgPSAodGhpcy5fY29udGV4dE9wdGlvbnMuYW50aWFsaWFzICYmICEgZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKS5hbnRpYWxpYXMpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZih0aGlzLl91c2VGWEFBKVxyXG4gICAge1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oJ0ZYQUEgYW50aWFsaWFzaW5nIGJlaW5nIHVzZWQgaW5zdGVhZCBvZiBuYXRpdmUgYW50aWFsaWFzaW5nJyk7XHJcbiAgICAgICAgdGhpcy5fRlhBQUZpbHRlciA9IFtuZXcgRlhBQUZpbHRlcigpXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gaXRzIHdlYkdMIHZpZXdcclxuICpcclxuICogQHBhcmFtIG9iamVjdCB7UElYSS5EaXNwbGF5T2JqZWN0fSB0aGUgb2JqZWN0IHRvIGJlIHJlbmRlcmVkXHJcbiAqL1xyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAob2JqZWN0KVxyXG57XHJcblxyXG4gICAgdGhpcy5lbWl0KCdwcmVyZW5kZXInKTtcclxuXHJcbiAgICAvLyBubyBwb2ludCByZW5kZXJpbmcgaWYgb3VyIGNvbnRleHQgaGFzIGJlZW4gYmxvd24gdXAhXHJcbiAgICBpZiAodGhpcy5nbC5pc0NvbnRleHRMb3N0KCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJhd0NvdW50ID0gMDtcclxuXHJcbiAgICB0aGlzLl9sYXN0T2JqZWN0UmVuZGVyZWQgPSBvYmplY3Q7XHJcblxyXG4gICAgaWYodGhpcy5fdXNlRlhBQSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9GWEFBRmlsdGVyWzBdLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUueCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fRlhBQUZpbHRlclswXS51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnkgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICBvYmplY3QuZmlsdGVyQXJlYSA9IHRoaXMucmVuZGVyVGFyZ2V0LnNpemU7XHJcbiAgICAgICAgb2JqZWN0LmZpbHRlcnMgPSB0aGlzLl9GWEFBRmlsdGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjYWNoZVBhcmVudCA9IG9iamVjdC5wYXJlbnQ7XHJcbiAgICBvYmplY3QucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XHJcblxyXG4gICAgLy8gdXBkYXRlIHRoZSBzY2VuZSBncmFwaFxyXG4gICAgb2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgIG9iamVjdC5wYXJlbnQgPSBjYWNoZVBhcmVudDtcclxuXHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgYm91bmQgdG8gdGhlIG1haW4gZnJhbWUgYnVmZmVyXHJcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRhcmdldCk7XHJcblxyXG4gICAgaWYgKHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwYXJlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKHRoaXMuX2JhY2tncm91bmRDb2xvclJnYlswXSwgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiWzFdLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JbMl0sIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZW5kZXJEaXNwbGF5T2JqZWN0KG9iamVjdCwgdGhpcy5yZW5kZXJUYXJnZXQpOy8vdGhpcy5wcm9qZWN0aW9uKTtcclxuXHJcbiAgICB0aGlzLmVtaXQoJ3Bvc3RyZW5kZXInKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIGEgRGlzcGxheSBPYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIHJlbmRlclxyXG4gKiBAcGFyYW0gcmVuZGVyVGFyZ2V0IHtQSVhJLlJlbmRlclRhcmdldH0gVGhlIHJlbmRlciB0YXJnZXQgdG8gdXNlIHRvIHJlbmRlciB0aGlzIGRpc3BsYXkgb2JqZWN0XHJcbiAqXHJcbiAqL1xyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJEaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24gKGRpc3BsYXlPYmplY3QsIHJlbmRlclRhcmdldCwgY2xlYXIpLy9wcm9qZWN0aW9uLCBidWZmZXIpXHJcbntcclxuICAgIC8vIFRPRE8gaXMgdGhpcyBuZWVkZWQuLi5cclxuICAgIC8vdGhpcy5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZShDT05TVC5CTEVORF9NT0RFUy5OT1JNQUwpO1xyXG4gICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcclxuXHJcbiAgICBpZihjbGVhcilcclxuICAgIHtcclxuICAgICAgICByZW5kZXJUYXJnZXQuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzdGFydCB0aGUgZmlsdGVyIG1hbmFnZXJcclxuICAgIHRoaXMuZmlsdGVyTWFuYWdlci5zZXRGaWx0ZXJTdGFjayggcmVuZGVyVGFyZ2V0LmZpbHRlclN0YWNrICk7XHJcblxyXG4gICAgLy8gcmVuZGVyIHRoZSBzY2VuZSFcclxuICAgIGRpc3BsYXlPYmplY3QucmVuZGVyV2ViR0wodGhpcyk7XHJcblxyXG4gICAgLy8gZmluaXNoIHRoZSBjdXJyZW50IHJlbmRlcmVyLi5cclxuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hhbmdlcyB0aGUgY3VycmVudCByZW5kZXJlciB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0UmVuZGVyZXIge1BJWEkuT2JqZWN0UmVuZGVyZXJ9IFRoZSBvYmplY3QgcmVuZGVyZXIgdG8gdXNlLlxyXG4gKi9cclxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0T2JqZWN0UmVuZGVyZXIgPSBmdW5jdGlvbiAob2JqZWN0UmVuZGVyZXIpXHJcbntcclxuICAgIGlmICh0aGlzLmN1cnJlbnRSZW5kZXJlciA9PT0gb2JqZWN0UmVuZGVyZXIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLnN0b3AoKTtcclxuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gb2JqZWN0UmVuZGVyZXI7XHJcbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgcmVuZGVyIHRhcmdldCB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyVGFyZ2V0IHtQSVhJLlJlbmRlclRhcmdldH0gdGhlIG5ldyByZW5kZXIgdGFyZ2V0XHJcbiAqL1xyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0KVxyXG57XHJcbiAgICBpZiggdGhpcy5jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSByZW5kZXJUYXJnZXQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETyAtIG1heWJlIGRvd24gdGhlIGxpbmUgdGhpcyBzaG91bGQgYmUgYSBwdXNoIHBvcyB0aGluZz8gTGVhdmluZyBmb3Igbm93IHRob3VnaC5cclxuICAgIHRoaXMuY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcclxuICAgIHRoaXMuY3VycmVudFJlbmRlclRhcmdldC5hY3RpdmF0ZSgpO1xyXG4gICAgdGhpcy5zdGVuY2lsTWFuYWdlci5zZXRNYXNrU3RhY2soIHJlbmRlclRhcmdldC5zdGVuY2lsTWFza1N0YWNrICk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlc2l6ZXMgdGhlIHdlYkdMIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxyXG4gKlxyXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgd2ViR0wgdmlld1xyXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB3ZWJHTCB2aWV3XHJcbiAqL1xyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIHRoaXMuZmlsdGVyTWFuYWdlci5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICB0aGlzLnJlbmRlclRhcmdldC5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgaWYodGhpcy5jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSB0aGlzLnJlbmRlclRhcmdldClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlbmRlclRhcmdldC5hY3RpdmF0ZSgpO1xyXG4gICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgYW5kL29yIENyZWF0ZXMgYSBXZWJHTCB0ZXh0dXJlIGZvciB0aGUgcmVuZGVyZXIncyBjb250ZXh0LlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5CYXNlVGV4dHVyZXxQSVhJLlRleHR1cmV9IHRoZSB0ZXh0dXJlIHRvIHVwZGF0ZVxyXG4gKi9cclxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlKVxyXG57XHJcbiAgICB0ZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZSB8fCB0ZXh0dXJlO1xyXG5cclxuICAgIGlmICghdGV4dHVyZS5oYXNMb2FkZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgaWYgKCF0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSlcclxuICAgIHtcclxuICAgICAgICB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICB0ZXh0dXJlLm9uKCd1cGRhdGUnLCB0aGlzLnVwZGF0ZVRleHR1cmUsIHRoaXMpO1xyXG4gICAgICAgIHRleHR1cmUub24oJ2Rpc3Bvc2UnLCB0aGlzLmRlc3Ryb3lUZXh0dXJlLCB0aGlzKTtcclxuICAgICAgICB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pO1xyXG5cclxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBsaWVkQWxwaGEpO1xyXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlLnNvdXJjZSk7XHJcblxyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBDT05TVC5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcclxuXHJcblxyXG4gICAgaWYgKHRleHR1cmUubWlwbWFwICYmIHRleHR1cmUuaXNQb3dlck9mVHdvKVxyXG4gICAge1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gQ09OU1QuU0NBTEVfTU9ERVMuTElORUFSID8gZ2wuTElORUFSX01JUE1BUF9MSU5FQVIgOiBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUKTtcclxuICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IENPTlNULlNDQUxFX01PREVTLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGV4dHVyZS5pc1Bvd2VyT2ZUd28pXHJcbiAgICB7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF07XHJcbn07XHJcblxyXG4vKipcclxuICogRGVsZXRlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMXHJcbiAqXHJcbiAqIEBwYXJhbSB0ZXh0dXJlIHtQSVhJLkJhc2VUZXh0dXJlfFBJWEkuVGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gZGVzdHJveVxyXG4gKi9cclxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveVRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgX3NraXBSZW1vdmUpXHJcbntcclxuICAgIHRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlIHx8IHRleHR1cmU7XHJcblxyXG4gICAgaWYgKCF0ZXh0dXJlLmhhc0xvYWRlZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5nbC5pZF0pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5nbC5pZF0pO1xyXG4gICAgICAgIGRlbGV0ZSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuZ2wuaWRdO1xyXG5cclxuICAgICAgICBpZiAoIV9za2lwUmVtb3ZlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMuaW5kZXhPZih0ZXh0dXJlKTtcclxuICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlscy5yZW1vdmVJdGVtcyh0aGlzLl9tYW5hZ2VkVGV4dHVyZXMsIGksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgYSBsb3N0IHdlYmdsIGNvbnRleHRcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUNvbnRleHRMb3N0ID0gZnVuY3Rpb24gKGV2ZW50KVxyXG57XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgYSByZXN0b3JlZCB3ZWJnbCBjb250ZXh0XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLl9pbml0Q29udGV4dCgpO1xyXG5cclxuICAgIC8vIGVtcHR5IGFsbCB0aGUgb2xkIGdsIHRleHR1cmVzIGFzIHRoZXkgYXJlIHVzZWxlc3Mgbm93XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21hbmFnZWRUZXh0dXJlcy5sZW5ndGg7ICsraSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX21hbmFnZWRUZXh0dXJlc1tpXTtcclxuICAgICAgICBpZiAodGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLmdsLmlkXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuZ2wuaWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgKGV2ZW50IGxpc3RlbmVycywgc3ByaXRlYmF0Y2gsIGV0Yy4uLilcclxuICpcclxuICogQHBhcmFtIFtyZW1vdmVWaWV3PWZhbHNlXSB7Ym9vbGVhbn0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxyXG4gKi9cclxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmVWaWV3KVxyXG57XHJcbiAgICB0aGlzLmRlc3Ryb3lQbHVnaW5zKCk7XHJcblxyXG4gICAgLy8gcmVtb3ZlIGxpc3RlbmVyc1xyXG4gICAgdGhpcy52aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0KTtcclxuICAgIHRoaXMudmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkKTtcclxuXHJcbiAgICAvLyBkZXN0cm95IG1hbmFnZWQgdGV4dHVyZXNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgKytpKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fbWFuYWdlZFRleHR1cmVzW2ldO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveVRleHR1cmUodGV4dHVyZSwgdHJ1ZSk7XHJcbiAgICAgICAgdGV4dHVyZS5vZmYoJ3VwZGF0ZScsIHRoaXMudXBkYXRlVGV4dHVyZSwgdGhpcyk7XHJcbiAgICAgICAgdGV4dHVyZS5vZmYoJ2Rpc3Bvc2UnLCB0aGlzLmRlc3Ryb3lUZXh0dXJlLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYWxsIGJhc2UgZGVzdHJveVxyXG4gICAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCByZW1vdmVWaWV3KTtcclxuXHJcbiAgICB0aGlzLnVpZCA9IDA7XHJcblxyXG4gICAgLy8gZGVzdHJveSB0aGUgbWFuYWdlcnNcclxuICAgIHRoaXMuc2hhZGVyTWFuYWdlci5kZXN0cm95KCk7XHJcbiAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuc3RlbmNpbE1hbmFnZXIuZGVzdHJveSgpO1xyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuYmxlbmRNb2RlTWFuYWdlci5kZXN0cm95KCk7XHJcblxyXG4gICAgdGhpcy5zaGFkZXJNYW5hZ2VyID0gbnVsbDtcclxuICAgIHRoaXMubWFza01hbmFnZXIgPSBudWxsO1xyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gbnVsbDtcclxuICAgIHRoaXMuYmxlbmRNb2RlTWFuYWdlciA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCA9IG51bGw7XHJcbiAgICB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fY29udGV4dE9wdGlvbnMgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX21hbmFnZWRUZXh0dXJlcyA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5kcmF3Q291bnQgPSAwO1xyXG5cclxuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShudWxsKTtcclxuXHJcbiAgICB0aGlzLmdsID0gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXBzIFBpeGkgYmxlbmQgbW9kZXMgdG8gV2ViR0wgYmxlbmQgbW9kZXMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5fbWFwR2xNb2RlcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgaWYgKCF0aGlzLmJsZW5kTW9kZXMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5OT1JNQUxdICAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5BRERdICAgICAgICAgICA9IFtnbC5TUkNfQUxQSEEsIGdsLkRTVF9BTFBIQV07XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk1VTFRJUExZXSAgICAgID0gW2dsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNDUkVFTl0gICAgICAgID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuT1ZFUkxBWV0gICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuREFSS0VOXSAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTElHSFRFTl0gICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuQ09MT1JfRE9ER0VdICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuQ09MT1JfQlVSTl0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuSEFSRF9MSUdIVF0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuU09GVF9MSUdIVF0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuRElGRkVSRU5DRV0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuRVhDTFVTSU9OXSAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuSFVFXSAgICAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuU0FUVVJBVElPTl0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuQ09MT1JdICAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTFVNSU5PU0lUWV0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuZHJhd01vZGVzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZHJhd01vZGVzID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuZHJhd01vZGVzW0NPTlNULkRSQVdfTU9ERVMuUE9JTlRTXSAgICAgICAgID0gZ2wuUE9JTlRTO1xyXG4gICAgICAgIHRoaXMuZHJhd01vZGVzW0NPTlNULkRSQVdfTU9ERVMuTElORVNdICAgICAgICAgID0gZ2wuTElORVM7XHJcbiAgICAgICAgdGhpcy5kcmF3TW9kZXNbQ09OU1QuRFJBV19NT0RFUy5MSU5FX0xPT1BdICAgICAgPSBnbC5MSU5FX0xPT1A7XHJcbiAgICAgICAgdGhpcy5kcmF3TW9kZXNbQ09OU1QuRFJBV19NT0RFUy5MSU5FX1NUUklQXSAgICAgPSBnbC5MSU5FX1NUUklQO1xyXG4gICAgICAgIHRoaXMuZHJhd01vZGVzW0NPTlNULkRSQVdfTU9ERVMuVFJJQU5HTEVTXSAgICAgID0gZ2wuVFJJQU5HTEVTO1xyXG4gICAgICAgIHRoaXMuZHJhd01vZGVzW0NPTlNULkRSQVdfTU9ERVMuVFJJQU5HTEVfU1RSSVBdID0gZ2wuVFJJQU5HTEVfU1RSSVA7XHJcbiAgICAgICAgdGhpcy5kcmF3TW9kZXNbQ09OU1QuRFJBV19NT0RFUy5UUklBTkdMRV9GQU5dICAgPSBnbC5UUklBTkdMRV9GQU47XHJcbiAgICB9XHJcbn07XHJcbiIsInZhciBEZWZhdWx0U2hhZGVyID0gcmVxdWlyZSgnLi4vc2hhZGVycy9UZXh0dXJlU2hhZGVyJyk7XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgYSBQSVhJIGZpbHRlci4gQ3VycmVudGx5IG9ubHkgV2ViR0wgc3VwcG9ydHMgZmlsdGVycy5cclxuICogSWYgeW91IHdhbnQgdG8gbWFrZSBhIGN1c3RvbSBmaWx0ZXIgdGhpcyBzaG91bGQgYmUgeW91ciBiYXNlIGNsYXNzLlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIHZlcnRleFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgdmVydGV4IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICogQHBhcmFtIGZyYWdtZW50U3JjIHtzdHJpbmd8c3RyaW5nW119IFRoZSBmcmFnbWVudCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAqIEBwYXJhbSB1bmlmb3JtcyB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdW5pZm9ybXMgZm9yIHRoaXMgZmlsdGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gQWJzdHJhY3RGaWx0ZXIodmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMpXHJcbntcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHNoYWRlcnNcclxuICAgICAqIEBtZW1iZXIge1BJWEkuU2hhZGVyW119XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNoYWRlcnMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBleHRyYSBwYWRkaW5nIHRoYXQgdGhlIGZpbHRlciBtaWdodCBuZWVkXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFkZGluZyA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdW5pZm9ybXMgYXMgYW4gb2JqZWN0XHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5pZm9ybXMgPSB1bmlmb3JtcyB8fCB7fTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29kZSBvZiB0aGUgdmVydGV4IHNoYWRlclxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nW119XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYyB8fCBEZWZhdWx0U2hhZGVyLmRlZmF1bHRWZXJ0ZXhTcmM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29kZSBvZiB0aGUgZnJhbWVudCBzaGFkZXJcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ1tdfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjIHx8IERlZmF1bHRTaGFkZXIuZGVmYXVsdEZyYWdtZW50U3JjO1xyXG5cclxuICAgIC8vVE9ETyBhIHJlbWluZGVyIC0gd291bGQgYmUgY29vbCB0byBoYXZlIGxvd2VyIHJlcyBmaWx0ZXJzIGFzIHRoaXMgd291bGQgZ2l2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UuXHJcblxyXG4gICAgLy90eXBlb2YgZnJhZ21lbnRTcmMgPT09ICdzdHJpbmcnID8gZnJhZ21lbnRTcmMuc3BsaXQoJycpIDogKGZyYWdtZW50U3JjIHx8IFtdKTtcclxuXHJcbn1cclxuXHJcbkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFic3RyYWN0RmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0RmlsdGVyO1xyXG5cclxuLyoqXHJcbiAqIEdyYWJzIGEgc2hhZGVyIGZyb20gdGhlIGN1cnJlbnQgcmVuZGVyZXJcclxuICpcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0byByZXRyaWV2ZSB0aGUgc2hhZGVyIGZyb21cclxuICovXHJcbkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZS5nZXRTaGFkZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIpXHJcbntcclxuICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG5cclxuICAgIHZhciBzaGFkZXIgPSB0aGlzLnNoYWRlcnNbZ2wuaWRdO1xyXG5cclxuICAgIGlmICghc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHNoYWRlciA9IG5ldyBEZWZhdWx0U2hhZGVyKHJlbmRlcmVyLnNoYWRlck1hbmFnZXIsXHJcbiAgICAgICAgICAgIHRoaXMudmVydGV4U3JjLFxyXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50U3JjLFxyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLFxyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlcnNbZ2wuaWRdID0gc2hhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzaGFkZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbGllcyB0aGUgZmlsdGVyXHJcbiAqXHJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXHJcbiAqIEBwYXJhbSBpbnB1dCB7UElYSS5SZW5kZXJUYXJnZXR9XHJcbiAqIEBwYXJhbSBvdXRwdXQge1BJWEkuUmVuZGVyVGFyZ2V0fVxyXG4gKiBAcGFyYW0gY2xlYXIge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHdlIHdhbnQgdG8gY2xlYXIgdGhlIG91dHB1dFRhcmdldFxyXG4gKi9cclxuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcilcclxue1xyXG4gICAgdmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKHJlbmRlcmVyKTtcclxuXHJcbiAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN5bmNzIGEgdW5pZm9ybSBiZXR3ZWVuIHRoZSBjbGFzcyBvYmplY3QgYW5kIHRoZSBzaGFkZXJzLlxyXG4gKlxyXG4gKi9cclxuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlLnN5bmNVbmlmb3JtID0gZnVuY3Rpb24gKHVuaWZvcm0pXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5zaGFkZXJzLmxlbmd0aDsgaSA8IGo7ICsraSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNoYWRlcnNbaV0uc3luY1VuaWZvcm0odW5pZm9ybSk7XHJcbiAgICB9XHJcbn07XHJcbiIsInZhciBBYnN0cmFjdEZpbHRlciA9IHJlcXVpcmUoJy4vQWJzdHJhY3RGaWx0ZXInKTtcclxuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcclxuXHJcblxyXG4vKipcclxuICpcclxuICogQmFzaWMgRlhBQSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiB0aGUgY29kZSBvbiBnZWVrczNkLmNvbSB3aXRoIHRoZVxyXG4gKiBtb2RpZmljYXRpb24gdGhhdCB0aGUgdGV4dHVyZTJETG9kIHN0dWZmIHdhcyByZW1vdmVkIHNpbmNlIGl0J3NcclxuICogdW5zdXBwb3J0ZWQgYnkgV2ViR0wuXHJcbiAqXHJcbiAqIC0tXHJcbiAqIEZyb206XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taXRzdWhpa28vd2ViZ2wtbWVpbmNyYWZ0XHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBGWEFBRmlsdGVyKClcclxue1xyXG4gICAgQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxyXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcclxuICAgICAgICBcIlxcclxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2UmVzb2x1dGlvbjtcXHJcXG5cXHJcXG4vL3RleGNvb3JkcyBjb21wdXRlZCBpbiB2ZXJ0ZXggc3RlcFxcclxcbi8vdG8gYXZvaWQgZGVwZW5kZW50IHRleHR1cmUgcmVhZHNcXHJcXG52YXJ5aW5nIHZlYzIgdl9yZ2JOVztcXHJcXG52YXJ5aW5nIHZlYzIgdl9yZ2JORTtcXHJcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTVztcXHJcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTRTtcXHJcXG52YXJ5aW5nIHZlYzIgdl9yZ2JNO1xcclxcblxcclxcblxcclxcbnZvaWQgdGV4Y29vcmRzKHZlYzIgZnJhZ0Nvb3JkLCB2ZWMyIHJlc29sdXRpb24sXFxyXFxuICAgICAgICAgICAgb3V0IHZlYzIgdl9yZ2JOVywgb3V0IHZlYzIgdl9yZ2JORSxcXHJcXG4gICAgICAgICAgICBvdXQgdmVjMiB2X3JnYlNXLCBvdXQgdmVjMiB2X3JnYlNFLFxcclxcbiAgICAgICAgICAgIG91dCB2ZWMyIHZfcmdiTSkge1xcclxcbiAgICB2ZWMyIGludmVyc2VWUCA9IDEuMCAvIHJlc29sdXRpb24ueHk7XFxyXFxuICAgIHZfcmdiTlcgPSAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAtMS4wKSkgKiBpbnZlcnNlVlA7XFxyXFxuICAgIHZfcmdiTkUgPSAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIC0xLjApKSAqIGludmVyc2VWUDtcXHJcXG4gICAgdl9yZ2JTVyA9IChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIDEuMCkpICogaW52ZXJzZVZQO1xcclxcbiAgICB2X3JnYlNFID0gKGZyYWdDb29yZCArIHZlYzIoMS4wLCAxLjApKSAqIGludmVyc2VWUDtcXHJcXG4gICAgdl9yZ2JNID0gdmVjMihmcmFnQ29vcmQgKiBpbnZlcnNlVlApO1xcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxyXFxuICAgdkNvbG9yID0gdmVjNChhQ29sb3IucmdiICogYUNvbG9yLmEsIGFDb2xvci5hKTtcXHJcXG4gICB2UmVzb2x1dGlvbiA9IHJlc29sdXRpb247XFxyXFxuXFxyXFxuICAgLy9jb21wdXRlIHRoZSB0ZXh0dXJlIGNvb3JkcyBhbmQgc2VuZCB0aGVtIHRvIHZhcnlpbmdzXFxyXFxuICAgdGV4Y29vcmRzKGFUZXh0dXJlQ29vcmQgKiByZXNvbHV0aW9uLCByZXNvbHV0aW9uLCB2X3JnYk5XLCB2X3JnYk5FLCB2X3JnYlNXLCB2X3JnYlNFLCB2X3JnYk0pO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBsb3dwIGZsb2F0O1xcclxcblxcclxcblxcclxcbi8qKlxcclxcbkJhc2ljIEZYQUEgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gdGhlIGNvZGUgb24gZ2Vla3MzZC5jb20gd2l0aCB0aGVcXHJcXG5tb2RpZmljYXRpb24gdGhhdCB0aGUgdGV4dHVyZTJETG9kIHN0dWZmIHdhcyByZW1vdmVkIHNpbmNlIGl0J3NcXHJcXG51bnN1cHBvcnRlZCBieSBXZWJHTC5cXHJcXG5cXHJcXG4tLVxcclxcblxcclxcbkZyb206XFxyXFxuaHR0cHM6Ly9naXRodWIuY29tL21pdHN1aGlrby93ZWJnbC1tZWluY3JhZnRcXHJcXG5cXHJcXG5Db3B5cmlnaHQgKGMpIDIwMTEgYnkgQXJtaW4gUm9uYWNoZXIuXFxyXFxuXFxyXFxuU29tZSByaWdodHMgcmVzZXJ2ZWQuXFxyXFxuXFxyXFxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XFxyXFxubW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxcclxcbm1ldDpcXHJcXG5cXHJcXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxcclxcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cXHJcXG5cXHJcXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXFxyXFxuICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcXHJcXG4gICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcXHJcXG4gICAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXFxyXFxuXFxyXFxuICAgICogVGhlIG5hbWVzIG9mIHRoZSBjb250cmlidXRvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3JcXHJcXG4gICAgICBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcXHJcXG4gICAgICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxyXFxuXFxyXFxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xcclxcblxcXCJBUyBJU1xcXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXFxyXFxuTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXFxyXFxuQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcXHJcXG5PV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcXHJcXG5TUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXFxyXFxuTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXFxyXFxuREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXFxyXFxuVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxcclxcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxcclxcbk9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXFxyXFxuKi9cXHJcXG5cXHJcXG4jaWZuZGVmIEZYQUFfUkVEVUNFX01JTlxcclxcbiAgICAjZGVmaW5lIEZYQUFfUkVEVUNFX01JTiAgICgxLjAvIDEyOC4wKVxcclxcbiNlbmRpZlxcclxcbiNpZm5kZWYgRlhBQV9SRURVQ0VfTVVMXFxyXFxuICAgICNkZWZpbmUgRlhBQV9SRURVQ0VfTVVMICAgKDEuMCAvIDguMClcXHJcXG4jZW5kaWZcXHJcXG4jaWZuZGVmIEZYQUFfU1BBTl9NQVhcXHJcXG4gICAgI2RlZmluZSBGWEFBX1NQQU5fTUFYICAgICA4LjBcXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4vL29wdGltaXplZCB2ZXJzaW9uIGZvciBtb2JpbGUsIHdoZXJlIGRlcGVuZGVudFxcclxcbi8vdGV4dHVyZSByZWFkcyBjYW4gYmUgYSBib3R0bGVuZWNrXFxyXFxudmVjNCBmeGFhKHNhbXBsZXIyRCB0ZXgsIHZlYzIgZnJhZ0Nvb3JkLCB2ZWMyIHJlc29sdXRpb24sXFxyXFxuICAgICAgICAgICAgdmVjMiB2X3JnYk5XLCB2ZWMyIHZfcmdiTkUsXFxyXFxuICAgICAgICAgICAgdmVjMiB2X3JnYlNXLCB2ZWMyIHZfcmdiU0UsXFxyXFxuICAgICAgICAgICAgdmVjMiB2X3JnYk0pIHtcXHJcXG4gICAgdmVjNCBjb2xvcjtcXHJcXG4gICAgbWVkaXVtcCB2ZWMyIGludmVyc2VWUCA9IHZlYzIoMS4wIC8gcmVzb2x1dGlvbi54LCAxLjAgLyByZXNvbHV0aW9uLnkpO1xcclxcbiAgICB2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JOVykueHl6O1xcclxcbiAgICB2ZWMzIHJnYk5FID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JORSkueHl6O1xcclxcbiAgICB2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JTVykueHl6O1xcclxcbiAgICB2ZWMzIHJnYlNFID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JTRSkueHl6O1xcclxcbiAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JNKTtcXHJcXG4gICAgdmVjMyByZ2JNICA9IHRleENvbG9yLnh5ejtcXHJcXG4gICAgdmVjMyBsdW1hID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcXHJcXG4gICAgZmxvYXQgbHVtYU5XID0gZG90KHJnYk5XLCBsdW1hKTtcXHJcXG4gICAgZmxvYXQgbHVtYU5FID0gZG90KHJnYk5FLCBsdW1hKTtcXHJcXG4gICAgZmxvYXQgbHVtYVNXID0gZG90KHJnYlNXLCBsdW1hKTtcXHJcXG4gICAgZmxvYXQgbHVtYVNFID0gZG90KHJnYlNFLCBsdW1hKTtcXHJcXG4gICAgZmxvYXQgbHVtYU0gID0gZG90KHJnYk0sICBsdW1hKTtcXHJcXG4gICAgZmxvYXQgbHVtYU1pbiA9IG1pbihsdW1hTSwgbWluKG1pbihsdW1hTlcsIGx1bWFORSksIG1pbihsdW1hU1csIGx1bWFTRSkpKTtcXHJcXG4gICAgZmxvYXQgbHVtYU1heCA9IG1heChsdW1hTSwgbWF4KG1heChsdW1hTlcsIGx1bWFORSksIG1heChsdW1hU1csIGx1bWFTRSkpKTtcXHJcXG5cXHJcXG4gICAgbWVkaXVtcCB2ZWMyIGRpcjtcXHJcXG4gICAgZGlyLnggPSAtKChsdW1hTlcgKyBsdW1hTkUpIC0gKGx1bWFTVyArIGx1bWFTRSkpO1xcclxcbiAgICBkaXIueSA9ICAoKGx1bWFOVyArIGx1bWFTVykgLSAobHVtYU5FICsgbHVtYVNFKSk7XFxyXFxuXFxyXFxuICAgIGZsb2F0IGRpclJlZHVjZSA9IG1heCgobHVtYU5XICsgbHVtYU5FICsgbHVtYVNXICsgbHVtYVNFKSAqXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoMC4yNSAqIEZYQUFfUkVEVUNFX01VTCksIEZYQUFfUkVEVUNFX01JTik7XFxyXFxuXFxyXFxuICAgIGZsb2F0IHJjcERpck1pbiA9IDEuMCAvIChtaW4oYWJzKGRpci54KSwgYWJzKGRpci55KSkgKyBkaXJSZWR1Y2UpO1xcclxcbiAgICBkaXIgPSBtaW4odmVjMihGWEFBX1NQQU5fTUFYLCBGWEFBX1NQQU5fTUFYKSxcXHJcXG4gICAgICAgICAgICAgIG1heCh2ZWMyKC1GWEFBX1NQQU5fTUFYLCAtRlhBQV9TUEFOX01BWCksXFxyXFxuICAgICAgICAgICAgICBkaXIgKiByY3BEaXJNaW4pKSAqIGludmVyc2VWUDtcXHJcXG5cXHJcXG4gICAgdmVjMyByZ2JBID0gMC41ICogKFxcclxcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogKDEuMCAvIDMuMCAtIDAuNSkpLnh5eiArXFxyXFxuICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAoMi4wIC8gMy4wIC0gMC41KSkueHl6KTtcXHJcXG4gICAgdmVjMyByZ2JCID0gcmdiQSAqIDAuNSArIDAuMjUgKiAoXFxyXFxuICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAtMC41KS54eXogK1xcclxcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogMC41KS54eXopO1xcclxcblxcclxcbiAgICBmbG9hdCBsdW1hQiA9IGRvdChyZ2JCLCBsdW1hKTtcXHJcXG4gICAgaWYgKChsdW1hQiA8IGx1bWFNaW4pIHx8IChsdW1hQiA+IGx1bWFNYXgpKVxcclxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHJnYkEsIHRleENvbG9yLmEpO1xcclxcbiAgICBlbHNlXFxyXFxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQiwgdGV4Q29sb3IuYSk7XFxyXFxuICAgIHJldHVybiBjb2xvcjtcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXHJcXG52YXJ5aW5nIHZlYzIgdlJlc29sdXRpb247XFxyXFxuXFxyXFxuLy90ZXhjb29yZHMgY29tcHV0ZWQgaW4gdmVydGV4IHN0ZXBcXHJcXG4vL3RvIGF2b2lkIGRlcGVuZGVudCB0ZXh0dXJlIHJlYWRzXFxyXFxudmFyeWluZyB2ZWMyIHZfcmdiTlc7XFxyXFxudmFyeWluZyB2ZWMyIHZfcmdiTkU7XFxyXFxudmFyeWluZyB2ZWMyIHZfcmdiU1c7XFxyXFxudmFyeWluZyB2ZWMyIHZfcmdiU0U7XFxyXFxudmFyeWluZyB2ZWMyIHZfcmdiTTtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG5cXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuXFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IGZ4YWEodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKiB2UmVzb2x1dGlvbiwgdlJlc29sdXRpb24sIHZfcmdiTlcsIHZfcmdiTkUsIHZfcmdiU1csIHZfcmdiU0UsIHZfcmdiTSk7XFxyXFxuXFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIHVuaWZvcm1zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXNvbHV0aW9uOiB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDEsIHk6IDEgfSB9XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbn1cclxuXHJcbkZYQUFGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xyXG5GWEFBRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZYQUFGaWx0ZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gRlhBQUZpbHRlcjtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBmaWx0ZXJcclxuICpcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0byByZXRyaWV2ZSB0aGUgZmlsdGVyIGZyb21cclxuICogQHBhcmFtIGlucHV0IHtQSVhJLlJlbmRlclRhcmdldH1cclxuICogQHBhcmFtIG91dHB1dCB7UElYSS5SZW5kZXJUYXJnZXR9XHJcbiAqL1xyXG5GWEFBRmlsdGVyLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgaW5wdXQsIG91dHB1dClcclxue1xyXG4gICAgdmFyIGZpbHRlck1hbmFnZXIgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyO1xyXG5cclxuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlciggcmVuZGVyZXIgKTtcclxuICAgICAvLyBkcmF3IHRoZSBmaWx0ZXIuLi5cclxuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBpbnB1dCwgb3V0cHV0KTtcclxufTtcclxuIiwidmFyIEFic3RyYWN0RmlsdGVyID0gcmVxdWlyZSgnLi9BYnN0cmFjdEZpbHRlcicpLFxyXG4gICAgbWF0aCA9ICByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XHJcblxyXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgU3ByaXRlTWFza0ZpbHRlciBjbGFzc1xyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gc3ByaXRlIHtQSVhJLlNwcml0ZX0gdGhlIHRhcmdldCBzcHJpdGVcclxuICovXHJcbmZ1bmN0aW9uIFNwcml0ZU1hc2tGaWx0ZXIoc3ByaXRlKVxyXG57XHJcbiAgICB2YXIgbWFza01hdHJpeCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xyXG5cclxuICAgIEFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgb3RoZXJNYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXHJcXG4gICAgdk1hc2tDb29yZCA9ICggb3RoZXJNYXRyaXggKiB2ZWMzKCBhVGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcclxcbiAgICB2Q29sb3IgPSB2ZWM0KGFDb2xvci5yZ2IgKiBhQ29sb3IuYSwgYUNvbG9yLmEpO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICBcInByZWNpc2lvbiBsb3dwIGZsb2F0O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2TWFza0Nvb3JkO1xcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxudW5pZm9ybSBmbG9hdCBhbHBoYTtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXNrO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgLy8gY2hlY2sgY2xpcCEgdGhpcyB3aWxsIHN0b3AgdGhlIG1hc2sgYmxlZWRpbmcgb3V0IGZyb20gdGhlIGVkZ2VzXFxyXFxuICAgIHZlYzIgdGV4dCA9IGFicyggdk1hc2tDb29yZCAtIDAuNSApO1xcclxcbiAgICB0ZXh0ID0gc3RlcCgwLjUsIHRleHQpO1xcclxcbiAgICBmbG9hdCBjbGlwID0gMS4wIC0gbWF4KHRleHQueSwgdGV4dC54KTtcXHJcXG4gICAgdmVjNCBvcmlnaW5hbCA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxyXFxuICAgIHZlYzQgbWFza3kgPSB0ZXh0dXJlMkQobWFzaywgdk1hc2tDb29yZCk7XFxyXFxuICAgIG9yaWdpbmFsICo9IChtYXNreS5yICogbWFza3kuYSAqIGFscGhhICogY2xpcCk7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IG9yaWdpbmFsO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG1hc2s6ICAgICAgICAgICB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogc3ByaXRlLl90ZXh0dXJlIH0sXHJcbiAgICAgICAgICAgIGFscGhhOiAgICAgICAgICB7IHR5cGU6ICdmJywgdmFsdWU6IDF9LFxyXG4gICAgICAgICAgICBvdGhlck1hdHJpeDogICAgeyB0eXBlOiAnbWF0MycsIHZhbHVlOiBtYXNrTWF0cml4LnRvQXJyYXkodHJ1ZSkgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlO1xyXG4gICAgdGhpcy5tYXNrTWF0cml4ID0gbWFza01hdHJpeDtcclxufVxyXG5cclxuU3ByaXRlTWFza0ZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcblNwcml0ZU1hc2tGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByaXRlTWFza0ZpbHRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVNYXNrRmlsdGVyO1xyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIGZpbHRlclxyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRvIHJldHJpZXZlIHRoZSBmaWx0ZXIgZnJvbVxyXG4gKiBAcGFyYW0gaW5wdXQge1BJWEkuUmVuZGVyVGFyZ2V0fVxyXG4gKiBAcGFyYW0gb3V0cHV0IHtQSVhJLlJlbmRlclRhcmdldH1cclxuICovXHJcblNwcml0ZU1hc2tGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KVxyXG57XHJcbiAgICB2YXIgZmlsdGVyTWFuYWdlciA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXI7XHJcblxyXG4gICAgdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlID0gdGhpcy5tYXNrU3ByaXRlLl90ZXh0dXJlO1xyXG5cclxuICAgIGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlTWFwcGVkTWF0cml4KGlucHV0LmZyYW1lLCB0aGlzLm1hc2tTcHJpdGUsIHRoaXMubWFza01hdHJpeCk7XHJcblxyXG4gICAgdGhpcy51bmlmb3Jtcy5vdGhlck1hdHJpeC52YWx1ZSA9IHRoaXMubWFza01hdHJpeC50b0FycmF5KHRydWUpO1xyXG4gICAgdGhpcy51bmlmb3Jtcy5hbHBoYS52YWx1ZSA9IHRoaXMubWFza1Nwcml0ZS53b3JsZEFscGhhO1xyXG5cclxuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XHJcbiAgICAgLy8gZHJhdyB0aGUgZmlsdGVyLi4uXHJcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCk7XHJcbn07XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3ByaXRlTWFza0ZpbHRlci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbWVudCBtYXAuIE11c3QgYmUgcG93ZXIgb2YgMiBzaXplZCB0ZXh0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLlNwcml0ZU1hc2tGaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIG1hcDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hc2sudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMubWFzay52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb2Zmc2V0IHVzZWQgdG8gbW92ZSB0aGUgZGlzcGxhY2VtZW50IG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuU3ByaXRlTWFza0ZpbHRlciNcclxuICAgICAqL1xyXG4gICAgb2Zmc2V0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgV2ViR0xNYW5hZ2VyID0gcmVxdWlyZSgnLi9XZWJHTE1hbmFnZXInKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQGV4dGVuZHMgUElYSS5XZWJHbE1hbmFnZXJcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gQmxlbmRNb2RlTWFuYWdlcihyZW5kZXJlcilcclxue1xyXG4gICAgV2ViR0xNYW5hZ2VyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSA5OTk5OTtcclxufVxyXG5cclxuQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdlYkdMTWFuYWdlci5wcm90b3R5cGUpO1xyXG5CbGVuZE1vZGVNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsZW5kTW9kZU1hbmFnZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gQmxlbmRNb2RlTWFuYWdlcjtcclxuXHJcbi8qKlxyXG4gKiBTZXRzLXVwIHRoZSBnaXZlbiBibGVuZE1vZGUgZnJvbSBXZWJHTCdzIHBvaW50IG9mIHZpZXcuXHJcbiAqXHJcbiAqIEBwYXJhbSBibGVuZE1vZGUge251bWJlcn0gdGhlIGJsZW5kTW9kZSwgc2hvdWxkIGJlIGEgUGl4aSBjb25zdCwgc3VjaCBhcyBgUElYSS5CTEVORF9NT0RFUy5BRERgLiBTZWVcclxuICogIHtAbGluayBQSVhJLkJMRU5EX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzLlxyXG4gKi9cclxuQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUuc2V0QmxlbmRNb2RlID0gZnVuY3Rpb24gKGJsZW5kTW9kZSlcclxue1xyXG4gICAgaWYgKHRoaXMuY3VycmVudEJsZW5kTW9kZSA9PT0gYmxlbmRNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSBibGVuZE1vZGU7XHJcblxyXG4gICAgdmFyIG1vZGUgPSB0aGlzLnJlbmRlcmVyLmJsZW5kTW9kZXNbdGhpcy5jdXJyZW50QmxlbmRNb2RlXTtcclxuICAgIHRoaXMucmVuZGVyZXIuZ2wuYmxlbmRGdW5jKG1vZGVbMF0sIG1vZGVbMV0pO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4iLCJ2YXIgV2ViR0xNYW5hZ2VyID0gcmVxdWlyZSgnLi9XZWJHTE1hbmFnZXInKSxcclxuICAgIFJlbmRlclRhcmdldCA9IHJlcXVpcmUoJy4uL3V0aWxzL1JlbmRlclRhcmdldCcpLFxyXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpLFxyXG4gICAgUXVhZCA9IHJlcXVpcmUoJy4uL3V0aWxzL1F1YWQnKSxcclxuICAgIG1hdGggPSAgcmVxdWlyZSgnLi4vLi4vLi4vbWF0aCcpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAZXh0ZW5kcyBQSVhJLldlYkdMTWFuYWdlclxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRoaXMgbWFuYWdlciB3b3JrcyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBGaWx0ZXJNYW5hZ2VyKHJlbmRlcmVyKVxyXG57XHJcbiAgICBXZWJHTE1hbmFnZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3RbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5maWx0ZXJTdGFjayA9IFtdO1xyXG5cclxuICAgIHRoaXMuZmlsdGVyU3RhY2sucHVzaCh7XHJcbiAgICAgICAgcmVuZGVyVGFyZ2V0OnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQsXHJcbiAgICAgICAgZmlsdGVyOltdLFxyXG4gICAgICAgIGJvdW5kczpudWxsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVuZGVyVGFyZ2V0W119XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGV4dHVyZVBvb2wgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzaXplIG9mIHRoZSB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgKi9cclxuICAgIC8vIGxpc3RlbiBmb3IgY29udGV4dCBhbmQgdXBkYXRlIG5lY2Vzc2FyeSBidWZmZXJzXHJcbiAgICAvL1RPRE8gbWFrZSB0aGlzIGR5bmFtaWMhXHJcbiAgICAvL1RPRE8gdGVzdCB0aGlzIG91dCBieSBmb3JjZXMgcG93ZXIgb2YgdHdvP1xyXG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCByZW5kZXJlci53aWR0aCwgcmVuZGVyZXIuaGVpZ2h0KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IGZyYW1lXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gbnVsbDtcclxufVxyXG5cclxuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdlYkdMTWFuYWdlci5wcm90b3R5cGUpO1xyXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpbHRlck1hbmFnZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyTWFuYWdlcjtcclxuXHJcblxyXG4vKipcclxuICogQ2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBXZWJHTCBjb250ZXh0IGNoYW5nZS5cclxuICpcclxuICovXHJcbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMudGV4dHVyZVBvb2wubGVuZ3RoID0gMDtcclxuXHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG4gICAgdGhpcy5xdWFkID0gbmV3IFF1YWQoZ2wpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfVxyXG4gKiBAcGFyYW0gYnVmZmVyIHtBcnJheUJ1ZmZlcn1cclxuICovXHJcbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLnNldEZpbHRlclN0YWNrID0gZnVuY3Rpb24gKCBmaWx0ZXJTdGFjayApXHJcbntcclxuICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBmaWx0ZXJTdGFjaztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBmaWx0ZXIgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGFyZ2V0IHtQSVhJLkRpc3BsYXlPYmplY3R9XHJcbiAqIEBwYXJhbSBmaWx0ZXJzIHtQSVhJLkFic3RyYWN0RmlsZXJbXX0gdGhlIGZpbHRlcnMgdGhhdCB3aWxsIGJlIHB1c2hlZCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2tcclxuICovXHJcbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLnB1c2hGaWx0ZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBmaWx0ZXJzKVxyXG57XHJcbiAgICAvLyBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgb2JqZWN0Li5cclxuICAgIC8vIFRPRE8gcmVwbGFjZSBjbG9uZSB3aXRoIGEgY29weSB0byBzYXZlIG9iamVjdCBjcmVhdGlvblxyXG4gICAgdmFyIGJvdW5kcyA9IHRhcmdldC5maWx0ZXJBcmVhID8gdGFyZ2V0LmZpbHRlckFyZWEuY2xvbmUoKSA6IHRhcmdldC5nZXRCb3VuZHMoKTtcclxuXHJcbiAgICAvL2JvdW5kcyA9IGJvdW5kcy5jbG9uZSgpO1xyXG5cclxuICAgIC8vIHJvdW5kIG9mZiB0aGUgcmVjdGFuZ2xlIHRvIGdldCBhIG5pY2Ugc21vb29vb29vdGggZmlsdGVyIDopXHJcbiAgICBib3VuZHMueCA9IGJvdW5kcy54IHwgMDtcclxuICAgIGJvdW5kcy55ID0gYm91bmRzLnkgfCAwO1xyXG4gICAgYm91bmRzLndpZHRoID0gYm91bmRzLndpZHRoIHwgMDtcclxuICAgIGJvdW5kcy5oZWlnaHQgPSBib3VuZHMuaGVpZ2h0IHwgMDtcclxuXHJcblxyXG4gICAgLy8gcGFkZGluZyFcclxuICAgIHZhciBwYWRkaW5nID0gZmlsdGVyc1swXS5wYWRkaW5nIHwgMDtcclxuICAgIGJvdW5kcy54IC09IHBhZGRpbmc7XHJcbiAgICBib3VuZHMueSAtPSBwYWRkaW5nO1xyXG4gICAgYm91bmRzLndpZHRoICs9IHBhZGRpbmcgKiAyO1xyXG4gICAgYm91bmRzLmhlaWdodCArPSBwYWRkaW5nICogMjtcclxuXHJcblxyXG4gICAgaWYodGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnRyYW5zZm9ybSlcclxuICAgIHtcclxuICAgICAgICAvL1RPRE8gdGhpcyB3aWxsIGJyZWFrIGlmIHRoZSByZW5kZXJUZXh0dXJlIHRyYW5zZm9ybSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGEgdHJhbnNsYXRpb24uXHJcbiAgICAgICAgLy9XaWxsIG5lZWQgdG8gdGFrZSB0aGUgZnVsbCBtYXRyaXggdHJhbnNmb3JtIGludG8gYWNvdW50Li5cclxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnRyYW5zZm9ybTtcclxuXHJcbiAgICAgICAgYm91bmRzLnggKz0gdHJhbnNmb3JtLnR4O1xyXG4gICAgICAgIGJvdW5kcy55ICs9IHRyYW5zZm9ybS50eTtcclxuXHJcbiAgICAgICAgdGhpcy5jYXBGaWx0ZXJBcmVhKCBib3VuZHMgKTtcclxuXHJcbiAgICAgICAgYm91bmRzLnggLT0gdHJhbnNmb3JtLnR4O1xyXG4gICAgICAgIGJvdW5kcy55IC09IHRyYW5zZm9ybS50eTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAgdGhpcy5jYXBGaWx0ZXJBcmVhKCBib3VuZHMgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZihib3VuZHMud2lkdGggPiAwICYmIGJvdW5kcy5oZWlnaHQgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gYm91bmRzO1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRleHR1cmUpO1xyXG5cclxuICAgICAgICAvLyBjbGVhciB0aGUgdGV4dHVyZS4uXHJcbiAgICAgICAgdGV4dHVyZS5jbGVhcigpO1xyXG5cclxuICAgICAgICAvLyBUT0RPIGdldCByaWQgb2Ygb2JqZWN0IGNyZWF0aW9uIVxyXG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sucHVzaCh7XHJcbiAgICAgICAgICAgIHJlbmRlclRhcmdldDogdGV4dHVyZSxcclxuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXJzXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vIHB1c2ggc29tdGhpbmcgb24gdG8gdGhlIHN0YWNrIHRoYXQgaXMgZW1wdHlcclxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICByZW5kZXJUYXJnZXQ6IG51bGwsXHJcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSBsYXN0IGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2sgYW5kIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqL1xyXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5wb3BGaWx0ZXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgZmlsdGVyRGF0YSA9IHRoaXMuZmlsdGVyU3RhY2sucG9wKCk7XHJcbiAgICB2YXIgcHJldmlvdXNGaWx0ZXJEYXRhID0gdGhpcy5maWx0ZXJTdGFja1t0aGlzLmZpbHRlclN0YWNrLmxlbmd0aC0xXTtcclxuXHJcbiAgICB2YXIgaW5wdXQgPSBmaWx0ZXJEYXRhLnJlbmRlclRhcmdldDtcclxuXHJcbiAgICAvLyBpZiB0aGUgcmVuZGVyVGFyZ2V0IGlzIG51bGwgdGhlbiB3ZSBkb24ndCBhcHBseSB0aGUgZmlsdGVyIGFzIGl0cyBvZmZzY3JlZW5cclxuICAgIGlmKCFmaWx0ZXJEYXRhLnJlbmRlclRhcmdldClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG91dHB1dCA9IHByZXZpb3VzRmlsdGVyRGF0YS5yZW5kZXJUYXJnZXQ7XHJcblxyXG4gICAgLy8gdXNlIHByb2dyYW1cclxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcblxyXG5cclxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gaW5wdXQuZnJhbWU7XHJcblxyXG4gICAgdGhpcy5xdWFkLm1hcCh0aGlzLnRleHR1cmVTaXplLCBpbnB1dC5mcmFtZSk7XHJcblxyXG5cclxuICAgIC8vIFRPRE8uLiB0aGlzIHByb2JhYmx5IG9ubHkgbmVlZHMgdG8gYmUgZG9uZSBvbmNlIVxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMucXVhZC52ZXJ0ZXhCdWZmZXIpO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5xdWFkLmluZGV4QnVmZmVyKTtcclxuXHJcbiAgICB2YXIgZmlsdGVycyA9IGZpbHRlckRhdGEuZmlsdGVyO1xyXG5cclxuICAgIC8vIGFzc3VtaW5nIGFsbCBmaWx0ZXJzIGZvbGxvdyB0aGUgY29ycmVjdCBmb3JtYXQ/P1xyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIuZGVmYXVsdFNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDIgKiA0ICogNCk7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5kZWZhdWx0U2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCA0LCBnbC5GTE9BVCwgZmFsc2UsIDAsIDQgKiA0ICogNCk7XHJcblxyXG4gICAgLy8gcmVzdG9yZSB0aGUgbm9ybWFsIGJsZW5kbW9kZSFcclxuICAgIHRoaXMucmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoQ09OU1QuQkxFTkRfTU9ERVMuTk9STUFMKTtcclxuXHJcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gVE9ETyAoY2VuZ2xlcikgLSBUaGVyZSBoYXMgdG8gYmUgYSBiZXR0ZXIgd2F5IHRoZW4gc2V0dGluZyB0aGlzIGVhY2ggdGltZT9cclxuICAgICAgICBpZiAoZmlsdGVyc1swXS51bmlmb3Jtcy5kaW1lbnNpb25zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmlsdGVyc1swXS51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzBdID0gdGhpcy5yZW5kZXJlci53aWR0aDtcclxuICAgICAgICAgICAgZmlsdGVyc1swXS51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzFdID0gdGhpcy5yZW5kZXJlci5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGZpbHRlcnNbMF0udW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVsyXSA9IHRoaXMucXVhZC52ZXJ0aWNlc1swXTtcclxuICAgICAgICAgICAgZmlsdGVyc1swXS51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzNdID0gdGhpcy5xdWFkLnZlcnRpY2VzWzVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmlsdGVyc1swXS5hcHBseUZpbHRlciggdGhpcy5yZW5kZXJlciwgaW5wdXQsIG91dHB1dCApO1xyXG4gICAgICAgIHRoaXMucmV0dXJuUmVuZGVyVGFyZ2V0KCBpbnB1dCApO1xyXG5cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgZmxpcFRleHR1cmUgPSBpbnB1dDtcclxuICAgICAgICB2YXIgZmxvcFRleHR1cmUgPSB0aGlzLmdldFJlbmRlclRhcmdldCh0cnVlKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aC0xOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gZmlsdGVyc1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gKGNlbmdsZXIpIC0gVGhlcmUgaGFzIHRvIGJlIGEgYmV0dGVyIHdheSB0aGVuIHNldHRpbmcgdGhpcyBlYWNoIHRpbWU/XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbMF0gPSB0aGlzLnJlbmRlcmVyLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbMV0gPSB0aGlzLnJlbmRlcmVyLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGZpbHRlci51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzJdID0gdGhpcy5xdWFkLnZlcnRpY2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbM10gPSB0aGlzLnF1YWQudmVydGljZXNbNV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZpbHRlci5hcHBseUZpbHRlciggdGhpcy5yZW5kZXJlciwgZmxpcFRleHR1cmUsIGZsb3BUZXh0dXJlICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGZsaXBUZXh0dXJlO1xyXG4gICAgICAgICAgICBmbGlwVGV4dHVyZSA9IGZsb3BUZXh0dXJlO1xyXG4gICAgICAgICAgICBmbG9wVGV4dHVyZSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmaWx0ZXJzW2ZpbHRlcnMubGVuZ3RoLTFdLmFwcGx5RmlsdGVyKCB0aGlzLnJlbmRlcmVyLCBmbGlwVGV4dHVyZSwgb3V0cHV0ICk7XHJcblxyXG4gICAgICAgIHRoaXMucmV0dXJuUmVuZGVyVGFyZ2V0KCBmbGlwVGV4dHVyZSApO1xyXG4gICAgICAgIHRoaXMucmV0dXJuUmVuZGVyVGFyZ2V0KCBmbG9wVGV4dHVyZSApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaWx0ZXJEYXRhLmZpbHRlcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHcmFicyBhbiByZW5kZXIgdGFyZ2V0IGZyb20gdGhlIGludGVybmFsIHBvb2xcclxuICpcclxuICogQHBhcmFtIGNsZWFyIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIGNsZWFyIHRoZSBSZW5kZXJUYXJnZXRcclxuICogQHJldHVybiB7UmVuZGVyVGFyZ2V0fVxyXG4gKi9cclxuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuZ2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCBjbGVhciApXHJcbntcclxuICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnRleHR1cmVQb29sLnBvcCgpIHx8IG5ldyBSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJlci5nbCwgdGhpcy50ZXh0dXJlU2l6ZS53aWR0aCwgdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQsIENPTlNULlNDQUxFX01PREVTLkxJTkVBUiwgdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uICogQ09OU1QuRklMVEVSX1JFU09MVVRJT04pO1xyXG4gICAgcmVuZGVyVGFyZ2V0LmZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XHJcblxyXG4gICAgaWYgKGNsZWFyKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlclRhcmdldC5jbGVhcih0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVuZGVyVGFyZ2V0O1xyXG59O1xyXG5cclxuLypcclxuICogUmV0dXJucyBhIFJlbmRlclRhcmdldCB0byB0aGUgaW50ZXJuYWwgcG9vbFxyXG4gKiBAcGFyYW0gcmVuZGVyVGFyZ2V0IHtSZW5kZXJUYXJnZXR9IFRoZSBSZW5kZXJUYXJnZXQgd2Ugd2FudCB0byByZXR1cm4gdG8gdGhlIHBvb2xcclxuICovXHJcbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLnJldHVyblJlbmRlclRhcmdldCA9IGZ1bmN0aW9uIChyZW5kZXJUYXJnZXQpXHJcbntcclxuICAgIHRoaXMudGV4dHVyZVBvb2wucHVzaCggcmVuZGVyVGFyZ2V0ICk7XHJcbn07XHJcblxyXG4vKlxyXG4gKiBBcHBsaWVzIHRoZSBmaWx0ZXJcclxuICogQHBhcmFtIHNoYWRlciB7U2hhZGVyfSBUaGUgc2hhZGVyIHRvIHVwbG9hZFxyXG4gKiBAcGFyYW0gaW5wdXRUYXJnZXQge1JlbmRlclRhcmdldH1cclxuICogQHBhcmFtIG91dHB1dFRhcmdldCB7UmVuZGVyVGFyZ2V0fVxyXG4gKiBAcGFyYW0gY2xlYXIge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHdlIHdhbnQgdG8gY2xlYXIgdGhlIG91dHB1dFRhcmdldFxyXG4gKi9cclxuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoc2hhZGVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhcilcclxue1xyXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuXHJcbiAgICB0aGlzLnJlbmRlcmVyLnNldFJlbmRlclRhcmdldChvdXRwdXRUYXJnZXQpO1xyXG5cclxuICAgIGlmIChjbGVhcilcclxuICAgIHtcclxuICAgICAgICBvdXRwdXRUYXJnZXQuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgdGhlIHNoYWRlclxyXG4gICAgdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlcihzaGFkZXIpO1xyXG5cclxuICAgIC8vIFRPRE8gKGNlbmdsZXIpIC0gQ2FuIHRoaXMgYmUgY2FjaGVkIGFuZCBub3QgYHRvQXJyYXlgZWQgZWFjaCBmcmFtZT9cclxuICAgIHNoYWRlci51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LnZhbHVlID0gdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKTtcclxuXHJcbiAgICAvL1RPRE8gY2FuIHRoaXMgYmUgb3B0aW1pc2VkP1xyXG4gICAgc2hhZGVyLnN5bmNVbmlmb3JtcygpO1xyXG4vKlxyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hdHRyaWJ1dGVzLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMiAqIDQgKiA0KTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCA0LCBnbC5GTE9BVCwgZmFsc2UsIDAsIDQgKiA0ICogNCk7XHJcbiovXHJcblxyXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XHJcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRhcmdldC50ZXh0dXJlKTtcclxuXHJcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG4gICAgdGhpcy5yZW5kZXJlci5kcmF3Q291bnQrKztcclxufTtcclxuXHJcbi8qXHJcbiAqIENhbGN1bGF0ZXMgdGhlIG1hcHBlZCBtYXRyaXhcclxuICogQHBhcmFtIGZpbHRlckFyZWEge1JlY3RhbmdsZX0gVGhlIGZpbHRlciBhcmVhXHJcbiAqIEBwYXJhbSBzcHJpdGUge1Nwcml0ZX0gdGhlIHRhcmdldCBzcHJpdGVcclxuICogQHBhcmFtIG91dHB1dE1hdHJpeCB7TWF0cml4fSBAYWx2aW5cclxuICovXHJcbi8vIFRPRE8gcGxheWluZyBhcm91bmQgaGVyZS4uIHRoaXMgaXMgdGVtcG9yYXJ5IC0gKHdpbGwgZW5kIHVwIGluIHRoZSBzaGFkZXIpXHJcbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLmNhbGN1bGF0ZU1hcHBlZE1hdHJpeCA9IGZ1bmN0aW9uIChmaWx0ZXJBcmVhLCBzcHJpdGUsIG91dHB1dE1hdHJpeClcclxue1xyXG4gICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtLmNvcHkobWF0aC5NYXRyaXguVEVNUF9NQVRSSVgpLFxyXG4gICAgdGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuXHJcbiAgICB2YXIgbWFwcGVkTWF0cml4ID0gb3V0cHV0TWF0cml4LmlkZW50aXR5KCk7XHJcblxyXG4gICAgLy8gc2NhbGUuLlxyXG4gICAgdmFyIHJhdGlvID0gdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgLyB0aGlzLnRleHR1cmVTaXplLndpZHRoO1xyXG5cclxuICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoZmlsdGVyQXJlYS54IC8gdGhpcy50ZXh0dXJlU2l6ZS53aWR0aCwgZmlsdGVyQXJlYS55IC8gdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgKTtcclxuXHJcbiAgICBtYXBwZWRNYXRyaXguc2NhbGUoMSAsIHJhdGlvKTtcclxuXHJcbiAgICB2YXIgdHJhbnNsYXRlU2NhbGVYID0gKHRoaXMudGV4dHVyZVNpemUud2lkdGggLyB0ZXh0dXJlLndpZHRoKTtcclxuICAgIHZhciB0cmFuc2xhdGVTY2FsZVkgPSAodGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgLyB0ZXh0dXJlLmhlaWdodCk7XHJcblxyXG4gICAgd29ybGRUcmFuc2Zvcm0udHggLz0gdGV4dHVyZS53aWR0aCAqIHRyYW5zbGF0ZVNjYWxlWDtcclxuICAgIHdvcmxkVHJhbnNmb3JtLnR5IC89IHRleHR1cmUud2lkdGggKiB0cmFuc2xhdGVTY2FsZVg7XHJcblxyXG4gICAgd29ybGRUcmFuc2Zvcm0uaW52ZXJ0KCk7XHJcblxyXG4gICAgbWFwcGVkTWF0cml4LnByZXBlbmQod29ybGRUcmFuc2Zvcm0pO1xyXG5cclxuICAgIC8vIGFwcGx5IGludmVyc2Ugc2NhbGUuLlxyXG4gICAgbWFwcGVkTWF0cml4LnNjYWxlKDEgLCAxL3JhdGlvKTtcclxuXHJcbiAgICBtYXBwZWRNYXRyaXguc2NhbGUoIHRyYW5zbGF0ZVNjYWxlWCAsIHRyYW5zbGF0ZVNjYWxlWSApO1xyXG5cclxuICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoc3ByaXRlLmFuY2hvci54LCBzcHJpdGUuYW5jaG9yLnkpO1xyXG5cclxuICAgIHJldHVybiBtYXBwZWRNYXRyaXg7XHJcblxyXG4gICAgLy8gS2VlcGluZyB0aGUgb3JnaW5hbCBhcyBhIHJlbWluZGVyIHRvIG1lIG9uIGhvdyB0aGlzIHdvcmtzIVxyXG4gICAgLy9cclxuICAgIC8vIHZhciBtID0gbmV3IG1hdGguTWF0cml4KCk7XHJcblxyXG4gICAgLy8gLy8gc2NhbGUuLlxyXG4gICAgLy8gdmFyIHJhdGlvID0gdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgLyB0aGlzLnRleHR1cmVTaXplLndpZHRoO1xyXG5cclxuICAgIC8vIG0udHJhbnNsYXRlKGZpbHRlckFyZWEueCAvIHRoaXMudGV4dHVyZVNpemUud2lkdGgsIGZpbHRlckFyZWEueSAvIHRoaXMudGV4dHVyZVNpemUuaGVpZ2h0KTtcclxuXHJcblxyXG4gICAgLy8gbS5zY2FsZSgxICwgcmF0aW8pO1xyXG5cclxuXHJcbiAgICAvLyB2YXIgdHJhbnNmb3JtID0gd3QuY2xvbmUoKTtcclxuXHJcbiAgICAvLyB2YXIgdHJhbnNsYXRlU2NhbGVYID0gKHRoaXMudGV4dHVyZVNpemUud2lkdGggLyA2MjApO1xyXG4gICAgLy8gdmFyIHRyYW5zbGF0ZVNjYWxlWSA9ICh0aGlzLnRleHR1cmVTaXplLmhlaWdodCAvIDM4MCk7XHJcblxyXG4gICAgLy8gdHJhbnNmb3JtLnR4IC89IDYyMCAqIHRyYW5zbGF0ZVNjYWxlWDtcclxuICAgIC8vIHRyYW5zZm9ybS50eSAvPSA2MjAgKiB0cmFuc2xhdGVTY2FsZVg7XHJcblxyXG4gICAgLy8gdHJhbnNmb3JtLmludmVydCgpO1xyXG5cclxuICAgIC8vIHRyYW5zZm9ybS5hcHBlbmQobSk7XHJcblxyXG4gICAgLy8gLy8gYXBwbHkgaW52ZXJzZSBzY2FsZS4uXHJcbiAgICAvLyB0cmFuc2Zvcm0uc2NhbGUoMSAsIDEvcmF0aW8pO1xyXG5cclxuICAgIC8vIHRyYW5zZm9ybS5zY2FsZSggdHJhbnNsYXRlU2NhbGVYICwgdHJhbnNsYXRlU2NhbGVZICk7XHJcblxyXG4gICAgLy8gcmV0dXJuIHRyYW5zZm9ybTtcclxufTtcclxuXHJcbi8qXHJcbiAqIENvbnN0cmFpbnMgdGhlIGZpbHRlciBhcmVhIHRvIHRoZSB0ZXh0dXJlIHNpemVcclxuICogQHBhcmFtIGZpbHRlckFyZWEge1JlY3RhbmdsZX0gVGhlIGZpbHRlciBhcmVhIHdlIHdhbnQgdG8gY2FwXHJcbiAqL1xyXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5jYXBGaWx0ZXJBcmVhID0gZnVuY3Rpb24gKGZpbHRlckFyZWEpXHJcbntcclxuICAgIGlmIChmaWx0ZXJBcmVhLnggPCAwKVxyXG4gICAge1xyXG4gICAgICAgIGZpbHRlckFyZWEud2lkdGggKz0gZmlsdGVyQXJlYS54O1xyXG4gICAgICAgIGZpbHRlckFyZWEueCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpbHRlckFyZWEueSA8IDApXHJcbiAgICB7XHJcbiAgICAgICAgZmlsdGVyQXJlYS5oZWlnaHQgKz0gZmlsdGVyQXJlYS55O1xyXG4gICAgICAgIGZpbHRlckFyZWEueSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCBmaWx0ZXJBcmVhLnggKyBmaWx0ZXJBcmVhLndpZHRoID4gdGhpcy50ZXh0dXJlU2l6ZS53aWR0aCApXHJcbiAgICB7XHJcbiAgICAgICAgZmlsdGVyQXJlYS53aWR0aCA9IHRoaXMudGV4dHVyZVNpemUud2lkdGggLSBmaWx0ZXJBcmVhLng7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCBmaWx0ZXJBcmVhLnkgKyBmaWx0ZXJBcmVhLmhlaWdodCA+IHRoaXMudGV4dHVyZVNpemUuaGVpZ2h0IClcclxuICAgIHtcclxuICAgICAgICBmaWx0ZXJBcmVhLmhlaWdodCA9IHRoaXMudGV4dHVyZVNpemUuaGVpZ2h0IC0gZmlsdGVyQXJlYS55O1xyXG4gICAgfVxyXG59O1xyXG5cclxuLypcclxuICogUmVzaXplcyBhbGwgdGhlIHJlbmRlciB0YXJnZXRzIGluIHRoZSBwb29sXHJcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSB0aGUgbmV3IHdpZHRoXHJcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIG5ldyBoZWlnaHRcclxuICovXHJcbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCApXHJcbntcclxuICAgIHRoaXMudGV4dHVyZVNpemUud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMudGV4dHVyZVNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZXh0dXJlUG9vbC5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRleHR1cmVQb29sW2ldLnJlc2l6ZSggd2lkdGgsIGhlaWdodCApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc3Ryb3lzIHRoZSBmaWx0ZXIgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgZmlsdGVyIHN0YWNrLlxyXG4gKlxyXG4gKi9cclxuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMucXVhZC5kZXN0cm95KCk7XHJcbiAgICBcclxuICAgIFdlYkdMTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmZpbHRlclN0YWNrID0gbnVsbDtcclxuICAgIHRoaXMub2Zmc2V0WSA9IDA7XHJcblxyXG4gICAgLy8gZGVzdHJveSB0ZXh0dXJlc1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRleHR1cmVQb29sLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2xbaV0uZGVzdHJveSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGV4dHVyZVBvb2wgPSBudWxsO1xyXG59O1xyXG4iLCJ2YXIgV2ViR0xNYW5hZ2VyID0gcmVxdWlyZSgnLi9XZWJHTE1hbmFnZXInKSxcclxuICAgIEFscGhhTWFza0ZpbHRlciA9IHJlcXVpcmUoJy4uL2ZpbHRlcnMvU3ByaXRlTWFza0ZpbHRlcicpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRoaXMgbWFuYWdlciB3b3JrcyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBNYXNrTWFuYWdlcihyZW5kZXJlcilcclxue1xyXG4gICAgV2ViR0xNYW5hZ2VyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xyXG5cclxuICAgIHRoaXMuc3RlbmNpbFN0YWNrID0gW107XHJcbiAgICB0aGlzLnJldmVyc2UgPSB0cnVlO1xyXG4gICAgdGhpcy5jb3VudCA9IDA7XHJcblxyXG4gICAgdGhpcy5hbHBoYU1hc2tQb29sID0gW107XHJcbn1cclxuXHJcbk1hc2tNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV2ViR0xNYW5hZ2VyLnByb3RvdHlwZSk7XHJcbk1hc2tNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hc2tNYW5hZ2VyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1hc2tNYW5hZ2VyO1xyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxyXG4gKlxyXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge1BJWEkuR3JhcGhpY3N9XHJcbiAqIEBwYXJhbSB3ZWJHTERhdGEge2FueVtdfVxyXG4gKi9cclxuTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hNYXNrID0gZnVuY3Rpb24gKHRhcmdldCwgbWFza0RhdGEpXHJcbntcclxuICAgIGlmIChtYXNrRGF0YS50ZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucHVzaFNwcml0ZU1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wdXNoU3RlbmNpbE1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIGxhc3QgbWFzayBmcm9tIHRoZSBtYXNrIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cclxuICpcclxuICogQHBhcmFtIHRhcmdldCB7UElYSS5SZW5kZXJUYXJnZXR9XHJcbiAqIEBwYXJhbSBtYXNrRGF0YSB7YW55W119XHJcbiAqL1xyXG5NYXNrTWFuYWdlci5wcm90b3R5cGUucG9wTWFzayA9IGZ1bmN0aW9uICh0YXJnZXQsIG1hc2tEYXRhKVxyXG57XHJcbiAgICBpZiAobWFza0RhdGEudGV4dHVyZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBvcFNwcml0ZU1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wb3BTdGVuY2lsTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cclxuICpcclxuICogQHBhcmFtIHRhcmdldCB7UElYSS5SZW5kZXJUYXJnZXR9XHJcbiAqIEBwYXJhbSBtYXNrRGF0YSB7YW55W119XHJcbiAqL1xyXG5NYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaFNwcml0ZU1hc2sgPSBmdW5jdGlvbiAodGFyZ2V0LCBtYXNrRGF0YSlcclxue1xyXG4gICAgdmFyIGFscGhhTWFza0ZpbHRlciA9IHRoaXMuYWxwaGFNYXNrUG9vbC5wb3AoKTtcclxuXHJcbiAgICBpZiAoIWFscGhhTWFza0ZpbHRlcilcclxuICAgIHtcclxuICAgICAgICBhbHBoYU1hc2tGaWx0ZXIgPSBbbmV3IEFscGhhTWFza0ZpbHRlcihtYXNrRGF0YSldO1xyXG4gICAgfVxyXG5cclxuICAgIGFscGhhTWFza0ZpbHRlclswXS5tYXNrU3ByaXRlID0gbWFza0RhdGE7XHJcbiAgICB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0YXJnZXQsIGFscGhhTWFza0ZpbHRlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cclxuICpcclxuICovXHJcbk1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wb3BTcHJpdGVNYXNrID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIGZpbHRlcnMgPSB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXIucG9wRmlsdGVyKCk7XHJcblxyXG4gICAgdGhpcy5hbHBoYU1hc2tQb29sLnB1c2goZmlsdGVycyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGFyZ2V0IHtQSVhJLlJlbmRlclRhcmdldH1cclxuICogQHBhcmFtIG1hc2tEYXRhIHthbnlbXX1cclxuICovXHJcbk1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoU3RlbmNpbE1hc2sgPSBmdW5jdGlvbiAodGFyZ2V0LCBtYXNrRGF0YSlcclxue1xyXG4gICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsTWFuYWdlci5wdXNoTWFzayhtYXNrRGF0YSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cclxuICpcclxuICogQHBhcmFtIHRhcmdldCB7UElYSS5SZW5kZXJUYXJnZXR9XHJcbiAqIEBwYXJhbSBtYXNrRGF0YSB7YW55W119XHJcbiAqL1xyXG5NYXNrTWFuYWdlci5wcm90b3R5cGUucG9wU3RlbmNpbE1hc2sgPSBmdW5jdGlvbiAodGFyZ2V0LCBtYXNrRGF0YSlcclxue1xyXG4gICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsTWFuYWdlci5wb3BNYXNrKG1hc2tEYXRhKTtcclxufTtcclxuXHJcbiIsInZhciBXZWJHTE1hbmFnZXIgPSByZXF1aXJlKCcuL1dlYkdMTWFuYWdlcicpLFxyXG4gICAgVGV4dHVyZVNoYWRlciA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvVGV4dHVyZVNoYWRlcicpLFxyXG4gICAgQ29tcGxleFByaW1pdGl2ZVNoYWRlciA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvQ29tcGxleFByaW1pdGl2ZVNoYWRlcicpLFxyXG4gICAgUHJpbWl0aXZlU2hhZGVyID0gcmVxdWlyZSgnLi4vc2hhZGVycy9QcmltaXRpdmVTaGFkZXInKSxcclxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQGV4dGVuZHMgUElYSS5XZWJHTE1hbmFnZXJcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gU2hhZGVyTWFuYWdlcihyZW5kZXJlcilcclxue1xyXG4gICAgV2ViR0xNYW5hZ2VyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1heEF0dGlicyA9IDEwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7YW55W119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0cmliU3RhdGUgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge2FueVtdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRlbXBBdHRyaWJTdGF0ZSA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXhBdHRpYnM7IGkrKylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmF0dHJpYlN0YXRlW2ldID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHthbnlbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFjayA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fY3VycmVudElkID0gLTE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudFNoYWRlciA9IG51bGw7XHJcblxyXG4vLyAgICB0aGlzLmluaXRQbHVnaW5zKCk7XHJcbn1cclxuXHJcblNoYWRlck1hbmFnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXZWJHTE1hbmFnZXIucHJvdG90eXBlKTtcclxuU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFkZXJNYW5hZ2VyO1xyXG51dGlscy5wbHVnaW5UYXJnZXQubWl4aW4oU2hhZGVyTWFuYWdlcik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYWRlck1hbmFnZXI7XHJcblxyXG4vKipcclxuICogQ2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBXZWJHTCBjb250ZXh0IGNoYW5nZS5cclxuICpcclxuICovXHJcblNoYWRlck1hbmFnZXIucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuaW5pdFBsdWdpbnMoKTtcclxuXHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgIC8vIGdldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgYXR0cmlidXRlIGNvcnJlY3RseSBhcyB0aGlzIHRlbmRzIHRvIHZhcnlcclxuICAgIHRoaXMubWF4QXR0aWJzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUyk7XHJcblxyXG4gICAgdGhpcy5hdHRyaWJTdGF0ZSA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXhBdHRpYnM7IGkrKylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmF0dHJpYlN0YXRlW2ldID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETyAtIFdoeSBhcmUgdGhlc2Ugbm90IHBsdWdpbnM/IFdlIGNhbid0IGRlY291cGxlIHByaW1pdGl2ZXMgdW5sZXNzIHRoZXkgYXJlLi4uLlxyXG4gICAgdGhpcy5kZWZhdWx0U2hhZGVyID0gbmV3IFRleHR1cmVTaGFkZXIodGhpcyk7XHJcbiAgICB0aGlzLnByaW1pdGl2ZVNoYWRlciA9IG5ldyBQcmltaXRpdmVTaGFkZXIodGhpcyk7XHJcbiAgICB0aGlzLmNvbXBsZXhQcmltaXRpdmVTaGFkZXIgPSBuZXcgQ29tcGxleFByaW1pdGl2ZVNoYWRlcih0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUYWtlcyB0aGUgYXR0cmlidXRlcyBnaXZlbiBpbiBwYXJhbWV0ZXJzIGFuZCB1cGxvYWRzIHRoZW0uXHJcbiAqXHJcbiAqIEBwYXJhbSBhdHRyaWJzIHthbnlbXX0gYXR0cmlic1xyXG4gKi9cclxuU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuc2V0QXR0cmlicyA9IGZ1bmN0aW9uIChhdHRyaWJzKVxyXG57XHJcbiAgICAvLyByZXNldCB0ZW1wIHN0YXRlXHJcbiAgICB2YXIgaTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50ZW1wQXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50ZW1wQXR0cmliU3RhdGVbaV0gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgdGhlIG5ldyBhdHRyaWJzXHJcbiAgICBmb3IgKHZhciBhIGluIGF0dHJpYnMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50ZW1wQXR0cmliU3RhdGVbYXR0cmlic1thXV0gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXR0cmliU3RhdGVbaV0gIT09IHRoaXMudGVtcEF0dHJpYlN0YXRlW2ldKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZVtpXSA9IHRoaXMudGVtcEF0dHJpYlN0YXRlW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmliU3RhdGVbaV0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIGN1cnJlbnQgc2hhZGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2hhZGVyIHtQSVhJLlNoYWRlcn0gdGhlIHNoYWRlciB0byB1cGxvYWRcclxuICovXHJcblNoYWRlck1hbmFnZXIucHJvdG90eXBlLnNldFNoYWRlciA9IGZ1bmN0aW9uIChzaGFkZXIpXHJcbntcclxuICAgIGlmICh0aGlzLl9jdXJyZW50SWQgPT09IHNoYWRlci51aWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2N1cnJlbnRJZCA9IHNoYWRlci51aWQ7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50U2hhZGVyID0gc2hhZGVyO1xyXG5cclxuICAgIHRoaXMucmVuZGVyZXIuZ2wudXNlUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XHJcbiAgICB0aGlzLnNldEF0dHJpYnMoc2hhZGVyLmF0dHJpYnV0ZXMpO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LlxyXG4gKlxyXG4gKi9cclxuU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMucHJpbWl0aXZlU2hhZGVyLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuY29tcGxleFByaW1pdGl2ZVNoYWRlci5kZXN0cm95KCk7XHJcbiAgICBXZWJHTE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmRlc3Ryb3lQbHVnaW5zKCk7XHJcblxyXG4gICAgdGhpcy5hdHRyaWJTdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy50ZW1wQXR0cmliU3RhdGUgPSBudWxsO1xyXG59O1xyXG4iLCJ2YXIgV2ViR0xNYW5hZ2VyID0gcmVxdWlyZSgnLi9XZWJHTE1hbmFnZXInKSxcclxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gV2ViR0xNYXNrTWFuYWdlcihyZW5kZXJlcilcclxue1xyXG4gICAgV2ViR0xNYW5hZ2VyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xyXG4gICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrID0gbnVsbDtcclxufVxyXG5cclxuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdlYkdMTWFuYWdlci5wcm90b3R5cGUpO1xyXG5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYkdMTWFza01hbmFnZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gV2ViR0xNYXNrTWFuYWdlcjtcclxuXHJcbi8qKlxyXG4gKiBDaGFuZ2VzIHRoZSBtYXNrIHN0YWNrIHRoYXQgaXMgdXNlZCBieSB0aGlzIG1hbmFnZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBzdGVuY2lsTWFza1N0YWNrIHtQSVhJLlN0ZW5jaWxNYXNrU3RhY2t9IFRoZSBtYXNrIHN0YWNrXHJcbiAqL1xyXG5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5zZXRNYXNrU3RhY2sgPSBmdW5jdGlvbiAoIHN0ZW5jaWxNYXNrU3RhY2sgKVxyXG57XHJcbiAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBzdGVuY2lsTWFza1N0YWNrO1xyXG5cclxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgaWYgKHN0ZW5jaWxNYXNrU3RhY2suc3RlbmNpbFN0YWNrLmxlbmd0aCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suIEBhbHZpblxyXG4gKlxyXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge1BJWEkuR3JhcGhpY3N9XHJcbiAqIEBwYXJhbSB3ZWJHTERhdGEge2FueVtdfVxyXG4gKi9cclxuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaFN0ZW5jaWwgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIHdlYkdMRGF0YSlcclxue1xyXG4gICAgdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LmF0dGFjaFN0ZW5jaWxCdWZmZXIoKTtcclxuXHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsLFxyXG4gICAgICAgIHNtcyA9IHRoaXMuc3RlbmNpbE1hc2tTdGFjaztcclxuXHJcbiAgICB0aGlzLmJpbmRHcmFwaGljcyhncmFwaGljcywgd2ViR0xEYXRhKTtcclxuXHJcbiAgICBpZiAoc21zLnN0ZW5jaWxTdGFjay5sZW5ndGggPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcclxuICAgICAgICBzbXMucmV2ZXJzZSA9IHRydWU7XHJcbiAgICAgICAgc21zLmNvdW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBzbXMuc3RlbmNpbFN0YWNrLnB1c2god2ViR0xEYXRhKTtcclxuXHJcbiAgICB2YXIgbGV2ZWwgPSBzbXMuY291bnQ7XHJcblxyXG4gICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcclxuXHJcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5BTFdBWVMsMCwweEZGKTtcclxuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5WRVJUKTtcclxuXHJcbiAgICAvLyBkcmF3IHRoZSB0cmlhbmdsZSBzdHJpcCFcclxuXHJcbiAgICBpZiAod2ViR0xEYXRhLm1vZGUgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX0ZBTiwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG4gICAgICAgIGlmIChzbXMucmV2ZXJzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEZGIC0gbGV2ZWwsIDB4RkYpO1xyXG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLkRFQ1IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCwgMHhGRik7XHJcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5DUik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkcmF3IGEgcXVhZCB0byBpbmNyZW1lbnQuLlxyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9GQU4sIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAoIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQgKSAqIDIgKTtcclxuXHJcbiAgICAgICAgaWYgKHNtcy5yZXZlcnNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwrMSksIDB4RkYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCsxLCAweEZGKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNtcy5yZXZlcnNlID0gIXNtcy5yZXZlcnNlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmICghc21zLnJldmVyc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHhGRiAtIGxldmVsLCAweEZGKTtcclxuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5ERUNSKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwsIDB4RkYpO1xyXG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOQ1IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX1NUUklQLCAgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuICAgICAgICBpZiAoIXNtcy5yZXZlcnNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwrMSksIDB4RkYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCsxLCAweEZGKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xyXG4gICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5LRUVQKTtcclxuXHJcbiAgICBzbXMuY291bnQrKztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUT0RPIHRoaXMgZG9lcyBub3QgYmVsb25nIGhlcmUhXHJcbiAqXHJcbiAqIEBwYXJhbSBncmFwaGljcyB7UElYSS5HcmFwaGljc31cclxuICogQHBhcmFtIHdlYkdMRGF0YSB7YW55W119XHJcbiAqL1xyXG5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5iaW5kR3JhcGhpY3MgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIHdlYkdMRGF0YSlcclxue1xyXG4gICAgLy9pZiAodGhpcy5fY3VycmVudEdyYXBoaWNzID09PSBncmFwaGljcylyZXR1cm47XHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgICAvLyBiaW5kIHRoZSBncmFwaGljcyBvYmplY3QuLlxyXG4gICAgdmFyIHNoYWRlcjsvLyA9IHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5wbHVnaW5zLnByaW1pdGl2ZVNoYWRlcjtcclxuXHJcbiAgICBpZiAod2ViR0xEYXRhLm1vZGUgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgc2hhZGVyID0gdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLmNvbXBsZXhQcmltaXRpdmVTaGFkZXI7XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoc2hhZGVyKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKSk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKSk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLnVuaWZvcm1zLnRpbnQuX2xvY2F0aW9uLCB1dGlscy5oZXgycmdiKGdyYXBoaWNzLnRpbnQpKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTNmdihzaGFkZXIudW5pZm9ybXMuY29sb3IuX2xvY2F0aW9uLCB3ZWJHTERhdGEuY29sb3IpO1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVuaWZvcm1zLmFscGhhLl9sb2NhdGlvbiwgZ3JhcGhpY3Mud29ybGRBbHBoYSk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuYnVmZmVyKTtcclxuXHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIDIsIDApO1xyXG5cclxuXHJcbiAgICAgICAgLy8gbm93IGRvIHRoZSByZXN0Li5cclxuICAgICAgICAvLyBzZXQgdGhlIGluZGV4IGJ1ZmZlciFcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuaW5kZXhCdWZmZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLmFjdGl2YXRlUHJpbWl0aXZlU2hhZGVyKCk7XHJcbiAgICAgICAgc2hhZGVyID0gdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnByaW1pdGl2ZVNoYWRlcjtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlcihzaGFkZXIpO1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeC5fbG9jYXRpb24sIGZhbHNlLCBncmFwaGljcy53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC5fbG9jYXRpb24sIGZhbHNlLCB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTNmdihzaGFkZXIudW5pZm9ybXMudGludC5fbG9jYXRpb24sIHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3MudGludCkpO1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVuaWZvcm1zLmFscGhhLl9sb2NhdGlvbiwgZ3JhcGhpY3Mud29ybGRBbHBoYSk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuYnVmZmVyKTtcclxuXHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIDYsIDApO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCA0LCBnbC5GTE9BVCwgZmFsc2UsNCAqIDYsIDIgKiA0KTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHRoZSBpbmRleCBidWZmZXIhXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmluZGV4QnVmZmVyKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUT0RPIEBhbHZpblxyXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge1BJWEkuR3JhcGhpY3N9XHJcbiAqIEBwYXJhbSB3ZWJHTERhdGEge2FueVtdfVxyXG4gKi9cclxuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wU3RlbmNpbCA9IGZ1bmN0aW9uIChncmFwaGljcywgd2ViR0xEYXRhKVxyXG57XHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsLFxyXG4gICAgICAgIHNtcyA9IHRoaXMuc3RlbmNpbE1hc2tTdGFjaztcclxuXHJcbiAgICBzbXMuc3RlbmNpbFN0YWNrLnBvcCgpO1xyXG5cclxuICAgIHNtcy5jb3VudC0tO1xyXG5cclxuICAgIGlmIChzbXMuc3RlbmNpbFN0YWNrLmxlbmd0aCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICAvLyB0aGUgc3RhY2sgaXMgZW1wdHkhXHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xyXG5cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuXHJcbiAgICAgICAgdmFyIGxldmVsID0gc21zLmNvdW50O1xyXG5cclxuICAgICAgICB0aGlzLmJpbmRHcmFwaGljcyhncmFwaGljcywgd2ViR0xEYXRhKTtcclxuXHJcbiAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgaWYgKHdlYkdMRGF0YS5tb2RlID09PSAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc21zLnJldmVyc2UgPSAhc21zLnJldmVyc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoc21zLnJldmVyc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEZGIC0gKGxldmVsKzEpLCAweEZGKTtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5DUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCsxLCAweEZGKTtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuREVDUik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRyYXcgYSBxdWFkIHRvIGluY3JlbWVudC4uXHJcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9GQU4sIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAoIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQgKSAqIDIgKTtcclxuXHJcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywwLDB4RkYpO1xyXG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOVkVSVCk7XHJcblxyXG4gICAgICAgICAgICAvLyBkcmF3IHRoZSB0cmlhbmdsZSBzdHJpcCFcclxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX0ZBTiwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmRyYXdDb3VudCArPSAyO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzbXMucmV2ZXJzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwpLCAweEZGKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsLCAweEZGKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vICBjb25zb2xlLmxvZyhcIjw8Pj5cIilcclxuICAgICAgICAgICAgaWYgKCFzbXMucmV2ZXJzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4RkYgLSAobGV2ZWwrMSksIDB4RkYpO1xyXG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5JTkNSKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsKzEsIDB4RkYpO1xyXG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5ERUNSKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX1NUUklQLCAgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5kcmF3Q291bnQrKztcclxuXHJcbiAgICAgICAgICAgIGlmICghc21zLnJldmVyc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLDB4RkYtKGxldmVsKSwgMHhGRik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCwgMHhGRik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLktFRVApO1xyXG5cclxuXHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRGVzdHJveXMgdGhlIG1hc2sgc3RhY2suXHJcbiAqXHJcbiAqL1xyXG5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgV2ViR0xNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrLnN0ZW5jaWxTdGFjayA9IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXHJcbiAqXHJcbiAqIEBwYXJhbSBtYXNrRGF0YSB7YW55W119IFRoZSBtYXNrIGRhdGEgc3RydWN0dXJlIHRvIHVzZVxyXG4gKi9cclxuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaE1hc2sgPSBmdW5jdGlvbiAobWFza0RhdGEpXHJcbntcclxuXHJcblxyXG4gICAgdGhpcy5yZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcih0aGlzLnJlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MpO1xyXG5cclxuICAgIGlmIChtYXNrRGF0YS5kaXJ0eSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MudXBkYXRlR3JhcGhpY3MobWFza0RhdGEsIHRoaXMucmVuZGVyZXIuZ2wpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbWFza0RhdGEuX3dlYkdMW3RoaXMucmVuZGVyZXIuZ2wuaWRdLmRhdGEubGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnB1c2hTdGVuY2lsKG1hc2tEYXRhLCBtYXNrRGF0YS5fd2ViR0xbdGhpcy5yZW5kZXJlci5nbC5pZF0uZGF0YVswXSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cclxuICpcclxuICogQHBhcmFtIG1hc2tEYXRhIHthbnlbXX1cclxuICovXHJcbldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnBvcE1hc2sgPSBmdW5jdGlvbiAobWFza0RhdGEpXHJcbntcclxuICAgIHRoaXMucmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5yZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzKTtcclxuXHJcbiAgICB0aGlzLnBvcFN0ZW5jaWwobWFza0RhdGEsIG1hc2tEYXRhLl93ZWJHTFt0aGlzLnJlbmRlcmVyLmdsLmlkXS5kYXRhWzBdKTtcclxufTtcclxuXHJcbiIsIi8qKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gV2ViR0xNYW5hZ2VyKHJlbmRlcmVyKVxyXG57XHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuV2ViR0xSZW5kZXJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG5cclxuICAgIHRoaXMucmVuZGVyZXIub24oJ2NvbnRleHQnLCB0aGlzLm9uQ29udGV4dENoYW5nZSwgdGhpcyk7XHJcbn1cclxuXHJcbldlYkdMTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXZWJHTE1hbmFnZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gV2ViR0xNYW5hZ2VyO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyaWMgbWV0aG9kIGNhbGxlZCB3aGVuIHRoZXJlIGlzIGEgV2ViR0wgY29udGV4dCBjaGFuZ2UuXHJcbiAqXHJcbiAqL1xyXG5XZWJHTE1hbmFnZXIucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuXHQvLyBkbyBzb21lIGNvZGVzIGluaXQhXHJcbn07XHJcblxyXG4vKipcclxuICogR2VuZXJpYyBkZXN0cm95IG1ldGhvZHMgdG8gYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3ViY2xhc3NcclxuICpcclxuICovXHJcbldlYkdMTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMucmVuZGVyZXIub2ZmKCdjb250ZXh0JywgdGhpcy5vbkNvbnRleHRDaGFuZ2UsIHRoaXMpO1xyXG5cclxuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG59O1xyXG4iLCJ2YXIgU2hhZGVyID0gcmVxdWlyZSgnLi9TaGFkZXInKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNoYWRlciBpcyB1c2VkIHRvIGRyYXcgY29tcGxleCBwcmltaXRpdmUgc2hhcGVzIGZvciB7QGxpbmsgUElYSS5HcmFwaGljc30uXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAZXh0ZW5kcyBQSVhJLlNoYWRlclxyXG4gKiBAcGFyYW0gc2hhZGVyTWFuYWdlciB7UElYSS5TaGFkZXJNYW5hZ2VyfSBUaGUgd2ViZ2wgc2hhZGVyIG1hbmFnZXIgdGhpcyBzaGFkZXIgd29ya3MgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gQ29tcGxleFByaW1pdGl2ZVNoYWRlcihzaGFkZXJNYW5hZ2VyKVxyXG57XHJcbiAgICBTaGFkZXIuY2FsbCh0aGlzLFxyXG4gICAgICAgIHNoYWRlck1hbmFnZXIsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxyXG5cclxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JyxcclxuXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgdGludDsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYTsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGNvbG9yOycsXHJcblxyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxyXG4gICAgICAgICAgICAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsnLFxyXG4gICAgICAgICAgICAnICAgdkNvbG9yID0gdmVjNChjb2xvciAqIGFscGhhICogdGludCwgYWxwaGEpOycsLy9cIiAqIHZlYzQodGludCAqIGFscGhhLCBhbHBoYSk7JyxcclxuICAgICAgICAgICAgJ30nXHJcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcclxuICAgICAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjsnLFxyXG4gICAgICAgICAgICAnfSdcclxuICAgICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGludDogICB7IHR5cGU6ICczZicsIHZhbHVlOiBbMCwgMCwgMF0gfSxcclxuICAgICAgICAgICAgYWxwaGE6ICB7IHR5cGU6ICcxZicsIHZhbHVlOiAwIH0sXHJcbiAgICAgICAgICAgIGNvbG9yOiAgeyB0eXBlOiAnM2YnLCB2YWx1ZTogWzAsMCwwXSB9LFxyXG4gICAgICAgICAgICB0cmFuc2xhdGlvbk1hdHJpeDogeyB0eXBlOiAnbWF0MycsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDkpIH0sXHJcbiAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6IHsgdHlwZTogJ21hdDMnLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg5KSB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBhdHRyaWJ1dGVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhVmVydGV4UG9zaXRpb246MFxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn1cclxuXHJcbkNvbXBsZXhQcmltaXRpdmVTaGFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaGFkZXIucHJvdG90eXBlKTtcclxuQ29tcGxleFByaW1pdGl2ZVNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21wbGV4UHJpbWl0aXZlU2hhZGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBsZXhQcmltaXRpdmVTaGFkZXI7XHJcbiIsInZhciBTaGFkZXIgPSByZXF1aXJlKCcuL1NoYWRlcicpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2hhZGVyIGlzIHVzZWQgdG8gZHJhdyBzaW1wbGUgcHJpbWl0aXZlIHNoYXBlcyBmb3Ige0BsaW5rIFBJWEkuR3JhcGhpY3N9LlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQGV4dGVuZHMgUElYSS5TaGFkZXJcclxuICogQHBhcmFtIHNoYWRlck1hbmFnZXIge1NoYWRlck1hbmFnZXJ9IFRoZSB3ZWJnbCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBQcmltaXRpdmVTaGFkZXIoc2hhZGVyTWFuYWdlcilcclxue1xyXG4gICAgU2hhZGVyLmNhbGwodGhpcyxcclxuICAgICAgICBzaGFkZXJNYW5hZ2VyLFxyXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IGFDb2xvcjsnLFxyXG5cclxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JyxcclxuXHJcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGFscGhhOycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGZsaXBZOycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgdGludDsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcclxuICAgICAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7JyxcclxuICAgICAgICAgICAgJyAgIHZDb2xvciA9IGFDb2xvciAqIHZlYzQodGludCAqIGFscGhhLCBhbHBoYSk7JyxcclxuICAgICAgICAgICAgJ30nXHJcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcclxuICAgICAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjsnLFxyXG4gICAgICAgICAgICAnfSdcclxuICAgICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGludDogICB7IHR5cGU6ICczZicsIHZhbHVlOiBbMCwgMCwgMF0gfSxcclxuICAgICAgICAgICAgYWxwaGE6ICB7IHR5cGU6ICcxZicsIHZhbHVlOiAwIH0sXHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoOSkgfSxcclxuICAgICAgICAgICAgcHJvamVjdGlvbk1hdHJpeDogeyB0eXBlOiAnbWF0MycsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDkpIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGN1c3RvbSBhdHRyaWJ1dGVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhVmVydGV4UG9zaXRpb246MCxcclxuICAgICAgICAgICAgYUNvbG9yOjBcclxuICAgICAgICB9XHJcbiAgICApO1xyXG59XHJcblxyXG5QcmltaXRpdmVTaGFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaGFkZXIucHJvdG90eXBlKTtcclxuUHJpbWl0aXZlU2hhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByaW1pdGl2ZVNoYWRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBQcmltaXRpdmVTaGFkZXI7XHJcbiIsIi8qZ2xvYmFsIGNvbnNvbGUgKi9cclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIHNoYWRlciBjbGFzcyBmb3IgUElYSSBtYW5hZ2VkIHNoYWRlcnMuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gc2hhZGVyTWFuYWdlciB7UElYSS5TaGFkZXJNYW5hZ2VyfSBUaGUgd2ViZ2wgc2hhZGVyIG1hbmFnZXIgdGhpcyBzaGFkZXIgd29ya3MgZm9yLlxyXG4gKiBAcGFyYW0gW3ZlcnRleFNyY10ge3N0cmluZ30gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cclxuICogQHBhcmFtIFtmcmFnbWVudFNyY10ge3N0cmluZ30gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxyXG4gKiBAcGFyYW0gW3VuaWZvcm1zXSB7b2JqZWN0fSBVbmlmb3JtcyBmb3IgdGhpcyBzaGFkZXIuXHJcbiAqIEBwYXJhbSBbYXR0cmlidXRlc10ge29iamVjdH0gQXR0cmlidXRlcyBmb3IgdGhpcyBzaGFkZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBTaGFkZXIoc2hhZGVyTWFuYWdlciwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMsIGF0dHJpYnV0ZXMpXHJcbntcclxuICAgIGlmICghdmVydGV4U3JjIHx8ICFmcmFnbWVudFNyYylcclxuICAgIHtcclxuICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXhpLmpzIEVycm9yLiBTaGFkZXIgcmVxdWlyZXMgdmVydGV4U3JjIGFuZCBmcmFnbWVudFNyYycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB1bmlxdWUgaWRcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICB0aGlzLnVpZCA9IHV0aWxzLnVpZCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XHJcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5nbCA9IHNoYWRlck1hbmFnZXIucmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgLy9UT0RPIG1heWJlIHdlIHNob3VsZCBwYXNzIHJlbmRlcmVyIHJhdGhlciB0aGFuIHNoYWRlciBtYW5nZXI/PyBmb29kIGZvciB0aG91Z2h0Li5cclxuICAgIHRoaXMuc2hhZGVyTWFuYWdlciA9IHNoYWRlck1hbmFnZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgV2ViR0wgcHJvZ3JhbS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFByb2dyYW19XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB1bmlmb3JtcyBhcyBhbiBvYmplY3RcclxuICAgICAqIEBtZW1iZXIge29iamVjdH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5pZm9ybXMgPSB1bmlmb3JtcyB8fCB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhdHRyaWJ1dGVzIGFzIGFuIG9iamVjdFxyXG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIHRleHR1cmUgY291bnRlclxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy50ZXh0dXJlQ291bnQgPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZlcnRleCBzaGFkZXIgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy52ZXJ0ZXhTcmMgPSB2ZXJ0ZXhTcmM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGFzIGFuIGFycmF5IG9mIHN0cmluZ3NcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYztcclxuXHJcbiAgICB0aGlzLmluaXQoKTtcclxufVxyXG5cclxuU2hhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYWRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBTaGFkZXI7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyB0aGUgc2hhZGVyIGFuZCB1c2VzIGl0XHJcbiAqXHJcbiAqL1xyXG5TaGFkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLmNvbXBpbGUoKTtcclxuXHJcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuXHJcbiAgICB0aGlzLmNhY2hlVW5pZm9ybUxvY2F0aW9ucyhPYmplY3Qua2V5cyh0aGlzLnVuaWZvcm1zKSk7XHJcbiAgICB0aGlzLmNhY2hlQXR0cmlidXRlTG9jYXRpb25zKE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhY2hlcyB0aGUgbG9jYXRpb25zIG9mIHRoZSB1bmlmb3JtIGZvciByZXVzZS5cclxuICpcclxuICogQHBhcmFtIGtleXMge3N0cmluZ30gdGhlIHVuaWZvcm1zIHRvIGNhY2hlXHJcbiAqL1xyXG5TaGFkZXIucHJvdG90eXBlLmNhY2hlVW5pZm9ybUxvY2F0aW9ucyA9IGZ1bmN0aW9uIChrZXlzKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtc1trZXlzW2ldXS5fbG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIGtleXNbaV0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhY2hlcyB0aGUgbG9jYXRpb25zIG9mIHRoZSBhdHRyaWJ1dGUgZm9yIHJldXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ga2V5cyB7c3RyaW5nfSB0aGUgYXR0cmlidXRlcyB0byBjYWNoZVxyXG4gKi9cclxuU2hhZGVyLnByb3RvdHlwZS5jYWNoZUF0dHJpYnV0ZUxvY2F0aW9ucyA9IGZ1bmN0aW9uIChrZXlzKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2tleXNbaV1dID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIGtleXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgaXMgbmVlZGVkIGFueW1vcmUuLi5cclxuXHJcbiAgICAvLyBCZWdpbiB3b3JzdCBoYWNrIGV2YSAvL1xyXG5cclxuICAgIC8vIFdIWT8/PyBPTkxZIG9uIG15IGNocm9tZSBwaXhlbCB0aGUgbGluZSBhYm92ZSByZXR1cm5zIC0xIHdoZW4gdXNpbmcgZmlsdGVycz9cclxuICAgIC8vIG1heWJlIGl0cyBzb21ldGhpbmcgdG8gZG8gd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2wgY29udGV4dC5cclxuICAgIC8vIEknbSBjb252aW5jZWQgdGhpcyBpcyBhIGJ1ZyBpbiB0aGUgY2hyb21lIGJyb3dzZXIgYXMgdGhlcmUgaXMgTk8gcmVhc29uIHdoeSB0aGlzIHNob3VsZCBiZSByZXR1cm5pbmcgLTEgZXNwZWNpYWxseSBhcyBpdCBvbmx5IG1hbmlmZXN0cyBvbiBteSBjaHJvbWUgcGl4ZWxcclxuICAgIC8vIElmIHRoZXJlcyBhbnkgd2ViR0wgcGVvcGxlIHRoYXQga25vdyB3aHkgY291bGQgaGFwcGVuIHBsZWFzZSBoZWxwIDopXHJcbiAgICAvLyBpZiAodGhpcy5hdHRyaWJ1dGVzLmFDb2xvciA9PT0gLTEpe1xyXG4gICAgLy8gICAgIHRoaXMuYXR0cmlidXRlcy5hQ29sb3IgPSAyO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIEVuZCB3b3JzdCBoYWNrIGV2YSAvL1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEF0dGFjaGVzIHRoZSBzaGFkZXJzIGFuZCBjcmVhdGVzIHRoZSBwcm9ncmFtLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19XHJcbiAqL1xyXG5TaGFkZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgIHZhciBnbFZlcnRTaGFkZXIgPSB0aGlzLl9nbENvbXBpbGUoZ2wuVkVSVEVYX1NIQURFUiwgdGhpcy52ZXJ0ZXhTcmMpO1xyXG4gICAgdmFyIGdsRnJhZ1NoYWRlciA9IHRoaXMuX2dsQ29tcGlsZShnbC5GUkFHTUVOVF9TSEFERVIsIHRoaXMuZnJhZ21lbnRTcmMpO1xyXG5cclxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBnbFZlcnRTaGFkZXIpO1xyXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsRnJhZ1NoYWRlcik7XHJcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcbiAgICAvLyBpZiBsaW5raW5nIGZhaWxzLCB0aGVuIGxvZyBhbmQgY2xlYW51cFxyXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSlcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdQaXhpLmpzIEVycm9yOiBDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIuJyk7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdnbC5nZXRFcnJvcigpJywgZ2wuZ2V0RXJyb3IoKSk7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgcHJvZ3JhbSBpbmZvIGxvZywgbG9nIGl0XHJcbiAgICAgICAgaWYgKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pICE9PSAnJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUGl4aS5qcyBXYXJuaW5nOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjbGVhbiB1cCBzb21lIHNoYWRlcnNcclxuICAgIGdsLmRlbGV0ZVNoYWRlcihnbFZlcnRTaGFkZXIpO1xyXG4gICAgZ2wuZGVsZXRlU2hhZGVyKGdsRnJhZ1NoYWRlcik7XHJcblxyXG4gICAgcmV0dXJuICh0aGlzLnByb2dyYW0gPSBwcm9ncmFtKTtcclxufTtcclxuXHJcbi8qXHJcblNoYWRlci5wcm90b3R5cGUuYnVpbGRTeW5jID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAvLyB2YXIgc3RyID0gXCJcIlxyXG5cclxuICAgLy8gc3RyID0gIFwiU2hhZGVyLnByb3RvdHlwZS5zeW5jVW5pZm9ybXMgPSBmdW5jdGlvbigpXCI7XHJcbiAgIC8vIHN0ciArPSBcIntcXG5cIjtcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy51bmlmb3JtcylcclxuICAgIHtcclxuICAgICAgICB2YXIgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNba2V5XTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xyXG5cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5pZm9ybS52YWx1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtKHVuaWZvcm0sIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyggbWFrZVByb3BTZXR0ZXIoIGtleSwgXCIgYmxvb3BcIiwgdW5pZm9ybS50eXBlICkgIClcclxuICAvLyAgICAgIE9iamVjdC5kZWZcclxuICAgICAgICAvLyAgICBsb2NhdGlvbiA9IHVuaWZvcm0uX2xvY2F0aW9uLFxyXG4gICAgICAgICAgLy8gIHZhbHVlID0gdW5pZm9ybS52YWx1ZSxcclxuICAgICAgICAgICAgLy9pLCBpbDtcclxuXHJcbiAgICAvLyAgICBzdHIgKz0gXCJnbC51bmlmb3JtMWkodGhpcy51bmlmb3Jtcy5cIisga2V5ICtcIi5fbG9jYXRpb24sIHRoaXMudW5pZm9ybXMuXCIgKyBrZXkgKyBcIi52YWx1ZSApO1xcblwiXHJcblxyXG4gICAgfVxyXG5cclxufSovXHJcblxyXG4vKipcclxuKiBBZGRzIGEgbmV3IHVuaWZvcm1cclxuKlxyXG4qIEBwYXJhbSB1bmlmb3JtIHtvYmplY3R9IHRoZSBuZXcgdW5pZm9ybSB0byBhdHRhY2hcclxuKi9cclxuU2hhZGVyLnByb3RvdHlwZS5zeW5jVW5pZm9ybSA9IGZ1bmN0aW9uICh1bmlmb3JtKVxyXG57XHJcbiAgICB2YXIgbG9jYXRpb24gPSB1bmlmb3JtLl9sb2NhdGlvbixcclxuICAgICAgICB2YWx1ZSA9IHVuaWZvcm0udmFsdWUsXHJcbiAgICAgICAgZ2wgPSB0aGlzLmdsLFxyXG4gICAgICAgIGksIGlsO1xyXG5cclxuICAgIHN3aXRjaCAodW5pZm9ybS50eXBlKVxyXG4gICAge1xyXG4gICAgICAgIGNhc2UgJ2InOlxyXG4gICAgICAgIGNhc2UgJ2Jvb2wnOlxyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHZhbHVlID8gMSA6IDApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gc2luZ2xlIGludCB2YWx1ZVxyXG4gICAgICAgIGNhc2UgJ2knOlxyXG4gICAgICAgIGNhc2UgJzFpJzpcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAvLyBzaW5nbGUgZmxvYXQgdmFsdWVcclxuICAgICAgICBjYXNlICdmJzpcclxuICAgICAgICBjYXNlICcxZic6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gRmxvYXQzMkFycmF5KDIpIG9yIEpTIEFycnJheVxyXG4gICAgICAgIGNhc2UgJzJmJzpcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gRmxvYXQzMkFycmF5KDMpIG9yIEpTIEFycnJheVxyXG4gICAgICAgIGNhc2UgJzNmJzpcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSg0KSBvciBKUyBBcnJyYXlcclxuICAgICAgICBjYXNlICc0Zic6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm00Zihsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSwgdmFsdWVbM10pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gYSAyRCBQb2ludCBvYmplY3RcclxuICAgICAgICBjYXNlICd2Mic6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZihsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAvLyBhIDNEIFBvaW50IG9iamVjdFxyXG4gICAgICAgIGNhc2UgJ3YzJzpcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIGEgNEQgUG9pbnQgb2JqZWN0XHJcbiAgICAgICAgY2FzZSAndjQnOlxyXG4gICAgICAgICAgICBnbC51bmlmb3JtNGYobG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gSW50MzJBcnJheSBvciBKUyBBcnJheVxyXG4gICAgICAgIGNhc2UgJzFpdic6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIEludDMyQXJyYXkgb3IgSlMgQXJyYXlcclxuICAgICAgICBjYXNlICcyaXYnOlxyXG4gICAgICAgICAgICBnbC51bmlmb3JtMml2KGxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAvLyBJbnQzMkFycmF5IG9yIEpTIEFycmF5XHJcbiAgICAgICAgY2FzZSAnM2l2JzpcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gSW50MzJBcnJheSBvciBKUyBBcnJheVxyXG4gICAgICAgIGNhc2UgJzRpdic6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm00aXYobG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSBvciBKUyBBcnJheVxyXG4gICAgICAgIGNhc2UgJzFmdic6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSBvciBKUyBBcnJheVxyXG4gICAgICAgIGNhc2UgJzJmdic6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSBvciBKUyBBcnJheVxyXG4gICAgICAgIGNhc2UgJzNmdic6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSBvciBKUyBBcnJheVxyXG4gICAgICAgIGNhc2UgJzRmdic6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSBvciBKUyBBcnJheVxyXG4gICAgICAgIGNhc2UgJ20yJzpcclxuICAgICAgICBjYXNlICdtYXQyJzpcclxuICAgICAgICBjYXNlICdNYXRyaXgyZnYnOlxyXG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCB1bmlmb3JtLnRyYW5zcG9zZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gRmxvYXQzMkFycmF5IG9yIEpTIEFycmF5XHJcbiAgICAgICAgY2FzZSAnbTMnOlxyXG4gICAgICAgIGNhc2UgJ21hdDMnOlxyXG4gICAgICAgIGNhc2UgJ01hdHJpeDNmdic6XHJcblxyXG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCB1bmlmb3JtLnRyYW5zcG9zZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gRmxvYXQzMkFycmF5IG9yIEpTIEFycmF5XHJcbiAgICAgICAgY2FzZSAnbTQnOlxyXG4gICAgICAgIGNhc2UgJ21hdDQnOlxyXG4gICAgICAgIGNhc2UgJ01hdHJpeDRmdic6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIHVuaWZvcm0udHJhbnNwb3NlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAvLyBhIENvbG9yIFZhbHVlXHJcbiAgICAgICAgY2FzZSAnYyc6XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHV0aWxzLmhleDJyZ2IodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbC51bmlmb3JtM2YobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcbiAgICAgICAgY2FzZSAnaXYxJzpcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG4gICAgICAgIGNhc2UgJ2l2JzpcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBmbG9hdHMgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG4gICAgICAgIGNhc2UgJ2Z2MSc6XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcbiAgICAgICAgY2FzZSAnZnYnOlxyXG4gICAgICAgICAgICBnbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAvLyBhcnJheSBvZiAyRCBQb2ludCBvYmplY3RzXHJcbiAgICAgICAgY2FzZSAndjJ2JzpcclxuICAgICAgICAgICAgaWYgKCF1bmlmb3JtLl9hcnJheSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiB2YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5W2kgKiAyXSAgICAgICA9IHZhbHVlW2ldLng7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVtpICogMiArIDFdICAgPSB2YWx1ZVtpXS55O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAvLyBhcnJheSBvZiAzRCBQb2ludCBvYmplY3RzXHJcbiAgICAgICAgY2FzZSAndjN2JzpcclxuICAgICAgICAgICAgaWYgKCF1bmlmb3JtLl9hcnJheSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDMgKiB2YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5W2kgKiAzXSAgICAgICA9IHZhbHVlW2ldLng7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVtpICogMyArIDFdICAgPSB2YWx1ZVtpXS55O1xyXG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbaSAqIDMgKyAyXSAgID0gdmFsdWVbaV0uejtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHVuaWZvcm0uX2FycmF5KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIGFycmF5IG9mIDREIFBvaW50IG9iamVjdHNcclxuICAgICAgICBjYXNlICd2NHYnOlxyXG4gICAgICAgICAgICBpZiAoIXVuaWZvcm0uX2FycmF5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIHZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbaSAqIDRdICAgICAgID0gdmFsdWVbaV0ueDtcclxuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5W2kgKiA0ICsgMV0gICA9IHZhbHVlW2ldLnk7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVtpICogNCArIDJdICAgPSB2YWx1ZVtpXS56O1xyXG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbaSAqIDQgKyAzXSAgID0gdmFsdWVbaV0udztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHVuaWZvcm0uX2FycmF5KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIFBJWEkuVGV4dHVyZVxyXG4gICAgICAgIGNhc2UgJ3QnOlxyXG4gICAgICAgIGNhc2UgJ3NhbXBsZXIyRCc6XHJcblxyXG4gICAgICAgICAgICBpZiAoIXVuaWZvcm0udmFsdWUgfHwgIXVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gYWN0aXZhdGUgdGhpcyB0ZXh0dXJlXHJcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2xbJ1RFWFRVUkUnICsgdGhpcy50ZXh0dXJlQ291bnRdKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRleHR1cmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNhbXBsZXIyRCh1bmlmb3JtKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHRleHR1ciB0byB0aGUgbmV3bHkgY3JlYXRlZCBvbmUuLlxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZSA9IHVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBiaW5kIHRoZSB0ZXh0dXJlXHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cclxuICAgICAgICAgICAgLy8gc2V0IHVuaWZvcm0gdG8gdGV4dHVyZSBpbmRleFxyXG4gICAgICAgICAgICBnbC51bmlmb3JtMWkodW5pZm9ybS5fbG9jYXRpb24sIHRoaXMudGV4dHVyZUNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBuZXh0IHRleHR1cmUgaWRcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlQ291bnQrKztcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BpeGkuanMgU2hhZGVyIFdhcm5pbmc6IFVua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdW5pZm9ybS50eXBlKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBzaGFkZXIgdW5pZm9ybSB2YWx1ZXMuXHJcbiAqXHJcbiAqL1xyXG5TaGFkZXIucHJvdG90eXBlLnN5bmNVbmlmb3JtcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMTtcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy51bmlmb3JtcylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN5bmNVbmlmb3JtKHRoaXMudW5pZm9ybXNba2V5XSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpc2VzIGEgU2FtcGxlcjJEIHVuaWZvcm0gKHdoaWNoIG1heSBvbmx5IGJlIGF2YWlsYWJsZSBsYXRlciBvbiBhZnRlciBpbml0VW5pZm9ybXMgb25jZSB0aGUgdGV4dHVyZSBoYXMgbG9hZGVkKVxyXG4gKlxyXG4gKi9cclxuU2hhZGVyLnByb3RvdHlwZS5pbml0U2FtcGxlcjJEID0gZnVuY3Rpb24gKHVuaWZvcm0pXHJcbntcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgdmFyIHRleHR1cmUgPSB1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlO1xyXG5cclxuICAgIGlmKCF0ZXh0dXJlLmhhc0xvYWRlZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBpZiAodW5pZm9ybS50ZXh0dXJlRGF0YSlcclxuICAgIHtcclxuXHJcbiAgICAgICAgLy9UT0RPIG1vdmUgdGhpcy4uLlxyXG4gICAgICAgIHZhciBkYXRhID0gdW5pZm9ybS50ZXh0dXJlRGF0YTtcclxuXHJcbiAgICAgICAgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0gPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcclxuXHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGxpZWRBbHBoYSk7XHJcbiAgICAgICAgLy8gR0xUZXh0dXJlID0gbWFnIGxpbmVhciwgbWluIGxpbmVhcl9taXBtYXBfbGluZWFyLCB3cmFwIHJlcGVhdCArIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xyXG4gICAgICAgIC8vIEdMVGV4dHVyZUxpbmVhciA9IG1hZy9taW4gbGluZWFyLCB3cmFwIGNsYW1wXHJcbiAgICAgICAgLy8gR0xUZXh0dXJlTmVhcmVzdFJlcGVhdCA9IG1hZy9taW4gTkVBUkVTVCwgd3JhcCByZXBlYXRcclxuICAgICAgICAvLyBHTFRleHR1cmVOZWFyZXN0ID0gbWFnL21pbiBuZWFyZXN0LCB3cmFwIGNsYW1wXHJcbiAgICAgICAgLy8gQXVkaW9UZXh0dXJlID0gd2hhdGV2ZXIgKyBsdW1pbmFuY2UgKyB3aWR0aCA1MTIsIGhlaWdodCAyLCBib3JkZXIgMFxyXG4gICAgICAgIC8vIEtleVRleHR1cmUgPSB3aGF0ZXZlciArIGx1bWluYW5jZSArIHdpZHRoIDI1NiwgaGVpZ2h0IDIsIGJvcmRlciAwXHJcblxyXG4gICAgICAgIC8vICBtYWdGaWx0ZXIgY2FuIGJlOiBnbC5MSU5FQVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSIG9yIGdsLk5FQVJFU1RcclxuICAgICAgICAvLyAgd3JhcFMvVCBjYW4gYmU6IGdsLkNMQU1QX1RPX0VER0Ugb3IgZ2wuUkVQRUFUXHJcblxyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZGF0YS5sdW1pbmFuY2UgPyBnbC5MVU1JTkFOQ0UgOiBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlLnNvdXJjZSk7XHJcblxyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBkYXRhLm1hZ0ZpbHRlciA/IGRhdGEubWFnRmlsdGVyIDogZ2wuTElORUFSICk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGRhdGEud3JhcFMgPyBkYXRhLndyYXBTIDogZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBkYXRhLndyYXBTID8gZGF0YS53cmFwUyA6IGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGRhdGEud3JhcFQgPyBkYXRhLndyYXBUIDogZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zaGFkZXJNYW5hZ2VyLnJlbmRlcmVyLnVwZGF0ZVRleHR1cmUodGV4dHVyZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRGVzdHJveXMgdGhlIHNoYWRlci5cclxuICpcclxuICovXHJcblNoYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG5cclxuICAgIHRoaXMuZ2wgPSBudWxsO1xyXG4gICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XHJcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xyXG5cclxuICAgIHRoaXMudmVydGV4U3JjID0gbnVsbDtcclxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBudWxsO1xyXG59O1xyXG5cclxuU2hhZGVyLnByb3RvdHlwZS5fZ2xDb21waWxlID0gZnVuY3Rpb24gKHR5cGUsIHNyYylcclxue1xyXG4gICAgdmFyIHNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG5cclxuICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcclxuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG5cclxuICAgIGlmICghdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSlcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNoYWRlcjtcclxufTtcclxuIiwidmFyIFNoYWRlciA9IHJlcXVpcmUoJy4vU2hhZGVyJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqIEBleHRlbmRzIFBJWEkuU2hhZGVyXHJcbiAqIEBwYXJhbSBzaGFkZXJNYW5hZ2VyIHtQSVhJLlNoYWRlck1hbmFnZXJ9IFRoZSB3ZWJnbCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXHJcbiAqIEBwYXJhbSBbdmVydGV4U3JjXSB7c3RyaW5nfSBUaGUgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyLlxyXG4gKiBAcGFyYW0gW2ZyYWdtZW50U3JjXSB7c3RyaW5nfSBUaGUgc291cmNlIG9mIHRoZSBmcmFnbWVudCBzaGFkZXIuXHJcbiAqIEBwYXJhbSBbY3VzdG9tVW5pZm9ybXNdIHtvYmplY3R9IEN1c3RvbSB1bmlmb3JtcyB0byB1c2UgdG8gYXVnbWVudCB0aGUgYnVpbHQtaW4gb25lcy5cclxuICogQHBhcmFtIFtmcmFnbWVudFNyY10ge3N0cmluZ30gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gVGV4dHVyZVNoYWRlcihzaGFkZXJNYW5hZ2VyLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBjdXN0b21Vbmlmb3JtcywgY3VzdG9tQXR0cmlidXRlcylcclxue1xyXG4gICAgdmFyIHVuaWZvcm1zID0ge1xyXG5cclxuICAgICAgICB1U2FtcGxlcjogICAgICAgICAgIHsgdHlwZTogJ3NhbXBsZXIyRCcsIHZhbHVlOiAwIH0sXHJcbiAgICAgICAgcHJvamVjdGlvbk1hdHJpeDogICB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDEsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDFdKSB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChjdXN0b21Vbmlmb3JtcylcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciB1IGluIGN1c3RvbVVuaWZvcm1zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdW5pZm9ybXNbdV0gPSBjdXN0b21Vbmlmb3Jtc1t1XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHZhciBhdHRyaWJ1dGVzID0ge1xyXG4gICAgICAgIGFWZXJ0ZXhQb3NpdGlvbjogICAgMCxcclxuICAgICAgICBhVGV4dHVyZUNvb3JkOiAgICAgIDAsXHJcbiAgICAgICAgYUNvbG9yOiAgICAgICAgICAgICAwXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChjdXN0b21BdHRyaWJ1dGVzKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGEgaW4gY3VzdG9tQXR0cmlidXRlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYV0gPSBjdXN0b21BdHRyaWJ1dGVzW2FdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB2ZXJ0ZXggc2hhZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdmVydGV4U3JjID0gdmVydGV4U3JjIHx8IFRleHR1cmVTaGFkZXIuZGVmYXVsdFZlcnRleFNyYztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjIHx8IFRleHR1cmVTaGFkZXIuZGVmYXVsdEZyYWdtZW50U3JjO1xyXG5cclxuICAgIFNoYWRlci5jYWxsKHRoaXMsIHNoYWRlck1hbmFnZXIsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzKTtcclxufVxyXG5cclxuLy8gY29uc3RydWN0b3JcclxuVGV4dHVyZVNoYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNoYWRlci5wcm90b3R5cGUpO1xyXG5UZXh0dXJlU2hhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHR1cmVTaGFkZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZVNoYWRlcjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCB2ZXJ0ZXggc2hhZGVyIHNvdXJjZVxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBjb25zdGFudFxyXG4gKi9cclxuVGV4dHVyZVNoYWRlci5kZWZhdWx0VmVydGV4U3JjID0gW1xyXG4gICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXHJcbiAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXHJcbiAgICAnYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsnLFxyXG4gICAgJ2F0dHJpYnV0ZSB2ZWM0IGFDb2xvcjsnLFxyXG5cclxuICAgICd1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsnLFxyXG5cclxuICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxyXG4gICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcclxuXHJcbiAgICAndm9pZCBtYWluKHZvaWQpeycsXHJcbiAgICAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7JyxcclxuICAgICcgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDsnLFxyXG4gICAgJyAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2VcclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICovXHJcblRleHR1cmVTaGFkZXIuZGVmYXVsdEZyYWdtZW50U3JjID0gW1xyXG4gICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXHJcblxyXG4gICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXHJcbiAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxyXG5cclxuICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxyXG5cclxuICAgICd2b2lkIG1haW4odm9pZCl7JyxcclxuICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yIDsnLFxyXG4gICAgJ30nXHJcbl0uam9pbignXFxuJyk7XHJcbiIsInZhciBXZWJHTE1hbmFnZXIgPSByZXF1aXJlKCcuLi9tYW5hZ2Vycy9XZWJHTE1hbmFnZXInKTtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGZvciBhIGNvbW1vbiBvYmplY3QgcmVuZGVyZXIgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHN5c3RlbSByZW5kZXJlciBwbHVnaW4uXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLldlYkdMTWFuYWdlclxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRoaXMgb2JqZWN0IHJlbmRlcmVyIHdvcmtzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyKVxyXG57XHJcbiAgICBXZWJHTE1hbmFnZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XHJcbn1cclxuXHJcblxyXG5PYmplY3RSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdlYkdMTWFuYWdlci5wcm90b3R5cGUpO1xyXG5PYmplY3RSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPYmplY3RSZW5kZXJlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RSZW5kZXJlcjtcclxuXHJcbi8qKlxyXG4gKiBTdGFydHMgdGhlIHJlbmRlcmVyIGFuZCBzZXRzIHRoZSBzaGFkZXJcclxuICpcclxuICovXHJcbk9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIC8vIHNldCB0aGUgc2hhZGVyLi5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdG9wcyB0aGUgcmVuZGVyZXJcclxuICpcclxuICovXHJcbk9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5mbHVzaCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGZsdXNoZXNcclxuICpcclxuICovXHJcbk9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIC8vIGZsdXNoIVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgYW4gb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSBvYmplY3Qge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIG9iamVjdCB0byByZW5kZXIuXHJcbiAqL1xyXG5PYmplY3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKG9iamVjdCkgLy8ganNoaW50IHVudXNlZDpmYWxzZVxyXG57XHJcbiAgICAvLyByZW5kZXIgdGhlIG9iamVjdFxyXG59O1xyXG4iLCIvKipcclxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIHF1YWRcclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgZ2wgY29udGV4dCBmb3IgdGhpcyBxdWFkIHRvIHVzZS5cclxuICovXHJcbmZ1bmN0aW9uIFF1YWQoZ2wpXHJcbntcclxuICAgIC8qXHJcbiAgICAgKiB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2wgPSBnbDtcclxuXHJcbi8vICAgIHRoaXMudGV4dHVyZXMgPSBuZXcgVGV4dHVyZVV2cygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgdmVydGljZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAwLDAsXHJcbiAgICAgICAgMjAwLDAsXHJcbiAgICAgICAgMjAwLDIwMCxcclxuICAgICAgICAwLDIwMFxyXG4gICAgXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgVXZzIG9mIHRoZSBxdWFkXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgIDAsMCxcclxuICAgICAgICAxLDAsXHJcbiAgICAgICAgMSwxLFxyXG4gICAgICAgIDAsMVxyXG4gICAgXSk7XHJcblxyXG4vLyAgICB2YXIgd2hpdGUgPSAoMHhGRkZGRkYgPj4gMTYpICsgKDB4RkZGRkZGICYgMHhmZjAwKSArICgoMHhGRkZGRkYgJiAweGZmKSA8PCAxNikgKyAoMSAqIDI1NSA8PCAyNCk7XHJcbiAgICAvL1RPRE8gY29udmVydCB0aGlzIHRvIGEgMzIgdW5zaWduZWQgaW50IGFycmF5XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb2xvciBjb21wb25lbnRzIG9mIHRoZSB0cmlhbmdsZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgMSwxLDEsMSxcclxuICAgICAgICAxLDEsMSwxLFxyXG4gICAgICAgIDEsMSwxLDEsXHJcbiAgICAgICAgMSwxLDEsMVxyXG4gICAgXSk7XHJcblxyXG4gICAgLypcclxuICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlc1xyXG4gICAgICovXHJcbiAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoW1xyXG4gICAgICAgIDAsIDEsIDIsIDAsIDMsIDJcclxuICAgIF0pO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXJcclxuICAgICAqL1xyXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcbiAgICAvKlxyXG4gICAgICogQG1lbWJlciB7V2ViR0xCdWZmZXJ9IFRoZSBpbmRleCBidWZmZXJcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XHJcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgKDggKyA4ICsgMTYpICogNCwgZ2wuRFlOQU1JQ19EUkFXKTtcclxuXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgIHRoaXMudXBsb2FkKCk7XHJcbn1cclxuXHJcblF1YWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVhZDtcclxuXHJcbi8qKlxyXG4gKiBNYXBzIHR3byBSZWN0YW5nbGUgdG8gdGhlIHF1YWRcclxuICogQHBhcmFtIHJlY3Qge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZmlyc3QgcmVjdGFuZ2xlXHJcbiAqIEBwYXJhbSByZWN0MiB7UElYSS5SZWN0YW5nbGV9IHRoZSBzZWNvbmQgcmVjdGFuZ2xlXHJcbiAqL1xyXG5RdWFkLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihyZWN0LCByZWN0Milcclxue1xyXG4gICAgdmFyIHggPSAwOyAvL3JlY3QyLnggLyByZWN0LndpZHRoO1xyXG4gICAgdmFyIHkgPSAwOyAvL3JlY3QyLnkgLyByZWN0LmhlaWdodDtcclxuXHJcbiAgICB0aGlzLnV2c1swXSA9IHg7XHJcbiAgICB0aGlzLnV2c1sxXSA9IHk7XHJcblxyXG4gICAgdGhpcy51dnNbMl0gPSB4ICsgcmVjdDIud2lkdGggLyByZWN0LndpZHRoO1xyXG4gICAgdGhpcy51dnNbM10gPSB5O1xyXG5cclxuICAgIHRoaXMudXZzWzRdID0geCArIHJlY3QyLndpZHRoIC8gcmVjdC53aWR0aDtcclxuICAgIHRoaXMudXZzWzVdID0geSArIHJlY3QyLmhlaWdodCAvIHJlY3QuaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMudXZzWzZdID0geDtcclxuICAgIHRoaXMudXZzWzddID0geSArIHJlY3QyLmhlaWdodCAvIHJlY3QuaGVpZ2h0O1xyXG5cclxuICAgIC8vLyAtLS0tLVxyXG4gICAgeCA9IHJlY3QyLng7XHJcbiAgICB5ID0gcmVjdDIueTtcclxuXHJcbiAgICB0aGlzLnZlcnRpY2VzWzBdID0geDtcclxuICAgIHRoaXMudmVydGljZXNbMV0gPSB5O1xyXG5cclxuICAgIHRoaXMudmVydGljZXNbMl0gPSB4ICsgcmVjdDIud2lkdGg7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzNdID0geTtcclxuXHJcbiAgICB0aGlzLnZlcnRpY2VzWzRdID0geCArIHJlY3QyLndpZHRoO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1s1XSA9IHkgKyByZWN0Mi5oZWlnaHQ7XHJcblxyXG4gICAgdGhpcy52ZXJ0aWNlc1s2XSA9IHg7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzddID0geSArIHJlY3QyLmhlaWdodDtcclxuXHJcbiAgICB0aGlzLnVwbG9hZCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJpbmRzIHRoZSBidWZmZXIgYW5kIHVwbG9hZHMgdGhlIGRhdGFcclxuICovXHJcblF1YWQucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uKClcclxue1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAvLyBUT0RPIGNvdWxkIHByb2JhYmx5IGJlIHB1c2hlZCBpbnRvIG9uZSB1cGxvYWQhXHJcbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyICk7XHJcblxyXG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudmVydGljZXMpO1xyXG5cclxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCA4ICogNCwgdGhpcy51dnMpO1xyXG5cclxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAoOCArIDgpICogNCwgdGhpcy5jb2xvcnMpO1xyXG59O1xyXG5cclxuUXVhZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcclxue1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIFxyXG4gICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEJ1ZmZlcik7XHJcbiAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBRdWFkO1xyXG5cclxuXHJcbiIsInZhciBtYXRoID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aCcpLFxyXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpLFxyXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpLFxyXG4gICAgLy9TdGVuY2lsTWFuYWdlciA9IHJlcXVpcmUoJy4uL21hbmFnZXJzL1N0ZW5jaWxNYW5hZ2VyJyksXHJcbiAgICBTdGVuY2lsTWFza1N0YWNrID0gcmVxdWlyZSgnLi9TdGVuY2lsTWFza1N0YWNrJyk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XHJcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSB0aGUgaG9yaXpvbnRhbCByYW5nZSBvZiB0aGUgZmlsdGVyXHJcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIHZlcnRpY2FsIHJhbmdlIG9mIHRoZSBmaWx0ZXJcclxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcclxuICogQHBhcmFtIHJlc29sdXRpb24ge251bWJlcn0gdGhlIGN1cnJlbnQgcmVzb2x1dGlvblxyXG4gKiBAcGFyYW0gcm9vdCB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG9iamVjdCBpcyB0aGUgcm9vdCBlbGVtZW50IG9yIG5vdFxyXG4gKi9cclxudmFyIFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24sIHJvb3QpXHJcbntcclxuICAgIC8vVE9ETyBSZXNvbHV0aW9uIGNvdWxkIGdvIGhlcmUgKCBlZyBsb3cgcmVzIGJsdXJzIClcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2wgPSBnbDtcclxuXHJcbiAgICAvLyBuZXh0IHRpbWUgdG8gY3JlYXRlIGEgZnJhbWUgYnVmZmVyIGFuZCB0ZXh0dXJlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZyYW1lIGJ1ZmZlclxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1dlYkdMRnJhbWVCdWZmZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgb2JqZWN0IGFzIGEgcmVjdGFuZ2xlXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2l6ZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IHJlc29sdXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgQ09OU1QuUkVTT0xVVElPTjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwcm9qZWN0aW9uIG1hdHJpeFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgbWF0aC5NYXRyaXgoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvYmplY3QncyB0cmFuc2Zvcm1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZyYW1lID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdGVuY2lsIGJ1ZmZlciBzdG9yZXMgbWFza2luZyBkYXRhIGZvciB0aGUgcmVuZGVyIHRhcmdldFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyQnVmZmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhdGEgc3RydWN0dXJlIGZvciB0aGUgc3RlbmNpbCBtYXNrc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuU3RlbmNpbE1hc2tTdGFja31cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrID0gbmV3IFN0ZW5jaWxNYXNrU3RhY2soKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlcyBmaWx0ZXIgZGF0YSBmb3IgdGhlIHJlbmRlciB0YXJnZXRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3RbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5maWx0ZXJTdGFjayA9IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlbmRlclRhcmdldDp0aGlzLFxyXG4gICAgICAgICAgICBmaWx0ZXI6W10sXHJcbiAgICAgICAgICAgIGJvdW5kczp0aGlzLnNpemVcclxuICAgICAgICB9XHJcbiAgICBdO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzY2FsZSBtb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IFBJWEkuU0NBTEVfTU9ERVMuREVGQVVMVFxyXG4gICAgICogQHNlZSBQSVhJLlNDQUxFX01PREVTXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlIHx8IENPTlNULlNDQUxFX01PREVTLkRFRkFVTFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgb2JqZWN0IGlzIHRoZSByb290IGVsZW1lbnQgb3Igbm90XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yb290ID0gcm9vdDtcclxuXHJcbiAgICBpZiAoIXRoaXMucm9vdClcclxuICAgIHtcclxuICAgICAgIC8vIHRoaXMuZmxpcFkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICBBIGZyYW1lIGJ1ZmZlciBuZWVkcyBhIHRhcmdldCB0byByZW5kZXIgdG8uLlxyXG4gICAgICAgICAgICBjcmVhdGUgYSB0ZXh0dXJlIGFuZCBiaW5kIGl0IGF0dGFjaCBpdCB0byB0aGUgZnJhbWVidWZmZXIuLlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsICB0aGlzLnRleHR1cmUpO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIHNjYWxlIHByb3BlcnRpZXMgb2YgdGhlIHRleHR1cmUuLlxyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBzY2FsZU1vZGUgPT09IENPTlNULlNDQUxFX01PREVTLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBzY2FsZU1vZGUgPT09IENPTlNULlNDQUxFX01PREVTLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xyXG5cclxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHRleHR1cmUgaXMgYSBwb3dlciBvZiB0d28hXHJcbiAgICAgICAgdmFyIGlzUG93ZXJPZlR3byA9IHV0aWxzLmlzUG93ZXJPZlR3byh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgLy9UT0RPIGZvciA5OSUgb2YgdXNlIGNhc2VzIGlmIGEgdGV4dHVyZSBpcyBwb3dlciBvZiB0d28gd2Ugc2hvdWxkIHRpbGUgdGhlIHRleHR1cmUuLi5cclxuICAgICAgICAgaWYgKCFpc1Bvd2VyT2ZUd28pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5SRVBFQVQpO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyICk7XHJcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG59O1xyXG5cclxuUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlbmRlclRhcmdldDtcclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJUYXJnZXQ7XHJcblxyXG4vKipcclxuICogQ2xlYXJzIHRoZSBmaWx0ZXIgdGV4dHVyZS5cclxuICpcclxuICogQHBhcmFtIFtiaW5kPWZhbHNlXSB7Ym9vbGVhbn0gU2hvdWxkIHdlIGJpbmQgb3VyIGZyYW1lYnVmZmVyIGJlZm9yZSBjbGVhcmluZz9cclxuICovXHJcblJlbmRlclRhcmdldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihiaW5kKVxyXG57XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgaWYoYmluZClcclxuICAgIHtcclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGdsLmNsZWFyQ29sb3IoMCwwLDAsMCk7XHJcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCaW5kcyB0aGUgc3RlbmNpbCBidWZmZXIuXHJcbiAqXHJcbiAqL1xyXG5SZW5kZXJUYXJnZXQucHJvdG90eXBlLmF0dGFjaFN0ZW5jaWxCdWZmZXIgPSBmdW5jdGlvbigpXHJcbntcclxuXHJcbiAgICBpZiAodGhpcy5zdGVuY2lsQnVmZmVyKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdGVuY2lsIGJ1ZmZlciBpcyB1c2VkIGZvciBtYXNraW5nIGluIHBpeGlcclxuICAgICAqIGxldHMgY3JlYXRlIG9uZSBhbmQgdGhlbiBhZGQgYXR0YWNoIGl0IHRvIHRoZSBmcmFtZWJ1ZmZlci4uXHJcbiAgICAgKi9cclxuICAgIGlmICghdGhpcy5yb290KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgIHRoaXMuc3RlbmNpbEJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnN0ZW5jaWxCdWZmZXIpO1xyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5zdGVuY2lsQnVmZmVyKTtcclxuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgIHRoaXMuc2l6ZS53aWR0aCAqIHRoaXMucmVzb2x1dGlvbiAgLCB0aGlzLnNpemUuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uICk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQmluZHMgdGhlIGJ1ZmZlcnMgYW5kIGluaXRpYWxpc2VzIHRoZSB2aWV3cG9ydC5cclxuICpcclxuICovXHJcblJlbmRlclRhcmdldC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpXHJcbntcclxuICAgIC8vVE9PRCByZWZhY3RvciB1c2FnZSBvZiBmcmFtZS4uXHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlcik7XHJcblxyXG4gICAgdmFyIHByb2plY3Rpb25GcmFtZSA9IHRoaXMuZnJhbWUgfHwgdGhpcy5zaXplO1xyXG5cclxuICAgIC8vIFRPRE8gYWRkIGEgZGlydHkgZmxhZyB0byB0aGlzIG9mIGEgc2V0dGVyIGZvciB0aGUgZnJhbWU/XHJcbiAgICB0aGlzLmNhbGN1bGF0ZVByb2plY3Rpb24oIHByb2plY3Rpb25GcmFtZSApO1xyXG5cclxuICAgIGlmKHRoaXMudHJhbnNmb3JtKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5hcHBlbmQodGhpcy50cmFuc2Zvcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdsLnZpZXdwb3J0KDAsMCwgcHJvamVjdGlvbkZyYW1lLndpZHRoICogdGhpcy5yZXNvbHV0aW9uLCBwcm9qZWN0aW9uRnJhbWUuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCBiYXNlZCBvbiBhIHByb2plY3Rpb24gZnJhbWUgKHdoaWNoIGlzIGEgcmVjdGFuZ2xlKVxyXG4gKlxyXG4gKi9cclxuUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5jYWxjdWxhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24gKHByb2plY3Rpb25GcmFtZSlcclxue1xyXG4gICAgdmFyIHBtID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4O1xyXG5cclxuICAgIHBtLmlkZW50aXR5KCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLnJvb3QpXHJcbiAgICB7XHJcbiAgICAgICAgcG0uYSA9IDEgLyBwcm9qZWN0aW9uRnJhbWUud2lkdGgqMjtcclxuICAgICAgICBwbS5kID0gMSAvIHByb2plY3Rpb25GcmFtZS5oZWlnaHQqMjtcclxuXHJcbiAgICAgICAgcG0udHggPSAtMSAtIHByb2plY3Rpb25GcmFtZS54ICogcG0uYTtcclxuICAgICAgICBwbS50eSA9IC0xIC0gcHJvamVjdGlvbkZyYW1lLnkgKiBwbS5kO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHBtLmEgPSAxIC8gcHJvamVjdGlvbkZyYW1lLndpZHRoKjI7XHJcbiAgICAgICAgcG0uZCA9IC0xIC8gcHJvamVjdGlvbkZyYW1lLmhlaWdodCoyO1xyXG5cclxuICAgICAgICBwbS50eCA9IC0xIC0gcHJvamVjdGlvbkZyYW1lLnggKiBwbS5hO1xyXG4gICAgICAgIHBtLnR5ID0gMSAtIHByb2plY3Rpb25GcmFtZS55ICogcG0uZDtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmVzaXplcyB0aGUgdGV4dHVyZSB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcclxuICpcclxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcclxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgdGV4dHVyZVxyXG4gKi9cclxuUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgd2lkdGggPSB3aWR0aCB8IDA7XHJcbiAgICBoZWlnaHQgPSBoZWlnaHQgfCAwO1xyXG5cclxuICAgIGlmICh0aGlzLnNpemUud2lkdGggPT09IHdpZHRoICYmIHRoaXMuc2l6ZS5oZWlnaHQgPT09IGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNpemUud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuc2l6ZS5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgaWYgKCF0aGlzLnJvb3QpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgIHRoaXMudGV4dHVyZSk7XHJcblxyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgIHdpZHRoICogdGhpcy5yZXNvbHV0aW9uLCBoZWlnaHQgKiB0aGlzLnJlc29sdXRpb24gLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc3RlbmNpbEJ1ZmZlciApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHN0ZW5jaWwgYnVmZmVyIHdpZHRoIGFuZCBoZWlnaHRcclxuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHRoaXMuc3RlbmNpbEJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCAgd2lkdGggKiB0aGlzLnJlc29sdXRpb24sIGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbiApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvamVjdGlvbkZyYW1lID0gdGhpcy5mcmFtZSB8fCB0aGlzLnNpemU7XHJcblxyXG4gICAgdGhpcy5jYWxjdWxhdGVQcm9qZWN0aW9uKCBwcm9qZWN0aW9uRnJhbWUgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXN0cm95cyB0aGUgcmVuZGVyIHRhcmdldC5cclxuICpcclxuICovXHJcblJlbmRlclRhcmdldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIoIHRoaXMuc3RlbmNpbEJ1ZmZlciApO1xyXG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHRoaXMuZnJhbWVCdWZmZXIgKTtcclxuICAgIGdsLmRlbGV0ZVRleHR1cmUoIHRoaXMudGV4dHVyZSApO1xyXG5cclxuICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcclxufTtcclxuIiwiLyoqXHJcbiAqIEdlbmVyaWMgTWFzayBTdGFjayBkYXRhIHN0cnVjdHVyZVxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICovXHJcbmZ1bmN0aW9uIFN0ZW5jaWxNYXNrU3RhY2soKVxyXG57XHJcblx0LyoqXHJcbiAgICAgKiBUaGUgYWN0dWFsIHN0YWNrXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7YW55W119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RlbmNpbFN0YWNrID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPIEBhbHZpblxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmV2ZXJzZSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBjb3VudFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb3VudCA9IDA7XHJcbn1cclxuXHJcblN0ZW5jaWxNYXNrU3RhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RlbmNpbE1hc2tTdGFjaztcclxubW9kdWxlLmV4cG9ydHMgPSBTdGVuY2lsTWFza1N0YWNrO1xyXG4iLCJ2YXIgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcclxuICAgIFRleHR1cmUgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9UZXh0dXJlJyksXHJcbiAgICBDb250YWluZXIgPSByZXF1aXJlKCcuLi9kaXNwbGF5L0NvbnRhaW5lcicpLFxyXG4gICAgQ2FudmFzVGludGVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNUaW50ZXInKSxcclxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKSxcclxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcclxuICAgIHRlbXBQb2ludCA9IG5ldyBtYXRoLlBvaW50KCk7XHJcblxyXG4vKipcclxuICogVGhlIFNwcml0ZSBvYmplY3QgaXMgdGhlIGJhc2UgZm9yIGFsbCB0ZXh0dXJlZCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIHRvIHRoZSBzY3JlZW5cclxuICpcclxuICogQSBzcHJpdGUgY2FuIGJlIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBhbiBpbWFnZSBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUuZnJvbUltYWdlKCdhc3NldHMvaW1hZ2UucG5nJyk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5Db250YWluZXJcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIHRleHR1cmUge1BJWEkuVGV4dHVyZX0gVGhlIHRleHR1cmUgZm9yIHRoaXMgc3ByaXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBTcHJpdGUodGV4dHVyZSlcclxue1xyXG4gICAgQ29udGFpbmVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYW5jaG9yIHNldHMgdGhlIG9yaWdpbiBwb2ludCBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAqIFRoZSBkZWZhdWx0IGlzIDAsMCB0aGlzIG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdFxyXG4gICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIDAuNSwwLjUgbWVhbnMgdGhlIHRleHR1cmUncyBvcmlnaW4gaXMgY2VudGVyZWRcclxuICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byAxLDEgd291bGQgbWVhbiB0aGUgdGV4dHVyZSdzIG9yaWdpbiBwb2ludCB3aWxsIGJlIHRoZSBib3R0b20gcmlnaHQgY29ybmVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5hbmNob3IgPSBuZXcgbWF0aC5Qb2ludCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSAodGhpcyBpcyBpbml0aWFsbHkgc2V0IGJ5IHRoZSB0ZXh0dXJlKVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3dpZHRoID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSAodGhpcyBpcyBpbml0aWFsbHkgc2V0IGJ5IHRoZSB0ZXh0dXJlKVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2hlaWdodCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuIEEgdmFsdWUgb2YgMHhGRkZGRkYgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXHJcbiAgICAgKi9cclxuICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBBcHBseSBhIHZhbHVlIG9mIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcclxuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xyXG4gICAgICovXHJcbiAgICB0aGlzLmJsZW5kTW9kZSA9IENPTlNULkJMRU5EX01PREVTLk5PUk1BTDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzaGFkZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBzcHJpdGUuIFNldCB0byBudWxsIHRvIHJlbW92ZSBhIGN1cnJlbnQgc2hhZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuQWJzdHJhY3RGaWx0ZXJ8UElYSS5TaGFkZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGludGVybmFsIGNhY2hlZCB2YWx1ZSBvZiB0aGUgdGludC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcclxuXHJcbiAgICAvLyBjYWxsIHRleHR1cmUgc2V0dGVyXHJcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlIHx8IFRleHR1cmUuRU1QVFk7XHJcbn1cclxuXHJcbi8vIGNvbnN0cnVjdG9yXHJcblNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnRhaW5lci5wcm90b3R5cGUpO1xyXG5TcHJpdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByaXRlO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNwcml0ZS5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuU3ByaXRlI1xyXG4gICAgICovXHJcbiAgICB3aWR0aDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy50ZXh0dXJlLl9mcmFtZS53aWR0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gc2lnbiAqIHZhbHVlIC8gdGhpcy50ZXh0dXJlLl9mcmFtZS53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLlNwcml0ZSNcclxuICAgICAqL1xyXG4gICAgaGVpZ2h0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy50ZXh0dXJlLl9mcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IHNpZ24gKiB2YWx1ZSAvIHRoaXMudGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuU3ByaXRlI1xyXG4gICAgICovXHJcbiAgICB0ZXh0dXJlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICB0aGlzLl90ZXh0dXJlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcclxuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIHRleHR1cmUgdG8gbG9hZFxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vbmNlKCd1cGRhdGUnLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSB0ZXh0dXJlIGlzIHVwZGF0ZWQsIHRoaXMgZXZlbnQgd2lsbCBmaXJlIHRvIHVwZGF0ZSB0aGUgc2NhbGUgYW5kIGZyYW1lXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5TcHJpdGUucHJvdG90eXBlLl9vblRleHR1cmVVcGRhdGUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvLyBzbyBpZiBfd2lkdGggaXMgMCB0aGVuIHdpZHRoIHdhcyBub3Qgc2V0Li5cclxuICAgIGlmICh0aGlzLl93aWR0aClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNjYWxlLnggPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueCkgKiB0aGlzLl93aWR0aCAvIHRoaXMudGV4dHVyZS5mcmFtZS53aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5faGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2NhbGUueSA9IHV0aWxzLnNpZ24odGhpcy5zY2FsZS55KSAqIHRoaXMuX2hlaWdodCAvIHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuKlxyXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcclxuKlxyXG4qIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfVxyXG4qIEBwcml2YXRlXHJcbiovXHJcblNwcml0ZS5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxyXG57XHJcbiAgICByZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLnNwcml0ZSk7XHJcbiAgICByZW5kZXJlci5wbHVnaW5zLnNwcml0ZS5yZW5kZXIodGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBTcHJpdGUgYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC5cclxuICpcclxuICogQHBhcmFtIG1hdHJpeCB7UElYSS5NYXRyaXh9IHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIHNwcml0ZVxyXG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXHJcbiAqL1xyXG5TcHJpdGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChtYXRyaXgpXHJcbntcclxuICAgIGlmKCF0aGlzLl9jdXJyZW50Qm91bmRzKVxyXG4gICAge1xyXG5cclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl90ZXh0dXJlLl9mcmFtZS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgdzAgPSB3aWR0aCAqICgxLXRoaXMuYW5jaG9yLngpO1xyXG4gICAgICAgIHZhciB3MSA9IHdpZHRoICogLXRoaXMuYW5jaG9yLng7XHJcblxyXG4gICAgICAgIHZhciBoMCA9IGhlaWdodCAqICgxLXRoaXMuYW5jaG9yLnkpO1xyXG4gICAgICAgIHZhciBoMSA9IGhlaWdodCAqIC10aGlzLmFuY2hvci55O1xyXG5cclxuICAgICAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXggfHwgdGhpcy53b3JsZFRyYW5zZm9ybSA7XHJcblxyXG4gICAgICAgIHZhciBhID0gd29ybGRUcmFuc2Zvcm0uYTtcclxuICAgICAgICB2YXIgYiA9IHdvcmxkVHJhbnNmb3JtLmI7XHJcbiAgICAgICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5jO1xyXG4gICAgICAgIHZhciBkID0gd29ybGRUcmFuc2Zvcm0uZDtcclxuICAgICAgICB2YXIgdHggPSB3b3JsZFRyYW5zZm9ybS50eDtcclxuICAgICAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTtcclxuXHJcbiAgICAgICAgdmFyIG1pblgsXHJcbiAgICAgICAgICAgIG1heFgsXHJcbiAgICAgICAgICAgIG1pblksXHJcbiAgICAgICAgICAgIG1heFk7XHJcblxyXG4gICAgICAgIC8vVE9ETyAtIEkgYW0gU1VSRSB0aGlzIGNhbiBiZSBvcHRpbWlzZWQsIGJ1dCB0aGUgYmVsb3cgaXMgbm90IGFjY3VyYXRlIGVub3VnaC4uXHJcbiAgICAgICAgLypcclxuICAgICAgICBpZiAoYiA9PT0gMCAmJiBjID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gc2NhbGUgbWF5IGJlIG5lZ2F0aXZlIVxyXG4gICAgICAgICAgICBpZiAoYSA8IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGEgKj0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkIDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGVyZSBpcyBubyByb3RhdGlvbiBnb2luZyBvbiByaWdodD8gUklHSFQ/XHJcbiAgICAgICAgICAgIC8vIGlmIHRoYXRzIHRoZSBjYXNlIHRoZW4gd2UgY2FuIGF2b2lkIGNoZWNraW5nIHRoZSBib3VuZCB2YWx1ZXMhIHlheVxyXG4gICAgICAgICAgICBtaW5YID0gYSAqIHcxICsgdHg7XHJcbiAgICAgICAgICAgIG1heFggPSBhICogdzAgKyB0eDtcclxuICAgICAgICAgICAgbWluWSA9IGQgKiBoMSArIHR5O1xyXG4gICAgICAgICAgICBtYXhZID0gZCAqIGgwICsgdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgKi9cclxuICAgICAgIFxyXG4gICAgICAgIHZhciB4MSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xyXG4gICAgICAgIHZhciB5MSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xyXG5cclxuICAgICAgICB2YXIgeDIgPSBhICogdzAgKyBjICogaDEgKyB0eDtcclxuICAgICAgICB2YXIgeTIgPSBkICogaDEgKyBiICogdzAgKyB0eTtcclxuXHJcbiAgICAgICAgdmFyIHgzID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XHJcbiAgICAgICAgdmFyIHkzID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XHJcblxyXG4gICAgICAgIHZhciB4NCA9ICBhICogdzEgKyBjICogaDAgKyB0eDtcclxuICAgICAgICB2YXIgeTQgPSAgZCAqIGgwICsgYiAqIHcxICsgdHk7XHJcblxyXG4gICAgICAgIG1pblggPSB4MTtcclxuICAgICAgICBtaW5YID0geDIgPCBtaW5YID8geDIgOiBtaW5YO1xyXG4gICAgICAgIG1pblggPSB4MyA8IG1pblggPyB4MyA6IG1pblg7XHJcbiAgICAgICAgbWluWCA9IHg0IDwgbWluWCA/IHg0IDogbWluWDtcclxuXHJcbiAgICAgICAgbWluWSA9IHkxO1xyXG4gICAgICAgIG1pblkgPSB5MiA8IG1pblkgPyB5MiA6IG1pblk7XHJcbiAgICAgICAgbWluWSA9IHkzIDwgbWluWSA/IHkzIDogbWluWTtcclxuICAgICAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xyXG5cclxuICAgICAgICBtYXhYID0geDE7XHJcbiAgICAgICAgbWF4WCA9IHgyID4gbWF4WCA/IHgyIDogbWF4WDtcclxuICAgICAgICBtYXhYID0geDMgPiBtYXhYID8geDMgOiBtYXhYO1xyXG4gICAgICAgIG1heFggPSB4NCA+IG1heFggPyB4NCA6IG1heFg7XHJcblxyXG4gICAgICAgIG1heFkgPSB5MTtcclxuICAgICAgICBtYXhZID0geTIgPiBtYXhZID8geTIgOiBtYXhZO1xyXG4gICAgICAgIG1heFkgPSB5MyA+IG1heFkgPyB5MyA6IG1heFk7XHJcbiAgICAgICAgbWF4WSA9IHk0ID4gbWF4WSA/IHk0IDogbWF4WTtcclxuXHJcbiAgICAgICAgLy99XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIGZvciBjaGlsZHJlblxyXG4gICAgICAgIGlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkQm91bmRzID0gdGhpcy5jb250YWluZXJHZXRCb3VuZHMoKTtcclxuXHJcbiAgICAgICAgICAgIHcwID0gY2hpbGRCb3VuZHMueDtcclxuICAgICAgICAgICAgdzEgPSBjaGlsZEJvdW5kcy54ICsgY2hpbGRCb3VuZHMud2lkdGg7XHJcbiAgICAgICAgICAgIGgwID0gY2hpbGRCb3VuZHMueTtcclxuICAgICAgICAgICAgaDEgPSBjaGlsZEJvdW5kcy55ICsgY2hpbGRCb3VuZHMuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgbWluWCA9IChtaW5YIDwgdzApID8gbWluWCA6IHcwO1xyXG4gICAgICAgICAgICBtaW5ZID0gKG1pblkgPCBoMCkgPyBtaW5ZIDogaDA7XHJcblxyXG4gICAgICAgICAgICBtYXhYID0gKG1heFggPiB3MSkgPyBtYXhYIDogdzE7XHJcbiAgICAgICAgICAgIG1heFkgPSAobWF4WSA+IGgxKSA/IG1heFkgOiBoMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XHJcblxyXG4gICAgICAgIGJvdW5kcy54ID0gbWluWDtcclxuICAgICAgICBib3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcclxuXHJcbiAgICAgICAgYm91bmRzLnkgPSBtaW5ZO1xyXG4gICAgICAgIGJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuXHJcbiAgICAgICAgLy8gc3RvcmUgYSByZWZlcmVuY2Ugc28gdGhhdCBpZiB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGFnYWluIGluIHRoZSByZW5kZXIgY3ljbGUgd2UgZG8gbm90IGhhdmUgdG8gcmVjYWxjdWxhdGVcclxuICAgICAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gYm91bmRzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qm91bmRzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgc3ByaXRlIG9iamVjdC5cclxuICpcclxuICovXHJcblNwcml0ZS5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLl9ib3VuZHMueCA9IC10aGlzLl90ZXh0dXJlLl9mcmFtZS53aWR0aCAqIHRoaXMuYW5jaG9yLng7XHJcbiAgICB0aGlzLl9ib3VuZHMueSA9IC10aGlzLl90ZXh0dXJlLl9mcmFtZS5oZWlnaHQgKiB0aGlzLmFuY2hvci55O1xyXG4gICAgdGhpcy5fYm91bmRzLndpZHRoID0gdGhpcy5fdGV4dHVyZS5fZnJhbWUud2lkdGg7XHJcbiAgICB0aGlzLl9ib3VuZHMuaGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xyXG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcclxufTtcclxuXHJcbi8qKlxyXG4qIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgc3ByaXRlXHJcbipcclxuKiBAcGFyYW0gcG9pbnQge1BJWEkuUG9pbnR9IHRoZSBwb2ludCB0byB0ZXN0XHJcbiogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxyXG4qL1xyXG5TcHJpdGUucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiggcG9pbnQgKVxyXG57XHJcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgIHRlbXBQb2ludCk7XHJcblxyXG4gICAgdmFyIHdpZHRoID0gdGhpcy5fdGV4dHVyZS5fZnJhbWUud2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xyXG4gICAgdmFyIHgxID0gLXdpZHRoICogdGhpcy5hbmNob3IueDtcclxuICAgIHZhciB5MTtcclxuXHJcbiAgICBpZiAoIHRlbXBQb2ludC54ID4geDEgJiYgdGVtcFBvaW50LnggPCB4MSArIHdpZHRoIClcclxuICAgIHtcclxuICAgICAgICB5MSA9IC1oZWlnaHQgKiB0aGlzLmFuY2hvci55O1xyXG5cclxuICAgICAgICBpZiAoIHRlbXBQb2ludC55ID4geTEgJiYgdGVtcFBvaW50LnkgPCB5MSArIGhlaWdodCApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcclxuKlxyXG4qIEBwYXJhbSByZW5kZXJlciB7UElYSS5DYW52YXNSZW5kZXJlcn0gVGhlIHJlbmRlcmVyXHJcbiogQHByaXZhdGVcclxuKi9cclxuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxyXG57XHJcbiAgICBpZiAodGhpcy50ZXh0dXJlLmNyb3Aud2lkdGggPD0gMCB8fCB0aGlzLnRleHR1cmUuY3JvcC5oZWlnaHQgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbXBvc2l0ZU9wZXJhdGlvbiA9IHJlbmRlcmVyLmJsZW5kTW9kZXNbdGhpcy5ibGVuZE1vZGVdO1xyXG4gICAgaWYgKGNvbXBvc2l0ZU9wZXJhdGlvbiAhPT0gcmVuZGVyZXIuY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIElnbm9yZSBudWxsIHNvdXJjZXNcclxuICAgIGlmICh0aGlzLnRleHR1cmUudmFsaWQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlLFxyXG4gICAgICAgICAgICB3dCA9IHRoaXMud29ybGRUcmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIGR4LFxyXG4gICAgICAgICAgICBkeSxcclxuICAgICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDtcclxuXHJcbiAgICAgICAgcmVuZGVyZXIuY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcclxuXHJcbiAgICAgICAgLy8gSWYgc21vb3RoaW5nRW5hYmxlZCBpcyBzdXBwb3J0ZWQgYW5kIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBzbW9vdGhpbmcgcHJvcGVydHkgZm9yIHRoaXMgdGV4dHVyZVxyXG4gICAgICAgIHZhciBzbW9vdGhpbmdFbmFibGVkID0gdGV4dHVyZS5iYXNlVGV4dHVyZS5zY2FsZU1vZGUgPT09IENPTlNULlNDQUxFX01PREVTLkxJTkVBUjtcclxuICAgICAgICBpZiAocmVuZGVyZXIuc21vb3RoUHJvcGVydHkgJiYgcmVuZGVyZXIuY29udGV4dFtyZW5kZXJlci5zbW9vdGhQcm9wZXJ0eV0gIT09IHNtb290aGluZ0VuYWJsZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW5kZXJlci5jb250ZXh0W3JlbmRlcmVyLnNtb290aFByb3BlcnR5XSA9IHNtb290aGluZ0VuYWJsZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGUgdGV4dHVyZSBpcyB0cmltbWVkIHdlIG9mZnNldCBieSB0aGUgdHJpbSB4L3ksIG90aGVyd2lzZSB3ZSB1c2UgdGhlIGZyYW1lIGRpbWVuc2lvbnNcclxuXHJcbiAgICAgICAgaWYodGV4dHVyZS5yb3RhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3aWR0aCA9IHRleHR1cmUuY3JvcC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHRleHR1cmUuY3JvcC53aWR0aDtcclxuXHJcbiAgICAgICAgICAgIGR4ID0gKHRleHR1cmUudHJpbSkgPyB0ZXh0dXJlLnRyaW0ueSAtIHRoaXMuYW5jaG9yLnkgKiB0ZXh0dXJlLnRyaW0uaGVpZ2h0IDogdGhpcy5hbmNob3IueSAqIC10ZXh0dXJlLl9mcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGR5ID0gKHRleHR1cmUudHJpbSkgPyB0ZXh0dXJlLnRyaW0ueCAtIHRoaXMuYW5jaG9yLnggKiB0ZXh0dXJlLnRyaW0ud2lkdGggOiB0aGlzLmFuY2hvci54ICogLXRleHR1cmUuX2ZyYW1lLndpZHRoO1xyXG4gICAgICAgXHJcbiAgICAgICAgICAgIGR4ICs9IHdpZHRoO1xyXG5cclxuICAgICAgICAgICAgd3QudHggPSBkeSAqIHd0LmEgKyBkeCAqIHd0LmMgKyB3dC50eDtcclxuICAgICAgICAgICAgd3QudHkgPSBkeSAqIHd0LmIgKyBkeCAqIHd0LmQgKyB3dC50eTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gd3QuYTtcclxuICAgICAgICAgICAgd3QuYSAgPSAtd3QuYztcclxuICAgICAgICAgICAgd3QuYyAgPSAgdGVtcDtcclxuXHJcbiAgICAgICAgICAgIHRlbXAgPSB3dC5iO1xyXG4gICAgICAgICAgICB3dC5iICA9IC13dC5kO1xyXG4gICAgICAgICAgICB3dC5kICA9ICB0ZW1wO1xyXG5cclxuICAgICAgICAgICAgLy8gdGhlIGFuY2hvciBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYWJvdmUsIHNvIGxldHMgc2V0IGl0IHRvIHplcm9cclxuICAgICAgICAgICAgZHggPSAwO1xyXG4gICAgICAgICAgICBkeSA9IDA7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3aWR0aCA9IHRleHR1cmUuY3JvcC53aWR0aDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gdGV4dHVyZS5jcm9wLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGR4ID0gKHRleHR1cmUudHJpbSkgPyB0ZXh0dXJlLnRyaW0ueCAtIHRoaXMuYW5jaG9yLnggKiB0ZXh0dXJlLnRyaW0ud2lkdGggOiB0aGlzLmFuY2hvci54ICogLXRleHR1cmUuX2ZyYW1lLndpZHRoO1xyXG4gICAgICAgICAgICBkeSA9ICh0ZXh0dXJlLnRyaW0pID8gdGV4dHVyZS50cmltLnkgLSB0aGlzLmFuY2hvci55ICogdGV4dHVyZS50cmltLmhlaWdodCA6IHRoaXMuYW5jaG9yLnkgKiAtdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBBbGxvdyBmb3IgcGl4ZWwgcm91bmRpbmdcclxuICAgICAgICBpZiAocmVuZGVyZXIucm91bmRQaXhlbHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW5kZXJlci5jb250ZXh0LnNldFRyYW5zZm9ybShcclxuICAgICAgICAgICAgICAgIHd0LmEsXHJcbiAgICAgICAgICAgICAgICB3dC5iLFxyXG4gICAgICAgICAgICAgICAgd3QuYyxcclxuICAgICAgICAgICAgICAgIHd0LmQsXHJcbiAgICAgICAgICAgICAgICAod3QudHggKiByZW5kZXJlci5yZXNvbHV0aW9uKSB8IDAsXHJcbiAgICAgICAgICAgICAgICAod3QudHkgKiByZW5kZXJlci5yZXNvbHV0aW9uKSB8IDBcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGR4ID0gZHggfCAwO1xyXG4gICAgICAgICAgICBkeSA9IGR5IHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRleHQuc2V0VHJhbnNmb3JtKFxyXG4gICAgICAgICAgICAgICAgd3QuYSxcclxuICAgICAgICAgICAgICAgIHd0LmIsXHJcbiAgICAgICAgICAgICAgICB3dC5jLFxyXG4gICAgICAgICAgICAgICAgd3QuZCxcclxuICAgICAgICAgICAgICAgIHd0LnR4ICogcmVuZGVyZXIucmVzb2x1dGlvbixcclxuICAgICAgICAgICAgICAgIHd0LnR5ICogcmVuZGVyZXIucmVzb2x1dGlvblxyXG4gICAgICAgICAgICApO1xyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudGludCAhPT0gMHhGRkZGRkYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZWRUaW50ICE9PSB0aGlzLnRpbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkVGludCA9IHRoaXMudGludDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGNsZWFuIHVwIGNhY2hpbmcgLSBob3cgdG8gY2xlYW4gdXAgdGhlIGNhY2hlcz9cclxuICAgICAgICAgICAgICAgIHRoaXMudGludGVkVGV4dHVyZSA9IENhbnZhc1RpbnRlci5nZXRUaW50ZWRUZXh0dXJlKHRoaXMsIHRoaXMudGludCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRleHQuZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICAgICAgdGhpcy50aW50ZWRUZXh0dXJlLFxyXG4gICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICB3aWR0aCAqIHJlc29sdXRpb24sXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgKiByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgZHggKiByZW5kZXJlci5yZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgZHkgKiByZW5kZXJlci5yZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgd2lkdGggKiByZW5kZXJlci5yZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICogcmVuZGVyZXIucmVzb2x1dGlvblxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW5kZXJlci5jb250ZXh0LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5jcm9wLnggKiByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5jcm9wLnkgKiByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgd2lkdGggKiByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICogcmVzb2x1dGlvbixcclxuICAgICAgICAgICAgICAgIGR4ICAqIHJlbmRlcmVyLnJlc29sdXRpb24sXHJcbiAgICAgICAgICAgICAgICBkeSAgKiByZW5kZXJlci5yZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgd2lkdGggKiByZW5kZXJlci5yZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICogcmVuZGVyZXIucmVzb2x1dGlvblxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXN0cm95cyB0aGlzIHNwcml0ZSBhbmQgb3B0aW9uYWxseSBpdHMgdGV4dHVyZVxyXG4gKlxyXG4gKiBAcGFyYW0gW2Rlc3Ryb3lUZXh0dXJlPWZhbHNlXSB7Ym9vbGVhbn0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcclxuICogQHBhcmFtIFtkZXN0cm95QmFzZVRleHR1cmU9ZmFsc2VdIHtib29sZWFufSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxyXG4gKi9cclxuU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGRlc3Ryb3lUZXh0dXJlLCBkZXN0cm95QmFzZVRleHR1cmUpXHJcbntcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuYW5jaG9yID0gbnVsbDtcclxuXHJcbiAgICBpZiAoZGVzdHJveVRleHR1cmUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lCYXNlVGV4dHVyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XHJcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbn07XHJcblxyXG4vLyBzb21lIGhlbHBlciBmdW5jdGlvbnMuLlxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVDYWNoZSBiYXNlZCBvbiB0aGUgZnJhbWVJZFxyXG4gKiBUaGUgZnJhbWUgaWRzIGFyZSBjcmVhdGVkIHdoZW4gYSBUZXh0dXJlIHBhY2tlciBmaWxlIGhhcyBiZWVuIGxvYWRlZFxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSBmcmFtZUlkIHtzdHJpbmd9IFRoZSBmcmFtZSBJZCBvZiB0aGUgdGV4dHVyZSBpbiB0aGUgY2FjaGVcclxuICogQHBhcmFtIFtjcm9zc29yaWdpbj0oYXV0byldIHtib29sZWFufSBpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSBjcm9zcy1vcmlnaW4gcGFyYW1ldGVyXHJcbiAqIEBwYXJhbSBbc2NhbGVNb2RlPVBJWEkuU0NBTEVfTU9ERVMuREVGQVVMVF0ge251bWJlcn0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgc2NhbGUgbW9kZSwgc2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXHJcbiAqIEByZXR1cm4ge1BJWEkuU3ByaXRlfSBBIG5ldyBTcHJpdGUgdXNpbmcgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmUgY2FjaGUgbWF0Y2hpbmcgdGhlIGZyYW1lSWRcclxuICovXHJcblNwcml0ZS5mcm9tRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJZClcclxue1xyXG4gICAgdmFyIHRleHR1cmUgPSB1dGlscy5UZXh0dXJlQ2FjaGVbZnJhbWVJZF07XHJcblxyXG4gICAgaWYgKCF0ZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZyYW1lSWQgXCInICsgZnJhbWVJZCArICdcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdGV4dHVyZSBjYWNoZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgU3ByaXRlKHRleHR1cmUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGJhc2VkIG9uIGFuIGltYWdlIHVybFxyXG4gKiBJZiB0aGUgaW1hZ2UgaXMgbm90IGluIHRoZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgbG9hZGVkXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIGltYWdlSWQge3N0cmluZ30gVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxyXG4gKiBAcmV0dXJuIHtQSVhJLlNwcml0ZX0gQSBuZXcgU3ByaXRlIHVzaW5nIGEgdGV4dHVyZSBmcm9tIHRoZSB0ZXh0dXJlIGNhY2hlIG1hdGNoaW5nIHRoZSBpbWFnZSBpZFxyXG4gKi9cclxuU3ByaXRlLmZyb21JbWFnZSA9IGZ1bmN0aW9uIChpbWFnZUlkLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFNwcml0ZShUZXh0dXJlLmZyb21JbWFnZShpbWFnZUlkLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKSk7XHJcbn07XHJcbiIsInZhciBPYmplY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlcicpLFxyXG4gICAgV2ViR0xSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyJyksXHJcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBNYXQgR3JvdmVzXHJcbiAqXHJcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXHJcbiAqIGZvciBjcmVhdGluZyB0aGUgb3JpZ2luYWwgcGl4aSB2ZXJzaW9uIVxyXG4gKiBBbHNvIGEgdGhhbmtzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9iY2hldmFsaWVyIGZvciB0d2Vha2luZyB0aGUgdGludCBhbmQgYWxwaGEgc28gdGhhdCB0aGV5IG5vdyBzaGFyZSA0IGJ5dGVzIG9uIHRoZSB2ZXJ0ZXggYnVmZmVyXHJcbiAqXHJcbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnkgTGliR0RYJ3MgU3ByaXRlUmVuZGVyZXI6XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvU3ByaXRlUmVuZGVyZXIuamF2YVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJlciBkZWRpY2F0ZWQgdG8gZHJhd2luZyBhbmQgYmF0Y2hpbmcgc3ByaXRlcy5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqIEBleHRlbmRzIFBJWEkuT2JqZWN0UmVuZGVyZXJcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIHNwcml0ZSBiYXRjaCB3b3JrcyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBTcHJpdGVSZW5kZXJlcihyZW5kZXJlcilcclxue1xyXG4gICAgT2JqZWN0UmVuZGVyZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOdW1iZXIgb2YgdmFsdWVzIHNlbnQgaW4gdGhlIHZlcnRleCBidWZmZXIuXHJcbiAgICAgKiBwb3NpdGlvblgsIHBvc2l0aW9uWSwgY29sb3JSLCBjb2xvckcsIGNvbG9yQiA9IDVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmVydFNpemUgPSA1O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNpemUgb2YgdGhlIHZlcnRleCBpbmZvcm1hdGlvbiBpbiBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmVydEJ5dGVTaXplID0gdGhpcy52ZXJ0U2l6ZSAqIDQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGltYWdlcyBpbiB0aGUgU3ByaXRlQmF0Y2ggYmVmb3JlIGl0IGZsdXNoZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNpemUgPSBDT05TVC5TUFJJVEVfQkFUQ0hfU0laRTsgLy8gMjAwMCBpcyBhIG5pY2UgYmFsYW5jZSBiZXR3ZWVuIG1vYmlsZSAvIGRlc2t0b3BcclxuXHJcbiAgICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGluIG91ciBiYXRjaFxyXG4gICAgdmFyIG51bVZlcnRzID0gKHRoaXMuc2l6ZSAqIDQpICogdGhpcy52ZXJ0Qnl0ZVNpemU7XHJcblxyXG4gICAgLy8gdGhlIHRvdGFsIG51bWJlciBvZiBpbmRpY2VzIGluIG91ciBiYXRjaCwgdGhlcmUgYXJlIDYgcG9pbnRzIHBlciBxdWFkLlxyXG4gICAgdmFyIG51bUluZGljZXMgPSB0aGlzLnNpemUgKiA2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgdGhlIHZlcnRleCBkYXRhIHRoYXQgd2lsbCBiZSBzZW50IHRvIHRoZSB2ZXJ0ZXggc2hhZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge0FycmF5QnVmZmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEFycmF5QnVmZmVyKG51bVZlcnRzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZpZXcgb24gdGhlIHZlcnRpY2VzIGFzIGEgRmxvYXQzMkFycmF5IGZvciBwb3NpdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnZlcnRpY2VzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZpZXcgb24gdGhlIHZlcnRpY2VzIGFzIGEgVWludDMyQXJyYXkgZm9yIGNvbG9yc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1VpbnQzMkFycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbG9ycyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnZlcnRpY2VzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIHRoZSBpbmRpY2VzIG9mIHRoZSBnZW9tZXRyeSAocXVhZHMpIHRvIGRyYXdcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KG51bUluZGljZXMpO1xyXG5cclxuICAgIC8vIGZpbGwgdGhlIGluZGljZXMgd2l0aCB0aGUgcXVhZHMgdG8gZHJhd1xyXG4gICAgZm9yICh2YXIgaT0wLCBqPTA7IGkgPCBudW1JbmRpY2VzOyBpICs9IDYsIGogKz0gNClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmluZGljZXNbaSArIDBdID0gaiArIDA7XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMl0gPSBqICsgMjtcclxuICAgICAgICB0aGlzLmluZGljZXNbaSArIDNdID0gaiArIDA7XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNV0gPSBqICsgMztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGJhdGNoLCBlYWNoIHJlbmRlcigpIGNhbGwgYWRkcyB0byB0aGlzIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudEJhdGNoU2l6ZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBzcHJpdGVzIGluIHRoZSBiYXRjaC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlNwcml0ZVtdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNwcml0ZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IHNoYWRlciB0aGF0IGlzIHVzZWQgaWYgYSBzcHJpdGUgZG9lc24ndCBoYXZlIGEgbW9yZSBzcGVjaWZpYyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxufVxyXG5cclxuU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3RSZW5kZXJlci5wcm90b3R5cGUpO1xyXG5TcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJpdGVSZW5kZXJlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVSZW5kZXJlcjtcclxuXHJcbldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3Nwcml0ZScsIFNwcml0ZVJlbmRlcmVyKTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxyXG4gKi9cclxuU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgLy8gc2V0dXAgZGVmYXVsdCBzaGFkZXJcclxuICAgIHRoaXMuc2hhZGVyID0gdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXI7XHJcblxyXG4gICAgLy8gY3JlYXRlIGEgY291cGxlIG9mIGJ1ZmZlcnNcclxuICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG4gICAgLy91cGxvYWQgdGhlIGluZGV4IGRhdGFcclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xyXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRpY2VzLCBnbC5EWU5BTUlDX0RSQVcpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDk5OTk5O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIHNwcml0ZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcHJpdGUge1BJWEkuU3ByaXRlfSB0aGUgc3ByaXRlIHRvIHJlbmRlciB3aGVuIHVzaW5nIHRoaXMgc3ByaXRlYmF0Y2hcclxuICovXHJcblNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3ByaXRlKVxyXG57XHJcbiAgICB2YXIgdGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZTtcclxuXHJcbiAgICAvL1RPRE8gc2V0IGJsZW5kIG1vZGVzLi5cclxuICAgIC8vIGNoZWNrIHRleHR1cmUuLlxyXG4gICAgaWYgKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA+PSB0aGlzLnNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldCB0aGUgdXZzIGZvciB0aGUgdGV4dHVyZVxyXG4gICAgdmFyIHV2cyA9IHRleHR1cmUuX3V2cztcclxuXHJcbiAgICAvLyBpZiB0aGUgdXZzIGhhdmUgbm90IHVwZGF0ZWQgdGhlbiBubyBwb2ludCByZW5kZXJpbmcganVzdCB5ZXQhXHJcbiAgICBpZiAoIXV2cylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETyB0cmltPz9cclxuICAgIHZhciBhWCA9IHNwcml0ZS5hbmNob3IueDtcclxuICAgIHZhciBhWSA9IHNwcml0ZS5hbmNob3IueTtcclxuXHJcbiAgICB2YXIgdzAsIHcxLCBoMCwgaDE7XHJcblxyXG4gICAgaWYgKHRleHR1cmUudHJpbSAmJiBzcHJpdGUudGlsZVNjYWxlID09PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkIGFuZCBpcyBub3QgYSB0aWxpbmdzcHJpdGUgdGhlbiB3ZSBuZWVkIHRvIGFkZCB0aGUgZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZyB0aGUgc3ByaXRlIGNvb3Jkcy4uXHJcbiAgICAgICAgdmFyIHRyaW0gPSB0ZXh0dXJlLnRyaW07XHJcblxyXG4gICAgICAgIHcxID0gdHJpbS54IC0gYVggKiB0cmltLndpZHRoO1xyXG4gICAgICAgIHcwID0gdzEgKyB0ZXh0dXJlLmNyb3Aud2lkdGg7XHJcblxyXG4gICAgICAgIGgxID0gdHJpbS55IC0gYVkgKiB0cmltLmhlaWdodDtcclxuICAgICAgICBoMCA9IGgxICsgdGV4dHVyZS5jcm9wLmhlaWdodDtcclxuXHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdzAgPSAodGV4dHVyZS5fZnJhbWUud2lkdGggKSAqICgxLWFYKTtcclxuICAgICAgICB3MSA9ICh0ZXh0dXJlLl9mcmFtZS53aWR0aCApICogLWFYO1xyXG5cclxuICAgICAgICBoMCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAqICgxLWFZKTtcclxuICAgICAgICBoMSA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAqIC1hWTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLmN1cnJlbnRCYXRjaFNpemUgKiB0aGlzLnZlcnRCeXRlU2l6ZTtcclxuXHJcbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBzcHJpdGUud29ybGRUcmFuc2Zvcm07XHJcblxyXG4gICAgdmFyIGEgPSB3b3JsZFRyYW5zZm9ybS5hO1xyXG4gICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5iO1xyXG4gICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5jO1xyXG4gICAgdmFyIGQgPSB3b3JsZFRyYW5zZm9ybS5kO1xyXG4gICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7XHJcbiAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTtcclxuXHJcbiAgICB2YXIgY29sb3JzID0gdGhpcy5jb2xvcnM7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnM7XHJcblxyXG4gICAgaWYgKHRoaXMucmVuZGVyZXIucm91bmRQaXhlbHMpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XHJcblxyXG4gICAgICAgIC8vIHh5XHJcbiAgICAgICAgcG9zaXRpb25zW2luZGV4XSA9ICgoKGEgKiB3MSArIGMgKiBoMSArIHR4KSAqIHJlc29sdXRpb24pIHwgMCkgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxXSA9ICgoKGQgKiBoMSArIGIgKiB3MSArIHR5KSAqIHJlc29sdXRpb24pIHwgMCkgLyByZXNvbHV0aW9uO1xyXG5cclxuICAgICAgICAvLyB4eVxyXG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCs1XSA9ICgoKGEgKiB3MCArIGMgKiBoMSArIHR4KSAqIHJlc29sdXRpb24pIHwgMCkgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCs2XSA9ICgoKGQgKiBoMSArIGIgKiB3MCArIHR5KSAqIHJlc29sdXRpb24pIHwgMCkgLyByZXNvbHV0aW9uO1xyXG5cclxuICAgICAgICAgLy8geHlcclxuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrMTBdID0gKCgoYSAqIHcwICsgYyAqIGgwICsgdHgpICogcmVzb2x1dGlvbikgfCAwKSAvIHJlc29sdXRpb247XHJcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzExXSA9ICgoKGQgKiBoMCArIGIgKiB3MCArIHR5KSAqIHJlc29sdXRpb24pIHwgMCkgLyByZXNvbHV0aW9uO1xyXG5cclxuICAgICAgICAvLyB4eVxyXG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxNV0gPSAoKChhICogdzEgKyBjICogaDAgKyB0eCkgKiByZXNvbHV0aW9uKSB8IDApIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrMTZdID0gKCgoZCAqIGgwICsgYiAqIHcxICsgdHkpICogcmVzb2x1dGlvbikgfCAwKSAvIHJlc29sdXRpb247XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcblxyXG4gICAgICAgIC8vIHh5XHJcbiAgICAgICAgcG9zaXRpb25zW2luZGV4XSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xyXG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xyXG5cclxuICAgICAgICAvLyB4eVxyXG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCs1XSA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xyXG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCs2XSA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xyXG5cclxuICAgICAgICAgLy8geHlcclxuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrMTBdID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XHJcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzExXSA9IGQgKiBoMCArIGIgKiB3MCArIHR5O1xyXG5cclxuICAgICAgICAvLyB4eVxyXG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxNV0gPSBhICogdzEgKyBjICogaDAgKyB0eDtcclxuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrMTZdID0gZCAqIGgwICsgYiAqIHcxICsgdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdXZcclxuICAgIHBvc2l0aW9uc1tpbmRleCsyXSA9IHV2cy54MDtcclxuICAgIHBvc2l0aW9uc1tpbmRleCszXSA9IHV2cy55MDtcclxuXHJcbiAgICAvLyB1dlxyXG4gICAgcG9zaXRpb25zW2luZGV4KzddID0gdXZzLngxO1xyXG4gICAgcG9zaXRpb25zW2luZGV4KzhdID0gdXZzLnkxO1xyXG5cclxuICAgICAvLyB1dlxyXG4gICAgcG9zaXRpb25zW2luZGV4KzEyXSA9IHV2cy54MjtcclxuICAgIHBvc2l0aW9uc1tpbmRleCsxM10gPSB1dnMueTI7XHJcblxyXG4gICAgLy8gdXZcclxuICAgIHBvc2l0aW9uc1tpbmRleCsxN10gPSB1dnMueDM7XHJcbiAgICBwb3NpdGlvbnNbaW5kZXgrMThdID0gdXZzLnkzO1xyXG5cclxuICAgIC8vIGNvbG9yIGFuZCBhbHBoYVxyXG4gICAgdmFyIHRpbnQgPSBzcHJpdGUudGludDtcclxuICAgIGNvbG9yc1tpbmRleCs0XSA9IGNvbG9yc1tpbmRleCs5XSA9IGNvbG9yc1tpbmRleCsxNF0gPSBjb2xvcnNbaW5kZXgrMTldID0gKHRpbnQgPj4gMTYpICsgKHRpbnQgJiAweGZmMDApICsgKCh0aW50ICYgMHhmZikgPDwgMTYpICsgKHNwcml0ZS53b3JsZEFscGhhICogMjU1IDw8IDI0KTtcclxuXHJcbiAgICAvLyBpbmNyZW1lbnQgdGhlIGJhdGNoc2l6ZVxyXG4gICAgdGhpcy5zcHJpdGVzW3RoaXMuY3VycmVudEJhdGNoU2l6ZSsrXSA9IHNwcml0ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBjb250ZW50IGFuZCBlbXB0aWVzIHRoZSBjdXJyZW50IGJhdGNoLlxyXG4gKlxyXG4gKi9cclxuU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgLy8gSWYgdGhlIGJhdGNoIGlzIGxlbmd0aCAwIHRoZW4gcmV0dXJuIGFzIHRoZXJlIGlzIG5vdGhpbmcgdG8gZHJhd1xyXG4gICAgaWYgKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuICAgIHZhciBzaGFkZXI7XHJcblxyXG4gICAgLy8gdXBsb2FkIHRoZSB2ZXJ0cyB0byB0aGUgYnVmZmVyXHJcbiAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2hTaXplID4gKCB0aGlzLnNpemUgKiAwLjUgKSApXHJcbiAgICB7XHJcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudmVydGljZXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5wb3NpdGlvbnMuc3ViYXJyYXkoMCwgdGhpcy5jdXJyZW50QmF0Y2hTaXplICogdGhpcy52ZXJ0Qnl0ZVNpemUpO1xyXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB2aWV3KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmV4dFRleHR1cmUsIG5leHRCbGVuZE1vZGUsIG5leHRTaGFkZXI7XHJcbiAgICB2YXIgYmF0Y2hTaXplID0gMDtcclxuICAgIHZhciBzdGFydCA9IDA7XHJcblxyXG4gICAgdmFyIGN1cnJlbnRCYXNlVGV4dHVyZSA9IG51bGw7XHJcbiAgICB2YXIgY3VycmVudEJsZW5kTW9kZSA9IHRoaXMucmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5jdXJyZW50QmxlbmRNb2RlO1xyXG4gICAgdmFyIGN1cnJlbnRTaGFkZXIgPSBudWxsO1xyXG5cclxuICAgIHZhciBibGVuZFN3YXAgPSBmYWxzZTtcclxuICAgIHZhciBzaGFkZXJTd2FwID0gZmFsc2U7XHJcbiAgICB2YXIgc3ByaXRlO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jdXJyZW50QmF0Y2hTaXplOyBpIDwgajsgaSsrKVxyXG4gICAge1xyXG5cclxuICAgICAgICBzcHJpdGUgPSB0aGlzLnNwcml0ZXNbaV07XHJcblxyXG4gICAgICAgIG5leHRUZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgIG5leHRCbGVuZE1vZGUgPSBzcHJpdGUuYmxlbmRNb2RlO1xyXG4gICAgICAgIG5leHRTaGFkZXIgPSBzcHJpdGUuc2hhZGVyIHx8IHRoaXMuc2hhZGVyO1xyXG5cclxuICAgICAgICBibGVuZFN3YXAgPSBjdXJyZW50QmxlbmRNb2RlICE9PSBuZXh0QmxlbmRNb2RlO1xyXG4gICAgICAgIHNoYWRlclN3YXAgPSBjdXJyZW50U2hhZGVyICE9PSBuZXh0U2hhZGVyOyAvLyBzaG91bGQgSSB1c2UgdWlkUz8/P1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudEJhc2VUZXh0dXJlICE9PSBuZXh0VGV4dHVyZSB8fCBibGVuZFN3YXAgfHwgc2hhZGVyU3dhcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmF0Y2goY3VycmVudEJhc2VUZXh0dXJlLCBiYXRjaFNpemUsIHN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gaTtcclxuICAgICAgICAgICAgYmF0Y2hTaXplID0gMDtcclxuICAgICAgICAgICAgY3VycmVudEJhc2VUZXh0dXJlID0gbmV4dFRleHR1cmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmxlbmRTd2FwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmRNb2RlID0gbmV4dEJsZW5kTW9kZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoIGN1cnJlbnRCbGVuZE1vZGUgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNoYWRlclN3YXApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTaGFkZXIgPSBuZXh0U2hhZGVyO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgc2hhZGVyID0gY3VycmVudFNoYWRlci5zaGFkZXJzID8gY3VycmVudFNoYWRlci5zaGFkZXJzW2dsLmlkXSA6IGN1cnJlbnRTaGFkZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFzaGFkZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyID0gY3VycmVudFNoYWRlci5nZXRTaGFkZXIodGhpcy5yZW5kZXJlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNldCBzaGFkZXIgZnVuY3Rpb24/Pz9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoc2hhZGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gLSBpIEtOT1cgdGhpcyBjYW4gYmUgb3B0aW1pc2VkISBPbmNlIHYzIGlzIHN0YWJsZSBpbCBsb29rIGF0IHRoaXMgbmV4dC4uLlxyXG4gICAgICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgudmFsdWUgPSB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgLy9NYWtlIHRoaXMgYSBsaXR0bGUgbW9yZSBkeW5hbWljIC8gaW50ZWxsaWdlbnQhXHJcbiAgICAgICAgICAgICAgICBzaGFkZXIuc3luY1VuaWZvcm1zKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIGludmVzdGlnYXRlIHNvbWUga2luZCBvZiB0ZXh0dXJlIHN0YXRlIG1hbmFnbWVudD8/XHJcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIG1ha2Ugc3VyZSB0aGlzIHRleHR1cmUgaXMgdGhlIGFjdGl2ZSBvbmUgZm9yIGFsbCB0aGUgYmF0Y2ggc3dhcHMuLlxyXG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYm90aCB0aGVhc2Ugb25seSBuZWVkIHRvIGJlIHNldCBpZiB0aGV5IGFyZSBjaGFuZ2luZy4uXHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHByb2plY3Rpb25cclxuICAgICAgICAgICAgICAgIC8vZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC5fbG9jYXRpb24sIGZhbHNlLCB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpKTtcclxuXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBiYXRjaFNpemUrKztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlbmRlckJhdGNoKGN1cnJlbnRCYXNlVGV4dHVyZSwgYmF0Y2hTaXplLCBzdGFydCk7XHJcblxyXG4gICAgLy8gdGhlbiByZXNldCB0aGUgYmF0Y2ghXHJcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUgPSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERyYXdzIHRoZSBjdXJyZW50bHkgYmF0Y2hlcyBzcHJpdGVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5UZXh0dXJlfVxyXG4gKiBAcGFyYW0gc2l6ZSB7bnVtYmVyfVxyXG4gKiBAcGFyYW0gc3RhcnRJbmRleCB7bnVtYmVyfVxyXG4gKi9cclxuU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJhdGNoID0gZnVuY3Rpb24gKHRleHR1cmUsIHNpemUsIHN0YXJ0SW5kZXgpXHJcbntcclxuICAgIGlmIChzaXplID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgIGlmICghdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVUZXh0dXJlKHRleHR1cmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vIGJpbmQgdGhlIGN1cnJlbnQgdGV4dHVyZVxyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBub3cgZHJhdyB0aG9zZSBzdWNrYXMhXHJcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBzaXplICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIHN0YXJ0SW5kZXggKiA2ICogMik7XHJcblxyXG4gICAgLy8gaW5jcmVtZW50IHRoZSBkcmF3IGNvdW50XHJcbiAgICB0aGlzLnJlbmRlcmVyLmRyYXdDb3VudCsrO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN0YXJ0cyBhIG5ldyBzcHJpdGUgYmF0Y2guXHJcbiAqXHJcbiAqL1xyXG5TcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgIC8vIGJpbmQgdGhlIG1haW4gdGV4dHVyZVxyXG5cclxuXHJcbiAgICAvLyBiaW5kIHRoZSBidWZmZXJzXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XHJcblxyXG4gICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBmb3IgZWFjaCBzaGFkZXI/XHJcbiAgICB2YXIgc3RyaWRlID0gIHRoaXMudmVydEJ5dGVTaXplO1xyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDApO1xyXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCAyICogNCk7XHJcblxyXG4gICAgLy8gY29sb3IgYXR0cmlidXRlcyB3aWxsIGJlIGludGVycHJldGVkIGFzIHVuc2lnbmVkIGJ5dGVzIGFuZCBub3JtYWxpemVkXHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCA0LCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCBzdHJpZGUsIDQgKiA0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXN0cm95cyB0aGUgU3ByaXRlQmF0Y2guXHJcbiAqXHJcbiAqL1xyXG5TcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMucmVuZGVyZXIuZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QnVmZmVyKTtcclxuICAgIHRoaXMucmVuZGVyZXIuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXIpO1xyXG5cclxuICAgIE9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5zaGFkZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMudmVydGljZXMgPSBudWxsO1xyXG4gICAgdGhpcy5wb3NpdGlvbnMgPSBudWxsO1xyXG4gICAgdGhpcy5jb2xvcnMgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnNwcml0ZXMgPSBudWxsO1xyXG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG59O1xyXG4iLCJ2YXIgU3ByaXRlID0gcmVxdWlyZSgnLi4vc3ByaXRlcy9TcHJpdGUnKSxcclxuICAgIFRleHR1cmUgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9UZXh0dXJlJyksXHJcbiAgICBtYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpLFxyXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpLFxyXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG5cclxuLyoqXHJcbiAqIEEgVGV4dCBPYmplY3Qgd2lsbCBjcmVhdGUgYSBsaW5lIG9yIG11bHRpcGxlIGxpbmVzIG9mIHRleHQuIFRvIHNwbGl0IGEgbGluZSB5b3UgY2FuIHVzZSAnXFxuJyBpbiB5b3VyIHRleHQgc3RyaW5nLFxyXG4gKiBvciBhZGQgYSB3b3JkV3JhcCBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZSBhbmQgYW5kIHdvcmRXcmFwV2lkdGggcHJvcGVydHkgd2l0aCBhIHZhbHVlIGluIHRoZSBzdHlsZSBvYmplY3QuXHJcbiAqXHJcbiAqIEEgVGV4dCBjYW4gYmUgY3JlYXRlZCBkaXJlY3RseSBmcm9tIGEgc3RyaW5nIGFuZCBhIHN0eWxlIG9iamVjdFxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdGV4dCA9IG5ldyBQSVhJLlRleHQoJ1RoaXMgaXMgYSBwaXhpIHRleHQnLHtmb250IDogJzI0cHggQXJpYWwnLCBmaWxsIDogMHhmZjEwMTAsIGFsaWduIDogJ2NlbnRlcid9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLlNwcml0ZVxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gdGV4dCB7c3RyaW5nfSBUaGUgY29weSB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSB0ZXh0IHRvIGRpc3BsYXlcclxuICogQHBhcmFtIFtzdHlsZV0ge29iamVjdH0gVGhlIHN0eWxlIHBhcmFtZXRlcnNcclxuICogQHBhcmFtIFtzdHlsZS5mb250XSB7c3RyaW5nfSBkZWZhdWx0ICdib2xkIDIwcHggQXJpYWwnIFRoZSBzdHlsZSBhbmQgc2l6ZSBvZiB0aGUgZm9udFxyXG4gKiBAcGFyYW0gW3N0eWxlLmZpbGw9J2JsYWNrJ10ge1N0cmluZ3xOdW1iZXJ9IEEgY2FudmFzIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBlLmcgJ3JlZCcsICcjMDBGRjAwJ1xyXG4gKiBAcGFyYW0gW3N0eWxlLmFsaWduPSdsZWZ0J10ge3N0cmluZ30gQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcclxuICogQHBhcmFtIFtzdHlsZS5zdHJva2VdIHtTdHJpbmd8TnVtYmVyfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlIGUuZyAnYmx1ZScsICcjRkNGRjAwJ1xyXG4gKiBAcGFyYW0gW3N0eWxlLnN0cm9rZVRoaWNrbmVzcz0wXSB7bnVtYmVyfSBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgc3Ryb2tlLiBEZWZhdWx0IGlzIDAgKG5vIHN0cm9rZSlcclxuICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcD1mYWxzZV0ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWRcclxuICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcFdpZHRoPTEwMF0ge251bWJlcn0gVGhlIHdpZHRoIGF0IHdoaWNoIHRleHQgd2lsbCB3cmFwLCBpdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZVxyXG4gKiBAcGFyYW0gW3N0eWxlLmxpbmVIZWlnaHRdIHtudW1iZXJ9IFRoZSBsaW5lIGhlaWdodCwgYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IGEgbGV0dGVyIHVzZXNcclxuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93PWZhbHNlXSB7Ym9vbGVhbn0gU2V0IGEgZHJvcCBzaGFkb3cgZm9yIHRoZSB0ZXh0XHJcbiAqIEBwYXJhbSBbc3R5bGUuZHJvcFNoYWRvd0NvbG9yPScjMDAwMDAwJ10ge3N0cmluZ30gQSBmaWxsIHN0eWxlIHRvIGJlIHVzZWQgb24gdGhlIGRyb3BzaGFkb3cgZS5nICdyZWQnLCAnIzAwRkYwMCdcclxuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93QW5nbGU9TWF0aC5QSS80XSB7bnVtYmVyfSBTZXQgYSBhbmdsZSBvZiB0aGUgZHJvcCBzaGFkb3dcclxuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U9NV0ge251bWJlcn0gU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XHJcbiAqIEBwYXJhbSBbc3R5bGUuZHJvcFNoYWRvd0JsdXI9MF0ge251bWJlcn0gU2V0IGEgc2hhZG93IGJsdXIgcmFkaXVzXHJcbiAqIEBwYXJhbSBbc3R5bGUucGFkZGluZz0wXSB7bnVtYmVyfSBPY2Nhc2lvbmFsbHkgc29tZSBmb250cyBhcmUgY3JvcHBlZCBvbiB0b3Agb3IgYm90dG9tLiBBZGRpbmcgc29tZSBwYWRkaW5nIHdpbGxcclxuICogICAgICBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcgYnkgYWRkaW5nIHBhZGRpbmcgdG8gdGhlIHRvcCBhbmQgYm90dG9tIG9mIHRleHQgaGVpZ2h0LlxyXG4gKiBAcGFyYW0gW3N0eWxlLnRleHRCYXNlbGluZT0nYWxwaGFiZXRpYyddIHtzdHJpbmd9IFRoZSBiYXNlbGluZSBvZiB0aGUgdGV4dCB0aGF0IGlzIHJlbmRlcmVkLlxyXG4gKiBAcGFyYW0gW3N0eWxlLmxpbmVKb2luPSdtaXRlciddIHtzdHJpbmd9IFRoZSBsaW5lSm9pbiBwcm9wZXJ0eSBzZXRzIHRoZSB0eXBlIG9mIGNvcm5lciBjcmVhdGVkLCBpdCBjYW4gcmVzb2x2ZVxyXG4gKiAgICAgIHNwaWtlZCB0ZXh0IGlzc3Vlcy4gRGVmYXVsdCBpcyAnbWl0ZXInIChjcmVhdGVzIGEgc2hhcnAgY29ybmVyKS5cclxuICogQHBhcmFtIFtzdHlsZS5taXRlckxpbWl0PTEwXSB7bnVtYmVyfSBUaGUgbWl0ZXIgbGltaXQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdtaXRlcicgbGluZUpvaW4gbW9kZS4gVGhpcyBjYW4gcmVkdWNlXHJcbiAqICAgICAgb3IgaW5jcmVhc2UgdGhlIHNwaWtpbmVzcyBvZiByZW5kZXJlZCB0ZXh0LlxyXG4gKi9cclxuZnVuY3Rpb24gVGV4dCh0ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbilcclxue1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHRvXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7SFRNTENhbnZhc0VsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FudmFzIDJkIGNvbnRleHQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHdpdGhcclxuICAgICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIGNhbnZhcy5cclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBDT05TVC5SRVNPTFVUSU9OO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCB0ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3RleHQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCBzdHlsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9zdHlsZSA9IG51bGw7XHJcblxyXG4gICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlLmZyb21DYW52YXModGhpcy5jYW52YXMpO1xyXG4gICAgdGV4dHVyZS50cmltID0gbmV3IG1hdGguUmVjdGFuZ2xlKCk7XHJcbiAgICBTcHJpdGUuY2FsbCh0aGlzLCB0ZXh0dXJlKTtcclxuXHJcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xyXG59XHJcblxyXG4vLyBjb25zdHJ1Y3RvclxyXG5UZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3ByaXRlLnByb3RvdHlwZSk7XHJcblRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dDtcclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0O1xyXG5cclxuVGV4dC5mb250UHJvcGVydGllc0NhY2hlID0ge307XHJcblRleHQuZm9udFByb3BlcnRpZXNDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuVGV4dC5mb250UHJvcGVydGllc0NvbnRleHQgPSBUZXh0LmZvbnRQcm9wZXJ0aWVzQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUZXh0LnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIFRleHQsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuVGV4dCNcclxuICAgICAqL1xyXG4gICAgd2lkdGg6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlLnggKiB0aGlzLl90ZXh0dXJlLl9mcmFtZS53aWR0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gdmFsdWUgLyB0aGlzLl90ZXh0dXJlLl9mcmFtZS53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGV4dCwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5UZXh0I1xyXG4gICAgICovXHJcbiAgICBoZWlnaHQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAgdGhpcy5zY2FsZS55ICogdGhpcy5fdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIHRoaXMuX3RleHR1cmUuX2ZyYW1lLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgc3R5bGUgb2YgdGhlIHRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW3N0eWxlXSB7b2JqZWN0fSBUaGUgc3R5bGUgcGFyYW1ldGVyc1xyXG4gICAgICogQHBhcmFtIFtzdHlsZS5mb250PSdib2xkIDIwcHQgQXJpYWwnXSB7c3RyaW5nfSBUaGUgc3R5bGUgYW5kIHNpemUgb2YgdGhlIGZvbnRcclxuICAgICAqIEBwYXJhbSBbc3R5bGUuZmlsbD0nYmxhY2snXSB7c3RyaW5nfG51bWJlcn0gQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IGVnICdyZWQnLCAnIzAwRkYwMCdcclxuICAgICAqIEBwYXJhbSBbc3R5bGUuYWxpZ249J2xlZnQnXSB7c3RyaW5nfSBBbGlnbm1lbnQgZm9yIG11bHRpbGluZSB0ZXh0ICgnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCcpLCBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dFxyXG4gICAgICogQHBhcmFtIFtzdHlsZS5zdHJva2U9J2JsYWNrJ10ge3N0cmluZ3xudW1iZXJ9IEEgY2FudmFzIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBzdHJva2UgZWcgJ2JsdWUnLCAnI0ZDRkYwMCdcclxuICAgICAqIEBwYXJhbSBbc3R5bGUuc3Ryb2tlVGhpY2tuZXNzPTBdIHtudW1iZXJ9IEEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdGhpY2tuZXNzIG9mIHRoZSBzdHJva2UuIERlZmF1bHQgaXMgMCAobm8gc3Ryb2tlKVxyXG4gICAgICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcD1mYWxzZV0ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWRcclxuICAgICAqIEBwYXJhbSBbc3R5bGUud29yZFdyYXBXaWR0aD0xMDBdIHtudW1iZXJ9IFRoZSB3aWR0aCBhdCB3aGljaCB0ZXh0IHdpbGwgd3JhcFxyXG4gICAgICogQHBhcmFtIFtzdHlsZS5saW5lSGVpZ2h0XSB7bnVtYmVyfSBUaGUgbGluZSBoZWlnaHQsIGEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdmVydGljYWwgc3BhY2UgdGhhdCBhIGxldHRlciB1c2VzXHJcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3c9ZmFsc2VdIHtib29sZWFufSBTZXQgYSBkcm9wIHNoYWRvdyBmb3IgdGhlIHRleHRcclxuICAgICAqIEBwYXJhbSBbc3R5bGUuZHJvcFNoYWRvd0NvbG9yPScjMDAwMDAwJ10ge3N0cmluZ3xudW1iZXJ9IEEgZmlsbCBzdHlsZSB0byBiZSB1c2VkIG9uIHRoZSBkcm9wc2hhZG93IGUuZyAncmVkJywgJyMwMEZGMDAnXHJcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dBbmdsZT1NYXRoLlBJLzZdIHtudW1iZXJ9IFNldCBhIGFuZ2xlIG9mIHRoZSBkcm9wIHNoYWRvd1xyXG4gICAgICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U9NV0ge251bWJlcn0gU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XHJcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dCbHVyPTBdIHtudW1iZXJ9IFNldCBhIHNoYWRvdyBibHVyIHJhZGl1c1xyXG4gICAgICogQHBhcmFtIFtzdHlsZS5wYWRkaW5nPTBdIHtudW1iZXJ9IE9jY2FzaW9uYWxseSBzb21lIGZvbnRzIGFyZSBjcm9wcGVkIG9uIHRvcCBvciBib3R0b20uIEFkZGluZyBzb21lIHBhZGRpbmcgd2lsbFxyXG4gICAgICogICAgICBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcgYnkgYWRkaW5nIHBhZGRpbmcgdG8gdGhlIHRvcCBhbmQgYm90dG9tIG9mIHRleHQgaGVpZ2h0LlxyXG4gICAgICogQHBhcmFtIFtzdHlsZS50ZXh0QmFzZWxpbmU9J2FscGhhYmV0aWMnXSB7c3RyaW5nfSBUaGUgYmFzZWxpbmUgb2YgdGhlIHRleHQgdGhhdCBpcyByZW5kZXJlZC5cclxuICAgICAqIEBwYXJhbSBbc3R5bGUubGluZUpvaW49J21pdGVyJ10ge3N0cmluZ30gVGhlIGxpbmVKb2luIHByb3BlcnR5IHNldHMgdGhlIHR5cGUgb2YgY29ybmVyIGNyZWF0ZWQsIGl0IGNhbiByZXNvbHZlXHJcbiAgICAgKiAgICAgIHNwaWtlZCB0ZXh0IGlzc3Vlcy4gRGVmYXVsdCBpcyAnbWl0ZXInIChjcmVhdGVzIGEgc2hhcnAgY29ybmVyKS5cclxuICAgICAqIEBwYXJhbSBbc3R5bGUubWl0ZXJMaW1pdD0xMF0ge251bWJlcn0gVGhlIG1pdGVyIGxpbWl0IHRvIHVzZSB3aGVuIHVzaW5nIHRoZSAnbWl0ZXInIGxpbmVKb2luIG1vZGUuIFRoaXMgY2FuIHJlZHVjZVxyXG4gICAgICogICAgICBvciBpbmNyZWFzZSB0aGUgc3Bpa2luZXNzIG9mIHJlbmRlcmVkIHRleHQuXHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5UZXh0I1xyXG4gICAgICovXHJcbiAgICBzdHlsZToge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHN0eWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuZmlsbCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmZpbGwgPSB1dGlscy5oZXgyc3RyaW5nKHN0eWxlLmZpbGwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlLnN0cm9rZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnN0cm9rZSA9IHV0aWxzLmhleDJzdHJpbmcoc3R5bGUuc3Ryb2tlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5kcm9wU2hhZG93Q29sb3IgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5kcm9wU2hhZG93Q29sb3IgPSB1dGlscy5oZXgyc3RyaW5nKHN0eWxlLmRyb3BTaGFkb3dDb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN0eWxlLmZvbnQgPSBzdHlsZS5mb250IHx8ICdib2xkIDIwcHQgQXJpYWwnO1xyXG4gICAgICAgICAgICBzdHlsZS5maWxsID0gc3R5bGUuZmlsbCB8fCAnYmxhY2snO1xyXG4gICAgICAgICAgICBzdHlsZS5hbGlnbiA9IHN0eWxlLmFsaWduIHx8ICdsZWZ0JztcclxuICAgICAgICAgICAgc3R5bGUuc3Ryb2tlID0gc3R5bGUuc3Ryb2tlIHx8ICdibGFjayc7IC8vcHJvdmlkZSBhIGRlZmF1bHQsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL2lzc3Vlcy8xMzZcclxuICAgICAgICAgICAgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIHx8IDA7XHJcbiAgICAgICAgICAgIHN0eWxlLndvcmRXcmFwID0gc3R5bGUud29yZFdyYXAgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIHN0eWxlLndvcmRXcmFwV2lkdGggPSBzdHlsZS53b3JkV3JhcFdpZHRoIHx8IDEwMDtcclxuXHJcbiAgICAgICAgICAgIHN0eWxlLmRyb3BTaGFkb3cgPSBzdHlsZS5kcm9wU2hhZG93IHx8IGZhbHNlO1xyXG4gICAgICAgICAgICBzdHlsZS5kcm9wU2hhZG93Q29sb3IgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3IgfHwgJyMwMDAwMDAnO1xyXG4gICAgICAgICAgICBzdHlsZS5kcm9wU2hhZG93QW5nbGUgPSBzdHlsZS5kcm9wU2hhZG93QW5nbGUgIT09IHVuZGVmaW5lZCA/IHN0eWxlLmRyb3BTaGFkb3dBbmdsZSA6IE1hdGguUEkgLyA2O1xyXG4gICAgICAgICAgICBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgIT09IHVuZGVmaW5lZCA/IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSA6IDU7XHJcbiAgICAgICAgICAgIHN0eWxlLmRyb3BTaGFkb3dCbHVyID0gc3R5bGUuZHJvcFNoYWRvd0JsdXIgIT09IHVuZGVmaW5lZCA/IHN0eWxlLmRyb3BTaGFkb3dCbHVyIDogMDsgLy9zaGFkb3dCbHVyIGlzICcwJyBieSBkZWZhdWx0IGFjY29yZGluZyB0byBIVE1MXHJcblxyXG4gICAgICAgICAgICBzdHlsZS5wYWRkaW5nID0gc3R5bGUucGFkZGluZyB8fCAwO1xyXG5cclxuICAgICAgICAgICAgc3R5bGUudGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lIHx8ICdhbHBoYWJldGljJztcclxuXHJcbiAgICAgICAgICAgIHN0eWxlLmxpbmVKb2luID0gc3R5bGUubGluZUpvaW4gfHwgJ21pdGVyJztcclxuICAgICAgICAgICAgc3R5bGUubWl0ZXJMaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQgfHwgMTA7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjb3B5IGZvciB0aGUgdGV4dCBvYmplY3QuIFRvIHNwbGl0IGEgbGluZSB5b3UgY2FuIHVzZSAnXFxuJy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGV4dCB7c3RyaW5nfSBUaGUgY29weSB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSB0ZXh0IHRvIGRpc3BsYXlcclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLlRleHQjXHJcbiAgICAgKi9cclxuICAgIHRleHQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodGV4dCl7XHJcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvU3RyaW5nKCkgfHwgJyAnO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dCA9PT0gdGV4dClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGV4dCBhbmQgdXBkYXRlcyBpdCB3aGVuIG5lZWRlZFxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuVGV4dC5wcm90b3R5cGUudXBkYXRlVGV4dCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xyXG4gICAgdGhpcy5jb250ZXh0LmZvbnQgPSBzdHlsZS5mb250O1xyXG5cclxuICAgIC8vIHdvcmQgd3JhcFxyXG4gICAgLy8gcHJlc2VydmUgb3JpZ2luYWwgdGV4dFxyXG4gICAgdmFyIG91dHB1dFRleHQgPSBzdHlsZS53b3JkV3JhcCA/IHRoaXMud29yZFdyYXAodGhpcy5fdGV4dCkgOiB0aGlzLl90ZXh0O1xyXG5cclxuICAgIC8vIHNwbGl0IHRleHQgaW50byBsaW5lc1xyXG4gICAgdmFyIGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIHRleHQgd2lkdGhcclxuICAgIHZhciBsaW5lV2lkdGhzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XHJcbiAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcclxuICAgIHZhciBmb250UHJvcGVydGllcyA9IHRoaXMuZGV0ZXJtaW5lRm9udFByb3BlcnRpZXMoc3R5bGUuZm9udCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoO1xyXG4gICAgICAgIGxpbmVXaWR0aHNbaV0gPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsaW5lV2lkdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB3aWR0aCA9IG1heExpbmVXaWR0aCArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcclxuICAgIHZhciBpc0xpbmVQb3NpdGlvblkgPSB0eXBlb2Ygc3R5bGUubGluZVBvc2l0aW9uWSAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdylcclxuICAgIHtcclxuICAgICAgICB3aWR0aCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSAoIHdpZHRoICsgdGhpcy5jb250ZXh0LmxpbmVXaWR0aCApICogdGhpcy5yZXNvbHV0aW9uO1xyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSB0ZXh0IGhlaWdodFxyXG4gICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLnN0eWxlLmxpbmVIZWlnaHQgfHwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XHJcblxyXG4gICAgdmFyIGhlaWdodCA9IGxpbmVIZWlnaHQgKiBsaW5lcy5sZW5ndGg7XHJcbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdylcclxuICAgIHtcclxuICAgICAgICBoZWlnaHQgKz0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9ICggaGVpZ2h0ICsgdGhpcy5fc3R5bGUucGFkZGluZyAqIDIgKSAqIHRoaXMucmVzb2x1dGlvbjtcclxuXHJcbiAgICB0aGlzLmNvbnRleHQuc2NhbGUoIHRoaXMucmVzb2x1dGlvbiwgdGhpcy5yZXNvbHV0aW9uKTtcclxuXHJcbiAgICBpZiAobmF2aWdhdG9yLmlzQ29jb29uSlMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy90aGlzLmNvbnRleHQuZmlsbFN0eWxlPVwiI0ZGMDAwMFwiO1xyXG4gICAgLy90aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgdGhpcy5jb250ZXh0LmZvbnQgPSBzdHlsZS5mb250O1xyXG4gICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xyXG4gICAgdGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcclxuICAgIHRoaXMuY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XHJcbiAgICB0aGlzLmNvbnRleHQubGluZUpvaW4gPSBzdHlsZS5saW5lSm9pbjtcclxuICAgIHRoaXMuY29udGV4dC5taXRlckxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdDtcclxuXHJcbiAgICB2YXIgbGluZVBvc2l0aW9uWDtcclxuICAgIHZhciBsaW5lUG9zaXRpb25ZO1xyXG5cclxuICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChzdHlsZS5kcm9wU2hhZG93Qmx1ciA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNoYWRvd0NvbG9yID0gc3R5bGUuZHJvcFNoYWRvd0NvbG9yO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuc2hhZG93Qmx1ciA9IHN0eWxlLmRyb3BTaGFkb3dCbHVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgeFNoYWRvd09mZnNldCA9IE1hdGguY29zKHN0eWxlLmRyb3BTaGFkb3dBbmdsZSkgKiBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XHJcbiAgICAgICAgdmFyIHlTaGFkb3dPZmZzZXQgPSBNYXRoLnNpbihzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcclxuICAgICAgICAgICAgLy9UT0RPOiBwdWxsIHJlcXVlc3Qgb2YgcGl4aVxyXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25ZID0gKHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDIgKyBpICogbGluZUhlaWdodCkgKyBmb250UHJvcGVydGllcy5hc2NlbnQ7XHJcbiAgICAgICAgICAgIGlmIChpc0xpbmVQb3NpdGlvblkpIHtcclxuICAgICAgICAgICAgICBsaW5lUG9zaXRpb25ZID0gc3R5bGUubGluZVBvc2l0aW9uWSArIGkgKiBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3R5bGUuYWxpZ24gPT09ICdyaWdodCcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdHlsZS5hbGlnbiA9PT0gJ2NlbnRlcicpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0eWxlLmZpbGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dChsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHhTaGFkb3dPZmZzZXQsIGxpbmVQb3NpdGlvblkgKyB5U2hhZG93T2Zmc2V0ICsgdGhpcy5fc3R5bGUucGFkZGluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9zZXQgY2FudmFzIHRleHQgc3R5bGVzXHJcbiAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcclxuXHJcbiAgICAvL2RyYXcgbGluZXMgbGluZSBieSBsaW5lXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgbGluZVBvc2l0aW9uWCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDI7XHJcbiAgICAgICAgbGluZVBvc2l0aW9uWSA9IChzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyICsgaSAqIGxpbmVIZWlnaHQpICsgZm9udFByb3BlcnRpZXMuYXNjZW50O1xyXG4gICAgICAgIGlmIChpc0xpbmVQb3NpdGlvblkpIHtcclxuICAgICAgICAgIGxpbmVQb3NpdGlvblkgPSBzdHlsZS5saW5lUG9zaXRpb25ZICsgaSAqIGxpbmVIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3R5bGUuYWxpZ24gPT09ICdyaWdodCcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSAnY2VudGVyJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdHlsZS5zdHJva2UgJiYgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQobGluZXNbaV0sIGxpbmVQb3NpdGlvblgsIGxpbmVQb3NpdGlvblkgKyB0aGlzLl9zdHlsZS5wYWRkaW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdHlsZS5maWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KGxpbmVzW2ldLCBsaW5lUG9zaXRpb25YLCBsaW5lUG9zaXRpb25ZICsgdGhpcy5fc3R5bGUucGFkZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGV4dHVyZSBzaXplIGJhc2VkIG9uIGNhbnZhcyBzaXplXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5UZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xyXG5cclxuICAgIHRleHR1cmUuYmFzZVRleHR1cmUuaGFzTG9hZGVkID0gdHJ1ZTtcclxuICAgIHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcclxuXHJcbiAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XHJcbiAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcclxuICAgIHRleHR1cmUuY3JvcC53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XHJcbiAgICB0ZXh0dXJlLmNyb3AuaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xyXG5cclxuICAgIHRleHR1cmUudHJpbS54ID0gMDtcclxuICAgIHRleHR1cmUudHJpbS55ID0gLXRoaXMuX3N0eWxlLnBhZGRpbmc7XHJcblxyXG4gICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGg7XHJcbiAgICB0ZXh0dXJlLnRyaW0uaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0IC0gdGhpcy5fc3R5bGUucGFkZGluZyoyO1xyXG5cclxuICAgIHRoaXMuX3dpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XHJcbiAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XHJcblxyXG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5lbWl0KCd1cGRhdGUnLCAgdGV4dHVyZS5iYXNlVGV4dHVyZSk7XHJcblxyXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICpcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9XHJcbiAqL1xyXG5UZXh0LnByb3RvdHlwZS5yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChyZW5kZXJlcilcclxue1xyXG4gICAgaWYgKHRoaXMuZGlydHkpXHJcbiAgICB7XHJcbiAgICAgICAgLy90aGlzLnJlc29sdXRpb24gPSAxLy9yZW5kZXJlci5yZXNvbHV0aW9uO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBTcHJpdGUucHJvdG90eXBlLnJlbmRlcldlYkdMLmNhbGwodGhpcywgcmVuZGVyZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXHJcbiAqXHJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5DYW52YXNSZW5kZXJlcn1cclxuICogQHByaXZhdGVcclxuICovXHJcblRleHQucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiAocmVuZGVyZXIpXHJcbntcclxuICAgIGlmICh0aGlzLmRpcnR5KVxyXG4gICAge1xyXG4gICAgIC8vICAgdGhpcy5yZXNvbHV0aW9uID0gMS8vcmVuZGVyZXIucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzLmNhbGwodGhpcywgcmVuZGVyZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFzY2VudCwgZGVzY2VudCBhbmQgZm9udFNpemUgb2YgYSBnaXZlbiBmb250U3R5bGVcclxuICpcclxuICogQHBhcmFtIGZvbnRTdHlsZSB7b2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuVGV4dC5wcm90b3R5cGUuZGV0ZXJtaW5lRm9udFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZm9udFN0eWxlKVxyXG57XHJcbiAgICB2YXIgcHJvcGVydGllcyA9IFRleHQuZm9udFByb3BlcnRpZXNDYWNoZVtmb250U3R5bGVdO1xyXG5cclxuICAgIGlmICghcHJvcGVydGllcylcclxuICAgIHtcclxuICAgICAgICBwcm9wZXJ0aWVzID0ge307XHJcblxyXG4gICAgICAgIHZhciBjYW52YXMgPSBUZXh0LmZvbnRQcm9wZXJ0aWVzQ2FudmFzO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gVGV4dC5mb250UHJvcGVydGllc0NvbnRleHQ7XHJcblxyXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnRTdHlsZTtcclxuXHJcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQoJ3xNw4lxJykud2lkdGgpLCAxKTtcclxuICAgICAgICB2YXIgYmFzZWxpbmUgPSBNYXRoLm1heChNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dCgnTScpLndpZHRoKSwgMSk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9ICAyICogYmFzZWxpbmU7XHJcblxyXG4gICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgKiAxLjQgfCAwO1xyXG5cclxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjZjAwJztcclxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250U3R5bGU7XHJcblxyXG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMwMDAnO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoJ3xNw4lxJywgMCwgYmFzZWxpbmUpO1xyXG5cclxuICAgICAgICB2YXIgaW1hZ2VkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcclxuICAgICAgICB2YXIgcGl4ZWxzID0gaW1hZ2VkYXRhLmxlbmd0aDtcclxuICAgICAgICB2YXIgbGluZSA9IHdpZHRoICogNDtcclxuXHJcbiAgICAgICAgdmFyIGksIGo7XHJcblxyXG4gICAgICAgIHZhciBpZHggPSAwO1xyXG4gICAgICAgIHZhciBzdG9wID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIGFzY2VudC4gc2NhbiBmcm9tIHRvcCB0byBib3R0b20gdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZWxpbmU7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsaW5lOyBqICs9IDQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbWFnZWRhdGFbaWR4ICsgal0gIT09IDI1NSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXN0b3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlkeCArPSBsaW5lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3BlcnRpZXMuYXNjZW50ID0gYmFzZWxpbmUgLSBpO1xyXG5cclxuICAgICAgICBpZHggPSBwaXhlbHMgLSBsaW5lO1xyXG4gICAgICAgIHN0b3AgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gZGVzY2VudC4gc2NhbiBmcm9tIGJvdHRvbSB0byB0b3AgdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcclxuICAgICAgICBmb3IgKGkgPSBoZWlnaHQ7IGkgPiBiYXNlbGluZTsgaS0tKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxpbmU7IGogKz0gNClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc3RvcClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWR4IC09IGxpbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvcGVydGllcy5kZXNjZW50ID0gaSAtIGJhc2VsaW5lO1xyXG4gICAgICAgIHByb3BlcnRpZXMuZm9udFNpemUgPSBwcm9wZXJ0aWVzLmFzY2VudCArIHByb3BlcnRpZXMuZGVzY2VudDtcclxuXHJcbiAgICAgICAgVGV4dC5mb250UHJvcGVydGllc0NhY2hlW2ZvbnRTdHlsZV0gPSBwcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgbmV3bGluZXMgdG8gYSBzdHJpbmcgdG8gaGF2ZSBpdCBvcHRpbWFsbHkgZml0IGludG8gdGhlIGhvcml6b250YWxcclxuICogYm91bmRzIHNldCBieSB0aGUgVGV4dCBvYmplY3QncyB3b3JkV3JhcFdpZHRoIHByb3BlcnR5LlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dCB7c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuVGV4dC5wcm90b3R5cGUud29yZFdyYXAgPSBmdW5jdGlvbiAodGV4dClcclxue1xyXG4gICAgLy8gR3JlZWR5IHdyYXBwaW5nIGFsZ29yaXRobSB0aGF0IHdpbGwgd3JhcCB3b3JkcyBhcyB0aGUgbGluZSBncm93cyBsb25nZXJcclxuICAgIC8vIHRoYW4gaXRzIGhvcml6b250YWwgYm91bmRzLlxyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XHJcbiAgICB2YXIgd29yZFdyYXBXaWR0aCA9IHRoaXMuX3N0eWxlLndvcmRXcmFwV2lkdGg7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzcGFjZUxlZnQgPSB3b3JkV3JhcFdpZHRoO1xyXG4gICAgICAgIHZhciB3b3JkcyA9IGxpbmVzW2ldLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3b3Jkcy5sZW5ndGg7IGorKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB3b3JkV2lkdGggPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQod29yZHNbal0pLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgd29yZFdpZHRoV2l0aFNwYWNlID0gd29yZFdpZHRoICsgdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KCcgJykud2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChqID09PSAwIHx8IHdvcmRXaWR0aFdpdGhTcGFjZSA+IHNwYWNlTGVmdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBwcmludGluZyB0aGUgbmV3bGluZSBpZiBpdCdzIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBsaW5lIHRoYXQgaXNcclxuICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGUgd29yZCB3cmFwIHdpZHRoLlxyXG4gICAgICAgICAgICAgICAgaWYgKGogPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3b3Jkc1tqXTtcclxuICAgICAgICAgICAgICAgIHNwYWNlTGVmdCA9IHdvcmRXcmFwV2lkdGggLSB3b3JkV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzcGFjZUxlZnQgLT0gd29yZFdpZHRoV2l0aFNwYWNlO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgJyArIHdvcmRzW2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSA8IGxpbmVzLmxlbmd0aC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBUZXh0IGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIHRoZSB3b3JsZFRyYW5zZm9ybSBpbnRvIGFjY291bnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBtYXRyaXgge1BJWEkuTWF0cml4fSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBUZXh0XHJcbiAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcclxuICovXHJcblRleHQucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChtYXRyaXgpXHJcbntcclxuICAgIGlmICh0aGlzLmRpcnR5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBTcHJpdGUucHJvdG90eXBlLmdldEJvdW5kcy5jYWxsKHRoaXMsIG1hdHJpeCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVzdHJveXMgdGhpcyB0ZXh0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIFtkZXN0cm95QmFzZVRleHR1cmU9dHJ1ZV0ge2Jvb2xlYW59IHdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcclxuICovXHJcblRleHQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZGVzdHJveUJhc2VUZXh0dXJlKVxyXG57XHJcbiAgICAvLyBtYWtlIHN1cmUgdG8gcmVzZXQgdGhlIHRoZSBjb250ZXh0IGFuZCBjYW52YXMuLiBkb250IHdhbnQgdGhpcyBoYW5naW5nIGFyb3VuZCBpbiBtZW1vcnkhXHJcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl90ZXh0dXJlLmRlc3Ryb3koZGVzdHJveUJhc2VUZXh0dXJlID09PSB1bmRlZmluZWQgPyB0cnVlIDogZGVzdHJveUJhc2VUZXh0dXJlKTtcclxufTtcclxuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKSxcclxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcclxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcclxuXHJcbi8qKlxyXG4gKiBBIHRleHR1cmUgc3RvcmVzIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHJlcHJlc2VudHMgYW4gaW1hZ2UuIEFsbCB0ZXh0dXJlcyBoYXZlIGEgYmFzZSB0ZXh0dXJlLlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIHNvdXJjZSB7SW1hZ2V8Q2FudmFzfSB0aGUgc291cmNlIG9iamVjdCBvZiB0aGUgdGV4dHVyZS5cclxuICogQHBhcmFtIFtzY2FsZU1vZGU9UElYSS5TQ0FMRV9NT0RFUy5ERUZBVUxUXSB7bnVtYmVyfSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcclxuICogQHBhcmFtIHJlc29sdXRpb24ge251bWJlcn0gdGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgZm9yIGRldmljZXMgd2l0aCBkaWZmZXJlbnQgcGl4ZWwgcmF0aW9zXHJcbiAqL1xyXG5mdW5jdGlvbiBCYXNlVGV4dHVyZShzb3VyY2UsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbilcclxue1xyXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy51aWQgPSB1dGlscy51aWQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBSZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBiYXNlIHRleHR1cmUgc2V0IHdoZW4gdGhlIGltYWdlIGhhcyBsb2FkZWRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IDEwMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGJhc2UgdGV4dHVyZSBzZXQgd2hlbiB0aGUgaW1hZ2UgaGFzIGxvYWRlZFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhlaWdodCA9IDEwMDtcclxuXHJcbiAgICAvLyBUT0RPIGRvY3NcclxuICAgIC8vIHVzZWQgdG8gc3RvcmUgdGhlIGFjdHVhbCBkaW1lbnNpb25zIG9mIHRoZSBzb3VyY2VcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBzdG9yZSB0aGUgYWN0dWFsIHdpZHRoIG9mIHRoZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVhbFdpZHRoID0gMTAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIHN0b3JlIHRoZSBhY3R1YWwgaGVpZ2h0IG9mIHRoZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVhbEhlaWdodCA9IDEwMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzY2FsZSBtb2RlIHRvIGFwcGx5IHdoZW4gc2NhbGluZyB0aGlzIHRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLlNDQUxFX01PREVTLkxJTkVBUlxyXG4gICAgICogQHNlZSBQSVhJLlNDQUxFX01PREVTXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlIHx8IENPTlNULlNDQUxFX01PREVTLkRFRkFVTFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdG8gdHJ1ZSBvbmNlIHRoZSBiYXNlIHRleHR1cmUgaGFzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyBuZXZlciB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBmYWlscyB0byBsb2FkIG9yIGhhcyBubyB0ZXh0dXJlIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhhc0xvYWRlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRvIHRydWUgaWYgdGhlIHNvdXJjZSBpcyBjdXJyZW50bHkgbG9hZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBJZiBhbiBJbWFnZSBzb3VyY2UgaXMgbG9hZGluZyB0aGUgJ2xvYWRlZCcgb3IgJ2Vycm9yJyBldmVudCB3aWxsIGJlXHJcbiAgICAgKiBkaXNwYXRjaGVkIHdoZW4gdGhlIG9wZXJhdGlvbiBlbmRzLiBBbiB1bmRlcnlsaW5nIHNvdXJjZSB0aGF0IGlzXHJcbiAgICAgKiBpbW1lZGlhdGVseS1hdmFpbGFibGUgYnlwYXNzZXMgbG9hZGluZyBlbnRpcmVseS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW1hZ2Ugc291cmNlIHRoYXQgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHRleHR1cmUuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETzogTWFrZSB0aGlzIGEgc2V0dGVyIHRoYXQgY2FsbHMgbG9hZFNvdXJjZSgpO1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge0ltYWdlfENhbnZhc31cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7IC8vIHNldCBpbiBsb2FkU291cmNlLCBpZiBhdCBhbGxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRyb2xzIGlmIFJHQiBjaGFubmVscyBzaG91bGQgYmUgcHJlLW11bHRpcGxpZWQgYnkgQWxwaGEgIChXZWJHTCBvbmx5KVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbWFnZVVybCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXZXRoZXIgb3Igbm90IHRoZSB0ZXh0dXJlIGlzIGEgcG93ZXIgb2YgdHdvLCB0cnkgdG8gdXNlIHBvd2VyIG9mIHR3byB0ZXh0dXJlcyBhcyBtdWNoIGFzIHlvdSBjYW5cclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlzUG93ZXJPZlR3byA9IGZhbHNlO1xyXG5cclxuICAgIC8vIHVzZWQgZm9yIHdlYkdMXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiBhIG1pcG1hcCBvZiB0aGlzIHRleHR1cmUgbmVlZHMgdG8gYmUgZ2VuZXJhdGVkLiBUaGlzIHZhbHVlIG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgdGhlIHRleHR1cmUgaXMgdXNlZFxyXG4gICAgICogQWxzbyB0aGUgdGV4dHVyZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIHNpemUgdG8gd29ya1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWlwbWFwID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG1hcCBvZiByZW5kZXJlciBJRHMgdG8gd2ViZ2wgdGV4dHVyZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3Q8bnVtYmVyLCBXZWJHTFRleHR1cmU+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fZ2xUZXh0dXJlcyA9IHt9O1xyXG5cclxuICAgIC8vIGlmIG5vIHNvdXJjZSBwYXNzZWQgZG9uJ3QgdHJ5IHRvIGxvYWRcclxuICAgIGlmIChzb3VyY2UpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5sb2FkU291cmNlKHNvdXJjZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIGEgbm90LWltbWVkaWF0ZWx5LWF2YWlsYWJsZSBzb3VyY2UgZmluaXNoZXMgbG9hZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgbG9hZGVkXHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5CYXNlVGV4dHVyZSNcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiBhIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUgc291cmNlIGZhaWxzIHRvIGxvYWQuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50IGVycm9yXHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5CYXNlVGV4dHVyZSNcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG59XHJcblxyXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xyXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCYXNlVGV4dHVyZTtcclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlVGV4dHVyZTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSB0ZXh0dXJlIG9uIGFsbCB0aGUgd2ViZ2wgcmVuZGVyZXJzLCB0aGlzIGFsc28gYXNzdW1lcyB0aGUgc3JjIGhhcyBjaGFuZ2VkLlxyXG4gKlxyXG4gKiBAZmlyZXMgdXBkYXRlXHJcbiAqL1xyXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5yZWFsV2lkdGggPSB0aGlzLnNvdXJjZS5uYXR1cmFsV2lkdGggfHwgdGhpcy5zb3VyY2Uud2lkdGg7XHJcbiAgICB0aGlzLnJlYWxIZWlnaHQgPSB0aGlzLnNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHRoaXMuc291cmNlLmhlaWdodDtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gdGhpcy5yZWFsV2lkdGggLyB0aGlzLnJlc29sdXRpb247XHJcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMucmVhbEhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcclxuXHJcbiAgICB0aGlzLmlzUG93ZXJPZlR3byA9IHV0aWxzLmlzUG93ZXJPZlR3byh0aGlzLnJlYWxXaWR0aCwgdGhpcy5yZWFsSGVpZ2h0KTtcclxuXHJcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvYWQgYSBzb3VyY2UuXHJcbiAqXHJcbiAqIElmIHRoZSBzb3VyY2UgaXMgbm90LWltbWVkaWF0ZWx5LWF2YWlsYWJsZSwgc3VjaCBhcyBhbiBpbWFnZSB0aGF0IG5lZWRzIHRvIGJlXHJcbiAqIGRvd25sb2FkZWQsIHRoZW4gdGhlICdsb2FkZWQnIG9yICdlcnJvcicgZXZlbnQgd2lsbCBiZSBkaXNwYXRjaGVkIGluIHRoZSBmdXR1cmVcclxuICogYW5kIGBoYXNMb2FkZWRgIHdpbGwgcmVtYWluIGZhbHNlIGFmdGVyIHRoaXMgY2FsbC5cclxuICpcclxuICogVGhlIGxvZ2ljIHN0YXRlIGFmdGVyIGNhbGxpbmcgYGxvYWRTb3VyY2VgIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgKGVnLiBgZnJvbUltYWdlYCwgYG5ldyBCYXNlVGV4dHVyZWApIGlzOlxyXG4gKlxyXG4gKiAgICAgaWYgKHRleHR1cmUuaGFzTG9hZGVkKVxyXG4ge1xyXG4gKiAgICAgICAgLy8gdGV4dHVyZSByZWFkeSBmb3IgdXNlXHJcbiAqICAgICB9IGVsc2UgaWYgKHRleHR1cmUuaXNMb2FkaW5nKVxyXG4ge1xyXG4gKiAgICAgICAgLy8gbGlzdGVuIHRvICdsb2FkZWQnIGFuZC9vciAnZXJyb3InIGV2ZW50cyBvbiB0ZXh0dXJlXHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgLy8gbm90IGxvYWRpbmcsIG5vdCBnb2luZyB0byBsb2FkIFVOTEVTUyB0aGUgc291cmNlIGlzIHJlbG9hZGVkXHJcbiAqICAgICAgICAvLyAoaXQgbWF5IHN0aWxsIG1ha2Ugc2Vuc2UgdG8gbGlzdGVuIHRvIHRoZSBldmVudHMpXHJcbiAqICAgICB9XHJcbiAqXHJcbiAqIEBwcm90ZWN0ZWRcclxuICogQHBhcmFtIHNvdXJjZSB7SW1hZ2V8Q2FudmFzfSB0aGUgc291cmNlIG9iamVjdCBvZiB0aGUgdGV4dHVyZS5cclxuICovXHJcbkJhc2VUZXh0dXJlLnByb3RvdHlwZS5sb2FkU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSlcclxue1xyXG4gICAgdmFyIHdhc0xvYWRpbmcgPSB0aGlzLmlzTG9hZGluZztcclxuICAgIHRoaXMuaGFzTG9hZGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xyXG5cclxuICAgIGlmICh3YXNMb2FkaW5nICYmIHRoaXMuc291cmNlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc291cmNlLm9ubG9hZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zb3VyY2Uub25lcnJvciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblxyXG4gICAgLy8gQXBwbHkgc291cmNlIGlmIGxvYWRlZC4gT3RoZXJ3aXNlIHNldHVwIGFwcHJvcHJpYXRlIGxvYWRpbmcgbW9uaXRvcnMuXHJcbiAgICBpZiAoKHRoaXMuc291cmNlLmNvbXBsZXRlIHx8IHRoaXMuc291cmNlLmdldENvbnRleHQpICYmIHRoaXMuc291cmNlLndpZHRoICYmIHRoaXMuc291cmNlLmhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9zb3VyY2VMb2FkZWQoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFzb3VyY2UuZ2V0Q29udGV4dClcclxuICAgIHtcclxuXHJcbiAgICAgICAgLy8gSW1hZ2UgZmFpbCAvIG5vdCByZWFkeVxyXG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICAgICAgc291cmNlLm9ubG9hZCA9IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzb3VyY2Uub25sb2FkID0gbnVsbDtcclxuICAgICAgICAgICAgc291cmNlLm9uZXJyb3IgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzY29wZS5pc0xvYWRpbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2NvcGUuaXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNjb3BlLl9zb3VyY2VMb2FkZWQoKTtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLmVtaXQoJ2xvYWRlZCcsIHNjb3BlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzb3VyY2Uub25lcnJvciA9IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzb3VyY2Uub25sb2FkID0gbnVsbDtcclxuICAgICAgICAgICAgc291cmNlLm9uZXJyb3IgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzY29wZS5pc0xvYWRpbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2NvcGUuaXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNjb3BlLmVtaXQoJ2Vycm9yJywgc2NvcGUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFBlciBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCN0aGUtaW1nLWVsZW1lbnRcclxuICAgICAgICAvLyAgIFwiVGhlIHZhbHVlIG9mIGBjb21wbGV0ZWAgY2FuIHRodXMgY2hhbmdlIHdoaWxlIGEgc2NyaXB0IGlzIGV4ZWN1dGluZy5cIlxyXG4gICAgICAgIC8vIFNvIGNvbXBsZXRlIG5lZWRzIHRvIGJlIHJlLWNoZWNrZWQgYWZ0ZXIgdGhlIGNhbGxiYWNrcyBoYXZlIGJlZW4gYWRkZWQuLlxyXG4gICAgICAgIC8vIE5PVEU6IGNvbXBsZXRlIHdpbGwgYmUgdHJ1ZSBpZiB0aGUgaW1hZ2UgaGFzIG5vIHNyYyBzbyBiZXN0IHRvIGNoZWNrIGlmIHRoZSBzcmMgaXMgc2V0LlxyXG4gICAgICAgIGlmIChzb3VyY2UuY29tcGxldGUgJiYgc291cmNlLnNyYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyAuLmFuZCBpZiB3ZSdyZSBjb21wbGV0ZSBub3csIG5vIG5lZWQgZm9yIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICBzb3VyY2Uub25sb2FkID0gbnVsbDtcclxuICAgICAgICAgICAgc291cmNlLm9uZXJyb3IgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VMb2FkZWQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgcHJldmlvdXMgc3Vic2NyaWJlcnMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIGlmICh3YXNMb2FkaW5nKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgcHJldmlvdXMgc3Vic2NyaWJlcnMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIGlmICh3YXNMb2FkaW5nKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVc2VkIGludGVybmFsbHkgdG8gdXBkYXRlIHRoZSB3aWR0aCwgaGVpZ2h0LCBhbmQgc29tZSBvdGhlciB0cmFja2luZyB2YXJzIG9uY2VcclxuICogYSBzb3VyY2UgaGFzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUuX3NvdXJjZUxvYWRlZCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuaGFzTG9hZGVkID0gdHJ1ZTtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVzdHJveXMgdGhpcyBiYXNlIHRleHR1cmVcclxuICpcclxuICovXHJcbkJhc2VUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKHRoaXMuaW1hZ2VVcmwpXHJcbiAgICB7XHJcbiAgICAgICAgZGVsZXRlIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbdGhpcy5pbWFnZVVybF07XHJcbiAgICAgICAgZGVsZXRlIHV0aWxzLlRleHR1cmVDYWNoZVt0aGlzLmltYWdlVXJsXTtcclxuXHJcbiAgICAgICAgdGhpcy5pbWFnZVVybCA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmICghbmF2aWdhdG9yLmlzQ29jb29uSlMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5zcmMgPSAnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5fcGl4aUlkKVxyXG4gICAge1xyXG4gICAgICAgIGRlbGV0ZSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW3RoaXMuc291cmNlLl9waXhpSWRdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc291cmNlID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmRpc3Bvc2UoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGcmVlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMIG1lbW9yeSB3aXRob3V0IGRlc3Ryb3lpbmcgdGhpcyB0ZXh0dXJlIG9iamVjdC5cclxuICogVGhpcyBtZWFucyB5b3UgY2FuIHN0aWxsIHVzZSB0aGUgdGV4dHVyZSBsYXRlciB3aGljaCB3aWxsIHVwbG9hZCBpdCB0byBHUFVcclxuICogbWVtb3J5IGFnYWluLlxyXG4gKlxyXG4gKi9cclxuQmFzZVRleHR1cmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLmVtaXQoJ2Rpc3Bvc2UnLCB0aGlzKTtcclxuXHJcbiAgICAvLyB0aGlzIHNob3VsZCBubyBsb25nZXIgYmUgbmVlZGVkLCB0aGUgcmVuZGVyZXJzIHNob3VsZCBjbGVhbnVwIGFsbCB0aGUgZ2wgdGV4dHVyZXMuXHJcbiAgICAvLyB0aGlzLl9nbFRleHR1cmVzID0ge307XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hhbmdlcyB0aGUgc291cmNlIGltYWdlIG9mIHRoZSB0ZXh0dXJlLlxyXG4gKiBUaGUgb3JpZ2luYWwgc291cmNlIG11c3QgYmUgYW4gSW1hZ2UgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIG5ld1NyYyB7c3RyaW5nfSB0aGUgcGF0aCBvZiB0aGUgaW1hZ2VcclxuICovXHJcbkJhc2VUZXh0dXJlLnByb3RvdHlwZS51cGRhdGVTb3VyY2VJbWFnZSA9IGZ1bmN0aW9uIChuZXdTcmMpXHJcbntcclxuICAgIHRoaXMuc291cmNlLnNyYyA9IG5ld1NyYztcclxuXHJcbiAgICB0aGlzLmxvYWRTb3VyY2UodGhpcy5zb3VyY2UpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBiYXNlIHRleHR1cmUgZnJvbSB0aGUgZ2l2ZW4gaW1hZ2UgdXJsLlxyXG4gKiBJZiB0aGUgaW1hZ2UgaXMgbm90IGluIHRoZSBiYXNlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBsb2FkZWQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIGltYWdlVXJsIHtzdHJpbmd9IFRoZSBpbWFnZSB1cmwgb2YgdGhlIHRleHR1cmVcclxuICogQHBhcmFtIFtjcm9zc29yaWdpbj0oYXV0byldIHtib29sZWFufSBTaG91bGQgdXNlIGFub255bW91cyBDT1JTPyBEZWZhdWx0cyB0byB0cnVlIGlmIHRoZSBVUkwgaXMgbm90IGEgZGF0YS1VUkkuXHJcbiAqIEBwYXJhbSBbc2NhbGVNb2RlPVBJWEkuU0NBTEVfTU9ERVMuREVGQVVMVF0ge251bWJlcn0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXHJcbiAqIEByZXR1cm4gUElYSS5CYXNlVGV4dHVyZVxyXG4gKi9cclxuQmFzZVRleHR1cmUuZnJvbUltYWdlID0gZnVuY3Rpb24gKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxyXG57XHJcbiAgICB2YXIgYmFzZVRleHR1cmUgPSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2ltYWdlVXJsXTtcclxuXHJcbiAgICBpZiAoY3Jvc3NvcmlnaW4gPT09IHVuZGVmaW5lZCAmJiBpbWFnZVVybC5pbmRleE9mKCdkYXRhOicpICE9PSAwKVxyXG4gICAge1xyXG4gICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWJhc2VUZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIC8vIG5ldyBJbWFnZSgpIGJyZWFrcyB0ZXggbG9hZGluZyBpbiBzb21lIHZlcnNpb25zIG9mIENocm9tZS5cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIzODA3MVxyXG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpOy8vZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKGltYWdlLCBzY2FsZU1vZGUpO1xyXG4gICAgICAgIGJhc2VUZXh0dXJlLmltYWdlVXJsID0gaW1hZ2VVcmw7XHJcblxyXG4gICAgICAgIGltYWdlLnNyYyA9IGltYWdlVXJsO1xyXG5cclxuICAgICAgICB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2ltYWdlVXJsXSA9IGJhc2VUZXh0dXJlO1xyXG5cclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiBAMnggYXQgdGhlIGVuZCBvZiB0aGUgdXJsIHdlIGFyZSBnb2luZyB0byBhc3N1bWUgaXRzIGEgaGlnaHJlcyBpbWFnZVxyXG4gICAgICAgIGJhc2VUZXh0dXJlLnJlc29sdXRpb24gPSB1dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwoaW1hZ2VVcmwpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBiYXNlVGV4dHVyZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGZyb20gdGhlIGdpdmVuIGNhbnZhcyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSBjYW52YXMge0NhbnZhc30gVGhlIGNhbnZhcyBlbGVtZW50IHNvdXJjZSBvZiB0aGUgdGV4dHVyZVxyXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtudW1iZXJ9IFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xyXG4gKiBAcmV0dXJuIFBJWEkuQmFzZVRleHR1cmVcclxuICovXHJcbkJhc2VUZXh0dXJlLmZyb21DYW52YXMgPSBmdW5jdGlvbiAoY2FudmFzLCBzY2FsZU1vZGUpXHJcbntcclxuICAgIGlmICghY2FudmFzLl9waXhpSWQpXHJcbiAgICB7XHJcbiAgICAgICAgY2FudmFzLl9waXhpSWQgPSAnY2FudmFzXycgKyB1dGlscy51aWQoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYmFzZVRleHR1cmUgPSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2NhbnZhcy5fcGl4aUlkXTtcclxuXHJcbiAgICBpZiAoIWJhc2VUZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKGNhbnZhcywgc2NhbGVNb2RlKTtcclxuICAgICAgICB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2NhbnZhcy5fcGl4aUlkXSA9IGJhc2VUZXh0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBiYXNlVGV4dHVyZTtcclxufTtcclxuIiwidmFyIEJhc2VUZXh0dXJlID0gcmVxdWlyZSgnLi9CYXNlVGV4dHVyZScpLFxyXG4gICAgVGV4dHVyZSA9IHJlcXVpcmUoJy4vVGV4dHVyZScpLFxyXG4gICAgUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1JlbmRlclRhcmdldCcpLFxyXG4gICAgRmlsdGVyTWFuYWdlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9GaWx0ZXJNYW5hZ2VyJyksXHJcbiAgICBDYW52YXNCdWZmZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0J1ZmZlcicpLFxyXG4gICAgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcclxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcclxuICAgIHRlbXBNYXRyaXggPSBuZXcgbWF0aC5NYXRyaXgoKTtcclxuXHJcbi8qKlxyXG4gKiBBIFJlbmRlclRleHR1cmUgaXMgYSBzcGVjaWFsIHRleHR1cmUgdGhhdCBhbGxvd3MgYW55IFBpeGkgZGlzcGxheSBvYmplY3QgdG8gYmUgcmVuZGVyZWQgdG8gaXQuXHJcbiAqXHJcbiAqIF9fSGludF9fOiBBbGwgRGlzcGxheU9iamVjdHMgKGkuZS4gU3ByaXRlcykgdGhhdCByZW5kZXIgdG8gYSBSZW5kZXJUZXh0dXJlIHNob3VsZCBiZSBwcmVsb2FkZWRcclxuICogb3RoZXJ3aXNlIGJsYWNrIHJlY3RhbmdsZXMgd2lsbCBiZSBkcmF3biBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBBIFJlbmRlclRleHR1cmUgdGFrZXMgYSBzbmFwc2hvdCBvZiBhbnkgRGlzcGxheSBPYmplY3QgZ2l2ZW4gdG8gaXRzIHJlbmRlciBtZXRob2QuIFRoZSBwb3NpdGlvblxyXG4gKiBhbmQgcm90YXRpb24gb2YgdGhlIGdpdmVuIERpc3BsYXkgT2JqZWN0cyBpcyBpZ25vcmVkLiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHJlbmRlcmVyID0gUElYSS5hdXRvRGV0ZWN0UmVuZGVyZXIoMTAyNCwgMTAyNCwgeyB2aWV3OiBjYW52YXMsIHJhdGlvOiAxIH0pO1xyXG4gKiB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBQSVhJLlJlbmRlclRleHR1cmUocmVuZGVyZXIsIDgwMCwgNjAwKTtcclxuICogdmFyIHNwcml0ZSA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZShcInNwaW5PYmpfMDEucG5nXCIpO1xyXG4gKlxyXG4gKiBzcHJpdGUucG9zaXRpb24ueCA9IDgwMC8yO1xyXG4gKiBzcHJpdGUucG9zaXRpb24ueSA9IDYwMC8yO1xyXG4gKiBzcHJpdGUuYW5jaG9yLnggPSAwLjU7XHJcbiAqIHNwcml0ZS5hbmNob3IueSA9IDAuNTtcclxuICpcclxuICogcmVuZGVyVGV4dHVyZS5yZW5kZXIoc3ByaXRlKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBTcHJpdGUgaW4gdGhpcyBjYXNlIHdpbGwgYmUgcmVuZGVyZWQgdG8gYSBwb3NpdGlvbiBvZiAwLDAuIFRvIHJlbmRlciB0aGlzIHNwcml0ZSBhdCBpdHMgYWN0dWFsXHJcbiAqIHBvc2l0aW9uIGEgQ29udGFpbmVyIHNob3VsZCBiZSB1c2VkOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgZG9jID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XHJcbiAqXHJcbiAqIGRvYy5hZGRDaGlsZChzcHJpdGUpO1xyXG4gKlxyXG4gKiByZW5kZXJUZXh0dXJlLnJlbmRlcihkb2MpOyAgLy8gUmVuZGVycyB0byBjZW50ZXIgb2YgcmVuZGVyVGV4dHVyZVxyXG4gKiBgYGBcclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuVGV4dHVyZVxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdXNlZCBmb3IgdGhpcyBSZW5kZXJUZXh0dXJlXHJcbiAqIEBwYXJhbSBbd2lkdGg9MTAwXSB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlXHJcbiAqIEBwYXJhbSBbaGVpZ2h0PTEwMF0ge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcclxuICogQHBhcmFtIFtzY2FsZU1vZGVdIHtudW1iZXJ9IFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xyXG4gKiBAcGFyYW0gW3Jlc29sdXRpb249MV0ge251bWJlcn0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgYmVpbmcgZ2VuZXJhdGVkXHJcbiAqL1xyXG5mdW5jdGlvbiBSZW5kZXJUZXh0dXJlKHJlbmRlcmVyLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24pXHJcbntcclxuICAgIGlmICghcmVuZGVyZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY3JlYXRlIFJlbmRlclRleHR1cmUsIHlvdSBtdXN0IHBhc3MgYSByZW5kZXJlciBpbnRvIHRoZSBjb25zdHJ1Y3Rvci4nKTtcclxuICAgIH1cclxuXHJcbiAgICB3aWR0aCA9IHdpZHRoIHx8IDEwMDtcclxuICAgIGhlaWdodCA9IGhlaWdodCB8fCAxMDA7XHJcbiAgICByZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBDT05TVC5SRVNPTFVUSU9OO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgdGV4dHVyZSBvYmplY3QgdGhhdCB0aGlzIHRleHR1cmUgdXNlc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge0Jhc2VUZXh0dXJlfVxyXG4gICAgICovXHJcbiAgICB2YXIgYmFzZVRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmUoKTtcclxuICAgIGJhc2VUZXh0dXJlLndpZHRoID0gd2lkdGg7XHJcbiAgICBiYXNlVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICBiYXNlVGV4dHVyZS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuICAgIGJhc2VUZXh0dXJlLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSB8fCBDT05TVC5TQ0FMRV9NT0RFUy5ERUZBVUxUO1xyXG4gICAgYmFzZVRleHR1cmUuaGFzTG9hZGVkID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgVGV4dHVyZS5jYWxsKHRoaXMsXHJcbiAgICAgICAgYmFzZVRleHR1cmUsXHJcbiAgICAgICAgbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIHdpZHRoLCBoZWlnaHQpXHJcbiAgICApO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aXRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdy9yZW5kZXIgdGhlIGdpdmVuIERpc3BsYXlPYmplY3Qgb250byB0aGUgdGV4dHVyZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGlzcGxheU9iamVjdCBhbmQgZGVzY2VuZGVudHMgYXJlIHRyYW5zZm9ybWVkIGR1cmluZyB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAqIElmIGB1cGRhdGVUcmFuc2Zvcm1gIGlzIHRydWUgdGhlbiB0aGUgdHJhbnNmb3JtYXRpb25zIHdpbGwgYmUgcmVzdG9yZWQgYmVmb3JlIHRoZVxyXG4gICAgICogbWV0aG9kIHJldHVybnMuIE90aGVyd2lzZSBpdCBpcyB1cCB0byB0aGUgY2FsbGluZyBjb2RlIHRvIGNvcnJlY3RseSB1c2Ugb3IgcmVzZXRcclxuICAgICAqIHRoZSB0cmFuc2Zvcm1lZCBkaXNwbGF5IG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRpc3BsYXkgb2JqZWN0IGlzIGFsd2F5cyByZW5kZXJlZCB3aXRoIGEgd29ybGRBbHBoYSB2YWx1ZSBvZiAxLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXIgdGhpcyB0ZXh0dXJlIG9uXHJcbiAgICAgKiBAcGFyYW0gW21hdHJpeF0ge1BJWEkuTWF0cml4fSBPcHRpb25hbCBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGRpc3BsYXkgb2JqZWN0IGJlZm9yZSByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gW2NsZWFyPWZhbHNlXSB7Ym9vbGVhbn0gSWYgdHJ1ZSB0aGUgdGV4dHVyZSB3aWxsIGJlIGNsZWFyZWQgYmVmb3JlIHRoZSBkaXNwbGF5T2JqZWN0IGlzIGRyYXduXHJcbiAgICAgKiBAcGFyYW0gW3VwZGF0ZVRyYW5zZm9ybT10cnVlXSB7Ym9vbGVhbn0gSWYgdHJ1ZSB0aGUgZGlzcGxheU9iamVjdCdzIHdvcmxkVHJhbnNmb3JtL3dvcmxkQWxwaGEgYW5kIGFsbCBjaGlsZHJlblxyXG4gICAgICogIHRyYW5zZm9ybWF0aW9ucyB3aWxsIGJlIHJlc3RvcmVkLiBOb3QgcmVzdG9yaW5nIHRoaXMgaW5mb3JtYXRpb24gd2lsbCBiZSBhIGxpdHRsZSBmYXN0ZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVuZGVyID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZW5kZXJlciB0aGlzIFJlbmRlclRleHR1cmUgdXNlcy4gQSBSZW5kZXJUZXh0dXJlIGNhbiBvbmx5IGJlbG9uZyB0byBvbmUgcmVuZGVyZXIgYXQgdGhlIG1vbWVudCBpZiBpdHMgd2ViR0wuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5DYW52YXNSZW5kZXJlcnxQSVhJLldlYkdMUmVuZGVyZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHJcbiAgICBpZiAodGhpcy5yZW5kZXJlci50eXBlID09PSBDT05TVC5SRU5ERVJFUl9UWVBFLldFQkdMKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZUJ1ZmZlciA9IG5ldyBSZW5kZXJUYXJnZXQoZ2wsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBiYXNlVGV4dHVyZS5zY2FsZU1vZGUsIHRoaXMucmVzb2x1dGlvbik7Ly8sIHRoaXMuYmFzZVRleHR1cmUuc2NhbGVNb2RlKTtcclxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSA9IHRoaXMudGV4dHVyZUJ1ZmZlci50ZXh0dXJlO1xyXG5cclxuICAgICAgICAvL1RPRE8gcmVmYWN0b3IgZmlsdGVyIG1hbmFnZXIuLiBhcyByZWFsbHkgaXRzIG5vIGxvbmdlciBhIG1hbmFnZXIgaWYgd2UgdXNlIGl0IGhlcmUuLlxyXG4gICAgICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IG5ldyBGaWx0ZXJNYW5hZ2VyKHRoaXMucmVuZGVyZXIpO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyTWFuYWdlci5vbkNvbnRleHRDaGFuZ2UoKTtcclxuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXJXZWJHTDtcclxuXHJcbiAgICAgICAgLy8gdGhlIGNyZWF0aW9uIG9mIGEgZmlsdGVyIG1hbmFnZXIgdW5iaW5kcyB0aGUgYnVmZmVycy4uXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQuYWN0aXZhdGUoKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlckNhbnZhcztcclxuICAgICAgICB0aGlzLnRleHR1cmVCdWZmZXIgPSBuZXcgQ2FudmFzQnVmZmVyKHRoaXMud2lkdGgqIHRoaXMucmVzb2x1dGlvbiwgdGhpcy5oZWlnaHQqIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5zb3VyY2UgPSB0aGlzLnRleHR1cmVCdWZmZXIuY2FudmFzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy52YWxpZCA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlVXZzKCk7XHJcbn1cclxuXHJcblJlbmRlclRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUZXh0dXJlLnByb3RvdHlwZSk7XHJcblJlbmRlclRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVuZGVyVGV4dHVyZTtcclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJUZXh0dXJlO1xyXG5cclxuLyoqXHJcbiAqIFJlc2l6ZXMgdGhlIFJlbmRlclRleHR1cmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggdG8gcmVzaXplIHRvLlxyXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IFRoZSBoZWlnaHQgdG8gcmVzaXplIHRvLlxyXG4gKiBAcGFyYW0gdXBkYXRlQmFzZSB7Ym9vbGVhbn0gU2hvdWxkIHRoZSBiYXNlVGV4dHVyZS53aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyBiZSByZXNpemVkIGFzIHdlbGw/XHJcbiAqL1xyXG5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgdXBkYXRlQmFzZSlcclxue1xyXG4gICAgaWYgKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudmFsaWQgPSAod2lkdGggPiAwICYmIGhlaWdodCA+IDApO1xyXG5cclxuICAgIHRoaXMud2lkdGggPSB0aGlzLl9mcmFtZS53aWR0aCA9IHRoaXMuY3JvcC53aWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5oZWlnaHQgPSAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gdGhpcy5jcm9wLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICBpZiAodXBkYXRlQmFzZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy52YWxpZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgaWYodGhpcy5maWx0ZXJNYW5hZ2VyKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZmlsdGVyTWFuYWdlci5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFycyB0aGUgUmVuZGVyVGV4dHVyZS5cclxuICpcclxuICovXHJcblJlbmRlclRleHR1cmUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKCF0aGlzLnZhbGlkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5yZW5kZXJlci50eXBlID09PSBDT05TVC5SRU5ERVJFUl9UWVBFLldFQkdMKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMucmVuZGVyZXIuZ2wuRlJBTUVCVUZGRVIsIHRoaXMudGV4dHVyZUJ1ZmZlci5mcmFtZUJ1ZmZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLmNsZWFyKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgbWV0aG9kIGFzc2lnbmVkIHRvIHRoZSBgcmVuZGVyYCBwcm9wZXJ0eSBpZiB1c2luZyBhIENhbnZhc1JlbmRlcmVyLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgZGlzcGxheSBvYmplY3QgdG8gcmVuZGVyIHRoaXMgdGV4dHVyZSBvblxyXG4gKiBAcGFyYW0gW21hdHJpeF0ge1BJWEkuTWF0cml4fSBPcHRpb25hbCBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGRpc3BsYXkgb2JqZWN0IGJlZm9yZSByZW5kZXJpbmcuXHJcbiAqIEBwYXJhbSBbY2xlYXI9ZmFsc2VdIHtib29sZWFufSBJZiB0cnVlIHRoZSB0ZXh0dXJlIHdpbGwgYmUgY2xlYXJlZCBiZWZvcmUgdGhlIGRpc3BsYXlPYmplY3QgaXMgZHJhd25cclxuICogQHBhcmFtIFt1cGRhdGVUcmFuc2Zvcm09dHJ1ZV0ge2Jvb2xlYW59IElmIHRydWUgdGhlIGRpc3BsYXlPYmplY3QncyB3b3JsZFRyYW5zZm9ybS93b3JsZEFscGhhIGFuZCBhbGwgY2hpbGRyZW5cclxuICogIHRyYW5zZm9ybWF0aW9ucyB3aWxsIGJlIHJlc3RvcmVkLiBOb3QgcmVzdG9yaW5nIHRoaXMgaW5mb3JtYXRpb24gd2lsbCBiZSBhIGxpdHRsZSBmYXN0ZXIuXHJcbiAqL1xyXG5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChkaXNwbGF5T2JqZWN0LCBtYXRyaXgsIGNsZWFyLCB1cGRhdGVUcmFuc2Zvcm0pXHJcbntcclxuICAgIGlmICghdGhpcy52YWxpZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHVwZGF0ZVRyYW5zZm9ybSA9ICh1cGRhdGVUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkgPyB1cGRhdGVUcmFuc2Zvcm0gOiB0cnVlOy8vIXVwZGF0ZVRyYW5zZm9ybTtcclxuXHJcbiAgICB0aGlzLnRleHR1cmVCdWZmZXIudHJhbnNmb3JtID0gbWF0cml4O1xyXG5cclxuICAgIC8vVE9ETyBub3QgYSBmYW4gdGhhdCB0aGlzIGlzIGhlcmUuLi4gaXQgd2lsbCBtb3ZlIVxyXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLmFjdGl2YXRlKCk7XHJcblxyXG4gICAgLy8gc2V0V29ybGQgQWxwaGEgdG8gZW5zdXJlIHRoYXQgdGhlIG9iamVjdCBpcyByZW5kZXJlciBhdCBmdWxsIG9wYWNpdHlcclxuICAgIGRpc3BsYXlPYmplY3Qud29ybGRBbHBoYSA9IDE7XHJcblxyXG4gICAgaWYgKHVwZGF0ZVRyYW5zZm9ybSlcclxuICAgIHtcclxuXHJcbiAgICAgICAgLy8gcmVzZXQgdGhlIG1hdHJpeCBvZiB0aGUgZGlzcGxhdHlPYmplY3QuLlxyXG4gICAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcclxuXHJcbiAgICAgICAgZGlzcGxheU9iamVjdC5jdXJyZW50Qm91bmRzID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVGltZSB0byB1cGRhdGUgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzcGxheU9iamVjdCB3aXRoIHRoZSBuZXcgbWF0cml4Li5cclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xyXG4gICAgICAgIHZhciBpLCBqO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vVE9ETyByZW5hbWUgdGV4dHVyZUJ1ZmZlciB0byByZW5kZXJUYXJnZXQuLlxyXG4gICAgdmFyIHRlbXAgPSAgdGhpcy5yZW5kZXJlci5maWx0ZXJNYW5hZ2VyO1xyXG5cclxuICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyTWFuYWdlciA9IHRoaXMuZmlsdGVyTWFuYWdlcjtcclxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCB0aGlzLnRleHR1cmVCdWZmZXIsIGNsZWFyKTtcclxuXHJcbiAgICB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXIgPSB0ZW1wO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBtZXRob2QgYXNzaWduZWQgdG8gdGhlIGByZW5kZXJgIHByb3BlcnR5IGlmIHVzaW5nIGEgQ2FudmFzUmVuZGVyZXIuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXIgdGhpcyB0ZXh0dXJlIG9uXHJcbiAqIEBwYXJhbSBbbWF0cml4XSB7UElYSS5NYXRyaXh9IE9wdGlvbmFsIG1hdHJpeCB0byBhcHBseSB0byB0aGUgZGlzcGxheSBvYmplY3QgYmVmb3JlIHJlbmRlcmluZy5cclxuICogQHBhcmFtIFtjbGVhcl0ge2Jvb2xlYW59IElmIHRydWUgdGhlIHRleHR1cmUgd2lsbCBiZSBjbGVhcmVkIGJlZm9yZSB0aGUgZGlzcGxheU9iamVjdCBpcyBkcmF3blxyXG4gKi9cclxuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUucmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKGRpc3BsYXlPYmplY3QsIG1hdHJpeCwgY2xlYXIsIHVwZGF0ZVRyYW5zZm9ybSlcclxue1xyXG4gICAgaWYgKCF0aGlzLnZhbGlkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVUcmFuc2Zvcm0gPSAhIXVwZGF0ZVRyYW5zZm9ybTtcclxuXHJcbiAgICB2YXIgd3QgPSB0ZW1wTWF0cml4O1xyXG5cclxuICAgIHd0LmlkZW50aXR5KCk7XHJcblxyXG4gICAgaWYgKG1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB3dC5hcHBlbmQobWF0cml4KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2FjaGVkV3QgPSBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtO1xyXG4gICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybSA9IHd0O1xyXG5cclxuICAgIC8vIHNldFdvcmxkIEFscGhhIHRvIGVuc3VyZSB0aGF0IHRoZSBvYmplY3QgaXMgcmVuZGVyZXIgYXQgZnVsbCBvcGFjaXR5XHJcbiAgICBkaXNwbGF5T2JqZWN0LndvcmxkQWxwaGEgPSAxO1xyXG5cclxuICAgIC8vIFRpbWUgdG8gdXBkYXRlIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhlIGRpc3BsYXlPYmplY3Qgd2l0aCB0aGUgbmV3IG1hdHJpeC4uXHJcbiAgICB2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xyXG4gICAgdmFyIGksIGo7XHJcblxyXG4gICAgZm9yIChpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcclxuICAgIHtcclxuICAgICAgICBjaGlsZHJlbltpXS51cGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2xlYXIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlQnVmZmVyLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG5cclxuLy8gICAgdGhpcy50ZXh0dXJlQnVmZmVyLlxyXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLnRleHR1cmVCdWZmZXIuY29udGV4dDtcclxuXHJcbiAgICB2YXIgcmVhbFJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XHJcblxyXG4gICAgdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xyXG5cclxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCBjb250ZXh0KTtcclxuXHJcbiAgICB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb24gPSByZWFsUmVzb2x1dGlvbjtcclxuXHJcbiAgICBpZihkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtID09PSB3dClcclxuICAgIHtcclxuICAgICAgICAvLyBmaXhlcyBjYWNoZUFzQml0bWFwIEhhcHBlbmluZyBkdXJpbmcgdGhlIGFib3ZlLi5cclxuICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtID0gY2FjaGVkV3Q7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxyXG4gKlxyXG4gKiBAcGFyYW0gZGVzdHJveUJhc2Uge2Jvb2xlYW59IFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcclxuICovXHJcblJlbmRlclRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICBUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgdHJ1ZSk7XHJcblxyXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLmRlc3Ryb3koKTtcclxuXHJcbiAgICAvLyBkZXN0cm95IHRoZSBmaWx0ZXJtYW5hZ2VyLi5cclxuICAgIGlmKHRoaXMuZmlsdGVyTWFuYWdlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgcmV0dXJuIGEgSFRNTCBJbWFnZSBvZiB0aGUgdGV4dHVyZVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtJbWFnZX1cclxuICovXHJcblJlbmRlclRleHR1cmUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICBpbWFnZS5zcmMgPSB0aGlzLmdldEJhc2U2NCgpO1xyXG4gICAgcmV0dXJuIGltYWdlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgcmV0dXJuIGEgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgdGhpcyB0ZXh0dXJlLiBJdCB3b3JrcyBieSBjYWxsaW5nIFJlbmRlclRleHR1cmUuZ2V0Q2FudmFzIGFuZCB0aGVuIHJ1bm5pbmcgdG9EYXRhVVJMIG9uIHRoYXQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgdGhlIHRleHR1cmUuXHJcbiAqL1xyXG5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5nZXRCYXNlNjQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5nZXRDYW52YXMoKS50b0RhdGFVUkwoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgQ2FudmFzIGVsZW1lbnQsIHJlbmRlcnMgdGhpcyBSZW5kZXJUZXh0dXJlIHRvIGl0IGFuZCB0aGVuIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBBIENhbnZhcyBlbGVtZW50IHdpdGggdGhlIHRleHR1cmUgcmVuZGVyZWQgb24uXHJcbiAqL1xyXG5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5nZXRDYW52YXMgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJlci50eXBlID09PSBDT05TVC5SRU5ERVJFUl9UWVBFLldFQkdMKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy50ZXh0dXJlQnVmZmVyLnNpemUud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMudGV4dHVyZUJ1ZmZlci5zaXplLmhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIHdlYkdMUGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoNCAqIHdpZHRoICogaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLnRleHR1cmVCdWZmZXIuZnJhbWVCdWZmZXIpO1xyXG4gICAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgd2ViR0xQaXhlbHMpO1xyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcblxyXG4gICAgICAgIHZhciB0ZW1wQ2FudmFzID0gbmV3IENhbnZhc0J1ZmZlcih3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB2YXIgY2FudmFzRGF0YSA9IHRlbXBDYW52YXMuY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgY2FudmFzRGF0YS5kYXRhLnNldCh3ZWJHTFBpeGVscyk7XHJcblxyXG4gICAgICAgIHRlbXBDYW52YXMuY29udGV4dC5wdXRJbWFnZURhdGEoY2FudmFzRGF0YSwgMCwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZW1wQ2FudmFzLmNhbnZhcztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQnVmZmVyLmNhbnZhcztcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBXaWxsIHJldHVybiBhIG9uZS1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIG9mIHRoZSBlbnRpcmUgdGV4dHVyZSBpbiBSR0JBIG9yZGVyLCB3aXRoIGludGVnZXIgdmFsdWVzIGJldHdlZW4gMCBhbmQgMjU1IChpbmNsdWRlZCkuXHJcbiAqXHJcbiAqIEByZXR1cm4ge1VpbnQ4Q2xhbXBlZEFycmF5fVxyXG4gKi9cclxuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUuZ2V0UGl4ZWxzID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIHdpZHRoLCBoZWlnaHQ7XHJcblxyXG4gICAgaWYgKHRoaXMucmVuZGVyZXIudHlwZSA9PT0gQ09OU1QuUkVOREVSRVJfVFlQRS5XRUJHTClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG4gICAgICAgIHdpZHRoID0gdGhpcy50ZXh0dXJlQnVmZmVyLnNpemUud2lkdGg7XHJcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy50ZXh0dXJlQnVmZmVyLnNpemUuaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgd2ViR0xQaXhlbHMgPSBuZXcgVWludDhBcnJheSg0ICogd2lkdGggKiBoZWlnaHQpO1xyXG5cclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMudGV4dHVyZUJ1ZmZlci5mcmFtZUJ1ZmZlcik7XHJcbiAgICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB3ZWJHTFBpeGVscyk7XHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHdlYkdMUGl4ZWxzO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHdpZHRoID0gdGhpcy50ZXh0dXJlQnVmZmVyLmNhbnZhcy53aWR0aDtcclxuICAgICAgICBoZWlnaHQgPSB0aGlzLnRleHR1cmVCdWZmZXIuY2FudmFzLmhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZUJ1ZmZlci5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBXaWxsIHJldHVybiBhIG9uZS1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIG9mIGEgcGl4ZWwgd2l0aGluIHRoZSB0ZXh0dXJlIGluIFJHQkEgb3JkZXIsIHdpdGggaW50ZWdlciB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAyNTUgKGluY2x1ZGVkKS5cclxuICpcclxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcGl4ZWwgdG8gcmV0cmlldmUuXHJcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBpeGVsIHRvIHJldHJpZXZlLlxyXG4gKiBAcmV0dXJuIHtVaW50OENsYW1wZWRBcnJheX1cclxuICovXHJcblJlbmRlclRleHR1cmUucHJvdG90eXBlLmdldFBpeGVsID0gZnVuY3Rpb24gKHgsIHkpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlcmVyLnR5cGUgPT09IENPTlNULlJFTkRFUkVSX1RZUEUuV0VCR0wpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuXHJcbiAgICAgICAgdmFyIHdlYkdMUGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy50ZXh0dXJlQnVmZmVyLmZyYW1lQnVmZmVyKTtcclxuICAgICAgICBnbC5yZWFkUGl4ZWxzKHgsIHksIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHdlYkdMUGl4ZWxzKTtcclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG5cclxuICAgICAgICByZXR1cm4gd2ViR0xQaXhlbHM7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZUJ1ZmZlci5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoeCwgeSwgMSwgMSkuZGF0YTtcclxuICAgIH1cclxufTtcclxuIiwidmFyIEJhc2VUZXh0dXJlID0gcmVxdWlyZSgnLi9CYXNlVGV4dHVyZScpLFxyXG4gICAgVmlkZW9CYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4vVmlkZW9CYXNlVGV4dHVyZScpLFxyXG4gICAgVGV4dHVyZVV2cyA9IHJlcXVpcmUoJy4vVGV4dHVyZVV2cycpLFxyXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpLFxyXG4gICAgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcclxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxuXHJcbi8qKlxyXG4gKiBBIHRleHR1cmUgc3RvcmVzIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHJlcHJlc2VudHMgYW4gaW1hZ2Ugb3IgcGFydCBvZiBhbiBpbWFnZS4gSXQgY2Fubm90IGJlIGFkZGVkXHJcbiAqIHRvIHRoZSBkaXNwbGF5IGxpc3QgZGlyZWN0bHkuIEluc3RlYWQgdXNlIGl0IGFzIHRoZSB0ZXh0dXJlIGZvciBhIFNwcml0ZS4gSWYgbm8gZnJhbWUgaXMgcHJvdmlkZWQgdGhlbiB0aGUgd2hvbGUgaW1hZ2UgaXMgdXNlZC5cclxuICpcclxuICogWW91IGNhbiBkaXJlY3RseSBjcmVhdGUgYSB0ZXh0dXJlIGZyb20gYW4gaW1hZ2UgYW5kIHRoZW4gcmV1c2UgaXQgbXVsdGlwbGUgdGltZXMgbGlrZSB0aGlzIDpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKCdhc3NldHMvaW1hZ2UucG5nJyk7XHJcbiAqIHZhciBzcHJpdGUxID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xyXG4gKiB2YXIgc3ByaXRlMiA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcGFyYW0gYmFzZVRleHR1cmUge1BJWEkuQmFzZVRleHR1cmV9IFRoZSBiYXNlIHRleHR1cmUgc291cmNlIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZSBmcm9tXHJcbiAqIEBwYXJhbSBbZnJhbWVdIHtQSVhJLlJlY3RhbmdsZX0gVGhlIHJlY3RhbmdsZSBmcmFtZSBvZiB0aGUgdGV4dHVyZSB0byBzaG93XHJcbiAqIEBwYXJhbSBbY3JvcF0ge1BJWEkuUmVjdGFuZ2xlfSBUaGUgYXJlYSBvZiBvcmlnaW5hbCB0ZXh0dXJlXHJcbiAqIEBwYXJhbSBbdHJpbV0ge1BJWEkuUmVjdGFuZ2xlfSBUcmltbWVkIHRleHR1cmUgcmVjdGFuZ2xlXHJcbiAqIEBwYXJhbSBbcm90YXRlXSB7Ym9vbGVhbn0gaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRleHR1cmUgc2hvdWxkIGJlIHJvdGF0ZWQgYnkgOTAgZGVncmVlcyAoIHVzZWQgYnkgdGV4dHVyZSBwYWNrZXIgKVxyXG4gKi9cclxuZnVuY3Rpb24gVGV4dHVyZShiYXNlVGV4dHVyZSwgZnJhbWUsIGNyb3AsIHRyaW0sIHJvdGF0ZSlcclxue1xyXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEb2VzIHRoaXMgVGV4dHVyZSBoYXZlIGFueSBmcmFtZSBkYXRhIGFzc2lnbmVkIHRvIGl0P1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubm9GcmFtZSA9IGZhbHNlO1xyXG5cclxuICAgIGlmICghZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ub0ZyYW1lID0gdHJ1ZTtcclxuICAgICAgICBmcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIGJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyYW1lIHNwZWNpZmllcyB0aGUgcmVnaW9uIG9mIHRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fZnJhbWUgPSBmcmFtZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0dXJlIHRyaW0gZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmltID0gdHJpbTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgd2lsbCBsZXQgdGhlIHJlbmRlcmVyIGtub3cgaWYgdGhlIHRleHR1cmUgaXMgdmFsaWQuIElmIGl0J3Mgbm90IHRoZW4gaXQgY2Fubm90IGJlIHJlbmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgd2lsbCBsZXQgYSByZW5kZXJlciBrbm93IHRoYXQgYSB0ZXh0dXJlIGhhcyBiZWVuIHVwZGF0ZWQgKHVzZWQgbWFpbmx5IGZvciB3ZWJHTCB1diB1cGRhdGVzKVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVxdWlyZXNVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBXZWJHTCBVViBkYXRhIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZVV2c31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3V2cyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIFRleHR1cmUgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgdGhlIGFyZWEgb2YgdGhlIEJhc2VUZXh0dXJlIGltYWdlIHRvIGFjdHVhbGx5IGNvcHkgdG8gdGhlIENhbnZhcyAvIFdlYkdMIHdoZW4gcmVuZGVyaW5nLFxyXG4gICAgICogaXJyZXNwZWN0aXZlIG9mIHRoZSBhY3R1YWwgZnJhbWUgc2l6ZSBvciBwbGFjZW1lbnQgKHdoaWNoIGNhbiBiZSBpbmZsdWVuY2VkIGJ5IHRyaW1tZWQgdGV4dHVyZSBhdGxhc2VzKVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNyb3AgPSBjcm9wIHx8IGZyYW1lOy8vbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRleHR1cmUgc2hvdWxkIGJlIHJvdGF0ZWQgYnkgOTAgZGVncmVlc1xyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJvdGF0ZSA9ICEhcm90YXRlO1xyXG5cclxuICAgIGlmIChiYXNlVGV4dHVyZS5oYXNMb2FkZWQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMubm9GcmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZyYW1lID0gbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZnJhbWUgd2Ugc2hvdWxkIG1vbml0b3IgZm9yIGFueSBiYXNlIHRleHR1cmUgY2hhbmdlcy4uXHJcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlLm9uKCd1cGRhdGUnLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGJhc2VUZXh0dXJlLm9uY2UoJ2xvYWRlZCcsIHRoaXMub25CYXNlVGV4dHVyZUxvYWRlZCwgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSB0ZXh0dXJlIGlzIHVwZGF0ZWQuIFRoaXMgaGFwcGVucyBpZiB0aGUgZnJhbWUgb3IgdGhlIGJhc2VUZXh0dXJlIGlzIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50IHVwZGF0ZVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuVGV4dHVyZSNcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG59XHJcblxyXG5UZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XHJcblRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dHVyZTtcclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4dHVyZS5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyYW1lIHNwZWNpZmllcyB0aGUgcmVnaW9uIG9mIHRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLlRleHR1cmUjXHJcbiAgICAgKi9cclxuICAgIGZyYW1lOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZnJhbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ub0ZyYW1lID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZnJhbWUud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRyaW0gJiYgIXRoaXMucm90YXRlICYmIChmcmFtZS54ICsgZnJhbWUud2lkdGggPiB0aGlzLmJhc2VUZXh0dXJlLndpZHRoIHx8IGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQgPiB0aGlzLmJhc2VUZXh0dXJlLmhlaWdodCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZSBFcnJvcjogZnJhbWUgZG9lcyBub3QgZml0IGluc2lkZSB0aGUgYmFzZSBUZXh0dXJlIGRpbWVuc2lvbnMgJyArIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3RoaXMudmFsaWQgPSBmcmFtZSAmJiBmcmFtZS53aWR0aCAmJiBmcmFtZS5oZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS5zb3VyY2UgJiYgdGhpcy5iYXNlVGV4dHVyZS5oYXNMb2FkZWQ7XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmcmFtZSAmJiBmcmFtZS53aWR0aCAmJiBmcmFtZS5oZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS5oYXNMb2FkZWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50cmltKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy50cmltLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnRyaW0uaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhbWUud2lkdGggPSB0aGlzLnRyaW0ud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmFtZS5oZWlnaHQgPSB0aGlzLnRyaW0uaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcm9wID0gZnJhbWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVVdnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogVXBkYXRlcyB0aGlzIHRleHR1cmUgb24gdGhlIGdwdS5cclxuICpcclxuICovXHJcblRleHR1cmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuYmFzZVRleHR1cmUudXBkYXRlKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsbGVkIHdoZW4gdGhlIGJhc2UgdGV4dHVyZSBpcyBsb2FkZWRcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcblRleHR1cmUucHJvdG90eXBlLm9uQmFzZVRleHR1cmVMb2FkZWQgPSBmdW5jdGlvbiAoYmFzZVRleHR1cmUpXHJcbntcclxuICAgIC8vIFRPRE8gdGhpcyBjb2RlIGxvb2tzIGNvbmZ1c2luZy4uIGJvbyB0byBhYnVzaW5nIGdldHRlcnMgYW5kIHNldHRlcnNzIVxyXG4gICAgaWYgKHRoaXMubm9GcmFtZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZyYW1lID0gbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLl9mcmFtZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxlZCB3aGVuIHRoZSBiYXNlIHRleHR1cmUgaXMgdXBkYXRlZFxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuVGV4dHVyZS5wcm90b3R5cGUub25CYXNlVGV4dHVyZVVwZGF0ZWQgPSBmdW5jdGlvbiAoYmFzZVRleHR1cmUpXHJcbntcclxuICAgIHRoaXMuX2ZyYW1lLndpZHRoID0gYmFzZVRleHR1cmUud2lkdGg7XHJcbiAgICB0aGlzLl9mcmFtZS5oZWlnaHQgPSBiYXNlVGV4dHVyZS5oZWlnaHQ7XHJcblxyXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcclxuICpcclxuICogQHBhcmFtIFtkZXN0cm95QmFzZT1mYWxzZV0ge2Jvb2xlYW59IFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcclxuICovXHJcblRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZGVzdHJveUJhc2UpXHJcbntcclxuICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChkZXN0cm95QmFzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5vZmYoJ3VwZGF0ZScsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUub2ZmKCdsb2FkZWQnLCB0aGlzLm9uQmFzZVRleHR1cmVMb2FkZWQsIHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9mcmFtZSA9IG51bGw7XHJcbiAgICB0aGlzLl91dnMgPSBudWxsO1xyXG4gICAgdGhpcy50cmltID0gbnVsbDtcclxuICAgIHRoaXMuY3JvcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy52YWxpZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlLCB0aGlzKTtcclxuICAgIHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLnVwZGF0ZSwgdGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB0ZXh0dXJlIG9iamVjdCB0aGF0IGFjdHMgdGhlIHNhbWUgYXMgdGhpcyBvbmUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX1cclxuICovXHJcblRleHR1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsIHRoaXMuZnJhbWUsIHRoaXMuY3JvcCwgdGhpcy50cmltLCB0aGlzLnJvdGF0ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgV2ViR0wgVVYgY2FjaGUuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5UZXh0dXJlLnByb3RvdHlwZS5fdXBkYXRlVXZzID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKCF0aGlzLl91dnMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fdXZzID0gbmV3IFRleHR1cmVVdnMoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl91dnMuc2V0KHRoaXMuY3JvcCwgdGhpcy5iYXNlVGV4dHVyZSwgdGhpcy5yb3RhdGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBUZXh0dXJlIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBpbWFnZSB1cmwuXHJcbiAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSAgY3JlYXRlZCBhbmQgbG9hZGVkLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSBpbWFnZVVybCB7c3RyaW5nfSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXHJcbiAqIEBwYXJhbSBjcm9zc29yaWdpbiB7Ym9vbGVhbn0gV2hldGhlciByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zc29yaWdpblxyXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtudW1iZXJ9IFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xyXG4gKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IFRoZSBuZXdseSBjcmVhdGVkIHRleHR1cmVcclxuICovXHJcblRleHR1cmUuZnJvbUltYWdlID0gZnVuY3Rpb24gKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxyXG57XHJcbiAgICB2YXIgdGV4dHVyZSA9IHV0aWxzLlRleHR1cmVDYWNoZVtpbWFnZVVybF07XHJcblxyXG4gICAgaWYgKCF0ZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIHRleHR1cmUgPSBuZXcgVGV4dHVyZShCYXNlVGV4dHVyZS5mcm9tSW1hZ2UoaW1hZ2VVcmwsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUpKTtcclxuICAgICAgICB1dGlscy5UZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdID0gdGV4dHVyZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc3ByaXRlIHRoYXQgd2lsbCBjb250YWluIGEgdGV4dHVyZSBmcm9tIHRoZSBUZXh0dXJlQ2FjaGUgYmFzZWQgb24gdGhlIGZyYW1lSWRcclxuICogVGhlIGZyYW1lIGlkcyBhcmUgY3JlYXRlZCB3aGVuIGEgVGV4dHVyZSBwYWNrZXIgZmlsZSBoYXMgYmVlbiBsb2FkZWRcclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0gZnJhbWVJZCB7c3RyaW5nfSBUaGUgZnJhbWUgSWQgb2YgdGhlIHRleHR1cmUgaW4gdGhlIGNhY2hlXHJcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxyXG4gKi9cclxuVGV4dHVyZS5mcm9tRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJZClcclxue1xyXG4gICAgdmFyIHRleHR1cmUgPSB1dGlscy5UZXh0dXJlQ2FjaGVbZnJhbWVJZF07XHJcblxyXG4gICAgaWYgKCF0ZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZyYW1lSWQgXCInICsgZnJhbWVJZCArICdcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdGV4dHVyZSBjYWNoZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVGV4dHVyZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2FudmFzIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIGNhbnZhcyB7Q2FudmFzfSBUaGUgY2FudmFzIGVsZW1lbnQgc291cmNlIG9mIHRoZSB0ZXh0dXJlXHJcbiAqIEBwYXJhbSBzY2FsZU1vZGUge251bWJlcn0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXHJcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX1cclxuICovXHJcblRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uIChjYW52YXMsIHNjYWxlTW9kZSlcclxue1xyXG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlKEJhc2VUZXh0dXJlLmZyb21DYW52YXMoY2FudmFzLCBzY2FsZU1vZGUpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFRleHR1cmUgYmFzZWQgb24gdGhlIGdpdmVuIHZpZGVvIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHZpZGVvIHtIVE1MVmlkZW9FbGVtZW50fVxyXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtudW1iZXJ9IFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xyXG4gKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IEEgVGV4dHVyZVxyXG4gKi9cclxuVGV4dHVyZS5mcm9tVmlkZW8gPSBmdW5jdGlvbiAodmlkZW8sIHNjYWxlTW9kZSlcclxue1xyXG4gICAgaWYgKHR5cGVvZiB2aWRlbyA9PT0gJ3N0cmluZycpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIFRleHR1cmUuZnJvbVZpZGVvVXJsKHZpZGVvLCBzY2FsZU1vZGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZShWaWRlb0Jhc2VUZXh0dXJlLmZyb21WaWRlbyh2aWRlbywgc2NhbGVNb2RlKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBUZXh0dXJlIGJhc2VkIG9uIHRoZSB2aWRlbyB1cmwuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHZpZGVvVXJsIHtzdHJpbmd9XHJcbiAqIEBwYXJhbSBzY2FsZU1vZGUge251bWJlcn0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXHJcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gQSBUZXh0dXJlXHJcbiAqL1xyXG5UZXh0dXJlLmZyb21WaWRlb1VybCA9IGZ1bmN0aW9uICh2aWRlb1VybCwgc2NhbGVNb2RlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFRleHR1cmUoVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsKHZpZGVvVXJsLCBzY2FsZU1vZGUpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgdGV4dHVyZSB0byB0aGUgZ2xvYmFsIHV0aWxzLlRleHR1cmVDYWNoZS4gVGhpcyBjYWNoZSBpcyBzaGFyZWQgYWNyb3NzIHRoZSB3aG9sZSBQSVhJIG9iamVjdC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5UZXh0dXJlfSBUaGUgVGV4dHVyZSB0byBhZGQgdG8gdGhlIGNhY2hlLlxyXG4gKiBAcGFyYW0gaWQge3N0cmluZ30gVGhlIGlkIHRoYXQgdGhlIHRleHR1cmUgd2lsbCBiZSBzdG9yZWQgYWdhaW5zdC5cclxuICovXHJcblRleHR1cmUuYWRkVGV4dHVyZVRvQ2FjaGUgPSBmdW5jdGlvbiAodGV4dHVyZSwgaWQpXHJcbntcclxuICAgIHV0aWxzLlRleHR1cmVDYWNoZVtpZF0gPSB0ZXh0dXJlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhIHRleHR1cmUgZnJvbSB0aGUgZ2xvYmFsIHV0aWxzLlRleHR1cmVDYWNoZS5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0gaWQge3N0cmluZ30gVGhlIGlkIG9mIHRoZSB0ZXh0dXJlIHRvIGJlIHJlbW92ZWRcclxuICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgdGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkXHJcbiAqL1xyXG5UZXh0dXJlLnJlbW92ZVRleHR1cmVGcm9tQ2FjaGUgPSBmdW5jdGlvbiAoaWQpXHJcbntcclxuICAgIHZhciB0ZXh0dXJlID0gdXRpbHMuVGV4dHVyZUNhY2hlW2lkXTtcclxuXHJcbiAgICBkZWxldGUgdXRpbHMuVGV4dHVyZUNhY2hlW2lkXTtcclxuICAgIGRlbGV0ZSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2lkXTtcclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbiBlbXB0eSB0ZXh0dXJlLCB1c2VkIG9mdGVuIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBtdWx0aXBsZSBlbXB0eSB0ZXh0dXJlcy5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICovXHJcblRleHR1cmUuRU1QVFkgPSBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmUoKSk7XHJcbiIsIlxyXG4vKipcclxuICogQSBzdGFuZGFyZCBvYmplY3QgdG8gc3RvcmUgdGhlIFV2cyBvZiBhIHRleHR1cmVcclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqL1xyXG5mdW5jdGlvbiBUZXh0dXJlVXZzKClcclxue1xyXG4gICAgdGhpcy54MCA9IDA7XHJcbiAgICB0aGlzLnkwID0gMDtcclxuXHJcbiAgICB0aGlzLngxID0gMTtcclxuICAgIHRoaXMueTEgPSAwO1xyXG5cclxuICAgIHRoaXMueDIgPSAxO1xyXG4gICAgdGhpcy55MiA9IDE7XHJcblxyXG4gICAgdGhpcy54MyA9IDA7XHJcbiAgICB0aGlzLnkzID0gMTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlVXZzO1xyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIHRleHR1cmUgVXZzIGJhc2VkIG9uIHRoZSBnaXZlbiBmcmFtZSBpbmZvcm1hdGlvblxyXG4gKiBAcGFyYW0gZnJhbWUge1BJWEkuUmVjdGFuZ2xlfVxyXG4gKiBAcGFyYW0gYmFzZUZyYW1lIHtQSVhJLlJlY3RhbmdsZX1cclxuICogQHBhcmFtIHJvdGF0ZSB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGZyYW1lIGlzIHJvdGF0ZWRcclxuICogQHByaXZhdGVcclxuICovXHJcblRleHR1cmVVdnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChmcmFtZSwgYmFzZUZyYW1lLCByb3RhdGUpXHJcbntcclxuICAgIHZhciB0dyA9IGJhc2VGcmFtZS53aWR0aDtcclxuICAgIHZhciB0aCA9IGJhc2VGcmFtZS5oZWlnaHQ7XHJcblxyXG4gICAgaWYocm90YXRlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueDAgPSAoZnJhbWUueCArIGZyYW1lLmhlaWdodCkgLyB0dztcclxuICAgICAgICB0aGlzLnkwID0gZnJhbWUueSAvIHRoO1xyXG5cclxuICAgICAgICB0aGlzLngxID0gKGZyYW1lLnggKyBmcmFtZS5oZWlnaHQpIC8gdHc7XHJcbiAgICAgICAgdGhpcy55MSA9IChmcmFtZS55ICsgZnJhbWUud2lkdGgpIC8gdGg7XHJcblxyXG4gICAgICAgIHRoaXMueDIgPSBmcmFtZS54IC8gdHc7XHJcbiAgICAgICAgdGhpcy55MiA9IChmcmFtZS55ICsgZnJhbWUud2lkdGgpIC8gdGg7XHJcblxyXG4gICAgICAgIHRoaXMueDMgPSBmcmFtZS54IC8gdHc7XHJcbiAgICAgICAgdGhpcy55MyA9IGZyYW1lLnkgLyB0aDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuXHJcbiAgICAgICAgdGhpcy54MCA9IGZyYW1lLnggLyB0dztcclxuICAgICAgICB0aGlzLnkwID0gZnJhbWUueSAvIHRoO1xyXG5cclxuICAgICAgICB0aGlzLngxID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcclxuICAgICAgICB0aGlzLnkxID0gZnJhbWUueSAvIHRoO1xyXG5cclxuICAgICAgICB0aGlzLngyID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcclxuICAgICAgICB0aGlzLnkyID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XHJcblxyXG4gICAgICAgIHRoaXMueDMgPSBmcmFtZS54IC8gdHc7XHJcbiAgICAgICAgdGhpcy55MyA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIHRoO1xyXG4gICAgfVxyXG59O1xyXG4iLCJ2YXIgQmFzZVRleHR1cmUgPSByZXF1aXJlKCcuL0Jhc2VUZXh0dXJlJyksXHJcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcblxyXG4vKipcclxuICogQSB0ZXh0dXJlIG9mIGEgW3BsYXlpbmddIFZpZGVvLlxyXG4gKlxyXG4gKiBWaWRlbyBiYXNlIHRleHR1cmVzIG1pbWljIFBpeGkgQmFzZVRleHR1cmUuZnJvbS4uLi4gbWV0aG9kIGluIHRoZWlyIGNyZWF0aW9uIHByb2Nlc3MuXHJcbiAqXHJcbiAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gc2V2ZXJhbCB3YXlzLCBzdWNoIGFzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsKCdodHRwOi8vbXlkb21haW4uY29tL3ZpZGVvLm1wNCcpO1xyXG4gKlxyXG4gKiB2YXIgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsKHsgc3JjOiAnaHR0cDovL215ZG9tYWluLmNvbS92aWRlby5tcDQnLCBtaW1lOiAndmlkZW8vbXA0JyB9KTtcclxuICpcclxuICogdmFyIHRleHR1cmUgPSBQSVhJLlZpZGVvQmFzZVRleHR1cmUuZnJvbVVybHMoWycvdmlkZW8ud2VibScsICcvdmlkZW8ubXA0J10pO1xyXG4gKlxyXG4gKiB2YXIgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJscyhbXHJcbiAqICAgICB7IHNyYzogJy92aWRlby53ZWJtJywgbWltZTogJ3ZpZGVvL3dlYm0nIH0sXHJcbiAqICAgICB7IHNyYzogJy92aWRlby5tcDQnLCBtaW1lOiAndmlkZW8vbXA0JyB9XHJcbiAqIF0pO1xyXG4gKiBgYGBcclxuICpcclxuICogU2VlIHRoZSBbXCJkZXVzXCIgZGVtb10oaHR0cDovL3d3dy5nb29kYm95ZGlnaXRhbC5jb20vcGl4aWpzL2V4YW1wbGVzL2RldXMvKS5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuQmFzZVRleHR1cmVcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHBhcmFtIHNvdXJjZSB7SFRNTFZpZGVvRWxlbWVudH1cclxuICogQHBhcmFtIFtzY2FsZU1vZGVdIHtudW1iZXJ9IFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xyXG4gKi9cclxuZnVuY3Rpb24gVmlkZW9CYXNlVGV4dHVyZShzb3VyY2UsIHNjYWxlTW9kZSlcclxue1xyXG4gICAgaWYgKCFzb3VyY2UpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2aWRlbyBzb3VyY2UgZWxlbWVudCBzcGVjaWZpZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaG9vayBpbiBoZXJlIHRvIGNoZWNrIGlmIHZpZGVvIGlzIGFscmVhZHkgYXZhaWxhYmxlLlxyXG4gICAgLy8gQmFzZVRleHR1cmUgbG9va3MgZm9yIGEgc291cmNlLmNvbXBsZXRlIGJvb2xlYW4sIHBsdXMgd2lkdGggJiBoZWlnaHQuXHJcblxyXG4gICAgaWYgKChzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRU5PVUdIX0RBVEEgfHwgc291cmNlLnJlYWR5U3RhdGUgPT09IHNvdXJjZS5IQVZFX0ZVVFVSRV9EQVRBKSAmJiBzb3VyY2Uud2lkdGggJiYgc291cmNlLmhlaWdodClcclxuICAgIHtcclxuICAgICAgICBzb3VyY2UuY29tcGxldGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIEJhc2VUZXh0dXJlLmNhbGwodGhpcywgc291cmNlLCBzY2FsZU1vZGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdWxkIHRoZSBiYXNlIHRleHR1cmUgYXV0b21hdGljYWxseSB1cGRhdGUgaXRzZWxmLCBzZXQgdG8gdHJ1ZSBieSBkZWZhdWx0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fb25VcGRhdGUgPSB0aGlzLl9vblVwZGF0ZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fb25DYW5QbGF5ID0gdGhpcy5fb25DYW5QbGF5LmJpbmQodGhpcyk7XHJcblxyXG4gICAgaWYgKCFzb3VyY2UuY29tcGxldGUpXHJcbiAgICB7XHJcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCB0aGlzLl9vbkNhblBsYXkpO1xyXG4gICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuX29uQ2FuUGxheSk7XHJcblxyXG4gICAgICAgIC8vIHN0YXJ0ZWQgcGxheWluZy4uXHJcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCB0aGlzLl9vblBsYXlTdGFydC5iaW5kKHRoaXMpKTtcclxuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCB0aGlzLl9vblBsYXlTdG9wLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX19sb2FkZWQgPSBmYWxzZTtcclxufVxyXG5cclxuVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VUZXh0dXJlLnByb3RvdHlwZSk7XHJcblZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmlkZW9CYXNlVGV4dHVyZTtcclxubW9kdWxlLmV4cG9ydHMgPSBWaWRlb0Jhc2VUZXh0dXJlO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBpbnRlcm5hbCB1cGRhdGUgbG9vcCBvZiB0aGUgdmlkZW8gYmFzZSB0ZXh0dXJlLCBvbmx5IHJ1bnMgd2hlbiBhdXRvVXBkYXRlIGlzIHNldCB0byB0cnVlXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5WaWRlb0Jhc2VUZXh0dXJlLnByb3RvdHlwZS5fb25VcGRhdGUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICBpZiAodGhpcy5hdXRvVXBkYXRlKVxyXG4gICAge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fb25VcGRhdGUpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUnVucyB0aGUgdXBkYXRlIGxvb3Agd2hlbiB0aGUgdmlkZW8gaXMgcmVhZHkgdG8gcGxheVxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuX29uUGxheVN0YXJ0ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKCF0aGlzLmF1dG9VcGRhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9vblVwZGF0ZSk7XHJcbiAgICAgICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaXJlZCB3aGVuIGEgcGF1c2UgZXZlbnQgaXMgdHJpZ2dlcmVkLCBzdG9wcyB0aGUgdXBkYXRlIGxvb3BcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcblZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9vblBsYXlTdG9wID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5hdXRvVXBkYXRlID0gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogRmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgbG9hZGVkIGFuZCByZWFkeSB0byBwbGF5XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5WaWRlb0Jhc2VUZXh0dXJlLnByb3RvdHlwZS5fb25DYW5QbGF5ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5oYXNMb2FkZWQgPSB0cnVlO1xyXG5cclxuICAgIGlmICh0aGlzLnNvdXJjZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgdGhpcy5fb25DYW5QbGF5KTtcclxuICAgICAgICB0aGlzLnNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuX29uQ2FuUGxheSk7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnNvdXJjZS52aWRlb1dpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5zb3VyY2UudmlkZW9IZWlnaHQ7XHJcblxyXG4gICAgICAgIHRoaXMuc291cmNlLnBsYXkoKTtcclxuXHJcbiAgICAgICAgLy8gcHJldmVudCBtdWx0aXBsZSBsb2FkZWQgZGlzcGF0Y2hlcy4uXHJcbiAgICAgICAgaWYgKCF0aGlzLl9fbG9hZGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fX2xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxyXG4gKlxyXG4gKi9cclxuVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIGlmICh0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5fcGl4aUlkKVxyXG4gICAge1xyXG4gICAgICAgIGRlbGV0ZSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlWyB0aGlzLnNvdXJjZS5fcGl4aUlkIF07XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlLl9waXhpSWQ7XHJcbiAgICB9XHJcblxyXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaW1pYyBQaXhpIEJhc2VUZXh0dXJlLmZyb20uLi4uIG1ldGhvZC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0gdmlkZW8ge0hUTUxWaWRlb0VsZW1lbnR9XHJcbiAqIEBwYXJhbSBzY2FsZU1vZGUge251bWJlcn0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXHJcbiAqIEByZXR1cm4ge1BJWEkuVmlkZW9CYXNlVGV4dHVyZX1cclxuICovXHJcblZpZGVvQmFzZVRleHR1cmUuZnJvbVZpZGVvID0gZnVuY3Rpb24gKHZpZGVvLCBzY2FsZU1vZGUpXHJcbntcclxuICAgIGlmICghdmlkZW8uX3BpeGlJZClcclxuICAgIHtcclxuICAgICAgICB2aWRlby5fcGl4aUlkID0gJ3ZpZGVvXycgKyB1dGlscy51aWQoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYmFzZVRleHR1cmUgPSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW3ZpZGVvLl9waXhpSWRdO1xyXG5cclxuICAgIGlmICghYmFzZVRleHR1cmUpXHJcbiAgICB7XHJcbiAgICAgICAgYmFzZVRleHR1cmUgPSBuZXcgVmlkZW9CYXNlVGV4dHVyZSh2aWRlbywgc2NhbGVNb2RlKTtcclxuICAgICAgICB1dGlscy5CYXNlVGV4dHVyZUNhY2hlWyB2aWRlby5fcGl4aUlkIF0gPSBiYXNlVGV4dHVyZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYmFzZVRleHR1cmU7XHJcbn07XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBCYXNlVGV4dHVyZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gdmlkZW8gZWxlbWVudC5cclxuICogVGhpcyBCYXNlVGV4dHVyZSBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIHRleHR1cmVcclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0gdmlkZW9TcmMge3N0cmluZ3xvYmplY3R8c3RyaW5nW118b2JqZWN0W119IFRoZSBVUkwocykgZm9yIHRoZSB2aWRlby5cclxuICogQHBhcmFtIFt2aWRlb1NyYy5zcmNdIHtzdHJpbmd9IE9uZSBvZiB0aGUgc291cmNlIHVybHMgZm9yIHRoZSB2aWRlb1xyXG4gKiBAcGFyYW0gW3ZpZGVvU3JjLm1pbWVdIHtzdHJpbmd9IFRoZSBtaW1ldHlwZSBvZiB0aGUgdmlkZW8gKGUuZy4gJ3ZpZGVvL21wNCcpLiBJZiBub3Qgc3BlY2lmaWVkXHJcbiAqICB0aGUgdXJsJ3MgZXh0ZW5zaW9uIHdpbGwgYmUgdXNlZCBhcyB0aGUgc2Vjb25kIHBhcnQgb2YgdGhlIG1pbWUgdHlwZS5cclxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcclxuICogQHJldHVybiB7UElYSS5WaWRlb0Jhc2VUZXh0dXJlfVxyXG4gKi9cclxuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsID0gZnVuY3Rpb24gKHZpZGVvU3JjLCBzY2FsZU1vZGUpXHJcbntcclxuICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XHJcblxyXG4gICAgLy8gYXJyYXkgb2Ygb2JqZWN0cyBvciBzdHJpbmdzXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2aWRlb1NyYykpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWRlb1NyYy5sZW5ndGg7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZpZGVvLmFwcGVuZENoaWxkKGNyZWF0ZVNvdXJjZSh2aWRlb1NyY1tpXS5zcmMgfHwgdmlkZW9TcmNbaV0sIHZpZGVvU3JjW2ldLm1pbWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzaW5nbGUgb2JqZWN0IG9yIHN0cmluZ1xyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHZpZGVvLmFwcGVuZENoaWxkKGNyZWF0ZVNvdXJjZSh2aWRlb1NyYy5zcmMgfHwgdmlkZW9TcmMsIHZpZGVvU3JjLm1pbWUpKTtcclxuICAgIH1cclxuXHJcbiAgICB2aWRlby5sb2FkKCk7XHJcbiAgICB2aWRlby5wbGF5KCk7XHJcblxyXG4gICAgcmV0dXJuIFZpZGVvQmFzZVRleHR1cmUuZnJvbVZpZGVvKHZpZGVvLCBzY2FsZU1vZGUpO1xyXG59O1xyXG5cclxuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJscyA9IFZpZGVvQmFzZVRleHR1cmUuZnJvbVVybDtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVNvdXJjZShwYXRoLCB0eXBlKVxyXG57XHJcbiAgICBpZiAoIXR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgdHlwZSA9ICd2aWRlby8nICsgcGF0aC5zdWJzdHIocGF0aC5sYXN0SW5kZXhPZignLicpICsgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNvdXJjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xyXG5cclxuICAgIHNvdXJjZS5zcmMgPSBwYXRoO1xyXG4gICAgc291cmNlLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgIHJldHVybiBzb3VyY2U7XHJcbn1cclxuIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcclxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKSxcclxuICAgIC8vIEludGVybmFsIGV2ZW50IHVzZWQgYnkgY29tcG9zZWQgZW1pdHRlclxyXG4gICAgVElDSyA9ICd0aWNrJztcclxuXHJcbi8qKlxyXG4gKiBBIFRpY2tlciBjbGFzcyB0aGF0IHJ1bnMgYW4gdXBkYXRlIGxvb3AgdGhhdCBvdGhlciBvYmplY3RzIGxpc3RlbiB0by5cclxuICogVGhpcyBjbGFzcyBpcyBjb21wb3NlZCBhcm91bmQgYW4gRXZlbnRFbWl0dGVyIG9iamVjdCB0byBhZGQgbGlzdGVuZXJzXHJcbiAqIG1lYW50IGZvciBleGVjdXRpb24gb24gdGhlIG5leHQgcmVxdWVzdGVkIGFuaW1hdGlvbiBmcmFtZS5cclxuICogQW5pbWF0aW9uIGZyYW1lcyBhcmUgcmVxdWVzdGVkIG9ubHkgd2hlbiBuZWNlc3NhcnksXHJcbiAqIGUuZy4gV2hlbiB0aGUgdGlja2VyIGlzIHN0YXJ0ZWQgYW5kIHRoZSBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSS50aWNrZXJcclxuICovXHJcbmZ1bmN0aW9uIFRpY2tlcigpXHJcbntcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCB0aWNrIG1ldGhvZCBib3VuZCB0byB0aWNrZXIgaW5zdGFuY2UuXHJcbiAgICAgKiBUaGlzIGlzIGJlY2F1c2UgaW4gZWFybHkgMjAxNSwgRnVuY3Rpb24uYmluZFxyXG4gICAgICogaXMgc3RpbGwgNjAlIHNsb3dlciBpbiBoaWdoIHBlcmZvcm1hbmNlIHNjZW5hcmlvcy5cclxuICAgICAqIEFsc28gc2VwYXJhdGluZyBmcmFtZSByZXF1ZXN0cyBmcm9tIHVwZGF0ZSBtZXRob2RcclxuICAgICAqIHNvIGxpc3RlbmVycyBtYXkgYmUgY2FsbGVkIGF0IGFueSB0aW1lIGFuZCB3aXRoXHJcbiAgICAgKiBhbnkgYW5pbWF0aW9uIEFQSSwganVzdCBpbnZva2UgdGlja2VyLnVwZGF0ZSh0aW1lKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl90aWNrID0gZnVuY3Rpb24gX3RpY2sodGltZSkge1xyXG5cclxuICAgICAgICBfdGhpcy5fcmVxdWVzdElkID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKF90aGlzLnN0YXJ0ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBJbnZva2UgbGlzdGVuZXJzIG5vd1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGUodGltZSk7XHJcbiAgICAgICAgICAgIC8vIExpc3RlbmVyIHNpZGUgZWZmZWN0cyBtYXkgaGF2ZSBtb2RpZmllZCB0aWNrZXIgc3RhdGUuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydGVkICYmIF90aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgX3RoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKFRJQ0ssIHRydWUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLl90aWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBlbWl0dGVyIHVzZWQgdG8gZmlyZSAndGljaycgZXZlbnRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBjdXJyZW50IGZyYW1lIHJlcXVlc3QgSURcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCB2YWx1ZSBtYW5hZ2VkIGJ5IG1pbkZQUyBwcm9wZXJ0eSBzZXR0ZXIgYW5kIGdldHRlci5cclxuICAgICAqIFRoaXMgaXMgdGhlIG1heGltdW0gYWxsb3dlZCBtaWxsaXNlY29uZHMgYmV0d2VlbiB1cGRhdGVzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbWF4RWxhcHNlZE1TID0gMTAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBvciBub3QgdGhpcyB0aWNrZXIgc2hvdWxkIGludm9rZSB0aGUgbWV0aG9kXHJcbiAgICAgKiB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI3N0YXJ0fSBhdXRvbWF0aWNhbGx5XHJcbiAgICAgKiB3aGVuIGEgbGlzdGVuZXIgaXMgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXV0b1N0YXJ0ID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsYXIgdGltZSB2YWx1ZSBmcm9tIGxhc3QgZnJhbWUgdG8gdGhpcyBmcmFtZS5cclxuICAgICAqIFRoaXMgdmFsdWUgaXMgY2FwcGVkIGJ5IHNldHRpbmcge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNtaW5GUFN9XHJcbiAgICAgKiBhbmQgaXMgc2NhbGVkIHdpdGgge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNzcGVlZH0uXHJcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhcCBtYXkgYmUgZXhjZWVkZWQgYnkgc2NhbGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGVsdGFUaW1lID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpbWUgZWxhcHNlZCBpbiBtaWxsaXNlY29uZHMgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXHJcbiAgICAgKiBPcHBvc2VkIHRvIHdoYXQgdGhlIHNjYWxhciB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2RlbHRhVGltZX1cclxuICAgICAqIGlzIGJhc2VkLCB0aGlzIHZhbHVlIGlzIG5laXRoZXIgY2FwcGVkIG5vciBzY2FsZWQuXHJcbiAgICAgKiBJZiB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgRE9NSGlnaFJlc1RpbWVTdGFtcCxcclxuICAgICAqIHRoaXMgdmFsdWUgd2lsbCBoYXZlIGEgcHJlY2lzaW9uIG9mIDEgwrVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge0RPTUhpZ2hSZXNUaW1lU3RhbXB8bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMSAvIFRBUkdFVF9GUE1TXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZWxhcHNlZE1TID0gMSAvIENPTlNULlRBUkdFVF9GUE1TOyAvLyBkZWZhdWx0IHRvIHRhcmdldCBmcmFtZSB0aW1lXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGFzdCB0aW1lIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjdXBkYXRlfSB3YXMgaW52b2tlZC5cclxuICAgICAqIFRoaXMgdmFsdWUgaXMgYWxzbyByZXNldCBpbnRlcm5hbGx5IG91dHNpZGUgb2YgaW52b2tpbmdcclxuICAgICAqIHVwZGF0ZSwgYnV0IG9ubHkgd2hlbiBhIG5ldyBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkLlxyXG4gICAgICogSWYgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIERPTUhpZ2hSZXNUaW1lU3RhbXAsXHJcbiAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtET01IaWdoUmVzVGltZVN0YW1wfG51bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG4gICAgdGhpcy5sYXN0VGltZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGYWN0b3Igb2YgY3VycmVudCB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2RlbHRhVGltZX0uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gU2NhbGVzIHRpY2tlci5kZWx0YVRpbWUgdG8gd2hhdCB3b3VsZCBiZVxyXG4gICAgICogLy8gdGhlIGVxdWl2YWxlbnQgb2YgYXBwcm94aW1hdGVseSAxMjAgRlBTXHJcbiAgICAgKiB0aWNrZXIuc3BlZWQgPSAyO1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqL1xyXG4gICAgdGhpcy5zcGVlZCA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkLlxyXG4gICAgICogYHRydWVgIGlmIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjc3RhcnR9IGhhcyBiZWVuIGNhbGxlZC5cclxuICAgICAqIGBmYWxzZWAgaWYge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNzdG9wfSBoYXMgYmVlbiBjYWxsZWQuXHJcbiAgICAgKiBXaGlsZSBgZmFsc2VgLCB0aGlzIHZhbHVlIG1heSBjaGFuZ2UgdG8gYHRydWVgIGluIHRoZVxyXG4gICAgICogZXZlbnQgb2Yge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNhdXRvU3RhcnR9IGJlaW5nIGB0cnVlYFxyXG4gICAgICogYW5kIGEgbGlzdGVuZXIgaXMgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWNrZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmFtZXMgcGVyIHNlY29uZCBhdCB3aGljaCB0aGlzIHRpY2tlciBpcyBydW5uaW5nLlxyXG4gICAgICogVGhlIGRlZmF1bHQgaXMgYXBwcm94aW1hdGVseSA2MCBpbiBtb3N0IG1vZGVybiBicm93c2Vycy5cclxuICAgICAqICoqTm90ZToqKiBUaGlzIGRvZXMgbm90IGZhY3RvciBpbiB0aGUgdmFsdWUgb2ZcclxuICAgICAqIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjc3BlZWR9LCB3aGljaCBpcyBzcGVjaWZpY1xyXG4gICAgICogdG8gc2NhbGluZyB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2RlbHRhVGltZX0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlclxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkudGlja2VyLlRpY2tlciNcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBGUFM6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAxMDAwIC8gdGhpcy5lbGFwc2VkTVM7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hbmFnZXMgdGhlIG1heGltdW0gYW1vdW50IG9mIG1pbGxpc2Vjb25kcyBhbGxvd2VkIHRvXHJcbiAgICAgKiBlbGFwc2UgYmV0d2VlbiBpbnZva2luZyB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI3VwZGF0ZX0uXHJcbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVzZWQgdG8gY2FwIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjZGVsdGFUaW1lfSxcclxuICAgICAqIGJ1dCBkb2VzIG5vdCBlZmZlY3QgdGhlIG1lYXN1cmVkIHZhbHVlIG9mIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjRlBTfS5cclxuICAgICAqIFdoZW4gc2V0dGluZyB0aGlzIHByb3BlcnR5IGl0IGlzIGNsYW1wZWQgdG8gYSB2YWx1ZSBiZXR3ZWVuXHJcbiAgICAgKiBgMGAgYW5kIGBQSVhJLlRBUkdFVF9GUE1TICogMTAwMGAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlclxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkudGlja2VyLlRpY2tlciNcclxuICAgICAqIEBkZWZhdWx0IDEwXHJcbiAgICAgKi9cclxuICAgIG1pbkZQUzoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLl9tYXhFbGFwc2VkTVM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGZwcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIENsYW1wOiAwIHRvIFRBUkdFVF9GUE1TXHJcbiAgICAgICAgICAgIHZhciBtaW5GUE1TID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZnBzKSAvIDEwMDAsIENPTlNULlRBUkdFVF9GUE1TKTtcclxuICAgICAgICAgICAgdGhpcy5fbWF4RWxhcHNlZE1TID0gMSAvIG1pbkZQTVM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBDb25kaXRpb25hbGx5IHJlcXVlc3RzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZS5cclxuICogSWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHkgYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWxcclxuICogZW1pdHRlciBoYXMgbGlzdGVuZXJzLCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5UaWNrZXIucHJvdG90eXBlLl9yZXF1ZXN0SWZOZWVkZWQgPSBmdW5jdGlvbiBfcmVxdWVzdElmTmVlZGVkKClcclxue1xyXG4gICAgaWYgKHRoaXMuX3JlcXVlc3RJZCA9PT0gbnVsbCAmJiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyhUSUNLLCB0cnVlKSlcclxuICAgIHtcclxuICAgICAgICAvLyBlbnN1cmUgY2FsbGJhY2tzIGdldCBjb3JyZWN0IGRlbHRhXHJcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25kaXRpb25hbGx5IGNhbmNlbHMgYSBwZW5kaW5nIGFuaW1hdGlvbiBmcmFtZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcblRpY2tlci5wcm90b3R5cGUuX2NhbmNlbElmTmVlZGVkID0gZnVuY3Rpb24gX2NhbmNlbElmTmVlZGVkKClcclxue1xyXG4gICAgaWYgKHRoaXMuX3JlcXVlc3RJZCAhPT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZXF1ZXN0SWQpO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXHJcbiAqIElmIHRoZSB0aWNrZXIgaGFzIGJlZW4gc3RhcnRlZCBpdCBjaGVja3MgaWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHlcclxuICogYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWwgZW1pdHRlciBoYXMgbGlzdGVuZXJzLiBJZiB0aGVzZVxyXG4gKiBjb25kaXRpb25zIGFyZSBtZXQsIGEgbmV3IGZyYW1lIGlzIHJlcXVlc3RlZC4gSWYgdGhlIHRpY2tlciBoYXMgbm90XHJcbiAqIGJlZW4gc3RhcnRlZCwgYnV0IGF1dG9TdGFydCBpcyBgdHJ1ZWAsIHRoZW4gdGhlIHRpY2tlciBzdGFydHMgbm93LFxyXG4gKiBhbmQgY29udGludWVzIHdpdGggdGhlIHByZXZpb3VzIGNvbmRpdGlvbnMgdG8gcmVxdWVzdCBhIG5ldyBmcmFtZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcblRpY2tlci5wcm90b3R5cGUuX3N0YXJ0SWZQb3NzaWJsZSA9IGZ1bmN0aW9uIF9zdGFydElmUG9zc2libGUoKVxyXG57XHJcbiAgICBpZiAodGhpcy5zdGFydGVkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZk5lZWRlZCgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy5hdXRvU3RhcnQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGFydCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxzIHtAbGluayBtb2R1bGU6ZXZlbnRlbWl0dGVyMy5FdmVudEVtaXR0ZXIjb259IGludGVybmFsbHkgZm9yIHRoZVxyXG4gKiBpbnRlcm5hbCAndGljaycgZXZlbnQuIEl0IGNoZWNrcyBpZiB0aGUgZW1pdHRlciBoYXMgbGlzdGVuZXJzLFxyXG4gKiBhbmQgaWYgc28gaXQgcmVxdWVzdHMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGF0IHRoaXMgcG9pbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbiB7RnVuY3Rpb259IFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBhZGRlZCBmb3IgdXBkYXRlc1xyXG4gKiBAcGFyYW0gW2NvbnRleHRdIHtGdW5jdGlvbn0gVGhlIGxpc3RlbmVyIGNvbnRleHRcclxuICogQHJldHVybnMge1BJWEkudGlja2VyLlRpY2tlcn0gdGhpc1xyXG4gKi9cclxuVGlja2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoZm4sIGNvbnRleHQpXHJcbntcclxuICAgIHRoaXMuX2VtaXR0ZXIub24oVElDSywgZm4sIGNvbnRleHQpO1xyXG5cclxuICAgIHRoaXMuX3N0YXJ0SWZQb3NzaWJsZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxzIHtAbGluayBtb2R1bGU6ZXZlbnRlbWl0dGVyMy5FdmVudEVtaXR0ZXIjb25jZX0gaW50ZXJuYWxseSBmb3IgdGhlXHJcbiAqIGludGVybmFsICd0aWNrJyBldmVudC4gSXQgY2hlY2tzIGlmIHRoZSBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMsXHJcbiAqIGFuZCBpZiBzbyBpdCByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUgYXQgdGhpcyBwb2ludC5cclxuICpcclxuICogQHBhcmFtIGZuIHtGdW5jdGlvbn0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXHJcbiAqIEBwYXJhbSBbY29udGV4dF0ge0Z1bmN0aW9ufSBUaGUgbGlzdGVuZXIgY29udGV4dFxyXG4gKiBAcmV0dXJucyB7UElYSS50aWNrZXIuVGlja2VyfSB0aGlzXHJcbiAqL1xyXG5UaWNrZXIucHJvdG90eXBlLmFkZE9uY2UgPSBmdW5jdGlvbiBhZGRPbmNlKGZuLCBjb250ZXh0KVxyXG57XHJcbiAgICB0aGlzLl9lbWl0dGVyLm9uY2UoVElDSywgZm4sIGNvbnRleHQpO1xyXG5cclxuICAgIHRoaXMuX3N0YXJ0SWZQb3NzaWJsZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxzIHtAbGluayBtb2R1bGU6ZXZlbnRlbWl0dGVyMy5FdmVudEVtaXR0ZXIjb2ZmfSBpbnRlcm5hbGx5IGZvciAndGljaycgZXZlbnQuXHJcbiAqIEl0IGNoZWNrcyBpZiB0aGUgZW1pdHRlciBoYXMgbGlzdGVuZXJzIGZvciAndGljaycgZXZlbnQuXHJcbiAqIElmIGl0IGRvZXMsIHRoZW4gaXQgY2FuY2VscyB0aGUgYW5pbWF0aW9uIGZyYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0gW2ZuXSB7RnVuY3Rpb259IFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSByZW1vdmVkXHJcbiAqIEBwYXJhbSBbY29udGV4dF0ge0Z1bmN0aW9ufSBUaGUgbGlzdGVuZXIgY29udGV4dCB0byBiZSByZW1vdmVkXHJcbiAqIEByZXR1cm5zIHtQSVhJLnRpY2tlci5UaWNrZXJ9IHRoaXNcclxuICovXHJcblRpY2tlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGZuLCBjb250ZXh0KVxyXG57XHJcbiAgICB0aGlzLl9lbWl0dGVyLm9mZihUSUNLLCBmbiwgY29udGV4dCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyhUSUNLLCB0cnVlKSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN0YXJ0cyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyBsaXN0ZW5lcnNcclxuICogYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZCBhdCB0aGlzIHBvaW50LlxyXG4gKi9cclxuVGlja2VyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KClcclxue1xyXG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdG9wcyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyByZXF1ZXN0ZWRcclxuICogYW4gYW5pbWF0aW9uIGZyYW1lIGl0IGlzIGNhbmNlbGVkIGF0IHRoaXMgcG9pbnQuXHJcbiAqL1xyXG5UaWNrZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKClcclxue1xyXG4gICAgaWYgKHRoaXMuc3RhcnRlZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyaWdnZXJzIGFuIHVwZGF0ZS4gQW4gdXBkYXRlIGVudGFpbHMgc2V0dGluZyB0aGVcclxuICogY3VycmVudCB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2VsYXBzZWRNU30sXHJcbiAqIHRoZSBjdXJyZW50IHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjZGVsdGFUaW1lfSxcclxuICogaW52b2tpbmcgYWxsIGxpc3RlbmVycyB3aXRoIGN1cnJlbnQgZGVsdGFUaW1lLFxyXG4gKiBhbmQgdGhlbiBmaW5hbGx5IHNldHRpbmcge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNsYXN0VGltZX1cclxuICogd2l0aCB0aGUgdmFsdWUgb2YgY3VycmVudFRpbWUgdGhhdCB3YXMgcHJvdmlkZWQuXHJcbiAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgYW5pbWF0aW9uXHJcbiAqIGZyYW1lIGNhbGxiYWNrcyBpZiB0aGUgdGlja2VyIGluc3RhbmNlIGhhcyBiZWVuIHN0YXJ0ZWRcclxuICogYW5kIGxpc3RlbmVycyBhcmUgYWRkZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBbY3VycmVudFRpbWU9cGVyZm9ybWFuY2Uubm93KCldIHtET01IaWdoUmVzVGltZVN0YW1wfG51bWJlcn0gdGhlIGN1cnJlbnQgdGltZSBvZiBleGVjdXRpb25cclxuICovXHJcblRpY2tlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGN1cnJlbnRUaW1lKVxyXG57XHJcbiAgICB2YXIgZWxhcHNlZE1TO1xyXG5cclxuICAgIC8vIEFsbG93IGNhbGxpbmcgdXBkYXRlIGRpcmVjdGx5IHdpdGggZGVmYXVsdCBjdXJyZW50VGltZS5cclxuICAgIGN1cnJlbnRUaW1lID0gY3VycmVudFRpbWUgfHwgcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAvLyBTYXZlIHVuY2FwcGVkIGVsYXBzZWRNUyBmb3IgbWVhc3VyZW1lbnRcclxuICAgIGVsYXBzZWRNUyA9IHRoaXMuZWxhcHNlZE1TID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lO1xyXG5cclxuICAgIC8vIGNhcCB0aGUgbWlsbGlzZWNvbmRzIGVsYXBzZWQgdXNlZCBmb3IgZGVsdGFUaW1lXHJcbiAgICBpZiAoZWxhcHNlZE1TID4gdGhpcy5fbWF4RWxhcHNlZE1TKVxyXG4gICAge1xyXG4gICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuX21heEVsYXBzZWRNUztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRlbHRhVGltZSA9IGVsYXBzZWRNUyAqIENPTlNULlRBUkdFVF9GUE1TICogdGhpcy5zcGVlZDtcclxuXHJcbiAgICAvLyBJbnZva2UgbGlzdGVuZXJzIGFkZGVkIHRvIGludGVybmFsIGVtaXR0ZXJcclxuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChUSUNLLCB0aGlzLmRlbHRhVGltZSk7XHJcblxyXG4gICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaWNrZXI7XHJcbiIsInZhciBUaWNrZXIgPSByZXF1aXJlKCcuL1RpY2tlcicpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBzaGFyZWQgdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIFBJWEkuZXh0cmFzLk1vdmllQ2xpcH0uXHJcbiAqIGFuZCBieSB7QGxpbmsgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXJ9LlxyXG4gKiBUaGUgcHJvcGVydHkge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNhdXRvU3RhcnR9IGlzIHNldCB0byBgdHJ1ZWBcclxuICogZm9yIHRoaXMgaW5zdGFuY2UuIFBsZWFzZSBmb2xsb3cgdGhlIGV4YW1wbGVzIGZvciB1c2FnZSwgaW5jbHVkaW5nXHJcbiAqIGhvdyB0byBvcHQtb3V0IG9mIGF1dG8tc3RhcnRpbmcgdGhlIHNoYXJlZCB0aWNrZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciB0aWNrZXIgPSBQSVhJLnRpY2tlci5zaGFyZWQ7XHJcbiAqIC8vIFNldCB0aGlzIHRvIHByZXZlbnQgc3RhcnRpbmcgdGhpcyB0aWNrZXIgd2hlbiBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxyXG4gKiAvLyBCeSBkZWZhdWx0IHRoaXMgaXMgdHJ1ZSBvbmx5IGZvciB0aGUgUElYSS50aWNrZXIuc2hhcmVkIGluc3RhbmNlLlxyXG4gKiB0aWNrZXIuYXV0b1N0YXJ0ID0gZmFsc2U7XHJcbiAqIC8vIEZZSSwgY2FsbCB0aGlzIHRvIGVuc3VyZSB0aGUgdGlja2VyIGlzIHN0b3BwZWQuIEl0IHNob3VsZCBiZSBzdG9wcGVkXHJcbiAqIC8vIGlmIHlvdSBoYXZlIG5vdCBhdHRlbXB0ZWQgdG8gcmVuZGVyIGFueXRoaW5nIHlldC5cclxuICogdGlja2VyLnN0b3AoKTtcclxuICogLy8gQ2FsbCB0aGlzIHdoZW4geW91IGFyZSByZWFkeSBmb3IgYSBydW5uaW5nIHNoYXJlZCB0aWNrZXIuXHJcbiAqIHRpY2tlci5zdGFydCgpO1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBZb3UgbWF5IHVzZSB0aGUgc2hhcmVkIHRpY2tlciB0byByZW5kZXIuLi5cclxuICogdmFyIHJlbmRlcmVyID0gUElYSS5hdXRvRGV0ZWN0UmVuZGVyZXIoODAwLCA2MDApO1xyXG4gKiB2YXIgc3RhZ2UgPSBuZXcgUElYSS5Db250YWluZXIoKTtcclxuICogdmFyIGludGVyYWN0aW9uTWFuYWdlciA9IFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyKHJlbmRlcmVyKTtcclxuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlci52aWV3KTtcclxuICogdGlja2VyLmFkZChmdW5jdGlvbiAodGltZSkge1xyXG4gKiAgICAgcmVuZGVyZXIucmVuZGVyKHN0YWdlKTtcclxuICogfSk7XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIE9yIHlvdSBjYW4ganVzdCB1cGRhdGUgaXQgbWFudWFsbHkuXHJcbiAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcclxuICogdGlja2VyLnN0b3AoKTtcclxuICogZnVuY3Rpb24gYW5pbWF0ZSh0aW1lKSB7XHJcbiAqICAgICB0aWNrZXIudXBkYXRlKHRpbWUpO1xyXG4gKiAgICAgcmVuZGVyZXIucmVuZGVyKHN0YWdlKTtcclxuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICogfVxyXG4gKiBhbmltYXRlKHBlcmZvcm1hbmNlLm5vdygpKTtcclxuICpcclxuICogQHR5cGUge1BJWEkudGlja2VyLlRpY2tlcn1cclxuICogQG1lbWJlcm9mIFBJWEkudGlja2VyXHJcbiAqL1xyXG52YXIgc2hhcmVkID0gbmV3IFRpY2tlcigpO1xyXG5zaGFyZWQuYXV0b1N0YXJ0ID0gdHJ1ZTtcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIFBJWEkudGlja2VyXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHNoYXJlZDogc2hhcmVkLFxyXG4gICAgVGlja2VyOiBUaWNrZXJcclxufTtcclxuIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIFBJWEkudXRpbHNcclxuICovXHJcbnZhciB1dGlscyA9IG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgX3VpZDogMCxcclxuICAgIF9zYWlkSGVsbG86IGZhbHNlLFxyXG5cclxuICAgIEV2ZW50RW1pdHRlcjogICByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyksXHJcbiAgICBwbHVnaW5UYXJnZXQ6ICAgcmVxdWlyZSgnLi9wbHVnaW5UYXJnZXQnKSxcclxuICAgIGFzeW5jOiAgICAgICAgICByZXF1aXJlKCdhc3luYycpLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmV4dCB1bmlxdWUgaWRlbnRpZmllclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5leHQgdW5pcXVlIGlkZW50aWZpZXIgdG8gdXNlLlxyXG4gICAgICovXHJcbiAgICB1aWQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICsrdXRpbHMuX3VpZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIGhleCBjb2xvciBudW1iZXIgdG8gYW4gW1IsIEcsIEJdIGFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGhleCB7bnVtYmVyfVxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyW119IFtvdXQ9W11dXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBbUiwgRywgQl0gb2YgdGhlIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBoZXgycmdiOiBmdW5jdGlvbiAoaGV4LCBvdXQpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0ID0gb3V0IHx8IFtdO1xyXG5cclxuICAgICAgICBvdXRbMF0gPSAoaGV4ID4+IDE2ICYgMHhGRikgLyAyNTU7XHJcbiAgICAgICAgb3V0WzFdID0gKGhleCA+PiA4ICYgMHhGRikgLyAyNTU7XHJcbiAgICAgICAgb3V0WzJdID0gKGhleCAmIDB4RkYpIC8gMjU1O1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgaGV4IGNvbG9yIG51bWJlciB0byBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaGV4IHtudW1iZXJ9XHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIGhleDJzdHJpbmc6IGZ1bmN0aW9uIChoZXgpXHJcbiAgICB7XHJcbiAgICAgICAgaGV4ID0gaGV4LnRvU3RyaW5nKDE2KTtcclxuICAgICAgICBoZXggPSAnMDAwMDAwJy5zdWJzdHIoMCwgNiAtIGhleC5sZW5ndGgpICsgaGV4O1xyXG5cclxuICAgICAgICByZXR1cm4gJyMnICsgaGV4O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgY29sb3IgYXMgYW4gW1IsIEcsIEJdIGFycmF5IHRvIGEgaGV4IG51bWJlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZ2Ige251bWJlcltdfVxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29sb3IgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHJnYjJoZXg6IGZ1bmN0aW9uIChyZ2IpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICgocmdiWzBdKjI1NSA8PCAxNikgKyAocmdiWzFdKjI1NSA8PCA4KSArIHJnYlsyXSoyNTUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBDYW52YXMgQmxlbmRNb2RlcyBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGJyb3dzZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZXkgYXJlIHN1cHBvcnRlZFxyXG4gICAgICovXHJcbiAgICBjYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBuZ0hlYWQgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBUUFBQUFCQVFNQUFBREQ4cDJPQUFBQUExQk1WRVgvJztcclxuICAgICAgICB2YXIgcG5nRW5kID0gJ0FBQUFDa2xFUVZRSTEyTmdBQUFBQWdBQjRpRzhNd0FBQUFCSlJVNUVya0pnZ2c9PSc7XHJcblxyXG4gICAgICAgIHZhciBtYWdlbnRhID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgbWFnZW50YS5zcmMgPSBwbmdIZWFkICsgJ0FQODA0T2E2JyArIHBuZ0VuZDtcclxuXHJcbiAgICAgICAgdmFyIHllbGxvdyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIHllbGxvdy5zcmMgPSBwbmdIZWFkICsgJy93Q0t4dlJGJyArIHBuZ0VuZDtcclxuXHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDY7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDE7XHJcblxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbXVsdGlwbHknO1xyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG1hZ2VudGEsIDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHllbGxvdywgMiwgMCk7XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMiwwLDEsMSkuZGF0YTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChkYXRhWzBdID09PSAyNTUgJiYgZGF0YVsxXSA9PT0gMCAmJiBkYXRhWzJdID09PSAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIG51bWJlciwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjbG9zZXN0IG51bWJlciB0aGF0IGlzIGEgcG93ZXIgb2YgdHdvXHJcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGlzIHRha2VuIGZyb20gU3RhcmxpbmcgRnJhbWV3b3JrIGFzIGl0cyBwcmV0dHkgbmVhdCA7KVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBudW1iZXIge251bWJlcn1cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNsb3Nlc3QgbnVtYmVyIHRoYXQgaXMgYSBwb3dlciBvZiB0d29cclxuICAgICAqL1xyXG4gICAgZ2V0TmV4dFBvd2VyT2ZUd286IGZ1bmN0aW9uIChudW1iZXIpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gc2VlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Bvd2VyX29mX3R3byNGYXN0X2FsZ29yaXRobV90b19jaGVja19pZl9hX3Bvc2l0aXZlX251bWJlcl9pc19hX3Bvd2VyX29mX3R3b1xyXG4gICAgICAgIGlmIChudW1iZXIgPiAwICYmIChudW1iZXIgJiAobnVtYmVyIC0gMSkpID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IDE7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0IDwgbnVtYmVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPDw9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNoZWNrcyBpZiB0aGUgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodCBtYWtlIGEgcG93ZXIgb2YgdHdvIHJlY3RhbmdsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfVxyXG4gICAgICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfVxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgaXNQb3dlck9mVHdvOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHdpZHRoID4gMCAmJiAod2lkdGggJiAod2lkdGggLSAxKSkgPT09IDAgJiYgaGVpZ2h0ID4gMCAmJiAoaGVpZ2h0ICYgKGhlaWdodCAtIDEpKSA9PT0gMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0IHRoZSByZXNvbHV0aW9uIG9mIGFuIGFzc2V0IGJ5IGxvb2tpbmcgZm9yIHRoZSBwcmVmaXhcclxuICAgICAqIHVzZWQgYnkgc3ByaXRlc2hlZXRzIGFuZCBpbWFnZSB1cmxzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVybCB7c3RyaW5nfSB0aGUgaW1hZ2UgcGF0aFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXRSZXNvbHV0aW9uT2ZVcmw6IGZ1bmN0aW9uICh1cmwpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBDT05TVC5SRVRJTkFfUFJFRklYLmV4ZWModXJsKTtcclxuXHJcbiAgICAgICAgaWYgKHJlc29sdXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHJlc29sdXRpb25bMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBvdXQgdGhlIHZlcnNpb24gYW5kIHJlbmRlcmVyIGluZm9ybWF0aW9uIGZvciB0aGlzIHJ1bm5pbmcgaW5zdGFuY2Ugb2YgUElYSS5cclxuICAgICAqIElmIHlvdSBkb24ndCB3YW50IHRvIHNlZSB0aGlzIG1lc3NhZ2UgeW91IGNhbiBzZXQgYFBJWEkudXRpbHMuX3NhaWRIZWxsbyA9IHRydWU7YFxyXG4gICAgICogc28gdGhlIGxpYnJhcnkgdGhpbmtzIGl0IGFscmVhZHkgc2FpZCBpdC4gS2VlcCBpbiBtaW5kIHRoYXQgZG9pbmcgdGhhdCB3aWxsIGZvcmV2ZXJcclxuICAgICAqIG1ha2VzIHlvdSBhIGplcmsgZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBzdHJpbmcgcmVuZGVyZXIgdHlwZSB0byBsb2cuXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgc2F5SGVsbG86IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh1dGlscy5fc2FpZEhlbGxvKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXHJcbiAgICAgICAgICAgICAgICAnXFxuICVjICVjICVjIFBpeGkuanMgJyArIENPTlNULlZFUlNJT04gKyAnIC0g4pywICcgKyB0eXBlICsgJyDinLAgICVjICcgKyAnICVjICcgKyAnIGh0dHA6Ly93d3cucGl4aWpzLmNvbS8gICVjICVjIOKZpSVj4pmlJWPimaUgXFxuXFxuJyxcclxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kOiAjZmY2NmE1OyBwYWRkaW5nOjVweCAwOycsXHJcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZDogI2ZmNjZhNTsgcGFkZGluZzo1cHggMDsnLFxyXG4gICAgICAgICAgICAgICAgJ2NvbG9yOiAjZmY2NmE1OyBiYWNrZ3JvdW5kOiAjMDMwMzA3OyBwYWRkaW5nOjVweCAwOycsXHJcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZDogI2ZmNjZhNTsgcGFkZGluZzo1cHggMDsnLFxyXG4gICAgICAgICAgICAgICAgJ2JhY2tncm91bmQ6ICNmZmMzZGM7IHBhZGRpbmc6NXB4IDA7JyxcclxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kOiAjZmY2NmE1OyBwYWRkaW5nOjVweCAwOycsXHJcbiAgICAgICAgICAgICAgICAnY29sb3I6ICNmZjI0MjQ7IGJhY2tncm91bmQ6ICNmZmY7IHBhZGRpbmc6NXB4IDA7JyxcclxuICAgICAgICAgICAgICAgICdjb2xvcjogI2ZmMjQyNDsgYmFja2dyb3VuZDogI2ZmZjsgcGFkZGluZzo1cHggMDsnLFxyXG4gICAgICAgICAgICAgICAgJ2NvbG9yOiAjZmYyNDI0OyBiYWNrZ3JvdW5kOiAjZmZmOyBwYWRkaW5nOjVweCAwOydcclxuICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTsgLy9qc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2luZG93LmNvbnNvbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1BpeGkuanMgJyArIENPTlNULlZFUlNJT04gKyAnIC0gJyArIHR5cGUgKyAnIC0gaHR0cDovL3d3dy5waXhpanMuY29tLycpOyAvL2pzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdXRpbHMuX3NhaWRIZWxsbyA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZvciBjaGVja2luZyBmb3Igd2ViZ2wgc3VwcG9ydFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGlzV2ViR0xTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNvbnRleHRPcHRpb25zID0geyBzdGVuY2lsOiB0cnVlIH07XHJcbiAgICAgICAgdHJ5XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxyXG4gICAgICAgICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBjb250ZXh0T3B0aW9ucykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGNvbnRleHRPcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAhIShnbCAmJiBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpLnN0ZW5jaWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBzaWduIG9mIG51bWJlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuIHtudW1iZXJ9XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIG4gaXMgMCwgLTEgaWYgbiBpcyBuZWdhdGl2ZSwgMSBpZiBuIGkgcG9zaXRpdmVcclxuICAgICAqL1xyXG4gICAgc2lnbjogZnVuY3Rpb24gKG4pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG4gPyAobiA8IDAgPyAtMSA6IDEpIDogMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZW1vdmVJdGVtc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFyciBUaGUgdGFyZ2V0IGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJZHggVGhlIGluZGV4IHRvIGJlZ2luIHJlbW92aW5nIGZyb20gKGluY2x1c2l2ZSlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZW1vdmVDb3VudCBIb3cgbWFueSBpdGVtcyB0byByZW1vdmVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlSXRlbXM6IGZ1bmN0aW9uIChhcnIsIHN0YXJ0SWR4LCByZW1vdmVDb3VudClcclxuICAgIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKHN0YXJ0SWR4ID49IGxlbmd0aCB8fCByZW1vdmVDb3VudCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbW92ZUNvdW50ID0gKHN0YXJ0SWR4K3JlbW92ZUNvdW50ID4gbGVuZ3RoID8gbGVuZ3RoLXN0YXJ0SWR4IDogcmVtb3ZlQ291bnQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydElkeCwgbGVuID0gbGVuZ3RoLXJlbW92ZUNvdW50OyBpIDwgbGVuOyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbaSArIHJlbW92ZUNvdW50XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFyci5sZW5ndGggPSBsZW47XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHRvZG8gRGVzY3JpYmUgcHJvcGVydHkgdXNhZ2VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIFRleHR1cmVDYWNoZToge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdG9kbyBEZXNjcmliZSBwcm9wZXJ0eSB1c2FnZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQmFzZVRleHR1cmVDYWNoZToge31cclxufTtcclxuIiwiLyoqXHJcbiAqIE1peGlucyBmdW5jdGlvbmFsaXR5IHRvIG1ha2UgYW4gb2JqZWN0IGhhdmUgXCJwbHVnaW5zXCIuXHJcbiAqXHJcbiAqIEBtaXhpblxyXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xyXG4gKiBAcGFyYW0gb2JqIHtvYmplY3R9IFRoZSBvYmplY3QgdG8gbWl4IGludG8uXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICAgZnVuY3Rpb24gTXlPYmplY3QoKSB7fVxyXG4gKlxyXG4gKiAgICAgIHBsdWdpblRhcmdldC5taXhpbihNeU9iamVjdCk7XHJcbiAqL1xyXG5mdW5jdGlvbiBwbHVnaW5UYXJnZXQob2JqKVxyXG57XHJcbiAgICBvYmouX19wbHVnaW5zID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcGx1Z2luIHRvIGFuIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwbHVnaW5OYW1lIHtzdHJpbmd9IFRoZSBldmVudHMgdGhhdCBzaG91bGQgYmUgbGlzdGVkLlxyXG4gICAgICogQHBhcmFtIGN0b3Ige0Z1bmN0aW9ufSBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBwbHVnaW4uXHJcbiAgICAgKi9cclxuICAgIG9iai5yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIChwbHVnaW5OYW1lLCBjdG9yKVxyXG4gICAge1xyXG4gICAgICAgIG9iai5fX3BsdWdpbnNbcGx1Z2luTmFtZV0gPSBjdG9yO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlcyBhbGwgdGhlIHBsdWdpbnMgb2YgdGhpcyBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIG9iai5wcm90b3R5cGUuaW5pdFBsdWdpbnMgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucyB8fCB7fTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgbyBpbiBvYmouX19wbHVnaW5zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW29dID0gbmV3IChvYmouX19wbHVnaW5zW29dKSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIHBsdWdpbnMgb2YgdGhpcyBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIG9iai5wcm90b3R5cGUuZGVzdHJveVBsdWdpbnMgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIG8gaW4gdGhpcy5wbHVnaW5zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW29dLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW29dID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IG51bGw7XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIE1peGVzIGluIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBwbHVnaW5UYXJnZXQgaW50byBhbm90aGVyIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmplY3Qge29iamVjdH0gVGhlIG9iaiB0byBtaXggaW50b1xyXG4gICAgICovXHJcbiAgICBtaXhpbjogZnVuY3Rpb24gbWl4aW4ob2JqKVxyXG4gICAge1xyXG4gICAgICAgIHBsdWdpblRhcmdldChvYmopO1xyXG4gICAgfVxyXG59O1xyXG4iLCIvKmdsb2JhbCBjb25zb2xlICovXHJcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9jb3JlJyksXHJcbiAgICBtZXNoID0gcmVxdWlyZSgnLi9tZXNoJyksXHJcbiAgICBleHRyYXMgPSByZXF1aXJlKCcuL2V4dHJhcycpLFxyXG4gICAgZmlsdGVycyA9IHJlcXVpcmUoJy4vZmlsdGVycycpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBTcHJpdGVCYXRjaFxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAc2VlIFBJWEkuUGFydGljbGVDb250YWluZXJcclxuICogQHRocm93cyB7UmVmZXJlbmNlRXJyb3J9IFNwcml0ZUJhdGNoIGRvZXMgbm90IGV4aXN0IGFueSBtb3JlLCBwbGVhc2UgdXNlIHRoZSBuZXcgUGFydGljbGVDb250YWluZXIgaW5zdGVhZC5cclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxyXG4gKi9cclxuY29yZS5TcHJpdGVCYXRjaCA9IGZ1bmN0aW9uKClcclxue1xyXG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdTcHJpdGVCYXRjaCBkb2VzIG5vdCBleGlzdCBhbnkgbW9yZSwgcGxlYXNlIHVzZSB0aGUgbmV3IFBhcnRpY2xlQ29udGFpbmVyIGluc3RlYWQuJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIEFzc2V0TG9hZGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqIEBzZWUgUElYSS5sb2FkZXJzLkxvYWRlclxyXG4gKiBAdGhyb3dzIHtSZWZlcmVuY2VFcnJvcn0gVGhlIGxvYWRlciBzeXN0ZW0gd2FzIG92ZXJoYXVsZWQgaW4gcGl4aSB2MywgcGxlYXNlIHNlZSB0aGUgbmV3IFBJWEkubG9hZGVycy5Mb2FkZXIgY2xhc3MuXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcclxuICovXHJcbmNvcmUuQXNzZXRMb2FkZXIgPSBmdW5jdGlvbigpXHJcbntcclxuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignVGhlIGxvYWRlciBzeXN0ZW0gd2FzIG92ZXJoYXVsZWQgaW4gcGl4aSB2MywgcGxlYXNlIHNlZSB0aGUgbmV3IFBJWEkubG9hZGVycy5Mb2FkZXIgY2xhc3MuJyk7XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb3JlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBTdGFnZVxyXG4gICAgICogQG1lbWJlcm9mIFBJWElcclxuICAgICAqIEBzZWUgUElYSS5Db250YWluZXJcclxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcclxuICAgICAqL1xyXG4gICAgU3RhZ2U6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignWW91IGRvIG5vdCBuZWVkIHRvIHVzZSBhIFBJWEkgU3RhZ2UgYW55IG1vcmUsIHlvdSBjYW4gc2ltcGx5IHJlbmRlciBhbnkgY29udGFpbmVyLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZS5Db250YWluZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBuYW1lIERpc3BsYXlPYmplY3RDb250YWluZXJcclxuICAgICAqIEBtZW1iZXJvZiBQSVhJXHJcbiAgICAgKiBAc2VlIFBJWEkuQ29udGFpbmVyXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXHJcbiAgICAgKi9cclxuICAgIERpc3BsYXlPYmplY3RDb250YWluZXI6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzcGxheU9iamVjdENvbnRhaW5lciBoYXMgYmVlbiBzaG9ydGVuZWQgdG8gQ29udGFpbmVyLCBwbGVhc2UgdXNlIENvbnRhaW5lciBmcm9tIG5vdyBvbi4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvcmUuQ29udGFpbmVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBTdHJpcFxyXG4gICAgICogQG1lbWJlcm9mIFBJWElcclxuICAgICAqIEBzZWUgUElYSS5tZXNoLk1lc2hcclxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcclxuICAgICAqL1xyXG4gICAgU3RyaXA6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIFN0cmlwIGNsYXNzIGhhcyBiZWVuIHJlbmFtZWQgdG8gTWVzaCBhbmQgbW92ZWQgdG8gbWVzaC5NZXNoLCBwbGVhc2UgdXNlIG1lc2guTWVzaCBmcm9tIG5vdyBvbi4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc2guTWVzaDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgUm9wZVxyXG4gICAgICogQG1lbWJlcm9mIFBJWElcclxuICAgICAqIEBzZWUgUElYSS5tZXNoLlJvcGVcclxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcclxuICAgICAqL1xyXG4gICAgUm9wZToge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgUm9wZSBjbGFzcyBoYXMgYmVlbiBtb3ZlZCB0byBtZXNoLlJvcGUsIHBsZWFzZSB1c2UgbWVzaC5Sb3BlIGZyb20gbm93IG9uLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWVzaC5Sb3BlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBNb3ZpZUNsaXBcclxuICAgICAqIEBtZW1iZXJvZiBQSVhJXHJcbiAgICAgKiBAc2VlIFBJWEkuZXh0cmFzLk1vdmllQ2xpcFxyXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxyXG4gICAgICovXHJcbiAgICBNb3ZpZUNsaXA6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIE1vdmllQ2xpcCBjbGFzcyBoYXMgYmVlbiBtb3ZlZCB0byBleHRyYXMuTW92aWVDbGlwLCBwbGVhc2UgdXNlIGV4dHJhcy5Nb3ZpZUNsaXAgZnJvbSBub3cgb24uJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRyYXMuTW92aWVDbGlwO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBUaWxpbmdTcHJpdGVcclxuICAgICAqIEBtZW1iZXJvZiBQSVhJXHJcbiAgICAgKiBAc2VlIFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZVxyXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxyXG4gICAgICovXHJcbiAgICBUaWxpbmdTcHJpdGU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIFRpbGluZ1Nwcml0ZSBjbGFzcyBoYXMgYmVlbiBtb3ZlZCB0byBleHRyYXMuVGlsaW5nU3ByaXRlLCBwbGVhc2UgdXNlIGV4dHJhcy5UaWxpbmdTcHJpdGUgZnJvbSBub3cgb24uJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRyYXMuVGlsaW5nU3ByaXRlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBCaXRtYXBUZXh0XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSVxyXG4gICAgICogQHNlZSBQSVhJLmV4dHJhcy5CaXRtYXBUZXh0XHJcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXHJcbiAgICAgKi9cclxuICAgIEJpdG1hcFRleHQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIEJpdG1hcFRleHQgY2xhc3MgaGFzIGJlZW4gbW92ZWQgdG8gZXh0cmFzLkJpdG1hcFRleHQsIHBsZWFzZSB1c2UgZXh0cmFzLkJpdG1hcFRleHQgZnJvbSBub3cgb24uJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRyYXMuQml0bWFwVGV4dDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgYmxlbmRNb2Rlc1xyXG4gICAgICogQG1lbWJlcm9mIFBJWElcclxuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xyXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxyXG4gICAgICovXHJcbiAgICBibGVuZE1vZGVzOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBibGVuZE1vZGVzIGhhcyBiZWVuIG1vdmVkIHRvIEJMRU5EX01PREVTLCBwbGVhc2UgdXNlIEJMRU5EX01PREVTIGZyb20gbm93IG9uLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZS5CTEVORF9NT0RFUztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgc2NhbGVNb2Rlc1xyXG4gICAgICogQG1lbWJlcm9mIFBJWElcclxuICAgICAqIEBzZWUgUElYSS5TQ0FMRV9NT0RFU1xyXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxyXG4gICAgICovXHJcbiAgICBzY2FsZU1vZGVzOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBzY2FsZU1vZGVzIGhhcyBiZWVuIG1vdmVkIHRvIFNDQUxFX01PREVTLCBwbGVhc2UgdXNlIFNDQUxFX01PREVTIGZyb20gbm93IG9uLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZS5TQ0FMRV9NT0RFUztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgQmFzZVRleHR1cmVDYWNoZVxyXG4gICAgICogQG1lbWJlcm9mIFBJWElcclxuICAgICAqIEBzZWUgUElYSS51dGlscy5CYXNlVGV4dHVyZUNhY2hlXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXHJcbiAgICAgKi9cclxuICAgIEJhc2VUZXh0dXJlQ2FjaGU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBCYXNlVGV4dHVyZUNhY2hlIGNsYXNzIGhhcyBiZWVuIG1vdmVkIHRvIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGUsIHBsZWFzZSB1c2UgdXRpbHMuQmFzZVRleHR1cmVDYWNoZSBmcm9tIG5vdyBvbi4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvcmUudXRpbHMuQmFzZVRleHR1cmVDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgVGV4dHVyZUNhY2hlXHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSVxyXG4gICAgICogQHNlZSBQSVhJLnV0aWxzLlRleHR1cmVDYWNoZVxyXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxyXG4gICAgICovXHJcbiAgICBUZXh0dXJlQ2FjaGU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBUZXh0dXJlQ2FjaGUgY2xhc3MgaGFzIGJlZW4gbW92ZWQgdG8gdXRpbHMuVGV4dHVyZUNhY2hlLCBwbGVhc2UgdXNlIHV0aWxzLlRleHR1cmVDYWNoZSBmcm9tIG5vdyBvbi4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvcmUudXRpbHMuVGV4dHVyZUNhY2hlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgbWF0aFxyXG4gICAgICogQG1lbWJlcm9mIFBJWElcclxuICAgICAqIEBzZWUgUElYSVxyXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuNlxyXG4gICAgICovXHJcbiAgICBtYXRoOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgbWF0aCBuYW1lc3BhY2UgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIGFjY2VzcyBtZW1iZXJzIGFscmVhZHkgYWNjZXNzaWJsZSBvbiBQSVhJLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2RcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgUElYSS5TcHJpdGUjc2V0VGV4dHVyZVxyXG4gKiBAc2VlIFBJWEkuU3ByaXRlI3RleHR1cmVcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxyXG4gKi9cclxuY29yZS5TcHJpdGUucHJvdG90eXBlLnNldFRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlKVxyXG57XHJcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgY29uc29sZS53YXJuKCdzZXRUZXh0dXJlIGlzIG5vdyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRoZSB0ZXh0dXJlIHByb3BlcnR5LCBlLmcgOiBzcHJpdGUudGV4dHVyZSA9IHRleHR1cmU7Jyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZFxyXG4gKiBAbmFtZSBQSVhJLmV4dHJhcy5CaXRtYXBUZXh0I3NldFRleHRcclxuICogQHNlZSBQSVhJLmV4dHJhcy5CaXRtYXBUZXh0I3RleHRcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxyXG4gKi9cclxuZXh0cmFzLkJpdG1hcFRleHQucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbih0ZXh0KVxyXG57XHJcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgY29uc29sZS53YXJuKCdzZXRUZXh0IGlzIG5vdyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRoZSB0ZXh0IHByb3BlcnR5LCBlLmcgOiBteUJpdG1hcFRleHQudGV4dCA9IFxcJ215IHRleHRcXCc7Jyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZFxyXG4gKiBAbmFtZSBQSVhJLlRleHQjc2V0VGV4dFxyXG4gKiBAc2VlIFBJWEkuVGV4dCN0ZXh0XHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcclxuICovXHJcbmNvcmUuVGV4dC5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uKHRleHQpXHJcbntcclxuICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICBjb25zb2xlLndhcm4oJ3NldFRleHQgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdGhlIHRleHQgcHJvcGVydHksIGUuZyA6IG15VGV4dC50ZXh0ID0gXFwnbXkgdGV4dFxcJzsnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBuYW1lIFBJWEkuVGV4dCNzZXRTdHlsZVxyXG4gKiBAc2VlIFBJWEkuVGV4dCNzdHlsZVxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXHJcbiAqL1xyXG5jb3JlLlRleHQucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpXHJcbntcclxuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcclxuICAgIGNvbnNvbGUud2Fybignc2V0U3R5bGUgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdGhlIHN0eWxlIHByb3BlcnR5LCBlLmcgOiBteVRleHQuc3R5bGUgPSBzdHlsZTsnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBuYW1lIFBJWEkuVGV4dHVyZSNzZXRGcmFtZVxyXG4gKiBAc2VlIFBJWEkuVGV4dHVyZSNzZXRGcmFtZVxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXHJcbiAqL1xyXG5jb3JlLlRleHR1cmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24oZnJhbWUpXHJcbntcclxuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcclxuICAgIGNvbnNvbGUud2Fybignc2V0RnJhbWUgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdGhlIGZyYW1lIHByb3BlcnR5LCBlLmcgOiBteVRleHR1cmUuZnJhbWUgPSBmcmFtZTsnKTtcclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGZpbHRlcnMsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBuYW1lIFBJWEkuZmlsdGVycy5BYnN0cmFjdEZpbHRlclxyXG4gICAgICogQHNlZSBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC42XHJcbiAgICAgKi9cclxuICAgIEFic3RyYWN0RmlsdGVyOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2ZpbHRlcnMuQWJzdHJhY3RGaWx0ZXIgaXMgYW4gdW5kb2N1bWVudGVkIGFsaWFzLCBwbGVhc2UgdXNlIEFic3RyYWN0RmlsdGVyIGZyb20gbm93IG9uLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZS5BYnN0cmFjdEZpbHRlcjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgUElYSS5maWx0ZXJzLkZYQUFGaWx0ZXJcclxuICAgICAqIEBzZWUgUElYSS5GWEFBRmlsdGVyXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC42XHJcbiAgICAgKi9cclxuICAgIEZYQUFGaWx0ZXI6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignZmlsdGVycy5GWEFBRmlsdGVyIGlzIGFuIHVuZG9jdW1lbnRlZCBhbGlhcywgcGxlYXNlIHVzZSBGWEFBRmlsdGVyIGZyb20gbm93IG9uLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZS5GWEFBRmlsdGVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBQSVhJLmZpbHRlcnMuU3ByaXRlTWFza0ZpbHRlclxyXG4gICAgICogQHNlZSBQSVhJLlNwcml0ZU1hc2tGaWx0ZXJcclxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjZcclxuICAgICAqL1xyXG4gICAgU3ByaXRlTWFza0ZpbHRlcjoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdmaWx0ZXJzLlNwcml0ZU1hc2tGaWx0ZXIgaXMgYW4gdW5kb2N1bWVudGVkIGFsaWFzLCBwbGVhc2UgdXNlIFNwcml0ZU1hc2tGaWx0ZXIgZnJvbSBub3cgb24uJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb3JlLlNwcml0ZU1hc2tGaWx0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBuYW1lIFBJWEkudXRpbHMudXVpZFxyXG4gKiBAc2VlIFBJWEkudXRpbHMudWlkXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjZcclxuICovXHJcbmNvcmUudXRpbHMudXVpZCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIGNvbnNvbGUud2FybigndXRpbHMudXVpZCgpIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdXRpbHMudWlkKCkgZnJvbSBub3cgb24uJyk7XHJcbiAgICByZXR1cm4gY29yZS51dGlscy51aWQoKTtcclxufTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XHJcblxyXG4vKipcclxuICogQSBCaXRtYXBUZXh0IG9iamVjdCB3aWxsIGNyZWF0ZSBhIGxpbmUgb3IgbXVsdGlwbGUgbGluZXMgb2YgdGV4dCB1c2luZyBiaXRtYXAgZm9udC4gVG9cclxuICogc3BsaXQgYSBsaW5lIHlvdSBjYW4gdXNlICdcXG4nLCAnXFxyJyBvciAnXFxyXFxuJyBpbiB5b3VyIHN0cmluZy4gWW91IGNhbiBnZW5lcmF0ZSB0aGUgZm50IGZpbGVzIHVzaW5nOlxyXG4gKlxyXG4gKiBBIEJpdG1hcFRleHQgY2FuIG9ubHkgYmUgY3JlYXRlZCB3aGVuIHRoZSBmb250IGlzIGxvYWRlZFxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBpbiB0aGlzIGNhc2UgdGhlIGZvbnQgaXMgaW4gYSBmaWxlIGNhbGxlZCAnZGVzeXJlbC5mbnQnXHJcbiAqIHZhciBiaXRtYXBUZXh0ID0gbmV3IFBJWEkuZXh0cmFzLkJpdG1hcFRleHQoXCJ0ZXh0IHVzaW5nIGEgZmFuY3kgZm9udCFcIiwge2ZvbnQ6IFwiMzVweCBEZXN5cmVsXCIsIGFsaWduOiBcInJpZ2h0XCJ9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqXHJcbiAqIGh0dHA6Ly93d3cuYW5nZWxjb2RlLmNvbS9wcm9kdWN0cy9ibWZvbnQvIGZvciB3aW5kb3dzIG9yXHJcbiAqIGh0dHA6Ly93d3cuYm1nbHlwaC5jb20vIGZvciBtYWMuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkNvbnRhaW5lclxyXG4gKiBAbWVtYmVyb2YgUElYSS5leHRyYXNcclxuICogQHBhcmFtIHRleHQge3N0cmluZ30gVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XHJcbiAqIEBwYXJhbSBzdHlsZSB7b2JqZWN0fSBUaGUgc3R5bGUgcGFyYW1ldGVyc1xyXG4gKiBAcGFyYW0gc3R5bGUuZm9udCB7c3RyaW5nfG9iamVjdH0gVGhlIGZvbnQgZGVzY3JpcHRvciBmb3IgdGhlIG9iamVjdCwgY2FuIGJlIHBhc3NlZCBhcyBhIHN0cmluZyBvZiBmb3JtXHJcbiAqICAgICAgXCIyNHB4IEZvbnROYW1lXCIgb3IgXCJGb250TmFtZVwiIG9yIGFzIGFuIG9iamVjdCB3aXRoIGV4cGxpY2l0IG5hbWUvc2l6ZSBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0gW3N0eWxlLmZvbnQubmFtZV0ge3N0cmluZ30gVGhlIGJpdG1hcCBmb250IGlkXHJcbiAqIEBwYXJhbSBbc3R5bGUuZm9udC5zaXplXSB7bnVtYmVyfSBUaGUgc2l6ZSBvZiB0aGUgZm9udCBpbiBwaXhlbHMsIGUuZy4gMjRcclxuICogQHBhcmFtIFtzdHlsZS5hbGlnbj0nbGVmdCddIHtzdHJpbmd9IEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQgKCdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0JyksIGRvZXMgbm90IGFmZmVjdFxyXG4gKiAgICAgIHNpbmdsZSBsaW5lIHRleHRcclxuICogQHBhcmFtIFtzdHlsZS50aW50PTB4RkZGRkZGXSB7bnVtYmVyfSBUaGUgdGludCBjb2xvclxyXG4gKi9cclxuZnVuY3Rpb24gQml0bWFwVGV4dCh0ZXh0LCBzdHlsZSlcclxue1xyXG4gICAgY29yZS5Db250YWluZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBvdmVyYWxsIHRleHQsIGRpZmZlcmVudCBmcm9tIGZvbnRTaXplLFxyXG4gICAgICogd2hpY2ggaXMgZGVmaW5lZCBpbiB0aGUgc3R5bGUgb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGV4dFdpZHRoID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIG92ZXJhbGwgdGV4dCwgZGlmZmVyZW50IGZyb20gZm9udFNpemUsXHJcbiAgICAgKiB3aGljaCBpcyBkZWZpbmVkIGluIHRoZSBzdHlsZSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xyXG4gICAgdGhpcy50ZXh0SGVpZ2h0ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGxldHRlciBzcHJpdGUgcG9vbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlNwcml0ZVtdfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fZ2x5cGhzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IHN0eWxlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge29iamVjdH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2ZvbnQgPSB7XHJcbiAgICAgICAgdGludDogc3R5bGUudGludCAhPT0gdW5kZWZpbmVkID8gc3R5bGUudGludCA6IDB4RkZGRkZGLFxyXG4gICAgICAgIGFsaWduOiBzdHlsZS5hbGlnbiB8fCAnbGVmdCcsXHJcbiAgICAgICAgbmFtZTogbnVsbCxcclxuICAgICAgICBzaXplOiAwXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCBmb250LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge29iamVjdH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZm9udCA9IHN0eWxlLmZvbnQ7IC8vIHJ1biBmb250IHNldHRlclxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCB0ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heCB3aWR0aCBvZiB0aGlzIGJpdG1hcCB0ZXh0IGluIHBpeGVscy4gSWYgdGhlIHRleHQgcHJvdmlkZWQgaXMgbG9uZ2VyIHRoYW4gdGhlIHZhbHVlIHByb3ZpZGVkLCBsaW5lIGJyZWFrcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQgaW4gdGhlIGxhc3Qgd2hpdGVzcGFjZS5cclxuICAgICAqIERpc2FibGUgYnkgc2V0dGluZyB2YWx1ZSB0byAwXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1heFdpZHRoID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXggbGluZSBoZWlnaHQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdHJ5aW5nIHRvIHVzZSB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBUZXh0LCBpZTogd2hlbiB0cnlpbmcgdG8gdmVydGljYWxseSBhbGlnbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF4TGluZUhlaWdodCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGlydHkgc3RhdGUgb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMudXBkYXRlVGV4dCgpO1xyXG59XHJcblxyXG4vLyBjb25zdHJ1Y3RvclxyXG5CaXRtYXBUZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5Db250YWluZXIucHJvdG90eXBlKTtcclxuQml0bWFwVGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaXRtYXBUZXh0O1xyXG5tb2R1bGUuZXhwb3J0cyA9IEJpdG1hcFRleHQ7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCaXRtYXBUZXh0LnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGludCBvZiB0aGUgQml0bWFwVGV4dCBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5leHRyYXMuQml0bWFwVGV4dCNcclxuICAgICAqL1xyXG4gICAgdGludDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb250LnRpbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbnQudGludCA9ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlID49IDApID8gdmFsdWUgOiAweEZGRkZGRjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYWxpZ25tZW50IG9mIHRoZSBCaXRtYXBUZXh0IG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0ICdsZWZ0J1xyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzLkJpdG1hcFRleHQjXHJcbiAgICAgKi9cclxuICAgIGFsaWduOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnQuYWxpZ247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbnQuYWxpZ24gPSB2YWx1ZSB8fCAnbGVmdCc7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZvbnQgZGVzY3JpcHRvciBvZiB0aGUgQml0bWFwVGV4dCBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtGb250fVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzLkJpdG1hcFRleHQjXHJcbiAgICAgKi9cclxuICAgIGZvbnQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnICcpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnQubmFtZSA9IHZhbHVlLmxlbmd0aCA9PT0gMSA/IHZhbHVlWzBdIDogdmFsdWUuc2xpY2UoMSkuam9pbignICcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udC5zaXplID0gdmFsdWUubGVuZ3RoID49IDIgPyBwYXJzZUludCh2YWx1ZVswXSwgMTApIDogQml0bWFwVGV4dC5mb250c1t0aGlzLl9mb250Lm5hbWVdLnNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250Lm5hbWUgPSB2YWx1ZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udC5zaXplID0gdHlwZW9mIHZhbHVlLnNpemUgPT09ICdudW1iZXInID8gdmFsdWUuc2l6ZSA6IHBhcnNlSW50KHZhbHVlLnNpemUsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IG9mIHRoZSBCaXRtYXBUZXh0IG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhcy5CaXRtYXBUZXh0I1xyXG4gICAgICovXHJcbiAgICB0ZXh0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKSB8fCAnICc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0ID09PSB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRleHQgYW5kIHVwZGF0ZXMgaXQgd2hlbiBuZWVkZWRcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbkJpdG1hcFRleHQucHJvdG90eXBlLnVwZGF0ZVRleHQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgZGF0YSA9IEJpdG1hcFRleHQuZm9udHNbdGhpcy5fZm9udC5uYW1lXTtcclxuICAgIHZhciBwb3MgPSBuZXcgY29yZS5Qb2ludCgpO1xyXG4gICAgdmFyIHByZXZDaGFyQ29kZSA9IG51bGw7XHJcbiAgICB2YXIgY2hhcnMgPSBbXTtcclxuICAgIHZhciBsYXN0TGluZVdpZHRoID0gMDtcclxuICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xyXG4gICAgdmFyIGxpbmVXaWR0aHMgPSBbXTtcclxuICAgIHZhciBsaW5lID0gMDtcclxuICAgIHZhciBzY2FsZSA9IHRoaXMuX2ZvbnQuc2l6ZSAvIGRhdGEuc2l6ZTtcclxuICAgIHZhciBsYXN0U3BhY2UgPSAtMTtcclxuICAgIHZhciBtYXhMaW5lSGVpZ2h0ID0gMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGV4dC5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgY2hhckNvZGUgPSB0aGlzLnRleHQuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBsYXN0U3BhY2UgPSAvKFxccykvLnRlc3QodGhpcy50ZXh0LmNoYXJBdChpKSkgPyBpIDogbGFzdFNwYWNlO1xyXG5cclxuICAgICAgICBpZiAoLyg/OlxcclxcbnxcXHJ8XFxuKS8udGVzdCh0aGlzLnRleHQuY2hhckF0KGkpKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aHMucHVzaChsYXN0TGluZVdpZHRoKTtcclxuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsYXN0TGluZVdpZHRoKTtcclxuICAgICAgICAgICAgbGluZSsrO1xyXG5cclxuICAgICAgICAgICAgcG9zLnggPSAwO1xyXG4gICAgICAgICAgICBwb3MueSArPSBkYXRhLmxpbmVIZWlnaHQ7XHJcbiAgICAgICAgICAgIHByZXZDaGFyQ29kZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxhc3RTcGFjZSAhPT0gLTEgJiYgdGhpcy5tYXhXaWR0aCA+IDAgJiYgcG9zLnggKiBzY2FsZSA+IHRoaXMubWF4V2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb3JlLnV0aWxzLnJlbW92ZUl0ZW1zKGNoYXJzLCBsYXN0U3BhY2UsIGkgLSBsYXN0U3BhY2UpO1xyXG4gICAgICAgICAgICBpID0gbGFzdFNwYWNlO1xyXG4gICAgICAgICAgICBsYXN0U3BhY2UgPSAtMTtcclxuXHJcbiAgICAgICAgICAgIGxpbmVXaWR0aHMucHVzaChsYXN0TGluZVdpZHRoKTtcclxuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsYXN0TGluZVdpZHRoKTtcclxuICAgICAgICAgICAgbGluZSsrO1xyXG5cclxuICAgICAgICAgICAgcG9zLnggPSAwO1xyXG4gICAgICAgICAgICBwb3MueSArPSBkYXRhLmxpbmVIZWlnaHQ7XHJcbiAgICAgICAgICAgIHByZXZDaGFyQ29kZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNoYXJEYXRhID0gZGF0YS5jaGFyc1tjaGFyQ29kZV07XHJcblxyXG4gICAgICAgIGlmICghY2hhckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcmV2Q2hhckNvZGUgJiYgY2hhckRhdGEua2VybmluZ1twcmV2Q2hhckNvZGVdKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcG9zLnggKz0gY2hhckRhdGEua2VybmluZ1twcmV2Q2hhckNvZGVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hhcnMucHVzaCh7dGV4dHVyZTpjaGFyRGF0YS50ZXh0dXJlLCBsaW5lOiBsaW5lLCBjaGFyQ29kZTogY2hhckNvZGUsIHBvc2l0aW9uOiBuZXcgY29yZS5Qb2ludChwb3MueCArIGNoYXJEYXRhLnhPZmZzZXQsIHBvcy55ICsgY2hhckRhdGEueU9mZnNldCl9KTtcclxuICAgICAgICBsYXN0TGluZVdpZHRoID0gcG9zLnggKyAoY2hhckRhdGEudGV4dHVyZS53aWR0aCArIGNoYXJEYXRhLnhPZmZzZXQpO1xyXG4gICAgICAgIHBvcy54ICs9IGNoYXJEYXRhLnhBZHZhbmNlO1xyXG4gICAgICAgIG1heExpbmVIZWlnaHQgPSBNYXRoLm1heChtYXhMaW5lSGVpZ2h0LCAoY2hhckRhdGEueU9mZnNldCArIGNoYXJEYXRhLnRleHR1cmUuaGVpZ2h0KSk7XHJcbiAgICAgICAgcHJldkNoYXJDb2RlID0gY2hhckNvZGU7XHJcbiAgICB9XHJcblxyXG4gICAgbGluZVdpZHRocy5wdXNoKGxhc3RMaW5lV2lkdGgpO1xyXG4gICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsYXN0TGluZVdpZHRoKTtcclxuXHJcbiAgICB2YXIgbGluZUFsaWduT2Zmc2V0cyA9IFtdO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPD0gbGluZTsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhbGlnbk9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mb250LmFsaWduID09PSAncmlnaHQnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWxpZ25PZmZzZXQgPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9mb250LmFsaWduID09PSAnY2VudGVyJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFsaWduT2Zmc2V0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpbmVBbGlnbk9mZnNldHMucHVzaChhbGlnbk9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlbkNoYXJzID0gY2hhcnMubGVuZ3RoO1xyXG4gICAgdmFyIHRpbnQgPSB0aGlzLnRpbnQ7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbkNoYXJzOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLl9nbHlwaHNbaV07IC8vIGdldCB0aGUgbmV4dCBnbHlwaCBzcHJpdGVcclxuXHJcbiAgICAgICAgaWYgKGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjLnRleHR1cmUgPSBjaGFyc1tpXS50ZXh0dXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjID0gbmV3IGNvcmUuU3ByaXRlKGNoYXJzW2ldLnRleHR1cmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbHlwaHMucHVzaChjKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMucG9zaXRpb24ueCA9IChjaGFyc1tpXS5wb3NpdGlvbi54ICsgbGluZUFsaWduT2Zmc2V0c1tjaGFyc1tpXS5saW5lXSkgKiBzY2FsZTtcclxuICAgICAgICBjLnBvc2l0aW9uLnkgPSBjaGFyc1tpXS5wb3NpdGlvbi55ICogc2NhbGU7XHJcbiAgICAgICAgYy5zY2FsZS54ID0gYy5zY2FsZS55ID0gc2NhbGU7XHJcbiAgICAgICAgYy50aW50ID0gdGludDtcclxuXHJcbiAgICAgICAgaWYgKCFjLnBhcmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZSB1bm5lY2Vzc2FyeSBjaGlsZHJlbi5cclxuICAgIGZvciAoaSA9IGxlbkNoYXJzOyBpIDwgdGhpcy5fZ2x5cGhzLmxlbmd0aDsgKytpKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5fZ2x5cGhzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRleHRXaWR0aCA9IG1heExpbmVXaWR0aCAqIHNjYWxlO1xyXG4gICAgdGhpcy50ZXh0SGVpZ2h0ID0gKHBvcy55ICsgZGF0YS5saW5lSGVpZ2h0KSAqIHNjYWxlO1xyXG4gICAgdGhpcy5tYXhMaW5lSGVpZ2h0ID0gbWF4TGluZUhlaWdodCAqIHNjYWxlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybSBvZiB0aGlzIG9iamVjdFxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQml0bWFwVGV4dC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgdGhpcy5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0oKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGV4dCBiZWZvcmUgY2FsbGluZyBwYXJlbnQncyBnZXRMb2NhbEJvdW5kc1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcclxuICovXHJcblxyXG5CaXRtYXBUZXh0LnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uKClcclxue1xyXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgcmV0dXJuIGNvcmUuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGV4dCB3aGVuIG5lZWRlZFxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQml0bWFwVGV4dC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpXHJcbntcclxuICAgIGlmICh0aGlzLmRpcnR5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbkJpdG1hcFRleHQuZm9udHMgPSB7fTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XHJcblxyXG4vKipcclxuICogQSBNb3ZpZUNsaXAgaXMgYSBzaW1wbGUgd2F5IHRvIGRpc3BsYXkgYW4gYW5pbWF0aW9uIGRlcGljdGVkIGJ5IGEgbGlzdCBvZiB0ZXh0dXJlcy5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGFsaWVuSW1hZ2VzID0gW1wiaW1hZ2Vfc2VxdWVuY2VfMDEucG5nXCIsXCJpbWFnZV9zZXF1ZW5jZV8wMi5wbmdcIixcImltYWdlX3NlcXVlbmNlXzAzLnBuZ1wiLFwiaW1hZ2Vfc2VxdWVuY2VfMDQucG5nXCJdO1xyXG4gKiB2YXIgdGV4dHVyZUFycmF5ID0gW107XHJcbiAqXHJcbiAqIGZvciAodmFyIGk9MDsgaSA8IDQ7IGkrKylcclxuICoge1xyXG4gKiAgICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShhbGllbkltYWdlc1tpXSk7XHJcbiAqICAgICAgdGV4dHVyZUFycmF5LnB1c2godGV4dHVyZSk7XHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBtYyA9IG5ldyBQSVhJLk1vdmllQ2xpcCh0ZXh0dXJlQXJyYXkpO1xyXG4gKiBgYGBcclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuU3ByaXRlXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhc1xyXG4gKiBAcGFyYW0gdGV4dHVyZXMge1BJWEkuVGV4dHVyZVtdfE9iamVjdFtdfSBhbiBhcnJheSBvZiB7QGxpbmsgUElYSS5UZXh0dXJlfSBvciBmcmFtZSBvYmplY3RzIHRoYXQgbWFrZSB1cCB0aGUgYW5pbWF0aW9uXHJcbiAqIEBwYXJhbSB0ZXh0dXJlc1tdLnRleHR1cmUge1BJWEkuVGV4dHVyZX0gdGhlIHtAbGluayBQSVhJLlRleHR1cmV9IG9mIHRoZSBmcmFtZVxyXG4gKiBAcGFyYW0gdGV4dHVyZXNbXS50aW1lIHtudW1iZXJ9IHRoZSBkdXJhdGlvbiBvZiB0aGUgZnJhbWUgaW4gbXNcclxuICovXHJcbmZ1bmN0aW9uIE1vdmllQ2xpcCh0ZXh0dXJlcylcclxue1xyXG4gICAgY29yZS5TcHJpdGUuY2FsbCh0aGlzLCB0ZXh0dXJlc1swXSBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSA/IHRleHR1cmVzWzBdIDogdGV4dHVyZXNbMF0udGV4dHVyZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl90ZXh0dXJlcyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9kdXJhdGlvbnMgPSBudWxsO1xyXG5cclxuICAgIHRoaXMudGV4dHVyZXMgPSB0ZXh0dXJlcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzcGVlZCB0aGF0IHRoZSBNb3ZpZUNsaXAgd2lsbCBwbGF5IGF0LiBIaWdoZXIgaXMgZmFzdGVyLCBsb3dlciBpcyBzbG93ZXJcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vdmllIGNsaXAgcmVwZWF0cyBhZnRlciBwbGF5aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubG9vcCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBNb3ZpZUNsaXAgZmluaXNoZXMgcGxheWluZ1xyXG4gICAgICpcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhcy5Nb3ZpZUNsaXAjXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25Db21wbGV0ZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbGFwc2VkIHRpbWUgc2luY2UgYW5pbWF0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHVzZWQgaW50ZXJuYWxseSB0byBkaXNwbGF5IGN1cnJlbnQgdGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgTW92aWVDbGlwIGlzIGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcclxufVxyXG5cclxuLy8gY29uc3RydWN0b3JcclxuTW92aWVDbGlwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5TcHJpdGUucHJvdG90eXBlKTtcclxuTW92aWVDbGlwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vdmllQ2xpcDtcclxubW9kdWxlLmV4cG9ydHMgPSBNb3ZpZUNsaXA7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhNb3ZpZUNsaXAucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIHRvdGFsRnJhbWVzIGlzIHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBNb3ZpZUNsaXAuIFRoaXMgaXMgdGhlIHNhbWUgYXMgbnVtYmVyIG9mIHRleHR1cmVzXHJcbiAgICAgKiBhc3NpZ25lZCB0byB0aGUgTW92aWVDbGlwLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhcy5Nb3ZpZUNsaXAjXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgdG90YWxGcmFtZXM6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhcnJheSBvZiB0ZXh0dXJlcyB1c2VkIGZvciB0aGlzIE1vdmllQ2xpcFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZVtdfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzLk1vdmllQ2xpcCNcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHRleHR1cmVzOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZih2YWx1ZVswXSBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMucHVzaCh2YWx1ZVtpXS50ZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kdXJhdGlvbnMucHVzaCh2YWx1ZVtpXS50aW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBNb3ZpZUNsaXBzIGN1cnJlbnQgZnJhbWUgaW5kZXhcclxuICAgICpcclxuICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgKiBAbWVtYmVyb2YgUElYSS5leHRyYXMuTW92aWVDbGlwI1xyXG4gICAgKiBAcmVhZG9ubHlcclxuICAgICovXHJcbiAgICBjdXJyZW50RnJhbWU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudEZyYW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSkgJSB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgPCAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUgKz0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RnJhbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICogU3RvcHMgdGhlIE1vdmllQ2xpcFxyXG4gKlxyXG4gKi9cclxuTW92aWVDbGlwLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYoIXRoaXMucGxheWluZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcbiAgICBjb3JlLnRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQbGF5cyB0aGUgTW92aWVDbGlwXHJcbiAqXHJcbiAqL1xyXG5Nb3ZpZUNsaXAucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICBpZih0aGlzLnBsYXlpbmcpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGxheWluZyA9IHRydWU7XHJcbiAgICBjb3JlLnRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlLCB0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdG9wcyB0aGUgTW92aWVDbGlwIGFuZCBnb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWVcclxuICpcclxuICogQHBhcmFtIGZyYW1lTnVtYmVyIHtudW1iZXJ9IGZyYW1lIGluZGV4IHRvIHN0b3AgYXRcclxuICovXHJcbk1vdmllQ2xpcC5wcm90b3R5cGUuZ290b0FuZFN0b3AgPSBmdW5jdGlvbiAoZnJhbWVOdW1iZXIpXHJcbntcclxuICAgIHRoaXMuc3RvcCgpO1xyXG5cclxuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gZnJhbWVOdW1iZXI7XHJcblxyXG4gICAgdGhpcy5fdGV4dHVyZSA9IHRoaXMuX3RleHR1cmVzW3RoaXMuY3VycmVudEZyYW1lXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUgYW5kIGJlZ2lucyBwbGF5aW5nIHRoZSBNb3ZpZUNsaXBcclxuICpcclxuICogQHBhcmFtIGZyYW1lTnVtYmVyIHtudW1iZXJ9IGZyYW1lIGluZGV4IHRvIHN0YXJ0IGF0XHJcbiAqL1xyXG5Nb3ZpZUNsaXAucHJvdG90eXBlLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24gKGZyYW1lTnVtYmVyKVxyXG57XHJcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IGZyYW1lTnVtYmVyO1xyXG5cclxuICAgIHRoaXMucGxheSgpO1xyXG59O1xyXG5cclxuLypcclxuICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Nb3ZpZUNsaXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YVRpbWUpXHJcbntcclxuICAgIHZhciBlbGFwc2VkID0gdGhpcy5hbmltYXRpb25TcGVlZCAqIGRlbHRhVGltZTtcclxuXHJcbiAgICBpZiAodGhpcy5fZHVyYXRpb25zICE9PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsYWcgPSB0aGlzLl9jdXJyZW50VGltZSAlIDEgKiB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xyXG5cclxuICAgICAgICBsYWcgKz0gZWxhcHNlZCAvIDYwICogMTAwMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGxhZyA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZS0tO1xyXG4gICAgICAgICAgICBsYWcgKz0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaWduID0gTWF0aC5zaWduKHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWUpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSk7XHJcblxyXG4gICAgICAgIHdoaWxlIChsYWcgPj0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxhZyAtPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdICogc2lnbjtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gc2lnbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lICs9IGxhZyAvIHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV07XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gZWxhcHNlZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fY3VycmVudFRpbWUgPCAwICYmICF0aGlzLmxvb3ApXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCgwKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRUaW1lID49IHRoaXMuX3RleHR1cmVzLmxlbmd0aCAmJiAhdGhpcy5sb29wKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ290b0FuZFN0b3AodGhpcy5fdGV4dHVyZXMubGVuZ3RoIC0gMSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9uQ29tcGxldGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHRoaXMuX3RleHR1cmVzW3RoaXMuY3VycmVudEZyYW1lXTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vKlxyXG4gKiBTdG9wcyB0aGUgTW92aWVDbGlwIGFuZCBkZXN0cm95cyBpdFxyXG4gKlxyXG4gKi9cclxuTW92aWVDbGlwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCApXHJcbntcclxuICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgY29yZS5TcHJpdGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGEgbW92aWVjbGlwIGZyb20gYW4gYXJyYXkgb2YgZnJhbWUgaWRzXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIGZyYW1lcyB7c3RyaW5nW119IHRoZSBhcnJheSBvZiBmcmFtZXMgaWRzIHRoZSBtb3ZpZWNsaXAgd2lsbCB1c2UgYXMgaXRzIHRleHR1cmUgZnJhbWVzXHJcbiAqL1xyXG5Nb3ZpZUNsaXAuZnJvbUZyYW1lcyA9IGZ1bmN0aW9uIChmcmFtZXMpXHJcbntcclxuICAgIHZhciB0ZXh0dXJlcyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgKytpKVxyXG4gICAge1xyXG4gICAgICAgIHRleHR1cmVzLnB1c2gobmV3IGNvcmUuVGV4dHVyZS5mcm9tRnJhbWUoZnJhbWVzW2ldKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBNb3ZpZUNsaXAodGV4dHVyZXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgc2hvcnQgaGFuZCB3YXkgb2YgY3JlYXRpbmcgYSBtb3ZpZWNsaXAgZnJvbSBhbiBhcnJheSBvZiBpbWFnZSBpZHNcclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0gaW1hZ2VzIHtzdHJpbmdbXX0gdGhlIGFycmF5IG9mIGltYWdlIHVybHMgdGhlIG1vdmllY2xpcCB3aWxsIHVzZSBhcyBpdHMgdGV4dHVyZSBmcmFtZXNcclxuICovXHJcbk1vdmllQ2xpcC5mcm9tSW1hZ2VzID0gZnVuY3Rpb24gKGltYWdlcylcclxue1xyXG4gICAgdmFyIHRleHR1cmVzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpXHJcbiAgICB7XHJcbiAgICAgICAgdGV4dHVyZXMucHVzaChuZXcgY29yZS5UZXh0dXJlLmZyb21JbWFnZShpbWFnZXNbaV0pKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IE1vdmllQ2xpcCh0ZXh0dXJlcyk7XHJcbn07IiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyksXHJcbiAgICAvLyBhIHNwcml0ZSB1c2UgZGZvciByZW5kZXJpbmcgdGV4dHVyZXMuLlxyXG4gICAgdGVtcFBvaW50ID0gbmV3IGNvcmUuUG9pbnQoKSxcclxuICAgIENhbnZhc1RpbnRlciA9IHJlcXVpcmUoJy4uL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNUaW50ZXInKTtcclxuXHJcbi8qKlxyXG4gKiBBIHRpbGluZyBzcHJpdGUgaXMgYSBmYXN0IHdheSBvZiByZW5kZXJpbmcgYSB0aWxpbmcgaW1hZ2VcclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuU3ByaXRlXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhc1xyXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gdGhlIHRleHR1cmUgb2YgdGhlIHRpbGluZyBzcHJpdGVcclxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9ICB0aGUgd2lkdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcclxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBUaWxpbmdTcHJpdGUodGV4dHVyZSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgY29yZS5TcHJpdGUuY2FsbCh0aGlzLCB0ZXh0dXJlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzY2FsaW5nIG9mIHRoZSBpbWFnZSB0aGF0IGlzIGJlaW5nIHRpbGVkXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50aWxlU2NhbGUgPSBuZXcgY29yZS5Qb2ludCgxLDEpO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGltYWdlIHRoYXQgaXMgYmVpbmcgdGlsZWRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRpbGVQb3NpdGlvbiA9IG5ldyBjb3JlLlBvaW50KDAsMCk7XHJcblxyXG4gICAgLy8vLy8gcHJpdmF0ZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoIHx8IDEwMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQgfHwgMTAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW50ZXJuYWwgV2ViR0wgVVYgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlVXZzfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fdXZzID0gbmV3IGNvcmUuVGV4dHVyZVV2cygpO1xyXG5cclxuICAgIHRoaXMuX2NhbnZhc1BhdHRlcm4gPSBudWxsO1xyXG5cclxuICAgIC8vVE9ETyBtb3ZlLi5cclxuICAgIHRoaXMuc2hhZGVyID0gbmV3IGNvcmUuQWJzdHJhY3RGaWx0ZXIoXHJcblxyXG4gICAgICBbXHJcbiAgICAgICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IGFDb2xvcjsnLFxyXG5cclxuICAgICAgICAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JyxcclxuXHJcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1RnJhbWU7JyxcclxuICAgICAgICAndW5pZm9ybSB2ZWM0IHVUcmFuc2Zvcm07JyxcclxuXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcclxuXHJcbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxyXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsnLFxyXG5cclxuICAgICAgICAnICAgdmVjMiBjb29yZCA9IGFUZXh0dXJlQ29vcmQ7JyxcclxuICAgICAgICAnICAgY29vcmQgLT0gdVRyYW5zZm9ybS54eTsnLFxyXG4gICAgICAgICcgICBjb29yZCAvPSB1VHJhbnNmb3JtLnp3OycsXHJcbiAgICAgICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBjb29yZDsnLFxyXG5cclxuICAgICAgICAnICAgdkNvbG9yID0gdmVjNChhQ29sb3IucmdiICogYUNvbG9yLmEsIGFDb2xvci5hKTsnLFxyXG4gICAgICAgICd9J1xyXG4gICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICBbXHJcbiAgICAgICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXHJcblxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXHJcblxyXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxyXG4gICAgICAgICd1bmlmb3JtIHZlYzQgdUZyYW1lOycsXHJcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiB1UGl4ZWxTaXplOycsXHJcblxyXG4gICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcclxuXHJcbiAgICAgICAgJyAgIHZlYzIgY29vcmQgPSBtb2QodlRleHR1cmVDb29yZCwgdUZyYW1lLnp3KTsnLFxyXG4gICAgICAgICcgICBjb29yZCA9IGNsYW1wKGNvb3JkLCB1UGl4ZWxTaXplLCB1RnJhbWUuencgLSB1UGl4ZWxTaXplKTsnLFxyXG4gICAgICAgICcgICBjb29yZCArPSB1RnJhbWUueHk7JyxcclxuXHJcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9ICB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkKSAqIHZDb2xvciA7JyxcclxuICAgICAgICAnfSdcclxuICAgICAgXS5qb2luKCdcXG4nKSxcclxuXHJcbiAgICAgICAgICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdUZyYW1lOiB7IHR5cGU6ICc0ZnYnLCB2YWx1ZTogWzAsMCwxLDFdIH0sXHJcbiAgICAgICAgICAgICAgICB1VHJhbnNmb3JtOiB7IHR5cGU6ICc0ZnYnLCB2YWx1ZTogWzAsMCwxLDFdIH0sXHJcbiAgICAgICAgICAgICAgICB1UGl4ZWxTaXplIDogeyB0eXBlIDogJzJmdicsIHZhbHVlOiBbMSwgMV19XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgKTtcclxufVxyXG5cclxuVGlsaW5nU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5TcHJpdGUucHJvdG90eXBlKTtcclxuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbGluZ1Nwcml0ZTtcclxubW9kdWxlLmV4cG9ydHMgPSBUaWxpbmdTcHJpdGU7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGlsaW5nU3ByaXRlLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5leHRyYXMuVGlsaW5nU3ByaXRlI1xyXG4gICAgICovXHJcbiAgICB3aWR0aDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGlsaW5nU3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGUjXHJcbiAgICAgKi9cclxuICAgIGhlaWdodDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5UaWxpbmdTcHJpdGUucHJvdG90eXBlLl9vblRleHR1cmVVcGRhdGUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm47XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICpcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5UaWxpbmdTcHJpdGUucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChyZW5kZXJlcilcclxue1xyXG4gICAgLy8gdHdlYWsgb3VyIHRleHR1cmUgdGVtcG9yYXJpbHkuLlxyXG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xyXG5cclxuICAgIGlmKCF0ZXh0dXJlIHx8ICF0ZXh0dXJlLl91dnMpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0ZW1wVXZzID0gdGV4dHVyZS5fdXZzLFxyXG4gICAgICAgIHRlbXBXaWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoLFxyXG4gICAgICAgIHRlbXBIZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQsXHJcbiAgICAgICAgdHcgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoLFxyXG4gICAgICAgIHRoID0gdGV4dHVyZS5iYXNlVGV4dHVyZS5oZWlnaHQ7XHJcblxyXG4gICAgdGV4dHVyZS5fdXZzID0gdGhpcy5fdXZzO1xyXG4gICAgdGV4dHVyZS5fZnJhbWUud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcblxyXG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudVBpeGVsU2l6ZS52YWx1ZVswXSA9IDEuMC90dztcclxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVQaXhlbFNpemUudmFsdWVbMV0gPSAxLjAvdGg7XHJcblxyXG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudUZyYW1lLnZhbHVlWzBdID0gdGVtcFV2cy54MDtcclxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVGcmFtZS52YWx1ZVsxXSA9IHRlbXBVdnMueTA7XHJcbiAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy51RnJhbWUudmFsdWVbMl0gPSB0ZW1wVXZzLngxIC0gdGVtcFV2cy54MDtcclxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVGcmFtZS52YWx1ZVszXSA9IHRlbXBVdnMueTIgLSB0ZW1wVXZzLnkwO1xyXG5cclxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVUcmFuc2Zvcm0udmFsdWVbMF0gPSAodGhpcy50aWxlUG9zaXRpb24ueCAlICh0ZW1wV2lkdGggKiB0aGlzLnRpbGVTY2FsZS54KSkgLyB0aGlzLl93aWR0aDtcclxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVUcmFuc2Zvcm0udmFsdWVbMV0gPSAodGhpcy50aWxlUG9zaXRpb24ueSAlICh0ZW1wSGVpZ2h0ICogdGhpcy50aWxlU2NhbGUueSkpIC8gdGhpcy5faGVpZ2h0O1xyXG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudVRyYW5zZm9ybS52YWx1ZVsyXSA9ICggdHcgLyB0aGlzLl93aWR0aCApICogdGhpcy50aWxlU2NhbGUueDtcclxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVUcmFuc2Zvcm0udmFsdWVbM10gPSAoIHRoIC8gdGhpcy5faGVpZ2h0ICkgKiB0aGlzLnRpbGVTY2FsZS55O1xyXG5cclxuICAgIHJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnMuc3ByaXRlKTtcclxuICAgIHJlbmRlcmVyLnBsdWdpbnMuc3ByaXRlLnJlbmRlcih0aGlzKTtcclxuXHJcbiAgICB0ZXh0dXJlLl91dnMgPSB0ZW1wVXZzO1xyXG4gICAgdGV4dHVyZS5fZnJhbWUud2lkdGggPSB0ZW1wV2lkdGg7XHJcbiAgICB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgPSB0ZW1wSGVpZ2h0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXHJcbiAqXHJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5DYW52YXNSZW5kZXJlcn0gYSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyByZW5kZXJlclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxyXG57XHJcbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XHJcblxyXG4gICAgaWYgKCF0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcclxuICAgIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dCxcclxuICAgICAgICB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtLFxyXG4gICAgICAgIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uLFxyXG4gICAgICAgIGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZSxcclxuICAgICAgICBtb2RYID0gKHRoaXMudGlsZVBvc2l0aW9uLnggLyB0aGlzLnRpbGVTY2FsZS54KSAlIHRleHR1cmUuX2ZyYW1lLndpZHRoLFxyXG4gICAgICAgIG1vZFkgPSAodGhpcy50aWxlUG9zaXRpb24ueSAvIHRoaXMudGlsZVNjYWxlLnkpICUgdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xyXG5cclxuICAgIC8vIGNyZWF0ZSBhIG5pY2Ugc2hpbnkgcGF0dGVybiFcclxuICAgIC8vIFRPRE8gdGhpcyBuZWVkcyB0byBiZSByZWZyZXNoZWQgaWYgdGV4dHVyZSBjaGFuZ2VzLi5cclxuICAgIGlmKCF0aGlzLl9jYW52YXNQYXR0ZXJuKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGN1dCBhbiBvYmplY3QgZnJvbSBhIHNwcml0ZXNoZWV0Li5cclxuICAgICAgICB2YXIgdGVtcENhbnZhcyA9IG5ldyBjb3JlLkNhbnZhc0J1ZmZlcih0ZXh0dXJlLl9mcmFtZS53aWR0aCwgdGV4dHVyZS5fZnJhbWUuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgLy8gVGludCB0aGUgdGlsaW5nIHNwcml0ZVxyXG4gICAgICAgIGlmICh0aGlzLnRpbnQgIT09IDB4RkZGRkZGKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkVGludCAhPT0gdGhpcy50aW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSB0aGlzLnRpbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50aW50ZWRUZXh0dXJlID0gQ2FudmFzVGludGVyLmdldFRpbnRlZFRleHR1cmUodGhpcywgdGhpcy50aW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZW1wQ2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKHRoaXMudGludGVkVGV4dHVyZSwgMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRlbXBDYW52YXMuY29udGV4dC5kcmF3SW1hZ2UoYmFzZVRleHR1cmUuc291cmNlLCAtdGV4dHVyZS5fZnJhbWUueCwgLXRleHR1cmUuX2ZyYW1lLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYW52YXNQYXR0ZXJuID0gdGVtcENhbnZhcy5jb250ZXh0LmNyZWF0ZVBhdHRlcm4oIHRlbXBDYW52YXMuY2FudmFzLCAncmVwZWF0JyApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCBjb250ZXh0IHN0YXRlLi5cclxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XHJcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSAqIHJlc29sdXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmIgKiByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5jICogcmVzb2x1dGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZCAqIHJlc29sdXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLnR4ICogcmVzb2x1dGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udHkgKiByZXNvbHV0aW9uKTtcclxuXHJcbiAgICAvLyBUT0RPIC0gdGhpcyBzaG91bGQgYmUgcm9sbGVkIGludG8gdGhlIHNldFRyYW5zZm9ybSBhYm92ZS4uXHJcbiAgICBjb250ZXh0LnNjYWxlKHRoaXMudGlsZVNjYWxlLngsdGhpcy50aWxlU2NhbGUueSk7XHJcblxyXG4gICAgY29udGV4dC50cmFuc2xhdGUobW9kWCArICh0aGlzLmFuY2hvci54ICogLXRoaXMuX3dpZHRoICksXHJcbiAgICAgICAgICAgICAgICAgICAgICBtb2RZICsgKHRoaXMuYW5jaG9yLnkgKiAtdGhpcy5faGVpZ2h0KSk7XHJcblxyXG4gICAgLy8gY2hlY2sgYmxlbmQgbW9kZVxyXG4gICAgdmFyIGNvbXBvc2l0ZU9wZXJhdGlvbiA9IHJlbmRlcmVyLmJsZW5kTW9kZXNbdGhpcy5ibGVuZE1vZGVdO1xyXG4gICAgaWYgKGNvbXBvc2l0ZU9wZXJhdGlvbiAhPT0gcmVuZGVyZXIuY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmlsbCB0aGUgcGF0dGVybiFcclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fY2FudmFzUGF0dGVybjtcclxuICAgIGNvbnRleHQuZmlsbFJlY3QoLW1vZFgsXHJcbiAgICAgICAgICAgICAgICAgICAgIC1tb2RZLFxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLl93aWR0aCAvIHRoaXMudGlsZVNjYWxlLngsXHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodCAvIHRoaXMudGlsZVNjYWxlLnkpO1xyXG5cclxuXHJcbiAgICAvL1RPRE8gLSBwcmV0dHkgc3VyZSB0aGlzIGNhbiBiZSBkZWxldGVkLi4uXHJcbiAgICAvL2NvbnRleHQudHJhbnNsYXRlKC10aGlzLnRpbGVQb3NpdGlvbi54ICsgKHRoaXMuYW5jaG9yLnggKiB0aGlzLl93aWR0aCksIC10aGlzLnRpbGVQb3NpdGlvbi55ICsgKHRoaXMuYW5jaG9yLnkgKiB0aGlzLl9oZWlnaHQpKTtcclxuICAgIC8vY29udGV4dC5zY2FsZSgxIC8gdGhpcy50aWxlU2NhbGUueCwgMSAvIHRoaXMudGlsZVNjYWxlLnkpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgc3ByaXRlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxyXG4qXHJcbiAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcclxuICovXHJcblRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xyXG5cclxuICAgIHZhciB3MCA9IHdpZHRoICogKDEtdGhpcy5hbmNob3IueCk7XHJcbiAgICB2YXIgdzEgPSB3aWR0aCAqIC10aGlzLmFuY2hvci54O1xyXG5cclxuICAgIHZhciBoMCA9IGhlaWdodCAqICgxLXRoaXMuYW5jaG9yLnkpO1xyXG4gICAgdmFyIGgxID0gaGVpZ2h0ICogLXRoaXMuYW5jaG9yLnk7XHJcblxyXG4gICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcclxuXHJcbiAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7XHJcbiAgICB2YXIgYiA9IHdvcmxkVHJhbnNmb3JtLmI7XHJcbiAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmM7XHJcbiAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7XHJcbiAgICB2YXIgdHggPSB3b3JsZFRyYW5zZm9ybS50eDtcclxuICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5O1xyXG5cclxuICAgIHZhciB4MSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xyXG4gICAgdmFyIHkxID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XHJcblxyXG4gICAgdmFyIHgyID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XHJcbiAgICB2YXIgeTIgPSBkICogaDEgKyBiICogdzAgKyB0eTtcclxuXHJcbiAgICB2YXIgeDMgPSBhICogdzAgKyBjICogaDAgKyB0eDtcclxuICAgIHZhciB5MyA9IGQgKiBoMCArIGIgKiB3MCArIHR5O1xyXG5cclxuICAgIHZhciB4NCA9ICBhICogdzEgKyBjICogaDAgKyB0eDtcclxuICAgIHZhciB5NCA9ICBkICogaDAgKyBiICogdzEgKyB0eTtcclxuXHJcbiAgICB2YXIgbWluWCxcclxuICAgICAgICBtYXhYLFxyXG4gICAgICAgIG1pblksXHJcbiAgICAgICAgbWF4WTtcclxuXHJcbiAgICBtaW5YID0geDE7XHJcbiAgICBtaW5YID0geDIgPCBtaW5YID8geDIgOiBtaW5YO1xyXG4gICAgbWluWCA9IHgzIDwgbWluWCA/IHgzIDogbWluWDtcclxuICAgIG1pblggPSB4NCA8IG1pblggPyB4NCA6IG1pblg7XHJcblxyXG4gICAgbWluWSA9IHkxO1xyXG4gICAgbWluWSA9IHkyIDwgbWluWSA/IHkyIDogbWluWTtcclxuICAgIG1pblkgPSB5MyA8IG1pblkgPyB5MyA6IG1pblk7XHJcbiAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xyXG5cclxuICAgIG1heFggPSB4MTtcclxuICAgIG1heFggPSB4MiA+IG1heFggPyB4MiA6IG1heFg7XHJcbiAgICBtYXhYID0geDMgPiBtYXhYID8geDMgOiBtYXhYO1xyXG4gICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcclxuXHJcbiAgICBtYXhZID0geTE7XHJcbiAgICBtYXhZID0geTIgPiBtYXhZID8geTIgOiBtYXhZO1xyXG4gICAgbWF4WSA9IHkzID4gbWF4WSA/IHkzIDogbWF4WTtcclxuICAgIG1heFkgPSB5NCA+IG1heFkgPyB5NCA6IG1heFk7XHJcblxyXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcclxuXHJcbiAgICBib3VuZHMueCA9IG1pblg7XHJcbiAgICBib3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcclxuXHJcbiAgICBib3VuZHMueSA9IG1pblk7XHJcbiAgICBib3VuZHMuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XHJcblxyXG4gICAgLy8gc3RvcmUgYSByZWZlcmVuY2Ugc28gdGhhdCBpZiB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGFnYWluIGluIHRoZSByZW5kZXIgY3ljbGUgd2UgZG8gbm90IGhhdmUgdG8gcmVjYWxjdWxhdGVcclxuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBib3VuZHM7XHJcblxyXG4gICAgcmV0dXJuIGJvdW5kcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyB0aWxpbmcgc3ByaXRlXHJcbiAqIEBwYXJhbSBwb2ludCB7UElYSS5Qb2ludH0gdGhlIHBvaW50IHRvIGNoZWNrXHJcbiAqL1xyXG5UaWxpbmdTcHJpdGUucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiggcG9pbnQgKVxyXG57XHJcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgIHRlbXBQb2ludCk7XHJcblxyXG4gICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xyXG4gICAgdmFyIHgxID0gLXdpZHRoICogdGhpcy5hbmNob3IueDtcclxuICAgIHZhciB5MTtcclxuXHJcbiAgICBpZiAoIHRlbXBQb2ludC54ID4geDEgJiYgdGVtcFBvaW50LnggPCB4MSArIHdpZHRoIClcclxuICAgIHtcclxuICAgICAgICB5MSA9IC1oZWlnaHQgKiB0aGlzLmFuY2hvci55O1xyXG5cclxuICAgICAgICBpZiAoIHRlbXBQb2ludC55ID4geTEgJiYgdGVtcFBvaW50LnkgPCB5MSArIGhlaWdodCApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc3Ryb3lzIHRoaXMgdGlsaW5nIHNwcml0ZVxyXG4gKlxyXG4gKi9cclxuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgY29yZS5TcHJpdGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnRpbGVTY2FsZSA9IG51bGw7XHJcbiAgICB0aGlzLl90aWxlU2NhbGVPZmZzZXQgPSBudWxsO1xyXG4gICAgdGhpcy50aWxlUG9zaXRpb24gPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX3V2cyA9IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHRpbGluZyBzcHJpdGUgdGhhdCB3aWxsIHVzZSBhIHRleHR1cmUgZnJvbSB0aGUgVGV4dHVyZUNhY2hlIGJhc2VkIG9uIHRoZSBmcmFtZUlkXHJcbiAqIFRoZSBmcmFtZSBpZHMgYXJlIGNyZWF0ZWQgd2hlbiBhIFRleHR1cmUgcGFja2VyIGZpbGUgaGFzIGJlZW4gbG9hZGVkXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIGZyYW1lSWQge3N0cmluZ30gVGhlIGZyYW1lIElkIG9mIHRoZSB0ZXh0dXJlIGluIHRoZSBjYWNoZVxyXG4gKiBAcmV0dXJuIHtQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IEEgbmV3IFRpbGluZ1Nwcml0ZSB1c2luZyBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZSBjYWNoZSBtYXRjaGluZyB0aGUgZnJhbWVJZFxyXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gIHRoZSB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxyXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcclxuICovXHJcblRpbGluZ1Nwcml0ZS5mcm9tRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJZCx3aWR0aCxoZWlnaHQpXHJcbntcclxuICAgIHZhciB0ZXh0dXJlID0gY29yZS51dGlscy5UZXh0dXJlQ2FjaGVbZnJhbWVJZF07XHJcblxyXG4gICAgaWYgKCF0ZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZyYW1lSWQgXCInICsgZnJhbWVJZCArICdcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSAnICsgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUaWxpbmdTcHJpdGUodGV4dHVyZSx3aWR0aCxoZWlnaHQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGJhc2VkIG9uIGFuIGltYWdlIHVybFxyXG4gKiBJZiB0aGUgaW1hZ2UgaXMgbm90IGluIHRoZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgbG9hZGVkXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIGltYWdlSWQge3N0cmluZ30gVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxyXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gIHRoZSB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxyXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcclxuICogQHBhcmFtIFtjcm9zc29yaWdpbj0oYXV0byldIHtib29sZWFufSBpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSBjcm9zcy1vcmlnaW4gcGFyYW1ldGVyXHJcbiAqIEBwYXJhbSBbc2NhbGVNb2RlPVBJWEkuU0NBTEVfTU9ERVMuREVGQVVMVF0ge251bWJlcn0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgc2NhbGUgbW9kZSwgc2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXHJcbiAqIEByZXR1cm4ge1BJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gQSBuZXcgVGlsaW5nU3ByaXRlIHVzaW5nIGEgdGV4dHVyZSBmcm9tIHRoZSB0ZXh0dXJlIGNhY2hlIG1hdGNoaW5nIHRoZSBpbWFnZSBpZFxyXG4gKi9cclxuVGlsaW5nU3ByaXRlLmZyb21JbWFnZSA9IGZ1bmN0aW9uIChpbWFnZUlkLCB3aWR0aCwgaGVpZ2h0LCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFRpbGluZ1Nwcml0ZShjb3JlLlRleHR1cmUuZnJvbUltYWdlKGltYWdlSWQsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUpLHdpZHRoLGhlaWdodCk7XHJcbn07XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpLFxyXG4gICAgRGlzcGxheU9iamVjdCA9IGNvcmUuRGlzcGxheU9iamVjdCxcclxuICAgIF90ZW1wTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XHJcblxyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcCA9IGZhbHNlO1xyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fb3JpZ2luYWxSZW5kZXJXZWJHTCA9IG51bGw7XHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9vcmlnaW5hbFJlbmRlckNhbnZhcyA9IG51bGw7XHJcblxyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fb3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSBudWxsO1xyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fb3JpZ2luYWxIaXRUZXN0ID0gbnVsbDtcclxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX29yaWdpbmFsRGVzdHJveSA9IG51bGw7XHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZWRTcHJpdGUgPSBudWxsO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGlzcGxheU9iamVjdC5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgdGhpcyBkaXNwbGF5IG9iamVjdCB0byBiZSBjYWNoZWQgYXMgYSBiaXRtYXAuXHJcbiAgICAgKiBUaGlzIGJhc2ljYWxseSB0YWtlcyBhIHNuYXAgc2hvdCBvZiB0aGUgZGlzcGxheSBvYmplY3QgYXMgaXQgaXMgYXQgdGhhdCBtb21lbnQuIEl0IGNhbiBwcm92aWRlIGEgcGVyZm9ybWFuY2UgYmVuZWZpdCBmb3IgY29tcGxleCBzdGF0aWMgZGlzcGxheU9iamVjdHMuXHJcbiAgICAgKiBUbyByZW1vdmUgc2ltcGx5IHNldCB0aGlzIHByb3BlcnR5IHRvICdmYWxzZSdcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAqL1xyXG4gICAgY2FjaGVBc0JpdG1hcDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUFzQml0bWFwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVBc0JpdG1hcCA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFJlbmRlcldlYkdMID0gdGhpcy5yZW5kZXJXZWJHTDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsUmVuZGVyQ2FudmFzID0gdGhpcy5yZW5kZXJDYW52YXM7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSB0aGlzLnVwZGF0ZVRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsR2V0Qm91bmRzID0gdGhpcy5nZXRCb3VuZHM7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxEZXN0cm95ID0gdGhpcy5kZXN0cm95O1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsQ29udGFpbnNQb2ludCA9IHRoaXMuY29udGFpbnNQb2ludDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcldlYkdMID0gdGhpcy5fcmVuZGVyQ2FjaGVkV2ViR0w7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX3JlbmRlckNhY2hlZENhbnZhcztcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLl9jYWNoZUFzQml0bWFwRGVzdHJveTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVkU3ByaXRlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJXZWJHTCA9IHRoaXMuX29yaWdpbmFsUmVuZGVyV2ViR0w7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX29yaWdpbmFsUmVuZGVyQ2FudmFzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRCb3VuZHMgPSB0aGlzLl9vcmlnaW5hbEdldEJvdW5kcztcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLl9vcmlnaW5hbERlc3Ryb3k7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLl9vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbnNQb2ludCA9IHRoaXMuX29yaWdpbmFsQ29udGFpbnNQb2ludDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG4qIFJlbmRlcnMgYSBjYWNoZWQgdmVyc2lvbiBvZiB0aGUgc3ByaXRlIHdpdGggV2ViR0xcclxuKlxyXG4qIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSB0aGUgV2ViR0wgcmVuZGVyZXJcclxuKiBAcHJpdmF0ZVxyXG4qL1xyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fcmVuZGVyQ2FjaGVkV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpXHJcbntcclxuICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0KCByZW5kZXJlciApO1xyXG5cclxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xyXG5cclxuICAgIHJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnMuc3ByaXRlKTtcclxuICAgIHJlbmRlcmVyLnBsdWdpbnMuc3ByaXRlLnJlbmRlciggdGhpcy5fY2FjaGVkU3ByaXRlICk7XHJcbn07XHJcblxyXG4vKipcclxuKiBQcmVwYXJlcyB0aGUgV2ViR0wgcmVuZGVyZXIgdG8gY2FjaGUgdGhlIHNwcml0ZVxyXG4qXHJcbiogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHRoZSBXZWJHTCByZW5kZXJlclxyXG4qIEBwcml2YXRlXHJcbiovXHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uIChyZW5kZXJlcilcclxue1xyXG4gICAgaWYodGhpcy5fY2FjaGVkU3ByaXRlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmaXJzdCB3ZSBmbHVzaCBhbnl0aGluZyBsZWZ0IGluIHRoZSByZW5kZXJlciAob3RoZXJ3aXNlIGl0IHdvdWxkIGdldCByZW5kZXJlZCB0byB0aGUgY2FjaGVkIHRleHR1cmUpXHJcbiAgICByZW5kZXJlci5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuICAgIC8vdGhpcy5maWx0ZXJzPSBbXTtcclxuICAgIC8vIG5leHQgd2UgZmluZCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdW50cmFuc2Zvcm1lZCBvYmplY3RcclxuICAgIC8vIHRoaXMgZnVuY3Rpb24gYWxzbyBjYWxscyB1cGRhdGV0cmFuc2Zvcm0gb24gYWxsIGl0cyBjaGlsZHJlbiBhcyBwYXJ0IG9mIHRoZSBtZWFzdXJpbmcuIFRoaXMgbWVhbnMgd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIHRyYW5zZm9ybSBhZ2FpbiBpbiB0aGlzIGZ1bmN0aW9uXHJcbiAgICAvLyBUT0RPIHBhc3MgYW4gb2JqZWN0IHRvIGNsb25lIHRvbz8gc2F2ZXMgaGF2aW5nIHRvIGNyZWF0ZSBhIG5ldyBvbmUgZWFjaCB0aW1lIVxyXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5jbG9uZSgpO1xyXG5cclxuICAgIC8vIGFkZCBzb21lIHBhZGRpbmchXHJcbiAgICBpZih0aGlzLl9maWx0ZXJzKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5fZmlsdGVyc1swXS5wYWRkaW5nO1xyXG4gICAgICAgIGJvdW5kcy54IC09IHBhZGRpbmc7XHJcbiAgICAgICAgYm91bmRzLnkgLT0gcGFkZGluZztcclxuXHJcbiAgICAgICAgYm91bmRzLndpZHRoICs9IHBhZGRpbmcgKiAyO1xyXG4gICAgICAgIGJvdW5kcy5oZWlnaHQgKz0gcGFkZGluZyAqIDI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZm9yIG5vdyB3ZSBjYWNoZSB0aGUgY3VycmVudCByZW5kZXJUYXJnZXQgdGhhdCB0aGUgd2ViR0wgcmVuZGVyZXIgaXMgY3VycmVudGx5IHVzaW5nLlxyXG4gICAgLy8gdGhpcyBjb3VsZCBiZSBtb3JlIGVsZWdlbnQuLlxyXG4gICAgdmFyIGNhY2hlZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQ7XHJcbiAgICAvLyBXZSBhbHNvIHN0b3JlIHRoZSBmaWx0ZXIgc3RhY2sgLSBJIHdpbGwgZGVmaW5pdGVseSBsb29rIHRvIGNoYW5nZSBob3cgdGhpcyB3b3JrcyBhIGxpdHRsZSBsYXRlciBkb3duIHRoZSBsaW5lLlxyXG4gICAgdmFyIHN0YWNrID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5maWx0ZXJTdGFjaztcclxuXHJcbiAgICAvLyB0aGlzIHJlbmRlclRleHR1cmUgd2lsbCBiZSB1c2VkIHRvIHN0b3JlIHRoZSBjYWNoZWQgRGlzcGxheU9iamVjdFxyXG4gICAgdmFyIHJlbmRlclRleHR1cmUgPSBuZXcgY29yZS5SZW5kZXJUZXh0dXJlKHJlbmRlcmVyLCBib3VuZHMud2lkdGggfCAwLCBib3VuZHMuaGVpZ2h0IHwgMCk7XHJcblxyXG4gICAgLy8gbmVlZCB0byBzZXQgLy9cclxuICAgIHZhciBtID0gX3RlbXBNYXRyaXg7XHJcblxyXG4gICAgbS50eCA9IC1ib3VuZHMueDtcclxuICAgIG0udHkgPSAtYm91bmRzLnk7XHJcblxyXG5cclxuXHJcbiAgICAvLyBzZXQgYWxsIHByb3BlcnRpZXMgdG8gdGhlcmUgb3JpZ2luYWwgc28gd2UgY2FuIHJlbmRlciB0byBhIHRleHR1cmVcclxuICAgIHRoaXMucmVuZGVyV2ViR0wgPSB0aGlzLl9vcmlnaW5hbFJlbmRlcldlYkdMO1xyXG5cclxuICAgIHJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMsIG0sIHRydWUsIHRydWUpO1xyXG5cclxuICAgIC8vIG5vdyByZXN0b3JlIHRoZSBzdGF0ZSBiZSBzZXR0aW5nIHRoZSBuZXcgcHJvcGVydGllc1xyXG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGNhY2hlZFJlbmRlclRhcmdldCk7XHJcbiAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmZpbHRlclN0YWNrID0gc3RhY2s7XHJcblxyXG4gICAgdGhpcy5yZW5kZXJXZWJHTCAgICAgPSB0aGlzLl9yZW5kZXJDYWNoZWRXZWJHTDtcclxuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtO1xyXG4gICAgdGhpcy5nZXRCb3VuZHMgICAgICAgPSB0aGlzLl9nZXRDYWNoZWRCb3VuZHM7XHJcblxyXG5cclxuICAgIC8vIGNyZWF0ZSBvdXIgY2FjaGVkIHNwcml0ZVxyXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbmV3IGNvcmUuU3ByaXRlKHJlbmRlclRleHR1cmUpO1xyXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkVHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcclxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oIGJvdW5kcy54IC8gYm91bmRzLndpZHRoICk7XHJcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKCBib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQgKTtcclxuXHJcbiAgICAvLyByZXN0b3JlIHRoZSB0cmFuc2Zvcm0gb2YgdGhlIGNhY2hlZCBzcHJpdGUgdG8gYXZvaWQgdGhlIG5hc3R5IGZsaWNrZXIuLlxyXG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAvLyBtYXAgdGhlIGhpdCB0ZXN0Li5cclxuICAgIHRoaXMuY29udGFpbnNQb2ludCA9IHRoaXMuX2NhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQodGhpcy5fY2FjaGVkU3ByaXRlKTtcclxufTtcclxuXHJcbi8qKlxyXG4qIFJlbmRlcnMgYSBjYWNoZWQgdmVyc2lvbiBvZiB0aGUgc3ByaXRlIHdpdGggY2FudmFzXHJcbipcclxuKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IHRoZSBDYW52YXMgcmVuZGVyZXJcclxuKiBAcHJpdmF0ZVxyXG4qL1xyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fcmVuZGVyQ2FjaGVkQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxyXG57XHJcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhcyggcmVuZGVyZXIgKTtcclxuXHJcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcclxuXHJcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUucmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcclxufTtcclxuXHJcbi8vVE9ETyB0aGlzIGNhbiBiZSB0aGUgc2FtZSBhcyB0aGUgd2ViR0wgdmVyaXNvbi4uIHdpbGwgbmVlZCB0byBkbyBhIGxpdHRsZSB0d2Vha2luZyBmaXJzdCB0aG91Z2guLlxyXG4vKipcclxuKiBQcmVwYXJlcyB0aGUgQ2FudmFzIHJlbmRlcmVyIHRvIGNhY2hlIHRoZSBzcHJpdGVcclxuKlxyXG4qIEBwYXJhbSByZW5kZXJlciB7UElYSS5DYW52YXNSZW5kZXJlcn0gdGhlIENhbnZhcyByZW5kZXJlclxyXG4qIEBwcml2YXRlXHJcbiovXHJcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhcyA9IGZ1bmN0aW9uIChyZW5kZXJlcilcclxue1xyXG4gICAgaWYodGhpcy5fY2FjaGVkU3ByaXRlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvL2dldCBib3VuZHMgYWN0dWFsbHkgdHJhbnNmb3JtcyB0aGUgb2JqZWN0IGZvciB1cyBhbHJlYWR5IVxyXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcclxuXHJcbiAgICB2YXIgY2FjaGVkUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHJcbiAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBjb3JlLlJlbmRlclRleHR1cmUocmVuZGVyZXIsIGJvdW5kcy53aWR0aCB8IDAsIGJvdW5kcy5oZWlnaHQgfCAwKTtcclxuXHJcbiAgICAvLyBuZWVkIHRvIHNldCAvL1xyXG4gICAgdmFyIG0gPSBfdGVtcE1hdHJpeDtcclxuXHJcbiAgICBtLnR4ID0gLWJvdW5kcy54O1xyXG4gICAgbS50eSA9IC1ib3VuZHMueTtcclxuXHJcbiAgICAvLyBzZXQgYWxsIHByb3BlcnRpZXMgdG8gdGhlcmUgb3JpZ2luYWwgc28gd2UgY2FuIHJlbmRlciB0byBhIHRleHR1cmVcclxuICAgIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fb3JpZ2luYWxSZW5kZXJDYW52YXM7XHJcblxyXG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcywgbSwgdHJ1ZSk7XHJcblxyXG4gICAgLy8gbm93IHJlc3RvcmUgdGhlIHN0YXRlIGJlIHNldHRpbmcgdGhlIG5ldyBwcm9wZXJ0aWVzXHJcbiAgICByZW5kZXJlci5jb250ZXh0ID0gY2FjaGVkUmVuZGVyVGFyZ2V0O1xyXG5cclxuICAgIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fcmVuZGVyQ2FjaGVkQ2FudmFzO1xyXG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm07XHJcbiAgICB0aGlzLmdldEJvdW5kcyAgPSB0aGlzLl9nZXRDYWNoZWRCb3VuZHM7XHJcblxyXG5cclxuICAgIC8vIGNyZWF0ZSBvdXIgY2FjaGVkIHNwcml0ZVxyXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbmV3IGNvcmUuU3ByaXRlKHJlbmRlclRleHR1cmUpO1xyXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkVHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcclxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oIGJvdW5kcy54IC8gYm91bmRzLndpZHRoICk7XHJcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKCBib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQgKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgIHRoaXMuY29udGFpbnNQb2ludCA9IHRoaXMuX2NhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQodGhpcy5fY2FjaGVkU3ByaXRlKTtcclxufTtcclxuXHJcbi8qKlxyXG4qIENhbGN1bGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGVkIHNwcml0ZVxyXG4qXHJcbiogQHByaXZhdGVcclxuKi9cclxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2dldENhY2hlZEJvdW5kcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5fY3VycmVudEJvdW5kcyA9IG51bGw7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNwcml0ZS5nZXRCb3VuZHMoKTtcclxufTtcclxuXHJcbi8qKlxyXG4qIERlc3Ryb3lzIHRoZSBjYWNoZWQgc3ByaXRlLlxyXG4qXHJcbiogQHByaXZhdGVcclxuKi9cclxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLl90ZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZSA9IG51bGw7XHJcbn07XHJcblxyXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcERlc3Ryb3kgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLmNhY2hlQXNCaXRtYXAgPSBmYWxzZTtcclxuICAgIHRoaXMuX29yaWdpbmFsRGVzdHJveSgpO1xyXG59O1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgaW5zdGFuY2UgbmFtZSBvZiB0aGUgb2JqZWN0LlxyXG4gKlxyXG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAqL1xyXG5jb3JlLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLm5hbWUgPSBudWxsO1xyXG5cclxuLyoqXHJcbiogUmV0dXJucyB0aGUgZGlzcGxheSBvYmplY3QgaW4gdGhlIGNvbnRhaW5lclxyXG4qXHJcbiogQG1lbWJlcm9mIFBJWEkuQ29udGFpbmVyI1xyXG4qIEBwYXJhbSBuYW1lIHtzdHJpbmd9IGluc3RhbmNlIG5hbWVcclxuKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9XHJcbiovXHJcbmNvcmUuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRDaGlsZEJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcclxuXHJcbi8qKlxyXG4qIFJldHVybnMgdGhlIGdsb2JhbCBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdFxyXG4qXHJcbiogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuKiBAcGFyYW0gcG9pbnQge1BvaW50fSB0aGUgcG9pbnQgdG8gd3JpdGUgdGhlIGdsb2JhbCB2YWx1ZSB0by4gSWYgbnVsbCBhIG5ldyBwb2ludCB3aWxsIGJlIHJldHVybmVkXHJcbiogQHJldHVybiB7UG9pbnR9XHJcbiovXHJcbmNvcmUuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZ2V0R2xvYmFsUG9zaXRpb24gPSBmdW5jdGlvbiAocG9pbnQpXHJcbntcclxuICAgIHBvaW50ID0gcG9pbnQgfHwgbmV3IGNvcmUuUG9pbnQoKTtcclxuXHJcbiAgICBpZih0aGlzLnBhcmVudClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgcG9pbnQueCA9IHRoaXMud29ybGRUcmFuc2Zvcm0udHg7XHJcbiAgICAgICAgcG9pbnQueSA9IHRoaXMud29ybGRUcmFuc2Zvcm0udHk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcG9pbnQueCA9IHRoaXMucG9zaXRpb24ueDtcclxuICAgICAgICBwb2ludC55ID0gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuIiwiLyoqXHJcbiAqIEBmaWxlICAgICAgICBNYWluIGV4cG9ydCBvZiB0aGUgUElYSSBleHRyYXMgbGlicmFyeVxyXG4gKiBAYXV0aG9yICAgICAgTWF0IEdyb3ZlcyA8bWF0QGdvb2Rib3lkaWdpdGFsLmNvbT5cclxuICogQGNvcHlyaWdodCAgIDIwMTMtMjAxNSBHb29kQm95RGlnaXRhbFxyXG4gKiBAbGljZW5zZSAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS5qcy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVCBMaWNlbnNlfVxyXG4gKi9cclxuXHJcbnJlcXVpcmUoJy4vY2FjaGVBc0JpdG1hcCcpO1xyXG5yZXF1aXJlKCcuL2dldENoaWxkQnlOYW1lJyk7XHJcbnJlcXVpcmUoJy4vZ2V0R2xvYmFsUG9zaXRpb24nKTtcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIFBJWEkuZXh0cmFzXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIE1vdmllQ2xpcDogICAgICByZXF1aXJlKCcuL01vdmllQ2xpcCcpLFxyXG4gICAgVGlsaW5nU3ByaXRlOiAgIHJlcXVpcmUoJy4vVGlsaW5nU3ByaXRlJyksXHJcbiAgICBCaXRtYXBUZXh0OiAgICAgcmVxdWlyZSgnLi9CaXRtYXBUZXh0JylcclxufTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XHJcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XHJcblxyXG5cclxuLy8gVE9ETyAoY2VuZ2xlcikgLSBUaGUgWSBpcyBmbGlwcGVkIGluIHRoaXMgc2hhZGVyIGZvciBzb21lIHJlYXNvbi5cclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFZpY28gQHZpY29jb3RlYVxyXG4gKiBvcmlnaW5hbCBzaGFkZXIgOiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvbHNzR0RqIGJ5IEBtb3ZBWDEzaFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBbiBBU0NJSSBmaWx0ZXIuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIEFzY2lpRmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzQgZGltZW5zaW9ucztcXHJcXG51bmlmb3JtIGZsb2F0IHBpeGVsU2l6ZTtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG5cXHJcXG5mbG9hdCBjaGFyYWN0ZXIoZmxvYXQgbiwgdmVjMiBwKVxcclxcbntcXHJcXG4gICAgcCA9IGZsb29yKHAqdmVjMig0LjAsIC00LjApICsgMi41KTtcXHJcXG4gICAgaWYgKGNsYW1wKHAueCwgMC4wLCA0LjApID09IHAueCAmJiBjbGFtcChwLnksIDAuMCwgNC4wKSA9PSBwLnkpXFxyXFxuICAgIHtcXHJcXG4gICAgICAgIGlmIChpbnQobW9kKG4vZXhwMihwLnggKyA1LjAqcC55KSwgMi4wKSkgPT0gMSkgcmV0dXJuIDEuMDtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gMC4wO1xcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4oKVxcclxcbntcXHJcXG4gICAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eTtcXHJcXG5cXHJcXG4gICAgdmVjMyBjb2wgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGZsb29yKCB1diAvIHBpeGVsU2l6ZSApICogcGl4ZWxTaXplIC8gZGltZW5zaW9ucy54eSkucmdiO1xcclxcblxcclxcbiAgICBmbG9hdCBncmF5ID0gKGNvbC5yICsgY29sLmcgKyBjb2wuYikgLyAzLjA7XFxyXFxuXFxyXFxuICAgIGZsb2F0IG4gPSAgNjU1MzYuMDsgICAgICAgICAgICAgLy8gLlxcclxcbiAgICBpZiAoZ3JheSA+IDAuMikgbiA9IDY1NjAwLjA7ICAgIC8vIDpcXHJcXG4gICAgaWYgKGdyYXkgPiAwLjMpIG4gPSAzMzI3NzIuMDsgICAvLyAqXFxyXFxuICAgIGlmIChncmF5ID4gMC40KSBuID0gMTUyNTUwODYuMDsgLy8gb1xcclxcbiAgICBpZiAoZ3JheSA+IDAuNSkgbiA9IDIzMzg1MTY0LjA7IC8vICZcXHJcXG4gICAgaWYgKGdyYXkgPiAwLjYpIG4gPSAxNTI1MjAxNC4wOyAvLyA4XFxyXFxuICAgIGlmIChncmF5ID4gMC43KSBuID0gMTMxOTk0NTIuMDsgLy8gQFxcclxcbiAgICBpZiAoZ3JheSA+IDAuOCkgbiA9IDExNTEyODEwLjA7IC8vICNcXHJcXG5cXHJcXG4gICAgdmVjMiBwID0gbW9kKCB1diAvICggcGl4ZWxTaXplICogMC41ICksIDIuMCkgLSB2ZWMyKDEuMCk7XFxyXFxuICAgIGNvbCA9IGNvbCAqIGNoYXJhY3RlcihuLCBwKTtcXHJcXG5cXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2wsIDEuMCk7XFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGltZW5zaW9uczogeyB0eXBlOiAnNGZ2JywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDBdKSB9LFxyXG4gICAgICAgICAgICBwaXhlbFNpemU6ICB7IHR5cGU6ICcxZicsIHZhbHVlOiA4IH1cclxuICAgICAgICB9XHJcbiAgICApO1xyXG59XHJcblxyXG5Bc2NpaUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcclxuQXNjaWlGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXNjaWlGaWx0ZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gQXNjaWlGaWx0ZXI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBc2NpaUZpbHRlci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBpeGVsIHNpemUgdXNlZCBieSB0aGUgZmlsdGVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQXNjaWlGaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIHNpemU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5waXhlbFNpemUudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucGl4ZWxTaXplLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyksXHJcbiAgICBCbHVyWEZpbHRlciA9IHJlcXVpcmUoJy4uL2JsdXIvQmx1clhGaWx0ZXInKSxcclxuICAgIEJsdXJZRmlsdGVyID0gcmVxdWlyZSgnLi4vYmx1ci9CbHVyWUZpbHRlcicpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBCbG9vbUZpbHRlciBhcHBsaWVzIGEgR2F1c3NpYW4gYmx1ciB0byBhbiBvYmplY3QuXHJcbiAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ciBjYW4gYmUgc2V0IGZvciB4LSBhbmQgeS1heGlzIHNlcGFyYXRlbHkuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIEJsb29tRmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuYmx1clhGaWx0ZXIgPSBuZXcgQmx1clhGaWx0ZXIoKTtcclxuICAgIHRoaXMuYmx1cllGaWx0ZXIgPSBuZXcgQmx1cllGaWx0ZXIoKTtcclxuXHJcbiAgICB0aGlzLmRlZmF1bHRGaWx0ZXIgPSBuZXcgY29yZS5BYnN0cmFjdEZpbHRlcigpO1xyXG59XHJcblxyXG5CbG9vbUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcclxuQmxvb21GaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmxvb21GaWx0ZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gQmxvb21GaWx0ZXI7XHJcblxyXG5CbG9vbUZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQpXHJcbntcclxuICAgIHZhciByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmdldFJlbmRlclRhcmdldCh0cnVlKTtcclxuXHJcbiAgICAvL1RPRE8gLSBjb3B5VGV4U3ViSW1hZ2UyRCBjb3VsZCBiZSB1c2VkIGhlcmU/XHJcbiAgICB0aGlzLmRlZmF1bHRGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQpO1xyXG5cclxuICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIGlucHV0LCByZW5kZXJUYXJnZXQpO1xyXG5cclxuICAgIHJlbmRlcmVyLmJsZW5kTW9kZU1hbmFnZXIuc2V0QmxlbmRNb2RlKGNvcmUuQkxFTkRfTU9ERVMuU0NSRUVOKTtcclxuXHJcbiAgICB0aGlzLmJsdXJZRmlsdGVyLmFwcGx5RmlsdGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXQsIG91dHB1dCk7XHJcblxyXG4gICAgcmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoY29yZS5CTEVORF9NT0RFUy5OT1JNQUwpO1xyXG5cclxuICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbG9vbUZpbHRlci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1clggYW5kIGJsdXJZIHByb3BlcnRpZXMgc2ltdWx0YW5lb3VzbHlcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyT2YgUElYSS5maWx0ZXJzLkJsb29tRmlsdGVyI1xyXG4gICAgICogQGRlZmF1bHQgMlxyXG4gICAgICovXHJcbiAgICBibHVyOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWCBwcm9wZXJ0eVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJPZiBQSVhJLmZpbHRlcnMuQmxvb21GaWx0ZXIjXHJcbiAgICAgKiBAZGVmYXVsdCAyXHJcbiAgICAgKi9cclxuICAgIGJsdXJYOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWSBwcm9wZXJ0eVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJPZiBQSVhJLmZpbHRlcnMuQmxvb21GaWx0ZXIjXHJcbiAgICAgKiBAZGVmYXVsdCAyXHJcbiAgICAgKi9cclxuICAgIGJsdXJZOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1cllGaWx0ZXIuYmx1cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBCbHVyRGlyRmlsdGVyIGFwcGxpZXMgYSBHYXVzc2lhbiBibHVyIHRvd2FyZCBhIGRpcmVjdGlvbiB0byBhbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZGlyWFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGlyWVxyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIEJsdXJEaXJGaWx0ZXIoZGlyWCwgZGlyWSlcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcclxcblxcclxcbnVuaWZvcm0gZmxvYXQgc3RyZW5ndGg7XFxyXFxudW5pZm9ybSBmbG9hdCBkaXJYO1xcclxcbnVuaWZvcm0gZmxvYXQgZGlyWTtcXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcbnZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1szXTtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoKGFWZXJ0ZXhQb3NpdGlvbiksIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbiAgICB2Qmx1clRleENvb3Jkc1swXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKCAoMC4wMDQgKiBzdHJlbmd0aCkgKiBkaXJYLCAoMC4wMDQgKiBzdHJlbmd0aCkgKiBkaXJZICk7XFxyXFxuICAgIHZCbHVyVGV4Q29vcmRzWzFdID0gYVRleHR1cmVDb29yZCArIHZlYzIoICgwLjAwOCAqIHN0cmVuZ3RoKSAqIGRpclgsICgwLjAwOCAqIHN0cmVuZ3RoKSAqIGRpclkgKTtcXHJcXG4gICAgdkJsdXJUZXhDb29yZHNbMl0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMiggKDAuMDEyICogc3RyZW5ndGgpICogZGlyWCwgKDAuMDEyICogc3RyZW5ndGgpICogZGlyWSApO1xcclxcblxcclxcbiAgICB2Q29sb3IgPSB2ZWM0KGFDb2xvci5yZ2IgKiBhQ29sb3IuYSwgYUNvbG9yLmEpO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBsb3dwIGZsb2F0O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1szXTtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1xcclxcblxcclxcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICAgICApICogMC4zOTg5NDIyODA0MDE0MzI3O1xcclxcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMF0pICogMC4yNDE5NzA3MjQ1MTkxNDU0O1xcclxcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMV0pICogMC4wNTM5OTA5NjY1MTMxODk4NTtcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDJdKSAqIDAuMDA0NDMxODQ4NDExOTM4MzQxO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdHJlbmd0aDogeyB0eXBlOiAnMWYnLCB2YWx1ZTogMSB9LFxyXG4gICAgICAgICAgICBkaXJYOiB7IHR5cGU6ICcxZicsIHZhbHVlOiBkaXJYIHx8IDAgfSxcclxuICAgICAgICAgICAgZGlyWTogeyB0eXBlOiAnMWYnLCB2YWx1ZTogZGlyWSB8fCAwIH1cclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuZGVmYXVsdEZpbHRlciA9IG5ldyBjb3JlLkFic3RyYWN0RmlsdGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcGFzc2VzIGZvciBibHVyLiBNb3JlIHBhc3NlcyBtZWFucyBoaWdoZXIgcXVhaWxpdHkgYmx1cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFzc2VzID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIFggZGlyZWN0aW9uIG9mIHRoZSBibHVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpclggPSBkaXJYIHx8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBZIGRpcmVjdGlvbiBvZiB0aGUgYmx1clxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG4gICAgdGhpcy5kaXJZID0gZGlyWSB8fCAwO1xyXG5cclxuICAgIHRoaXMuc3RyZW5ndGggPSA0O1xyXG59XHJcblxyXG5CbHVyRGlyRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xyXG5CbHVyRGlyRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsdXJEaXJGaWx0ZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gQmx1ckRpckZpbHRlcjtcclxuXHJcbkJsdXJEaXJGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcikge1xyXG5cclxuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XHJcblxyXG4gICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aC52YWx1ZSA9IHRoaXMuc3RyZW5ndGggLyA0IC8gdGhpcy5wYXNzZXMgKiAoaW5wdXQuZnJhbWUud2lkdGggLyBpbnB1dC5zaXplLndpZHRoKTtcclxuXHJcbiAgICBpZiAodGhpcy5wYXNzZXMgPT09IDEpIHtcclxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5nZXRSZW5kZXJUYXJnZXQodHJ1ZSk7XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBpbnB1dCwgcmVuZGVyVGFyZ2V0LCBjbGVhcik7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnBhc3Nlcy0yOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL3RoaXMudW5pZm9ybXMuc3RyZW5ndGgudmFsdWUgPSB0aGlzLnN0cmVuZ3RoIC8gNCAvICh0aGlzLnBhc3NlcysoaSoyKSkgKiAoaW5wdXQuZnJhbWUud2lkdGggLyBpbnB1dC5zaXplLndpZHRoKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcihzaGFkZXIsIHJlbmRlclRhcmdldCwgcmVuZGVyVGFyZ2V0LCBjbGVhcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQsIGNsZWFyKTtcclxuXHJcbiAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5yZXR1cm5SZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbHVyRGlyRmlsdGVyLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBib3RoIHRoZSBibHVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQmx1ckRpckZpbHRlciNcclxuICAgICAqIEBkZWZhdWx0IDJcclxuICAgICAqL1xyXG4gICAgYmx1cjoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSB2YWx1ZSAqIDAuNTtcclxuICAgICAgICAgICAgdGhpcy5zdHJlbmd0aCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIFggZGlyZWN0aW9uIG9mIHRoZSBibHVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQmx1cllGaWx0ZXIjXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIGRpclg6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJYO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmRpclgudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBZIGRpcmVjdGlvbiBvZiB0aGUgYmx1ci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkJsdXJEaXJGaWx0ZXIjXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIGRpclk6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJZO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmRpclkudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKSxcclxuICAgIEJsdXJYRmlsdGVyID0gcmVxdWlyZSgnLi9CbHVyWEZpbHRlcicpLFxyXG4gICAgQmx1cllGaWx0ZXIgPSByZXF1aXJlKCcuL0JsdXJZRmlsdGVyJyk7XHJcblxyXG4vKipcclxuICogVGhlIEJsdXJGaWx0ZXIgYXBwbGllcyBhIEdhdXNzaWFuIGJsdXIgdG8gYW4gb2JqZWN0LlxyXG4gKiBUaGUgc3RyZW5ndGggb2YgdGhlIGJsdXIgY2FuIGJlIHNldCBmb3IgeC0gYW5kIHktYXhpcyBzZXBhcmF0ZWx5LlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBCbHVyRmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuYmx1clhGaWx0ZXIgPSBuZXcgQmx1clhGaWx0ZXIoKTtcclxuICAgIHRoaXMuYmx1cllGaWx0ZXIgPSBuZXcgQmx1cllGaWx0ZXIoKTtcclxufVxyXG5cclxuQmx1ckZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcclxuQmx1ckZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbHVyRmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEJsdXJGaWx0ZXI7XHJcblxyXG5CbHVyRmlsdGVyLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgaW5wdXQsIG91dHB1dClcclxue1xyXG4gICAgdmFyIHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZ2V0UmVuZGVyVGFyZ2V0KHRydWUpO1xyXG5cclxuICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIGlucHV0LCByZW5kZXJUYXJnZXQpO1xyXG4gICAgdGhpcy5ibHVyWUZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQpO1xyXG5cclxuICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbHVyRmlsdGVyLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBib3RoIHRoZSBibHVyWCBhbmQgYmx1clkgcHJvcGVydGllcyBzaW11bHRhbmVvdXNseVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJPZiBQSVhJLmZpbHRlcnMuQmx1ckZpbHRlciNcclxuICAgICAqIEBkZWZhdWx0IDJcclxuICAgICAqL1xyXG4gICAgYmx1cjoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucGFkZGluZyA9IE1hdGguYWJzKHZhbHVlKSAqIDAuNTtcclxuICAgICAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwYXNzZXMgZm9yIGJsdXIuIE1vcmUgcGFzc2VzIG1lYW5zIGhpZ2hlciBxdWFpbGl0eSBibHVyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQmx1cllGaWx0ZXIjXHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuICAgIHBhc3Nlczoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAgdGhpcy5ibHVyWEZpbHRlci5wYXNzZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1clhGaWx0ZXIucGFzc2VzID0gdGhpcy5ibHVyWUZpbHRlci5wYXNzZXMgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJYIHByb3BlcnR5XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlck9mIFBJWEkuZmlsdGVycy5CbHVyRmlsdGVyI1xyXG4gICAgICogQGRlZmF1bHQgMlxyXG4gICAgICovXHJcbiAgICBibHVyWDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyT2YgUElYSS5maWx0ZXJzLkJsdXJGaWx0ZXIjXHJcbiAgICAgKiBAZGVmYXVsdCAyXHJcbiAgICAgKi9cclxuICAgIGJsdXJZOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1cllGaWx0ZXIuYmx1cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XHJcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBCbHVyWEZpbHRlciBhcHBsaWVzIGEgaG9yaXpvbnRhbCBHYXVzc2lhbiBibHVyIHRvIGFuIG9iamVjdC5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gQmx1clhGaWx0ZXIoKVxyXG57XHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5hdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcbnZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1s2XTtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoKGFWZXJ0ZXhQb3NpdGlvbiksIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbiAgICB2Qmx1clRleENvb3Jkc1sgMF0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigtMC4wMTIgKiBzdHJlbmd0aCwgMC4wKTtcXHJcXG4gICAgdkJsdXJUZXhDb29yZHNbIDFdID0gYVRleHR1cmVDb29yZCArIHZlYzIoLTAuMDA4ICogc3RyZW5ndGgsIDAuMCk7XFxyXFxuICAgIHZCbHVyVGV4Q29vcmRzWyAyXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKC0wLjAwNCAqIHN0cmVuZ3RoLCAwLjApO1xcclxcbiAgICB2Qmx1clRleENvb3Jkc1sgM10gPSBhVGV4dHVyZUNvb3JkICsgdmVjMiggMC4wMDQgKiBzdHJlbmd0aCwgMC4wKTtcXHJcXG4gICAgdkJsdXJUZXhDb29yZHNbIDRdID0gYVRleHR1cmVDb29yZCArIHZlYzIoIDAuMDA4ICogc3RyZW5ndGgsIDAuMCk7XFxyXFxuICAgIHZCbHVyVGV4Q29vcmRzWyA1XSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKCAwLjAxMiAqIHN0cmVuZ3RoLCAwLjApO1xcclxcblxcclxcbiAgICB2Q29sb3IgPSB2ZWM0KGFDb2xvci5yZ2IgKiBhQ29sb3IuYSwgYUNvbG9yLmEpO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBsb3dwIGZsb2F0O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1s2XTtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1xcclxcblxcclxcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMF0pKjAuMDA0NDMxODQ4NDExOTM4MzQxO1xcclxcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMV0pKjAuMDUzOTkwOTY2NTEzMTg5ODU7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAyXSkqMC4yNDE5NzA3MjQ1MTkxNDU0O1xcclxcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICAgICApKjAuMzk4OTQyMjgwNDAxNDMyNztcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDNdKSowLjI0MTk3MDcyNDUxOTE0NTQ7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyA0XSkqMC4wNTM5OTA5NjY1MTMxODk4NTtcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDVdKSowLjAwNDQzMTg0ODQxMTkzODM0MTtcXHJcXG59XFxyXFxuXCIsXHJcbiAgICAgICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3RyZW5ndGg6IHsgdHlwZTogJzFmJywgdmFsdWU6IDEgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcGFzc2VzIGZvciBibHVyLiBNb3JlIHBhc3NlcyBtZWFucyBoaWdoZXIgcXVhaWxpdHkgYmx1cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFzc2VzID0gMTtcclxuXHJcbiAgICB0aGlzLnN0cmVuZ3RoID0gNDtcclxufVxyXG5cclxuQmx1clhGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcbkJsdXJYRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsdXJYRmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEJsdXJYRmlsdGVyO1xyXG5cclxuQmx1clhGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcilcclxue1xyXG4gICAgdmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKHJlbmRlcmVyKTtcclxuXHJcbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gdGhpcy5zdHJlbmd0aCAvIDQgLyB0aGlzLnBhc3NlcyAqIChpbnB1dC5mcmFtZS53aWR0aCAvIGlucHV0LnNpemUud2lkdGgpO1xyXG5cclxuICAgIGlmKHRoaXMucGFzc2VzID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZ2V0UmVuZGVyVGFyZ2V0KHRydWUpO1xyXG4gICAgICAgIHZhciBmbGlwID0gaW5wdXQ7XHJcbiAgICAgICAgdmFyIGZsb3AgPSByZW5kZXJUYXJnZXQ7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnBhc3Nlcy0xOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgZmxpcCwgZmxvcCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgIHZhciB0ZW1wID0gZmxvcDtcclxuICAgICAgICAgICBmbG9wID0gZmxpcDtcclxuICAgICAgICAgICBmbGlwID0gdGVtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBmbGlwLCBvdXRwdXQsIGNsZWFyKTtcclxuXHJcbiAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5yZXR1cm5SZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbHVyWEZpbHRlci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1ci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkJsdXJYRmlsdGVyI1xyXG4gICAgICogQGRlZmF1bHQgMlxyXG4gICAgICovXHJcbiAgICBibHVyOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICB0aGlzLnN0cmVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSAgTWF0aC5hYnModmFsdWUpICogMC41O1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVuZ3RoID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XHJcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBCbHVyWUZpbHRlciBhcHBsaWVzIGEgaG9yaXpvbnRhbCBHYXVzc2lhbiBibHVyIHRvIGFuIG9iamVjdC5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gQmx1cllGaWx0ZXIoKVxyXG57XHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5hdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcbnZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1s2XTtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoKGFWZXJ0ZXhQb3NpdGlvbiksIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbiAgICB2Qmx1clRleENvb3Jkc1sgMF0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsIC0wLjAxMiAqIHN0cmVuZ3RoKTtcXHJcXG4gICAgdkJsdXJUZXhDb29yZHNbIDFdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAtMC4wMDggKiBzdHJlbmd0aCk7XFxyXFxuICAgIHZCbHVyVGV4Q29vcmRzWyAyXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgLTAuMDA0ICogc3RyZW5ndGgpO1xcclxcbiAgICB2Qmx1clRleENvb3Jkc1sgM10gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsICAwLjAwNCAqIHN0cmVuZ3RoKTtcXHJcXG4gICAgdkJsdXJUZXhDb29yZHNbIDRdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAgMC4wMDggKiBzdHJlbmd0aCk7XFxyXFxuICAgIHZCbHVyVGV4Q29vcmRzWyA1XSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgIDAuMDEyICogc3RyZW5ndGgpO1xcclxcblxcclxcbiAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7XFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxyXG4gICAgICAgIFwicHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWzZdO1xcclxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7XFxyXFxuXFxyXFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAwXSkqMC4wMDQ0MzE4NDg0MTE5MzgzNDE7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAxXSkqMC4wNTM5OTA5NjY1MTMxODk4NTtcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDJdKSowLjI0MTk3MDcyNDUxOTE0NTQ7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgICAgICkqMC4zOTg5NDIyODA0MDE0MzI3O1xcclxcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgM10pKjAuMjQxOTcwNzI0NTE5MTQ1NDtcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDRdKSowLjA1Mzk5MDk2NjUxMzE4OTg1O1xcclxcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgNV0pKjAuMDA0NDMxODQ4NDExOTM4MzQxO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdHJlbmd0aDogeyB0eXBlOiAnMWYnLCB2YWx1ZTogMSB9XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLnBhc3NlcyA9IDE7XHJcbiAgICB0aGlzLnN0cmVuZ3RoID0gNDtcclxufVxyXG5cclxuQmx1cllGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcbkJsdXJZRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsdXJZRmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEJsdXJZRmlsdGVyO1xyXG5cclxuQmx1cllGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcilcclxue1xyXG4gICAgdmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKHJlbmRlcmVyKTtcclxuXHJcbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gTWF0aC5hYnModGhpcy5zdHJlbmd0aCkgLyA0IC8gdGhpcy5wYXNzZXMgKiAoaW5wdXQuZnJhbWUuaGVpZ2h0IC8gaW5wdXQuc2l6ZS5oZWlnaHQpO1xyXG5cclxuICAgIGlmKHRoaXMucGFzc2VzID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZ2V0UmVuZGVyVGFyZ2V0KHRydWUpO1xyXG4gICAgICAgIHZhciBmbGlwID0gaW5wdXQ7XHJcbiAgICAgICAgdmFyIGZsb3AgPSByZW5kZXJUYXJnZXQ7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnBhc3Nlcy0xOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgZmxpcCwgZmxvcCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgIHZhciB0ZW1wID0gZmxvcDtcclxuICAgICAgICAgICBmbG9wID0gZmxpcDtcclxuICAgICAgICAgICBmbGlwID0gdGVtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBmbGlwLCBvdXRwdXQsIGNsZWFyKTtcclxuXHJcbiAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5yZXR1cm5SZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbHVyWUZpbHRlci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1ci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkJsdXJZRmlsdGVyI1xyXG4gICAgICogQGRlZmF1bHQgMlxyXG4gICAgICovXHJcbiAgICBibHVyOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICB0aGlzLnN0cmVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSBNYXRoLmFicyh2YWx1ZSkgKiAwLjU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZW5ndGggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcclxuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcclxuXHJcblxyXG4vKipcclxuICogQSBTbWFydCBCbHVyIEZpbHRlci5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gU21hcnRCbHVyRmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIHZlYzIgZGVsdGE7XFxyXFxuXFxyXFxuZmxvYXQgcmFuZG9tKHZlYzMgc2NhbGUsIGZsb2F0IHNlZWQpXFxyXFxue1xcclxcbiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChnbF9GcmFnQ29vcmQueHl6ICsgc2VlZCwgc2NhbGUpKSAqIDQzNzU4LjU0NTMgKyBzZWVkKTtcXHJcXG59XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcclxcbiAgICBmbG9hdCB0b3RhbCA9IDAuMDtcXHJcXG5cXHJcXG4gICAgZmxvYXQgb2Zmc2V0ID0gcmFuZG9tKHZlYzMoMTIuOTg5OCwgNzguMjMzLCAxNTEuNzE4MiksIDAuMCk7XFxyXFxuXFxyXFxuICAgIGZvciAoZmxvYXQgdCA9IC0zMC4wOyB0IDw9IDMwLjA7IHQrKylcXHJcXG4gICAge1xcclxcbiAgICAgICAgZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIDMwLjA7XFxyXFxuICAgICAgICBmbG9hdCB3ZWlnaHQgPSAxLjAgLSBhYnMocGVyY2VudCk7XFxyXFxuICAgICAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCArIGRlbHRhICogcGVyY2VudCk7XFxyXFxuICAgICAgICBzYW1wbGUucmdiICo9IHNhbXBsZS5hO1xcclxcbiAgICAgICAgY29sb3IgKz0gc2FtcGxlICogd2VpZ2h0O1xcclxcbiAgICAgICAgdG90YWwgKz0gd2VpZ2h0O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yIC8gdG90YWw7XFxyXFxuICAgIGdsX0ZyYWdDb2xvci5yZ2IgLz0gZ2xfRnJhZ0NvbG9yLmEgKyAwLjAwMDAxO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICAvLyB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRlbHRhOiB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDAuMSwgeTogMC4wIH0gfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn1cclxuXHJcblNtYXJ0Qmx1ckZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcclxuU21hcnRCbHVyRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNtYXJ0Qmx1ckZpbHRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBTbWFydEJsdXJGaWx0ZXI7XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xyXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgQ29sb3JNYXRyaXhGaWx0ZXIgY2xhc3MgbGV0cyB5b3UgYXBwbHkgYSA1eDQgbWF0cml4IHRyYW5zZm9ybWF0aW9uIG9uIHRoZSBSR0JBXHJcbiAqIGNvbG9yIGFuZCBhbHBoYSB2YWx1ZXMgb2YgZXZlcnkgcGl4ZWwgb24geW91ciBkaXNwbGF5T2JqZWN0IHRvIHByb2R1Y2UgYSByZXN1bHRcclxuICogd2l0aCBhIG5ldyBzZXQgb2YgUkdCQSBjb2xvciBhbmQgYWxwaGEgdmFsdWVzLiBJdCdzIHByZXR0eSBwb3dlcmZ1bCFcclxuICpcclxuICogYGBganNcclxuICogIHZhciBjb2xvck1hdHJpeCA9IG5ldyBQSVhJLkNvbG9yTWF0cml4RmlsdGVyKCk7XHJcbiAqICBjb250YWluZXIuZmlsdGVycyA9IFtjb2xvck1hdHJpeF07XHJcbiAqICBjb2xvck1hdHJpeC5jb250cmFzdCgyKTtcclxuICogYGBgXHJcbiAqIEBhdXRob3IgQ2zDqW1lbnQgQ2hlbmViYXVsdCA8Y2xlbWVudEBnb29kYm95ZGlnaXRhbC5jb20+XHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIENvbG9yTWF0cml4RmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIGZsb2F0IG1bMjVdO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG5cXHJcXG4gICAgdmVjNCBjID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG5cXHJcXG4gICAgZ2xfRnJhZ0NvbG9yLnIgPSAobVswXSAqIGMucik7XFxyXFxuICAgICAgICBnbF9GcmFnQ29sb3IuciArPSAobVsxXSAqIGMuZyk7XFxyXFxuICAgICAgICBnbF9GcmFnQ29sb3IuciArPSAobVsyXSAqIGMuYik7XFxyXFxuICAgICAgICBnbF9GcmFnQ29sb3IuciArPSAobVszXSAqIGMuYSk7XFxyXFxuICAgICAgICBnbF9GcmFnQ29sb3IuciArPSBtWzRdO1xcclxcblxcclxcbiAgICBnbF9GcmFnQ29sb3IuZyA9IChtWzVdICogYy5yKTtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5nICs9IChtWzZdICogYy5nKTtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5nICs9IChtWzddICogYy5iKTtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5nICs9IChtWzhdICogYy5hKTtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5nICs9IG1bOV07XFxyXFxuXFxyXFxuICAgICBnbF9GcmFnQ29sb3IuYiA9IChtWzEwXSAqIGMucik7XFxyXFxuICAgICAgICBnbF9GcmFnQ29sb3IuYiArPSAobVsxMV0gKiBjLmcpO1xcclxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yLmIgKz0gKG1bMTJdICogYy5iKTtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5iICs9IChtWzEzXSAqIGMuYSk7XFxyXFxuICAgICAgICBnbF9GcmFnQ29sb3IuYiArPSBtWzE0XTtcXHJcXG5cXHJcXG4gICAgIGdsX0ZyYWdDb2xvci5hID0gKG1bMTVdICogYy5yKTtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5hICs9IChtWzE2XSAqIGMuZyk7XFxyXFxuICAgICAgICBnbF9GcmFnQ29sb3IuYSArPSAobVsxN10gKiBjLmIpO1xcclxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yLmEgKz0gKG1bMThdICogYy5hKTtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5hICs9IG1bMTldO1xcclxcblxcclxcbn1cXHJcXG5cIixcclxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG06IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICcxZnYnLCB2YWx1ZTogW1xyXG4gICAgICAgICAgICAgICAgICAgIDEsIDAsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMCwgMSwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAxLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn1cclxuXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xyXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xvck1hdHJpeEZpbHRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBDb2xvck1hdHJpeEZpbHRlcjtcclxuXHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtcyBjdXJyZW50IG1hdHJpeCBhbmQgc2V0IHRoZSBuZXcgb25lXHJcbiAqXHJcbiAqIEBwYXJhbSBtYXRyaXgge251bWJlcltdfSAobWF0IDV4NClcclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSwganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gKi9cclxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLl9sb2FkTWF0cml4ID0gZnVuY3Rpb24gKG1hdHJpeCwgbXVsdGlwbHkpXHJcbntcclxuICAgIG11bHRpcGx5ID0gISFtdWx0aXBseTtcclxuXHJcbiAgICB2YXIgbmV3TWF0cml4ID0gbWF0cml4O1xyXG5cclxuICAgIGlmIChtdWx0aXBseSkge1xyXG4gICAgICAgIHRoaXMuX211bHRpcGx5KG5ld01hdHJpeCwgdGhpcy51bmlmb3Jtcy5tLnZhbHVlLCBtYXRyaXgpO1xyXG4gICAgICAgIG5ld01hdHJpeCA9IHRoaXMuX2NvbG9yTWF0cml4KG5ld01hdHJpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHRoZSBuZXcgbWF0cml4XHJcbiAgICB0aGlzLnVuaWZvcm1zLm0udmFsdWUgPSBuZXdNYXRyaXg7XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbGllcyB0d28gbWF0NSdzXHJcbiAqXHJcbiAqIEBwYXJhbSBvdXQge251bWJlcltdfSAobWF0IDV4NCkgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIGEge251bWJlcltdfSAobWF0IDV4NCkgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIGIge251bWJlcltdfSAobWF0IDV4NCkgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIG91dCB7bnVtYmVyW119IChtYXQgNXg0KVxyXG4gKi9cclxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLl9tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpXHJcbntcclxuXHJcbiAgICAvLyBSZWQgQ2hhbm5lbFxyXG4gICAgb3V0WzBdID0gKGFbMF0gKiBiWzBdKSArIChhWzFdICogYls1XSkgKyAoYVsyXSAqIGJbMTBdKSArIChhWzNdICogYlsxNV0pO1xyXG4gICAgb3V0WzFdID0gKGFbMF0gKiBiWzFdKSArIChhWzFdICogYls2XSkgKyAoYVsyXSAqIGJbMTFdKSArIChhWzNdICogYlsxNl0pO1xyXG4gICAgb3V0WzJdID0gKGFbMF0gKiBiWzJdKSArIChhWzFdICogYls3XSkgKyAoYVsyXSAqIGJbMTJdKSArIChhWzNdICogYlsxN10pO1xyXG4gICAgb3V0WzNdID0gKGFbMF0gKiBiWzNdKSArIChhWzFdICogYls4XSkgKyAoYVsyXSAqIGJbMTNdKSArIChhWzNdICogYlsxOF0pO1xyXG4gICAgb3V0WzRdID0gKGFbMF0gKiBiWzRdKSArIChhWzFdICogYls5XSkgKyAoYVsyXSAqIGJbMTRdKSArIChhWzNdICogYlsxOV0pO1xyXG5cclxuICAgIC8vIEdyZWVuIENoYW5uZWxcclxuICAgIG91dFs1XSA9IChhWzVdICogYlswXSkgKyAoYVs2XSAqIGJbNV0pICsgKGFbN10gKiBiWzEwXSkgKyAoYVs4XSAqIGJbMTVdKTtcclxuICAgIG91dFs2XSA9IChhWzVdICogYlsxXSkgKyAoYVs2XSAqIGJbNl0pICsgKGFbN10gKiBiWzExXSkgKyAoYVs4XSAqIGJbMTZdKTtcclxuICAgIG91dFs3XSA9IChhWzVdICogYlsyXSkgKyAoYVs2XSAqIGJbN10pICsgKGFbN10gKiBiWzEyXSkgKyAoYVs4XSAqIGJbMTddKTtcclxuICAgIG91dFs4XSA9IChhWzVdICogYlszXSkgKyAoYVs2XSAqIGJbOF0pICsgKGFbN10gKiBiWzEzXSkgKyAoYVs4XSAqIGJbMThdKTtcclxuICAgIG91dFs5XSA9IChhWzVdICogYls0XSkgKyAoYVs2XSAqIGJbOV0pICsgKGFbN10gKiBiWzE0XSkgKyAoYVs4XSAqIGJbMTldKTtcclxuXHJcbiAgICAvLyBCbHVlIENoYW5uZWxcclxuICAgIG91dFsxMF0gPSAoYVsxMF0gKiBiWzBdKSArIChhWzExXSAqIGJbNV0pICsgKGFbMTJdICogYlsxMF0pICsgKGFbMTNdICogYlsxNV0pO1xyXG4gICAgb3V0WzExXSA9IChhWzEwXSAqIGJbMV0pICsgKGFbMTFdICogYls2XSkgKyAoYVsxMl0gKiBiWzExXSkgKyAoYVsxM10gKiBiWzE2XSk7XHJcbiAgICBvdXRbMTJdID0gKGFbMTBdICogYlsyXSkgKyAoYVsxMV0gKiBiWzddKSArIChhWzEyXSAqIGJbMTJdKSArIChhWzEzXSAqIGJbMTddKTtcclxuICAgIG91dFsxM10gPSAoYVsxMF0gKiBiWzNdKSArIChhWzExXSAqIGJbOF0pICsgKGFbMTJdICogYlsxM10pICsgKGFbMTNdICogYlsxOF0pO1xyXG4gICAgb3V0WzE0XSA9IChhWzEwXSAqIGJbNF0pICsgKGFbMTFdICogYls5XSkgKyAoYVsxMl0gKiBiWzE0XSkgKyAoYVsxM10gKiBiWzE5XSk7XHJcblxyXG4gICAgLy8gQWxwaGEgQ2hhbm5lbFxyXG4gICAgb3V0WzE1XSA9IChhWzE1XSAqIGJbMF0pICsgKGFbMTZdICogYls1XSkgKyAoYVsxN10gKiBiWzEwXSkgKyAoYVsxOF0gKiBiWzE1XSk7XHJcbiAgICBvdXRbMTZdID0gKGFbMTVdICogYlsxXSkgKyAoYVsxNl0gKiBiWzZdKSArIChhWzE3XSAqIGJbMTFdKSArIChhWzE4XSAqIGJbMTZdKTtcclxuICAgIG91dFsxN10gPSAoYVsxNV0gKiBiWzJdKSArIChhWzE2XSAqIGJbN10pICsgKGFbMTddICogYlsxMl0pICsgKGFbMThdICogYlsxN10pO1xyXG4gICAgb3V0WzE4XSA9IChhWzE1XSAqIGJbM10pICsgKGFbMTZdICogYls4XSkgKyAoYVsxN10gKiBiWzEzXSkgKyAoYVsxOF0gKiBiWzE4XSk7XHJcbiAgICBvdXRbMTldID0gKGFbMTVdICogYls0XSkgKyAoYVsxNl0gKiBiWzldKSArIChhWzE3XSAqIGJbMTRdKSArIChhWzE4XSAqIGJbMTldKTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIEZsb2F0MzIgQXJyYXkgYW5kIG5vcm1hbGl6ZSB0aGUgb2Zmc2V0IGNvbXBvbmVudCB0byAwLTFcclxuICpcclxuICogQHBhcmFtIG1hdHJpeCB7bnVtYmVyW119IChtYXQgNXg0KVxyXG4gKiBAcmV0dXJuIG0ge251bWJlcltdfSAobWF0IDV4NCkgd2l0aCBhbGwgdmFsdWVzIGJldHdlZW4gMC0xXHJcbiAqL1xyXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuX2NvbG9yTWF0cml4ID0gZnVuY3Rpb24gKG1hdHJpeClcclxue1xyXG4gICAgLy8gQ3JlYXRlIGEgRmxvYXQzMiBBcnJheSBhbmQgbm9ybWFsaXplIHRoZSBvZmZzZXQgY29tcG9uZW50IHRvIDAtMVxyXG4gICAgdmFyIG0gPSBuZXcgRmxvYXQzMkFycmF5KG1hdHJpeCk7XHJcbiAgICBtWzRdIC89IDI1NTtcclxuICAgIG1bOV0gLz0gMjU1O1xyXG4gICAgbVsxNF0gLz0gMjU1O1xyXG4gICAgbVsxOV0gLz0gMjU1O1xyXG5cclxuICAgIHJldHVybiBtO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkanVzdHMgYnJpZ2h0bmVzc1xyXG4gKlxyXG4gKiBAcGFyYW0gYiB7bnVtYmVyfSB2YWx1ZSBvZiB0aGUgYnJpZ3RobmVzcyAoMCBpcyBibGFjaylcclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5icmlnaHRuZXNzID0gZnVuY3Rpb24gKGIsIG11bHRpcGx5KVxyXG57XHJcbiAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgIGIsIDAsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgYiwgMCwgMCwgMCxcclxuICAgICAgICAwLCAwLCBiLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgIF07XHJcblxyXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIG1hdHJpY2VzIGluIGdyZXkgc2NhbGVzXHJcbiAqXHJcbiAqIEBwYXJhbSBzY2FsZSB7bnVtYmVyfSB2YWx1ZSBvZiB0aGUgZ3JleSAoMCBpcyBibGFjaylcclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5ncmV5c2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUsIG11bHRpcGx5KVxyXG57XHJcbiAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgIHNjYWxlLCBzY2FsZSwgc2NhbGUsIDAsIDAsXHJcbiAgICAgICAgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCxcclxuICAgICAgICBzY2FsZSwgc2NhbGUsIHNjYWxlLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgIF07XHJcblxyXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxufTtcclxuLy9BbWVyaWNhbml6ZWQgYWxpYXNcclxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmdyYXlzY2FsZSA9IENvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5ncmV5c2NhbGU7XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBibGFjayBhbmQgd2hpdGUgbWF0cmljZVxyXG4gKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5ibGFja0FuZFdoaXRlID0gZnVuY3Rpb24gKG11bHRpcGx5KVxyXG57XHJcbiAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgIDAuMywgMC42LCAwLjEsIDAsIDAsXHJcbiAgICAgICAgMC4zLCAwLjYsIDAuMSwgMCwgMCxcclxuICAgICAgICAwLjMsIDAuNiwgMC4xLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgIF07XHJcblxyXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGh1ZSBwcm9wZXJ0eSBvZiB0aGUgY29sb3JcclxuICpcclxuICogQHBhcmFtIHJvdGF0aW9uIHtudW1iZXJ9IGluIGRlZ3JlZXNcclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5odWUgPSBmdW5jdGlvbiAocm90YXRpb24sIG11bHRpcGx5KVxyXG57XHJcbiAgICByb3RhdGlvbiA9IChyb3RhdGlvbiB8fCAwKSAvIDE4MCAqIE1hdGguUEk7XHJcbiAgICB2YXIgY29zID0gTWF0aC5jb3Mocm90YXRpb24pLFxyXG4gICAgICAgIHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKTtcclxuXHJcbiAgICAvLyBsdW1pbmFuY2VSZWQsIGx1bWluYW5jZUdyZWVuLCBsdW1pbmFuY2VCbHVlXHJcbiAgICB2YXIgbHVtUiA9IDAuMjEzLCAvLyBvciAwLjMwODZcclxuICAgICAgICBsdW1HID0gMC43MTUsIC8vIG9yIDAuNjA5NFxyXG4gICAgICAgIGx1bUIgPSAwLjA3MjsgLy8gb3IgMC4wODIwXHJcblxyXG4gICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICBsdW1SICsgY29zICogKDEgLSBsdW1SKSArIHNpbiAqICgtbHVtUiksIGx1bUcgKyBjb3MgKiAoLWx1bUcpICsgc2luICogKC1sdW1HKSwgbHVtQiArIGNvcyAqICgtbHVtQikgKyBzaW4gKiAoMSAtIGx1bUIpLCAwLCAwLFxyXG4gICAgICAgIGx1bVIgKyBjb3MgKiAoLWx1bVIpICsgc2luICogKDAuMTQzKSwgbHVtRyArIGNvcyAqICgxIC0gbHVtRykgKyBzaW4gKiAoMC4xNDApLCBsdW1CICsgY29zICogKC1sdW1CKSArIHNpbiAqICgtMC4yODMpLCAwLCAwLFxyXG4gICAgICAgIGx1bVIgKyBjb3MgKiAoLWx1bVIpICsgc2luICogKC0oMSAtIGx1bVIpKSwgbHVtRyArIGNvcyAqICgtbHVtRykgKyBzaW4gKiAobHVtRyksIGx1bUIgKyBjb3MgKiAoMSAtIGx1bUIpICsgc2luICogKGx1bUIpLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgIF07XHJcblxyXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogU2V0IHRoZSBjb250cmFzdCBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gZGFyayBhbmQgYnJpZ2h0XHJcbiAqIEluY3JlYXNlIGNvbnRyYXN0IDogc2hhZG93cyBkYXJrZXIgYW5kIGhpZ2hsaWdodHMgYnJpZ2h0ZXJcclxuICogRGVjcmVhc2UgY29udHJhc3QgOiBicmluZyB0aGUgc2hhZG93cyB1cCBhbmQgdGhlIGhpZ2hsaWdodHMgZG93blxyXG4gKlxyXG4gKiBAcGFyYW0gYW1vdW50IHtudW1iZXJ9IHZhbHVlIG9mIHRoZSBjb250cmFzdFxyXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxyXG4gKi9cclxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmNvbnRyYXN0ID0gZnVuY3Rpb24gKGFtb3VudCwgbXVsdGlwbHkpXHJcbntcclxuICAgIHZhciB2ID0gKGFtb3VudCB8fCAwKSArIDE7XHJcbiAgICB2YXIgbyA9IC0xMjggKiAodiAtIDEpO1xyXG5cclxuICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgdiwgMCwgMCwgMCwgbyxcclxuICAgICAgICAwLCB2LCAwLCAwLCBvLFxyXG4gICAgICAgIDAsIDAsIHYsIDAsIG8sXHJcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgXTtcclxuXHJcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgc2F0dXJhdGlvbiBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gY29sb3JzXHJcbiAqIEluY3JlYXNlIHNhdHVyYXRpb24gOiBpbmNyZWFzZSBjb250cmFzdCwgYnJpZ2h0bmVzcywgYW5kIHNoYXJwbmVzc1xyXG4gKlxyXG4gKiBAcGFyYW0gYW1vdW50IHtudW1iZXJ9XHJcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXHJcbiAqL1xyXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbiAoYW1vdW50LCBtdWx0aXBseSlcclxue1xyXG4gICAgdmFyIHggPSAoYW1vdW50IHx8IDApICogMiAvIDMgKyAxO1xyXG4gICAgdmFyIHkgPSAoKHggLSAxKSAqIC0wLjUpO1xyXG5cclxuICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgeCwgeSwgeSwgMCwgMCxcclxuICAgICAgICB5LCB4LCB5LCAwLCAwLFxyXG4gICAgICAgIHksIHksIHgsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgXTtcclxuXHJcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc2F0dXJhdGUgaW1hZ2UgKHJlbW92ZSBjb2xvcilcclxuICpcclxuICogQ2FsbCB0aGUgc2F0dXJhdGUgZnVuY3Rpb25cclxuICpcclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24gKG11bHRpcGx5KSAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXHJcbntcclxuICAgIHRoaXMuc2F0dXJhdGUoLTEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0aXZlIGltYWdlIChpbnZlcnNlIG9mIGNsYXNzaWMgcmdiIG1hdHJpeClcclxuICpcclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5uZWdhdGl2ZSA9IGZ1bmN0aW9uIChtdWx0aXBseSlcclxue1xyXG4gICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAwLCAxLCAxLCAwLCAwLFxyXG4gICAgICAgIDEsIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgMSwgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICBdO1xyXG5cclxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbn07XHJcblxyXG4vKipcclxuICogU2VwaWEgaW1hZ2VcclxuICpcclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5zZXBpYSA9IGZ1bmN0aW9uIChtdWx0aXBseSlcclxue1xyXG4gICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAwLjM5MywgMC43Njg5OTk5LCAwLjE4ODk5OTk5LCAwLCAwLFxyXG4gICAgICAgIDAuMzQ5LCAwLjY4NTk5OTksIDAuMTY3OTk5OTksIDAsIDAsXHJcbiAgICAgICAgMC4yNzIsIDAuNTMzOTk5OSwgMC4xMzA5OTk5OSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICBdO1xyXG5cclxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29sb3IgbW90aW9uIHBpY3R1cmUgcHJvY2VzcyBpbnZlbnRlZCBpbiAxOTE2ICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxyXG4gKlxyXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxyXG4gKi9cclxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnRlY2huaWNvbG9yID0gZnVuY3Rpb24gKG11bHRpcGx5KVxyXG57XHJcbiAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgIDEuOTEyNTI3Nzg5MTQ1NjA4MywgLTAuODU0NTM0NDk3Njk1MTY0NSwgLTAuMDkxNTU1MDg0ODI3NTU1ODUsIDAsIDExLjc5MzYwMzQzNDM3NzMzNyxcclxuICAgICAgICAtMC4zMDg3ODMzMzg1OTI4MDk3LCAxLjc2NTg5MDg1NTU0NTg0MjgsIC0wLjEwNjAxNzQzMDc0NzIyMjQ1LCAwLCAtNzAuMzUyMDUxNjE0NjEzOTgsXHJcbiAgICAgICAgLTAuMjMxMTAzMzc3NTQ4NjE2LCAtMC43NTAxODk5MTk3NDQwMjEyLCAxLjg0NzU5NzgxNjEwODE4OSwgMCwgMzAuOTUwOTQwODY5NDkxMTM4LFxyXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgIF07XHJcblxyXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQb2xhcm9pZCBmaWx0ZXJcclxuICpcclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5wb2xhcm9pZCA9IGZ1bmN0aW9uIChtdWx0aXBseSlcclxue1xyXG4gICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAxLjQzOCwgLTAuMDYyLCAtMC4wNjIsIDAsIDAsXHJcbiAgICAgICAgLTAuMTIyLCAxLjM3OCwgLTAuMTIyLCAwLCAwLFxyXG4gICAgICAgIC0wLjAxNiwgLTAuMDE2LCAxLjQ4MywgMCwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICBdO1xyXG5cclxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbn07XHJcblxyXG4vKipcclxuICogRmlsdGVyIHdobyB0cmFuc2Zvcm1zIDogUmVkIC0+IEJsdWUgYW5kIEJsdWUgLT4gUmVkXHJcbiAqXHJcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXHJcbiAqL1xyXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUudG9CR1IgPSBmdW5jdGlvbiAobXVsdGlwbHkpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgMCwgMCwgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLCAwLFxyXG4gICAgICAgIDEsIDAsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgXTtcclxuXHJcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbG9yIHJldmVyc2FsIGZpbG0gaW50cm9kdWNlZCBieSBFYXN0bWFuIEtvZGFrIGluIDE5MzUuICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxyXG4gKlxyXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxyXG4gKi9cclxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmtvZGFjaHJvbWUgPSBmdW5jdGlvbiAobXVsdGlwbHkpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgMS4xMjg1NTgyMzk2NTkzNTI1LCAtMC4zOTY3MzgyMjgzNjAxMzQ4LCAtMC4wMzk5MjU1OTE3MjkyMTc5MywgMCwgNjMuNzI5NTg3NjIxOTY1MDIsXHJcbiAgICAgICAgLTAuMTY0MDQzMzk5NjIyNDQ2MTYsIDEuMDgzNTI1MTU2NjI5MTMwNCwgLTAuMDU0OTg4MDUxMTU2MzMxMzIsIDAsIDI0LjczMjQwNzg5NjcwNjIwMyxcclxuICAgICAgICAtMC4xNjc4NjAxMDcwNjE1NTc2MywgLTAuNTYwMzQxNjI3NzY5NTI0OCwgMS42MDE0ODUwNzYxOTY0OTQzLCAwLCAzNS42Mjk4MjgwNzQ2MDk0NixcclxuICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICBdO1xyXG5cclxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQnJvd24gZGVsaWNpb3VzIGJyb3duaSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXHJcbiAqXHJcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXHJcbiAqL1xyXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuYnJvd25pID0gZnVuY3Rpb24gKG11bHRpcGx5KVxyXG57XHJcbiAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgIDAuNTk5NzAyMzQ5ODE1OTcxNSwgMC4zNDU1MzI0MzA0ODM5MTI2MywgLTAuMjcwODI5ODY3NDUzODA0MiwgMCwgNDcuNDMxOTI4NTU2MDA4NzMsXHJcbiAgICAgICAgLTAuMDM3NzAzMjQ5ODM3NzgzMTU3LCAwLjg2MDk1Nzc1ODc5OTI2NDEsIDAuMTUwNTk1NTIzODg0NTk5MTMsIDAsIC0zNi45Njg0MTQ5ODMxOTEyNyxcclxuICAgICAgICAwLjI0MTEzNjM1MTI4MTUzMzM1LCAtMC4wNzQ0MTAzNzkwODQyMjQ5MiwgMC40NDk3MjE4MjA2NDg3NzE1MywgMCwgLTcuNTYyMDc1Mjc3NTkxMjgzLFxyXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgIF07XHJcblxyXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxufTtcclxuXHJcbi8qXHJcbiAqIFZpbnRhZ2UgZmlsdGVyICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxyXG4gKlxyXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxyXG4gKi9cclxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnZpbnRhZ2UgPSBmdW5jdGlvbiAobXVsdGlwbHkpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgMC42Mjc5MzQ1NjM1NjA1OTk0LCAwLjMyMDIxODM0MjA4MTkzNjcsIC0wLjAzOTY1NDA4MjExMzEyNDUzLCAwLCA5LjY1MTI4NTgzNTI5NDEyMyxcclxuICAgICAgICAwLjAyNTc4Mzk3NzA0ODA4ODY4LCAwLjY0NDExODg2NDQzNzQ3NzEsIDAuMDMyNTkxMjc2MTYxNDkyOTQsIDAsIDcuNDYyODI5MTc2NDcwNTkxLFxyXG4gICAgICAgIDAuMDQ2NjA1NTU1Njc4MjcxOSwgLTAuMDg1MTIzMjk4NzI0Nzg5MSwgMC41MjQxNjQ4MDE4NzAwNDY1LCAwLCA1LjE1OTE5MDU4ODIzNTI5NixcclxuICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICBdO1xyXG5cclxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbn07XHJcblxyXG4vKlxyXG4gKiBXZSBkb24ndCBrbm93IGV4YWN0bHkgd2hhdCBpdCBkb2VzLCBraW5kIG9mIGdyYWRpZW50IG1hcCwgYnV0IGZ1bm55IHRvIHBsYXkgd2l0aCFcclxuICpcclxuICogQHBhcmFtIGRlc2F0dXJhdGlvbiB7bnVtYmVyfVxyXG4gKiBAcGFyYW0gdG9uZWQge251bWJlcn1cclxuICogQHBhcmFtIGxpZ2h0Q29sb3Ige3N0cmluZ30gKGV4YW1wbGUgOiBcIjB4RkZFNTgwXCIpXHJcbiAqIEBwYXJhbSBkYXJrQ29sb3Ige3N0cmluZ30gIChleGFtcGxlIDogXCIweEZGRTU4MFwiKVxyXG4gKlxyXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxyXG4gKi9cclxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmNvbG9yVG9uZSA9IGZ1bmN0aW9uIChkZXNhdHVyYXRpb24sIHRvbmVkLCBsaWdodENvbG9yLCBkYXJrQ29sb3IsIG11bHRpcGx5KVxyXG57XHJcbiAgICBkZXNhdHVyYXRpb24gPSBkZXNhdHVyYXRpb24gfHwgMC4yO1xyXG4gICAgdG9uZWQgPSB0b25lZCB8fCAwLjE1O1xyXG4gICAgbGlnaHRDb2xvciA9IGxpZ2h0Q29sb3IgfHwgMHhGRkU1ODA7XHJcbiAgICBkYXJrQ29sb3IgPSBkYXJrQ29sb3IgfHwgMHgzMzgwMDA7XHJcblxyXG4gICAgdmFyIGxSID0gKChsaWdodENvbG9yID4+IDE2KSAmIDB4RkYpIC8gMjU1O1xyXG4gICAgdmFyIGxHID0gKChsaWdodENvbG9yID4+IDgpICYgMHhGRikgLyAyNTU7XHJcbiAgICB2YXIgbEIgPSAobGlnaHRDb2xvciAmIDB4RkYpIC8gMjU1O1xyXG5cclxuICAgIHZhciBkUiA9ICgoZGFya0NvbG9yID4+IDE2KSAmIDB4RkYpIC8gMjU1O1xyXG4gICAgdmFyIGRHID0gKChkYXJrQ29sb3IgPj4gOCkgJiAweEZGKSAvIDI1NTtcclxuICAgIHZhciBkQiA9IChkYXJrQ29sb3IgJiAweEZGKSAvIDI1NTtcclxuXHJcbiAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgIDAuMywgMC41OSwgMC4xMSwgMCwgMCxcclxuICAgICAgICBsUiwgbEcsIGxCLCBkZXNhdHVyYXRpb24sIDAsXHJcbiAgICAgICAgZFIsIGRHLCBkQiwgdG9uZWQsIDAsXHJcbiAgICAgICAgbFIgLSBkUiwgbEcgLSBkRywgbEIgLSBkQiwgMCwgMFxyXG4gICAgXTtcclxuXHJcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG59O1xyXG5cclxuLypcclxuICogTmlnaHQgZWZmZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSBpbnRlbnNpdHkge251bWJlcn1cclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5uaWdodCA9IGZ1bmN0aW9uIChpbnRlbnNpdHksIG11bHRpcGx5KVxyXG57XHJcbiAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkgfHwgMC4xO1xyXG4gICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICBpbnRlbnNpdHkgKiAoIC0yLjApLCAtaW50ZW5zaXR5LCAwLCAwLCAwLFxyXG4gICAgICAgIC1pbnRlbnNpdHksIDAsIGludGVuc2l0eSwgMCwgMCxcclxuICAgICAgICAwLCBpbnRlbnNpdHksIGludGVuc2l0eSAqIDIuMCwgMCwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICBdO1xyXG5cclxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUHJlZGF0b3IgZWZmZWN0XHJcbiAqXHJcbiAqIEVyYXNlIHRoZSBjdXJyZW50IG1hdHJpeCBieSBzZXR0aW5nIGEgbmV3IGluZGVwZW50IG9uZVxyXG4gKlxyXG4gKiBAcGFyYW0gYW1vdW50IHtudW1iZXJ9IGhvdyBtdWNoIHRoZSBwcmVkYXRvciBmZWVscyBoaXMgZnV0dXJlIHZpY3RpbVxyXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxyXG4gKi9cclxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnByZWRhdG9yID0gZnVuY3Rpb24gKGFtb3VudCwgbXVsdGlwbHkpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgMTEuMjI0MTMwNjMwNDkzMTY0ICogYW1vdW50LCAtNC43OTQ0ODY5OTk1MTE3MTkgKiBhbW91bnQsIC0yLjg3NDYxMTg1NDU1MzIyMjcgKiBhbW91bnQsIDAgKiBhbW91bnQsIDAuNDAzNDI0MzgyMjA5Nzc3ODMgKiBhbW91bnQsXHJcbiAgICAgICAgLTMuNjMzMDY5NzUzNjQ2ODUwNiAqIGFtb3VudCwgOS4xOTMxNTcxOTYwNDQ5MjIgKiBhbW91bnQsIC0yLjk1MTgxMDgzNjc5MTk5MiAqIGFtb3VudCwgMCAqIGFtb3VudCwgLTEuMzE2MTM1MDQ4ODY2MjcyICogYW1vdW50LFxyXG4gICAgICAgIC0zLjIxODQxOTc5MDI2Nzk0NDMgKiBhbW91bnQsIC00LjIzNzUwMzA1MTc1NzgxMjUgKiBhbW91bnQsIDcuNDc2NDQ4MDU5MDgyMDMxICogYW1vdW50LCAwICogYW1vdW50LCAwLjgwNDQ0NTkyMjM3NDcyNTMgKiBhbW91bnQsXHJcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgXTtcclxuXHJcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG59O1xyXG5cclxuLypcclxuICogTFNEIGVmZmVjdFxyXG4gKlxyXG4gKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIGFtb3VudCB7bnVtYmVyfSBIb3cgY3JhenkgaXMgeW91ciBlZmZlY3RcclxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5sc2QgPSBmdW5jdGlvbiAobXVsdGlwbHkpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgMiwgLTAuNCwgMC41LCAwLCAwLFxyXG4gICAgICAgIC0wLjUsIDIsIC0wLjQsIDAsIDAsXHJcbiAgICAgICAgLTAuNCwgLTAuNSwgMywgMCwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICBdO1xyXG5cclxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbn07XHJcblxyXG4vKlxyXG4gKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyB0aGUgZGVmYXVsdCBvbmVcclxuICpcclxuICovXHJcbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgMSwgMCwgMCwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgXTtcclxuXHJcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgZmFsc2UpO1xyXG59O1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXRyaXggb2YgdGhlIGNvbG9yIG1hdHJpeCBmaWx0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQ29sb3JNYXRyaXhGaWx0ZXIjXHJcbiAgICAgKiBAZGVmYXVsdCBbMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMF1cclxuICAgICAqL1xyXG4gICAgbWF0cml4OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubS52YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5tLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XHJcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoaXMgbG93ZXJzIHRoZSBjb2xvciBkZXB0aCBvZiB5b3VyIGltYWdlIGJ5IHRoZSBnaXZlbiBhbW91bnQsIHByb2R1Y2luZyBhbiBpbWFnZSB3aXRoIGEgc21hbGxlciBwYWxldHRlLlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBDb2xvclN0ZXBGaWx0ZXIoKVxyXG57XHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gZmxvYXQgc3RlcDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcclxcblxcclxcbiAgICBjb2xvciA9IGZsb29yKGNvbG9yICogc3RlcCkgLyBzdGVwO1xcclxcblxcclxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXHJcXG59XFxyXFxuXCIsXHJcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdGVwOiB7IHR5cGU6ICcxZicsIHZhbHVlOiA1IH1cclxuICAgICAgICB9XHJcbiAgICApO1xyXG59XHJcblxyXG5Db2xvclN0ZXBGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcbkNvbG9yU3RlcEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xvclN0ZXBGaWx0ZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29sb3JTdGVwRmlsdGVyO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29sb3JTdGVwRmlsdGVyLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHN0ZXBzIHRvIHJlZHVjZSB0aGUgcGFsZXR0ZSBieS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkNvbG9yU3RlcEZpbHRlciNcclxuICAgICAqL1xyXG4gICAgc3RlcDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnN0ZXAudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc3RlcC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xyXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgQ29udm9sdXRpb25GaWx0ZXIgY2xhc3MgYXBwbGllcyBhIG1hdHJpeCBjb252b2x1dGlvbiBmaWx0ZXIgZWZmZWN0LlxyXG4gKiBBIGNvbnZvbHV0aW9uIGNvbWJpbmVzIHBpeGVscyBpbiB0aGUgaW5wdXQgaW1hZ2Ugd2l0aCBuZWlnaGJvcmluZyBwaXhlbHMgdG8gcHJvZHVjZSBhIG5ldyBpbWFnZS5cclxuICogQSB3aWRlIHZhcmlldHkgb2YgaW1hZ2UgZWZmZWN0cyBjYW4gYmUgYWNoaWV2ZWQgdGhyb3VnaCBjb252b2x1dGlvbnMsIGluY2x1ZGluZyBibHVycmluZywgZWRnZVxyXG4gKiBkZXRlY3Rpb24sIHNoYXJwZW5pbmcsIGVtYm9zc2luZywgYW5kIGJldmVsaW5nLiBUaGUgbWF0cml4IHNob3VsZCBiZSBzcGVjaWZpZWQgYXMgYSA5IHBvaW50IEFycmF5LlxyXG4gKiBTZWUgaHR0cDovL2RvY3MuZ2ltcC5vcmcvZW4vcGx1Zy1pbi1jb252bWF0cml4Lmh0bWwgZm9yIG1vcmUgaW5mby5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xyXG4gKiBAcGFyYW0gbWF0cml4IHtudW1iZXJbXX0gQW4gYXJyYXkgb2YgdmFsdWVzIHVzZWQgZm9yIG1hdHJpeCB0cmFuc2Zvcm1hdGlvbi4gU3BlY2lmaWVkIGFzIGEgOSBwb2ludCBBcnJheS5cclxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IFdpZHRoIG9mIHRoZSBvYmplY3QgeW91IGFyZSB0cmFuc2Zvcm1pbmdcclxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBIZWlnaHQgb2YgdGhlIG9iamVjdCB5b3UgYXJlIHRyYW5zZm9ybWluZ1xyXG4gKi9cclxuZnVuY3Rpb24gQ29udm9sdXRpb25GaWx0ZXIobWF0cml4LCB3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbnZhcnlpbmcgbWVkaXVtcCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxudW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcXHJcXG51bmlmb3JtIGZsb2F0IG1hdHJpeFs5XTtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgdmVjNCBjMTEgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgLSB0ZXhlbFNpemUpOyAvLyB0b3AgbGVmdFxcclxcbiAgIHZlYzQgYzEyID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55IC0gdGV4ZWxTaXplLnkpKTsgLy8gdG9wIGNlbnRlclxcclxcbiAgIHZlYzQgYzEzID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIHRleGVsU2l6ZS54LCB2VGV4dHVyZUNvb3JkLnkgLSB0ZXhlbFNpemUueSkpOyAvLyB0b3AgcmlnaHRcXHJcXG5cXHJcXG4gICB2ZWM0IGMyMSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggLSB0ZXhlbFNpemUueCwgdlRleHR1cmVDb29yZC55KSk7IC8vIG1pZCBsZWZ0XFxyXFxuICAgdmVjNCBjMjIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpOyAvLyBtaWQgY2VudGVyXFxyXFxuICAgdmVjNCBjMjMgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54ICsgdGV4ZWxTaXplLngsIHZUZXh0dXJlQ29vcmQueSkpOyAvLyBtaWQgcmlnaHRcXHJcXG5cXHJcXG4gICB2ZWM0IGMzMSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggLSB0ZXhlbFNpemUueCwgdlRleHR1cmVDb29yZC55ICsgdGV4ZWxTaXplLnkpKTsgLy8gYm90dG9tIGxlZnRcXHJcXG4gICB2ZWM0IGMzMiA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSArIHRleGVsU2l6ZS55KSk7IC8vIGJvdHRvbSBjZW50ZXJcXHJcXG4gICB2ZWM0IGMzMyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCArIHRleGVsU2l6ZSk7IC8vIGJvdHRvbSByaWdodFxcclxcblxcclxcbiAgIGdsX0ZyYWdDb2xvciA9XFxyXFxuICAgICAgIGMxMSAqIG1hdHJpeFswXSArIGMxMiAqIG1hdHJpeFsxXSArIGMxMyAqIG1hdHJpeFsyXSArXFxyXFxuICAgICAgIGMyMSAqIG1hdHJpeFszXSArIGMyMiAqIG1hdHJpeFs0XSArIGMyMyAqIG1hdHJpeFs1XSArXFxyXFxuICAgICAgIGMzMSAqIG1hdHJpeFs2XSArIGMzMiAqIG1hdHJpeFs3XSArIGMzMyAqIG1hdHJpeFs4XTtcXHJcXG5cXHJcXG4gICBnbF9GcmFnQ29sb3IuYSA9IGMyMi5hO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG1hdHJpeDogICAgIHsgdHlwZTogJzFmdicsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KG1hdHJpeCkgfSxcclxuICAgICAgICAgICAgdGV4ZWxTaXplOiAgeyB0eXBlOiAndjInLCB2YWx1ZTogeyB4OiAxIC8gd2lkdGgsIHk6IDEgLyBoZWlnaHQgfSB9XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufVxyXG5cclxuQ29udm9sdXRpb25GaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcbkNvbnZvbHV0aW9uRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnZvbHV0aW9uRmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnZvbHV0aW9uRmlsdGVyO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29udm9sdXRpb25GaWx0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHZhbHVlcyB1c2VkIGZvciBtYXRyaXggdHJhbnNmb3JtYXRpb24uIFNwZWNpZmllZCBhcyBhIDkgcG9pbnQgQXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkNvbnZvbHV0aW9uRmlsdGVyI1xyXG4gICAgICovXHJcbiAgICBtYXRyaXg6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXRyaXgudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMubWF0cml4LnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdpZHRoIG9mIHRoZSBvYmplY3QgeW91IGFyZSB0cmFuc2Zvcm1pbmdcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkNvbnZvbHV0aW9uRmlsdGVyI1xyXG4gICAgICovXHJcbiAgICB3aWR0aDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAxL3RoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLng7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnggPSAxL3ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWlnaHQgb2YgdGhlIG9iamVjdCB5b3UgYXJlIHRyYW5zZm9ybWluZ1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQ29udm9sdXRpb25GaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIGhlaWdodDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAxL3RoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnkgPSAxL3ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xyXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxyXG5cclxuXHJcbi8qKlxyXG4gKiBBIENyb3NzIEhhdGNoIGVmZmVjdCBmaWx0ZXIuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIENyb3NzSGF0Y2hGaWx0ZXIoKVxyXG57XHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZmxvYXQgbHVtID0gbGVuZ3RoKHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZC54eSkucmdiKTtcXHJcXG5cXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcclxcblxcclxcbiAgICBpZiAobHVtIDwgMS4wMClcXHJcXG4gICAge1xcclxcbiAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCArIGdsX0ZyYWdDb29yZC55LCAxMC4wKSA9PSAwLjApXFxyXFxuICAgICAgICB7XFxyXFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGlmIChsdW0gPCAwLjc1KVxcclxcbiAgICB7XFxyXFxuICAgICAgICBpZiAobW9kKGdsX0ZyYWdDb29yZC54IC0gZ2xfRnJhZ0Nvb3JkLnksIDEwLjApID09IDAuMClcXHJcXG4gICAgICAgIHtcXHJcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgaWYgKGx1bSA8IDAuNTApXFxyXFxuICAgIHtcXHJcXG4gICAgICAgIGlmIChtb2QoZ2xfRnJhZ0Nvb3JkLnggKyBnbF9GcmFnQ29vcmQueSAtIDUuMCwgMTAuMCkgPT0gMC4wKVxcclxcbiAgICAgICAge1xcclxcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBpZiAobHVtIDwgMC4zKVxcclxcbiAgICB7XFxyXFxuICAgICAgICBpZiAobW9kKGdsX0ZyYWdDb29yZC54IC0gZ2xfRnJhZ0Nvb3JkLnkgLSA1LjAsIDEwLjApID09IDAuMClcXHJcXG4gICAgICAgIHtcXHJcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXCJcclxuICAgICk7XHJcbn1cclxuXHJcbkNyb3NzSGF0Y2hGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcbkNyb3NzSGF0Y2hGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3Jvc3NIYXRjaEZpbHRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBDcm9zc0hhdGNoRmlsdGVyO1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcclxuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcclxuXHJcblxyXG4vKipcclxuICogVGhlIERpc3BsYWNlbWVudEZpbHRlciBjbGFzcyB1c2VzIHRoZSBwaXhlbCB2YWx1ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHRleHR1cmUgKGNhbGxlZCB0aGUgZGlzcGxhY2VtZW50IG1hcCkgdG8gcGVyZm9ybSBhIGRpc3BsYWNlbWVudCBvZiBhbiBvYmplY3QuXHJcbiAqIFlvdSBjYW4gdXNlIHRoaXMgZmlsdGVyIHRvIGFwcGx5IGFsbCBtYW5vciBvZiBjcmF6eSB3YXJwaW5nIGVmZmVjdHNcclxuICogQ3VycmVudGx5IHRoZSByIHByb3BlcnR5IG9mIHRoZSB0ZXh0dXJlIGlzIHVzZWQgdG8gb2Zmc2V0IHRoZSB4IGFuZCB0aGUgZyBwcm9wZXJ0eSBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkIHRvIG9mZnNldCB0aGUgeS5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xyXG4gKiBAcGFyYW0gc3ByaXRlIHtQSVhJLlNwcml0ZX0gdGhlIHNwcml0ZSB1c2VkIGZvciB0aGUgZGlzcGxhY2VtZW50IG1hcC4gKG1ha2Ugc3VyZSBpdHMgYWRkZWQgdG8gdGhlIHNjZW5lISlcclxuICovXHJcbmZ1bmN0aW9uIERpc3BsYWNlbWVudEZpbHRlcihzcHJpdGUsIHNjYWxlKVxyXG57XHJcbiAgICB2YXIgbWFza01hdHJpeCA9IG5ldyBjb3JlLk1hdHJpeCgpO1xyXG4gICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcclxuXHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5hdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXFxudW5pZm9ybSBtYXQzIG90aGVyTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2TWFwQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxyXFxuICAgdk1hcENvb3JkID0gKCBvdGhlck1hdHJpeCAqIHZlYzMoIGFUZXh0dXJlQ29vcmQsIDEuMCkgICkueHk7XFxyXFxuICAgdkNvbG9yID0gdmVjNChhQ29sb3IucmdiICogYUNvbG9yLmEsIGFDb2xvci5hKTtcXHJcXG59XFxyXFxuXCIsXHJcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdk1hcENvb3JkO1xcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSB2ZWMyIHNjYWxlO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcFNhbXBsZXI7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgIHZlYzQgbWFwID0gIHRleHR1cmUyRChtYXBTYW1wbGVyLCB2TWFwQ29vcmQpO1xcclxcblxcclxcbiAgIG1hcCAtPSAwLjU7XFxyXFxuICAgbWFwLnh5ICo9IHNjYWxlO1xcclxcblxcclxcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggKyBtYXAueCwgdlRleHR1cmVDb29yZC55ICsgbWFwLnkpKTtcXHJcXG59XFxyXFxuXCIsXHJcbiAgICAgICAgLy8gdW5pZm9ybXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG1hcFNhbXBsZXI6ICAgICB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogc3ByaXRlLnRleHR1cmUgfSxcclxuICAgICAgICAgICAgb3RoZXJNYXRyaXg6ICAgIHsgdHlwZTogJ21hdDMnLCB2YWx1ZTogbWFza01hdHJpeC50b0FycmF5KHRydWUpIH0sXHJcbiAgICAgICAgICAgIHNjYWxlOiAgICAgICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDEsIHk6IDEgfSB9XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLm1hc2tTcHJpdGUgPSBzcHJpdGU7XHJcbiAgICB0aGlzLm1hc2tNYXRyaXggPSBtYXNrTWF0cml4O1xyXG5cclxuICAgIGlmIChzY2FsZSA9PT0gbnVsbCB8fCBzY2FsZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHNjYWxlID0gMjA7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zY2FsZSA9IG5ldyBjb3JlLlBvaW50KHNjYWxlLCBzY2FsZSk7XHJcbn1cclxuXHJcbkRpc3BsYWNlbWVudEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcclxuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpc3BsYWNlbWVudEZpbHRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBEaXNwbGFjZW1lbnRGaWx0ZXI7XHJcblxyXG5EaXNwbGFjZW1lbnRGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KVxyXG57XHJcbiAgICB2YXIgZmlsdGVyTWFuYWdlciA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXI7XHJcblxyXG4gICAgZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVNYXBwZWRNYXRyaXgoaW5wdXQuZnJhbWUsIHRoaXMubWFza1Nwcml0ZSwgdGhpcy5tYXNrTWF0cml4KTtcclxuXHJcbiAgICB0aGlzLnVuaWZvcm1zLm90aGVyTWF0cml4LnZhbHVlID0gdGhpcy5tYXNrTWF0cml4LnRvQXJyYXkodHJ1ZSk7XHJcbiAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlLnggPSB0aGlzLnNjYWxlLnggKiAoMS9pbnB1dC5mcmFtZS53aWR0aCk7XHJcbiAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlLnkgPSB0aGlzLnNjYWxlLnkgKiAoMS9pbnB1dC5mcmFtZS5oZWlnaHQpO1xyXG5cclxuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XHJcbiAgICAgLy8gZHJhdyB0aGUgZmlsdGVyLi4uXHJcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCk7XHJcbn07XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dHVyZSB1c2VkIGZvciB0aGUgZGlzcGxhY2VtZW50IG1hcC4gTXVzdCBiZSBwb3dlciBvZiAyIHNpemVkIHRleHR1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5EaXNwbGFjZW1lbnRGaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIG1hcDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hcFNhbXBsZXIudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMubWFwU2FtcGxlci52YWx1ZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcclxuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcclxuXHJcblxyXG4vKipcclxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXHJcbiAqIG9yaWdpbmFsIGZpbHRlcjogaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvZnVuL2RvdHNjcmVlbi5qc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZpbHRlciBhcHBsaWVzIGEgZG90c2NyZWVuIGVmZmVjdCBtYWtpbmcgZGlzcGxheSBvYmplY3RzIGFwcGVhciB0byBiZSBtYWRlIG91dCBvZlxyXG4gKiBibGFjayBhbmQgd2hpdGUgaGFsZnRvbmUgZG90cyBsaWtlIGFuIG9sZCBwcmludGVyLlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBEb3RTY3JlZW5GaWx0ZXIoKVxyXG57XHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSB2ZWM0IGRpbWVuc2lvbnM7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBhbmdsZTtcXHJcXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcclxcblxcclxcbmZsb2F0IHBhdHRlcm4oKVxcclxcbntcXHJcXG4gICBmbG9hdCBzID0gc2luKGFuZ2xlKSwgYyA9IGNvcyhhbmdsZSk7XFxyXFxuICAgdmVjMiB0ZXggPSB2VGV4dHVyZUNvb3JkICogZGltZW5zaW9ucy54eTtcXHJcXG4gICB2ZWMyIHBvaW50ID0gdmVjMihcXHJcXG4gICAgICAgYyAqIHRleC54IC0gcyAqIHRleC55LFxcclxcbiAgICAgICBzICogdGV4LnggKyBjICogdGV4LnlcXHJcXG4gICApICogc2NhbGU7XFxyXFxuICAgcmV0dXJuIChzaW4ocG9pbnQueCkgKiBzaW4ocG9pbnQueSkpICogNC4wO1xcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4oKVxcclxcbntcXHJcXG4gICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG4gICBmbG9hdCBhdmVyYWdlID0gKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikgLyAzLjA7XFxyXFxuICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGF2ZXJhZ2UgKiAxMC4wIC0gNS4wICsgcGF0dGVybigpKSwgY29sb3IuYSk7XFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2NhbGU6ICAgICAgeyB0eXBlOiAnMWYnLCB2YWx1ZTogMSB9LFxyXG4gICAgICAgICAgICBhbmdsZTogICAgICB7IHR5cGU6ICcxZicsIHZhbHVlOiA1IH0sXHJcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHsgdHlwZTogJzRmdicsIHZhbHVlOiBbMCwgMCwgMCwgMF0gfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn1cclxuXHJcbkRvdFNjcmVlbkZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcclxuRG90U2NyZWVuRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERvdFNjcmVlbkZpbHRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBEb3RTY3JlZW5GaWx0ZXI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEb3RTY3JlZW5GaWx0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzY2FsZSBvZiB0aGUgZWZmZWN0LlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5Eb3RTY3JlZW5GaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIHNjYWxlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGUgZWZmZWN0LlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5Eb3RTY3JlZW5GaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIGFuZ2xlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYW5nbGUudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuYW5nbGUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcclxuXHJcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBCbHVyWVRpbnRGaWx0ZXIgYXBwbGllcyBhIHZlcnRpY2FsIEdhdXNzaWFuIGJsdXIgdG8gYW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBCbHVyWVRpbnRGaWx0ZXIoKVxyXG57XHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5hdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXHJcXG51bmlmb3JtIHZlYzIgb2Zmc2V0O1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxyXFxudmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWzZdO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMygoYVZlcnRleFBvc2l0aW9uK29mZnNldCksIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbiAgICB2Qmx1clRleENvb3Jkc1sgMF0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsIC0wLjAxMiAqIHN0cmVuZ3RoKTtcXHJcXG4gICAgdkJsdXJUZXhDb29yZHNbIDFdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAtMC4wMDggKiBzdHJlbmd0aCk7XFxyXFxuICAgIHZCbHVyVGV4Q29vcmRzWyAyXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgLTAuMDA0ICogc3RyZW5ndGgpO1xcclxcbiAgICB2Qmx1clRleENvb3Jkc1sgM10gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsICAwLjAwNCAqIHN0cmVuZ3RoKTtcXHJcXG4gICAgdkJsdXJUZXhDb29yZHNbIDRdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAgMC4wMDggKiBzdHJlbmd0aCk7XFxyXFxuICAgIHZCbHVyVGV4Q29vcmRzWyA1XSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgIDAuMDEyICogc3RyZW5ndGgpO1xcclxcblxcclxcbiAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7XFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxyXG4gICAgICAgIFwicHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWzZdO1xcclxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSB2ZWMzIGNvbG9yO1xcclxcbnVuaWZvcm0gZmxvYXQgYWxwaGE7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcXHJcXG5cXHJcXG4gICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDBdKSowLjAwNDQzMTg0ODQxMTkzODM0MTtcXHJcXG4gICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDFdKSowLjA1Mzk5MDk2NjUxMzE4OTg1O1xcclxcbiAgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMl0pKjAuMjQxOTcwNzI0NTE5MTQ1NDtcXHJcXG4gICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCAgICAgKSowLjM5ODk0MjI4MDQwMTQzMjc7XFxyXFxuICAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAzXSkqMC4yNDE5NzA3MjQ1MTkxNDU0O1xcclxcbiAgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgNF0pKjAuMDUzOTkwOTY2NTEzMTg5ODU7XFxyXFxuICAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyA1XSkqMC4wMDQ0MzE4NDg0MTE5MzgzNDE7XFxyXFxuXFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLnJnYiAqIHN1bS5hICogYWxwaGEsIHN1bS5hICogYWxwaGEgKTtcXHJcXG59XFxyXFxuXCIsXHJcbiAgICAgICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmx1cjogeyB0eXBlOiAnMWYnLCB2YWx1ZTogMSAvIDUxMiB9LFxyXG4gICAgICAgICAgICBjb2xvcjogeyB0eXBlOiAnYycsIHZhbHVlOiBbMCwwLDBdfSxcclxuICAgICAgICAgICAgYWxwaGE6IHsgdHlwZTogJzFmJywgdmFsdWU6IDAuNyB9LFxyXG4gICAgICAgICAgICBvZmZzZXQ6IHsgdHlwZTogJzJmJywgdmFsdWU6WzUsIDVdfSxcclxuICAgICAgICAgICAgc3RyZW5ndGg6IHsgdHlwZTogJzFmJywgdmFsdWU6MX1cclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMucGFzc2VzID0gMTtcclxuICAgIHRoaXMuc3RyZW5ndGggPSA0O1xyXG59XHJcblxyXG5CbHVyWVRpbnRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcbkJsdXJZVGludEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbHVyWVRpbnRGaWx0ZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gQmx1cllUaW50RmlsdGVyO1xyXG5cclxuQmx1cllUaW50RmlsdGVyLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpXHJcbntcclxuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XHJcblxyXG4gICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aC52YWx1ZSA9IHRoaXMuc3RyZW5ndGggLyA0IC8gdGhpcy5wYXNzZXMgKiAoaW5wdXQuZnJhbWUuaGVpZ2h0IC8gaW5wdXQuc2l6ZS5oZWlnaHQpO1xyXG5cclxuICAgIGlmKHRoaXMucGFzc2VzID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZ2V0UmVuZGVyVGFyZ2V0KHRydWUpO1xyXG4gICAgICAgIHZhciBmbGlwID0gaW5wdXQ7XHJcbiAgICAgICAgdmFyIGZsb3AgPSByZW5kZXJUYXJnZXQ7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnBhc3Nlcy0xOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgZmxpcCwgZmxvcCwgY2xlYXIpO1xyXG5cclxuICAgICAgICAgICB2YXIgdGVtcCA9IGZsb3A7XHJcbiAgICAgICAgICAgZmxvcCA9IGZsaXA7XHJcbiAgICAgICAgICAgZmxpcCA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgZmxpcCwgb3V0cHV0LCBjbGVhcik7XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQmx1cllUaW50RmlsdGVyLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBib3RoIHRoZSBibHVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQmx1cllUaW50RmlsdGVyI1xyXG4gICAgICogQGRlZmF1bHQgMlxyXG4gICAgICovXHJcbiAgICBibHVyOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICB0aGlzLnN0cmVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSB2YWx1ZSAqIDAuNTtcclxuICAgICAgICAgICAgdGhpcy5zdHJlbmd0aCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpLFxyXG4gICAgQmx1clhGaWx0ZXIgPSByZXF1aXJlKCcuLi9ibHVyL0JsdXJYRmlsdGVyJyksXHJcbiAgICBCbHVyWVRpbnRGaWx0ZXIgPSByZXF1aXJlKCcuL0JsdXJZVGludEZpbHRlcicpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBEcm9wU2hhZG93RmlsdGVyIGFwcGxpZXMgYSBHYXVzc2lhbiBibHVyIHRvIGFuIG9iamVjdC5cclxuICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyIGNhbiBiZSBzZXQgZm9yIHgtIGFuZCB5LWF4aXMgc2VwYXJhdGVseS5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gRHJvcFNoYWRvd0ZpbHRlcigpXHJcbntcclxuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmJsdXJYRmlsdGVyID0gbmV3IEJsdXJYRmlsdGVyKCk7XHJcbiAgICB0aGlzLmJsdXJZVGludEZpbHRlciA9IG5ldyBCbHVyWVRpbnRGaWx0ZXIoKTtcclxuXHJcbiAgICB0aGlzLmRlZmF1bHRGaWx0ZXIgPSBuZXcgY29yZS5BYnN0cmFjdEZpbHRlcigpO1xyXG5cclxuICAgIHRoaXMucGFkZGluZyA9IDMwO1xyXG5cclxuICAgIHRoaXMuX2RpcnR5UG9zaXRpb24gPSB0cnVlO1xyXG4gICAgdGhpcy5fYW5nbGUgPSA0NSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICB0aGlzLl9kaXN0YW5jZSA9IDEwO1xyXG4gICAgdGhpcy5hbHBoYSA9IDAuNzU7XHJcbiAgICB0aGlzLmhpZGVPYmplY3QgPSBmYWxzZTtcclxuICAgIHRoaXMuYmxlbmRNb2RlID0gY29yZS5CTEVORF9NT0RFUy5NVUxUSVBMWTtcclxufVxyXG5cclxuRHJvcFNoYWRvd0ZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcclxuRHJvcFNoYWRvd0ZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcm9wU2hhZG93RmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IERyb3BTaGFkb3dGaWx0ZXI7XHJcblxyXG5Ecm9wU2hhZG93RmlsdGVyLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgaW5wdXQsIG91dHB1dClcclxue1xyXG4gICAgdmFyIHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZ2V0UmVuZGVyVGFyZ2V0KHRydWUpO1xyXG5cclxuICAgIC8vVE9ETyAtIGNvcHlUZXhTdWJJbWFnZTJEIGNvdWxkIGJlIHVzZWQgaGVyZT9cclxuICAgIGlmKHRoaXMuX2RpcnR5UG9zaXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fZGlydHlQb3NpdGlvbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5vZmZzZXQudmFsdWVbMF0gPSBNYXRoLnNpbih0aGlzLl9hbmdsZSkgKiB0aGlzLl9kaXN0YW5jZTtcclxuICAgICAgICB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5vZmZzZXQudmFsdWVbMV0gPSBNYXRoLmNvcyh0aGlzLl9hbmdsZSkgKiB0aGlzLl9kaXN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmJsdXJYRmlsdGVyLmFwcGx5RmlsdGVyKHJlbmRlcmVyLCBpbnB1dCwgcmVuZGVyVGFyZ2V0KTtcclxuXHJcbiAgICByZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZSh0aGlzLmJsZW5kTW9kZSk7XHJcblxyXG4gICAgdGhpcy5ibHVyWVRpbnRGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgb3V0cHV0KTtcclxuXHJcbiAgICByZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZShjb3JlLkJMRU5EX01PREVTLk5PUk1BTCk7XHJcblxyXG4gICAgaWYoIXRoaXMuaGlkZU9iamVjdClcclxuICAgIHtcclxuXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0RmlsdGVyLmFwcGx5RmlsdGVyKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5yZXR1cm5SZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKERyb3BTaGFkb3dGaWx0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlck9mIFBJWEkuZmlsdGVycy5Ecm9wU2hhZG93RmlsdGVyI1xyXG4gICAgICogQGRlZmF1bHQgMlxyXG4gICAgICovXHJcbiAgICBibHVyOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdGhpcy5ibHVyWVRpbnRGaWx0ZXIuYmx1ciA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clggcHJvcGVydHlcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyT2YgUElYSS5maWx0ZXJzLkRyb3BTaGFkb3dGaWx0ZXIjXHJcbiAgICAgKiBAZGVmYXVsdCAyXHJcbiAgICAgKi9cclxuICAgIGJsdXJYOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWSBwcm9wZXJ0eVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJPZiBQSVhJLmZpbHRlcnMuRHJvcFNoYWRvd0ZpbHRlciNcclxuICAgICAqIEBkZWZhdWx0IDJcclxuICAgICAqL1xyXG4gICAgYmx1clk6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibHVyWVRpbnRGaWx0ZXIuYmx1cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibHVyWVRpbnRGaWx0ZXIuYmx1ciA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgc2hhZG93XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlck9mIFBJWEkuZmlsdGVycy5Ecm9wU2hhZG93RmlsdGVyI1xyXG4gICAgICovXHJcbiAgICBjb2xvcjoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAgY29yZS51dGlscy5yZ2IyaGV4KCB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5jb2xvci52YWx1ZSApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5jb2xvci52YWx1ZSA9IGNvcmUudXRpbHMuaGV4MnJnYih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGFscGhhIG9mIHRoZSBzaGFkb3dcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyT2YgUElYSS5maWx0ZXJzLkRyb3BTaGFkb3dGaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIGFscGhhOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5hbHBoYS52YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibHVyWVRpbnRGaWx0ZXIudW5pZm9ybXMuYWxwaGEudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZGlzdGFuY2Ugb2YgdGhlIHNoYWRvd1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJPZiBQSVhJLmZpbHRlcnMuRHJvcFNoYWRvd0ZpbHRlciNcclxuICAgICAqL1xyXG4gICAgZGlzdGFuY2U6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gIHRoaXMuX2Rpc3RhbmNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eVBvc2l0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYW5nbGUgb2YgdGhlIHNoYWRvd1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJPZiBQSVhJLmZpbHRlcnMuRHJvcFNoYWRvd0ZpbHRlciNcclxuICAgICAqL1xyXG4gICAgYW5nbGU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gIHRoaXMuX2FuZ2xlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eVBvc2l0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fYW5nbGUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcclxuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcclxuXHJcblxyXG4vKipcclxuICogVGhpcyBncmV5c2NhbGVzIHRoZSBwYWxldHRlIG9mIHlvdXIgRGlzcGxheSBPYmplY3RzLlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBHcmF5RmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gZmxvYXQgZ3JheTtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG4gICBnbF9GcmFnQ29sb3IucmdiID0gbWl4KGdsX0ZyYWdDb2xvci5yZ2IsIHZlYzMoMC4yMTI2KmdsX0ZyYWdDb2xvci5yICsgMC43MTUyKmdsX0ZyYWdDb2xvci5nICsgMC4wNzIyKmdsX0ZyYWdDb2xvci5iKSwgZ3JheSk7XFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdyYXk6IHsgdHlwZTogJzFmJywgdmFsdWU6IDEgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn1cclxuXHJcbkdyYXlGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcbkdyYXlGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JheUZpbHRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBHcmF5RmlsdGVyO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoR3JheUZpbHRlci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBncmF5LiAxIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGJsYWNrIGFuZCB3aGl0ZSwgMCB3aWxsIG1ha2UgdGhlIG9iamVjdCBpdHMgbm9ybWFsIGNvbG9yLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuR3JheUZpbHRlciNcclxuICAgICAqL1xyXG4gICAgZ3JheToge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdyYXkudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuZ3JheS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsIi8qKlxyXG4gKiBAZmlsZSAgICAgICAgTWFpbiBleHBvcnQgb2YgdGhlIFBJWEkgZmlsdGVycyBsaWJyYXJ5XHJcbiAqIEBhdXRob3IgICAgICBNYXQgR3JvdmVzIDxtYXRAZ29vZGJveWRpZ2l0YWwuY29tPlxyXG4gKiBAY29weXJpZ2h0ICAgMjAxMy0yMDE1IEdvb2RCb3lEaWdpdGFsXHJcbiAqIEBsaWNlbnNlICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUIExpY2Vuc2V9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgUElYSS5maWx0ZXJzXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEFzY2lpRmlsdGVyOiAgICAgICAgcmVxdWlyZSgnLi9hc2NpaS9Bc2NpaUZpbHRlcicpLFxyXG4gICAgQmxvb21GaWx0ZXI6ICAgICAgICByZXF1aXJlKCcuL2Jsb29tL0Jsb29tRmlsdGVyJyksXHJcbiAgICBCbHVyRmlsdGVyOiAgICAgICAgIHJlcXVpcmUoJy4vYmx1ci9CbHVyRmlsdGVyJyksXHJcbiAgICBCbHVyWEZpbHRlcjogICAgICAgIHJlcXVpcmUoJy4vYmx1ci9CbHVyWEZpbHRlcicpLFxyXG4gICAgQmx1cllGaWx0ZXI6ICAgICAgICByZXF1aXJlKCcuL2JsdXIvQmx1cllGaWx0ZXInKSxcclxuICAgIEJsdXJEaXJGaWx0ZXI6ICAgICAgcmVxdWlyZSgnLi9ibHVyL0JsdXJEaXJGaWx0ZXInKSxcclxuICAgIENvbG9yTWF0cml4RmlsdGVyOiAgcmVxdWlyZSgnLi9jb2xvci9Db2xvck1hdHJpeEZpbHRlcicpLFxyXG4gICAgQ29sb3JTdGVwRmlsdGVyOiAgICByZXF1aXJlKCcuL2NvbG9yL0NvbG9yU3RlcEZpbHRlcicpLFxyXG4gICAgQ29udm9sdXRpb25GaWx0ZXI6ICByZXF1aXJlKCcuL2NvbnZvbHV0aW9uL0NvbnZvbHV0aW9uRmlsdGVyJyksXHJcbiAgICBDcm9zc0hhdGNoRmlsdGVyOiAgIHJlcXVpcmUoJy4vY3Jvc3NoYXRjaC9Dcm9zc0hhdGNoRmlsdGVyJyksXHJcbiAgICBEaXNwbGFjZW1lbnRGaWx0ZXI6IHJlcXVpcmUoJy4vZGlzcGxhY2VtZW50L0Rpc3BsYWNlbWVudEZpbHRlcicpLFxyXG4gICAgRG90U2NyZWVuRmlsdGVyOiAgICByZXF1aXJlKCcuL2RvdC9Eb3RTY3JlZW5GaWx0ZXInKSxcclxuICAgIEdyYXlGaWx0ZXI6ICAgICAgICAgcmVxdWlyZSgnLi9ncmF5L0dyYXlGaWx0ZXInKSxcclxuICAgIERyb3BTaGFkb3dGaWx0ZXI6ICAgcmVxdWlyZSgnLi9kcm9wc2hhZG93L0Ryb3BTaGFkb3dGaWx0ZXInKSxcclxuICAgIEludmVydEZpbHRlcjogICAgICAgcmVxdWlyZSgnLi9pbnZlcnQvSW52ZXJ0RmlsdGVyJyksXHJcbiAgICBOb2lzZUZpbHRlcjogICAgICAgIHJlcXVpcmUoJy4vbm9pc2UvTm9pc2VGaWx0ZXInKSxcclxuICAgIFBpeGVsYXRlRmlsdGVyOiAgICAgcmVxdWlyZSgnLi9waXhlbGF0ZS9QaXhlbGF0ZUZpbHRlcicpLFxyXG4gICAgUkdCU3BsaXRGaWx0ZXI6ICAgICByZXF1aXJlKCcuL3JnYi9SR0JTcGxpdEZpbHRlcicpLFxyXG4gICAgU2hvY2t3YXZlRmlsdGVyOiAgICByZXF1aXJlKCcuL3Nob2Nrd2F2ZS9TaG9ja3dhdmVGaWx0ZXInKSxcclxuICAgIFNlcGlhRmlsdGVyOiAgICAgICAgcmVxdWlyZSgnLi9zZXBpYS9TZXBpYUZpbHRlcicpLFxyXG4gICAgU21hcnRCbHVyRmlsdGVyOiAgICByZXF1aXJlKCcuL2JsdXIvU21hcnRCbHVyRmlsdGVyJyksXHJcbiAgICBUaWx0U2hpZnRGaWx0ZXI6ICAgIHJlcXVpcmUoJy4vdGlsdHNoaWZ0L1RpbHRTaGlmdEZpbHRlcicpLFxyXG4gICAgVGlsdFNoaWZ0WEZpbHRlcjogICByZXF1aXJlKCcuL3RpbHRzaGlmdC9UaWx0U2hpZnRYRmlsdGVyJyksXHJcbiAgICBUaWx0U2hpZnRZRmlsdGVyOiAgIHJlcXVpcmUoJy4vdGlsdHNoaWZ0L1RpbHRTaGlmdFlGaWx0ZXInKSxcclxuICAgIFR3aXN0RmlsdGVyOiAgICAgICAgcmVxdWlyZSgnLi90d2lzdC9Ud2lzdEZpbHRlcicpXHJcbn07XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xyXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGludmVydHMgeW91ciBEaXNwbGF5IE9iamVjdHMgY29sb3JzLlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBJbnZlcnRGaWx0ZXIoKVxyXG57XHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gZmxvYXQgaW52ZXJ0O1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG5cXHJcXG4gICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggKHZlYzMoMSktZ2xfRnJhZ0NvbG9yLnJnYikgKiBnbF9GcmFnQ29sb3IuYSwgZ2xfRnJhZ0NvbG9yLnJnYiwgMS4wIC0gaW52ZXJ0KTtcXHJcXG59XFxyXFxuXCIsXHJcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnZlcnQ6IHsgdHlwZTogJzFmJywgdmFsdWU6IDEgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn1cclxuXHJcbkludmVydEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcclxuSW52ZXJ0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludmVydEZpbHRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBJbnZlcnRGaWx0ZXI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhJbnZlcnRGaWx0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgaW52ZXJ0LiBgMWAgd2lsbCBmdWxseSBpbnZlcnQgdGhlIGNvbG9ycywgYW5kXHJcbiAgICAgKiBgMGAgd2lsbCBtYWtlIHRoZSBvYmplY3QgaXRzIG5vcm1hbCBjb2xvci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkludmVydEZpbHRlciNcclxuICAgICAqL1xyXG4gICAgaW52ZXJ0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuaW52ZXJ0LnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmludmVydC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xyXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFZpY28gQHZpY29jb3RlYVxyXG4gKiBvcmlnaW5hbCBmaWx0ZXI6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9nbGZ4LmpzL2Jsb2IvbWFzdGVyL3NyYy9maWx0ZXJzL2FkanVzdC9ub2lzZS5qc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIE5vaXNlIGVmZmVjdCBmaWx0ZXIuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIE5vaXNlRmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXHJcXG5cXHJcXG51bmlmb3JtIGZsb2F0IG5vaXNlO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbmZsb2F0IHJhbmQodmVjMiBjbylcXHJcXG57XFxyXFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4oKVxcclxcbntcXHJcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxyXFxuXFxyXFxuICAgIGZsb2F0IGRpZmYgPSAocmFuZCh2VGV4dHVyZUNvb3JkKSAtIDAuNSkgKiBub2lzZTtcXHJcXG5cXHJcXG4gICAgY29sb3IuciArPSBkaWZmO1xcclxcbiAgICBjb2xvci5nICs9IGRpZmY7XFxyXFxuICAgIGNvbG9yLmIgKz0gZGlmZjtcXHJcXG5cXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbm9pc2U6IHsgdHlwZTogJzFmJywgdmFsdWU6IDAuNSB9XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufVxyXG5cclxuTm9pc2VGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcbk5vaXNlRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vaXNlRmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE5vaXNlRmlsdGVyO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTm9pc2VGaWx0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbW91bnQgb2Ygbm9pc2UgdG8gYXBwbHkuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5Ob2lzZUZpbHRlciNcclxuICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICovXHJcbiAgICBub2lzZToge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm5vaXNlLnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLm5vaXNlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XHJcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoaXMgZmlsdGVyIGFwcGxpZXMgYSBwaXhlbGF0ZSBlZmZlY3QgbWFraW5nIGRpc3BsYXkgb2JqZWN0cyBhcHBlYXIgJ2Jsb2NreScuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIFBpeGVsYXRlRmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzQgZGltZW5zaW9ucztcXHJcXG51bmlmb3JtIHZlYzIgcGl4ZWxTaXplO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxuICAgIHZlYzIgc2l6ZSA9IGRpbWVuc2lvbnMueHkgLyBwaXhlbFNpemU7XFxyXFxuXFxyXFxuICAgIHZlYzIgY29sb3IgPSBmbG9vciggKCB2VGV4dHVyZUNvb3JkICogc2l6ZSApICkgLyBzaXplICsgcGl4ZWxTaXplL2RpbWVuc2lvbnMueHkgKiAwLjU7XFxyXFxuXFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29sb3IpO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHsgdHlwZTogJzRmdicsICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMF0pIH0sXHJcbiAgICAgICAgICAgIHBpeGVsU2l6ZTogIHsgdHlwZTogJ3YyJywgICB2YWx1ZTogeyB4OiAxMCwgeTogMTAgfSB9XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufVxyXG5cclxuUGl4ZWxhdGVGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcblBpeGVsYXRlRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBpeGVsYXRlRmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFBpeGVsYXRlRmlsdGVyO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUGl4ZWxhdGVGaWx0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgYSBwb2ludCB0aGF0IGRlc2NyaWJlcyB0aGUgc2l6ZSBvZiB0aGUgYmxvY2tzLlxyXG4gICAgICogeCBpcyB0aGUgd2lkdGggb2YgdGhlIGJsb2NrIGFuZCB5IGlzIHRoZSBoZWlnaHQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuUGl4ZWxhdGVGaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIHNpemU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5waXhlbFNpemUudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucGl4ZWxTaXplLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XHJcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XHJcblxyXG5cclxuLyoqXHJcbiAqIEFuIFJHQiBTcGxpdCBGaWx0ZXIuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIFJHQlNwbGl0RmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIHZlYzQgZGltZW5zaW9ucztcXHJcXG51bmlmb3JtIHZlYzIgcmVkO1xcclxcbnVuaWZvcm0gdmVjMiBncmVlbjtcXHJcXG51bmlmb3JtIHZlYzIgYmx1ZTtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgZ2xfRnJhZ0NvbG9yLnIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyByZWQvZGltZW5zaW9ucy54eSkucjtcXHJcXG4gICBnbF9GcmFnQ29sb3IuZyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCArIGdyZWVuL2RpbWVuc2lvbnMueHkpLmc7XFxyXFxuICAgZ2xfRnJhZ0NvbG9yLmIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyBibHVlL2RpbWVuc2lvbnMueHkpLmI7XFxyXFxuICAgZ2xfRnJhZ0NvbG9yLmEgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpLmE7XFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVkOiAgICAgICAgeyB0eXBlOiAndjInLCB2YWx1ZTogeyB4OiAyMCwgeTogMjAgfSB9LFxyXG4gICAgICAgICAgICBncmVlbjogICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IC0yMCwgeTogMjAgfSB9LFxyXG4gICAgICAgICAgICBibHVlOiAgICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDIwLCB5OiAtMjAgfSB9LFxyXG4gICAgICAgICAgICBkaW1lbnNpb25zOiB7IHR5cGU6ICc0ZnYnLCB2YWx1ZTogWzAsIDAsIDAsIDBdIH1cclxuICAgICAgICB9XHJcbiAgICApO1xyXG59XHJcblxyXG5SR0JTcGxpdEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcclxuUkdCU3BsaXRGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUkdCU3BsaXRGaWx0ZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gUkdCU3BsaXRGaWx0ZXI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSR0JTcGxpdEZpbHRlci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogUmVkIGNoYW5uZWwgb2Zmc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlJHQlNwbGl0RmlsdGVyI1xyXG4gICAgICovXHJcbiAgICByZWQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5yZWQudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucmVkLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyZWVuIGNoYW5uZWwgb2Zmc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlJHQlNwbGl0RmlsdGVyI1xyXG4gICAgICovXHJcbiAgICBncmVlbjoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdyZWVuLnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmdyZWVuLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJsdWUgb2Zmc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlJHQlNwbGl0RmlsdGVyI1xyXG4gICAgICovXHJcbiAgICBibHVlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYmx1ZS52YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5ibHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XHJcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoaXMgYXBwbGllcyBhIHNlcGlhIGVmZmVjdCB0byB5b3VyIERpc3BsYXkgT2JqZWN0cy5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gU2VwaWFGaWx0ZXIoKVxyXG57XHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gZmxvYXQgc2VwaWE7XFxyXFxuXFxyXFxuY29uc3QgbWF0MyBzZXBpYU1hdHJpeCA9IG1hdDMoMC4zNTg4LCAwLjcwNDQsIDAuMTM2OCwgMC4yOTkwLCAwLjU4NzAsIDAuMTE0MCwgMC4yMzkyLCAwLjQ2OTYsIDAuMDkxMik7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxyXFxuICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZ2xfRnJhZ0NvbG9yLnJnYiAqIHNlcGlhTWF0cml4LCBzZXBpYSk7XFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2VwaWE6IHsgdHlwZTogJzFmJywgdmFsdWU6IDEgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn1cclxuXHJcblNlcGlhRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xyXG5TZXBpYUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXBpYUZpbHRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBTZXBpYUZpbHRlcjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNlcGlhRmlsdGVyLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3RyZW5ndGggb2YgdGhlIHNlcGlhLiBgMWAgd2lsbCBhcHBseSB0aGUgZnVsbCBzZXBpYSBlZmZlY3QsIGFuZFxyXG4gICAgICogYDBgIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGl0cyBub3JtYWwgY29sb3IuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5TZXBpYUZpbHRlciNcclxuICAgICAqL1xyXG4gICAgc2VwaWE6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zZXBpYS52YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5zZXBpYS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xyXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgQ29sb3JNYXRyaXhGaWx0ZXIgY2xhc3MgbGV0cyB5b3UgYXBwbHkgYSA0eDQgbWF0cml4IHRyYW5zZm9ybWF0aW9uIG9uIHRoZSBSR0JBXHJcbiAqIGNvbG9yIGFuZCBhbHBoYSB2YWx1ZXMgb2YgZXZlcnkgcGl4ZWwgb24geW91ciBkaXNwbGF5T2JqZWN0IHRvIHByb2R1Y2UgYSByZXN1bHRcclxuICogd2l0aCBhIG5ldyBzZXQgb2YgUkdCQSBjb2xvciBhbmQgYWxwaGEgdmFsdWVzLiBJdCdzIHByZXR0eSBwb3dlcmZ1bCFcclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gU2hvY2t3YXZlRmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgXCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzIgY2VudGVyO1xcclxcbnVuaWZvcm0gdmVjMyBwYXJhbXM7IC8vIDEwLjAsIDAuOCwgMC4xXFxyXFxudW5pZm9ybSBmbG9hdCB0aW1lO1xcclxcblxcclxcbnZvaWQgbWFpbigpXFxyXFxue1xcclxcbiAgICB2ZWMyIHV2ID0gdlRleHR1cmVDb29yZDtcXHJcXG4gICAgdmVjMiB0ZXhDb29yZCA9IHV2O1xcclxcblxcclxcbiAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UodXYsIGNlbnRlcik7XFxyXFxuXFxyXFxuICAgIGlmICggKGRpc3QgPD0gKHRpbWUgKyBwYXJhbXMueikpICYmIChkaXN0ID49ICh0aW1lIC0gcGFyYW1zLnopKSApXFxyXFxuICAgIHtcXHJcXG4gICAgICAgIGZsb2F0IGRpZmYgPSAoZGlzdCAtIHRpbWUpO1xcclxcbiAgICAgICAgZmxvYXQgcG93RGlmZiA9IDEuMCAtIHBvdyhhYnMoZGlmZipwYXJhbXMueCksIHBhcmFtcy55KTtcXHJcXG5cXHJcXG4gICAgICAgIGZsb2F0IGRpZmZUaW1lID0gZGlmZiAgKiBwb3dEaWZmO1xcclxcbiAgICAgICAgdmVjMiBkaWZmVVYgPSBub3JtYWxpemUodXYgLSBjZW50ZXIpO1xcclxcbiAgICAgICAgdGV4Q29vcmQgPSB1diArIChkaWZmVVYgKiBkaWZmVGltZSk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB0ZXhDb29yZCk7XFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2VudGVyOiB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDAuNSwgeTogMC41IH0gfSxcclxuICAgICAgICAgICAgcGFyYW1zOiB7IHR5cGU6ICd2MycsIHZhbHVlOiB7IHg6IDEwLCB5OiAwLjgsIHo6IDAuMSB9IH0sXHJcbiAgICAgICAgICAgIHRpbWU6IHsgdHlwZTogJzFmJywgdmFsdWU6IDAgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn1cclxuXHJcblNob2Nrd2F2ZUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcclxuU2hvY2t3YXZlRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNob2Nrd2F2ZUZpbHRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBTaG9ja3dhdmVGaWx0ZXI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhTaG9ja3dhdmVGaWx0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNlbnRlciBvZiB0aGUgc2hvY2t3YXZlIGluIG5vcm1hbGl6ZWQgc2NyZWVuIGNvb3Jkcy4gVGhhdCBpc1xyXG4gICAgICogKDAsMCkgaXMgdGhlIHRvcC1sZWZ0IGFuZCAoMSwxKSBpcyB0aGUgYm90dG9tIHJpZ2h0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge29iamVjdDxzdHJpbmcsIG51bWJlcj59XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlNob2Nrd2F2ZUZpbHRlciNcclxuICAgICAqL1xyXG4gICAgY2VudGVyOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuY2VudGVyLnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmNlbnRlci52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBhcmFtcyBvZiB0aGUgc2hvY2t3YXZlLiBUaGVzZSBtb2RpZnkgdGhlIGxvb2sgYW5kIGJlaGF2aW9yIG9mXHJcbiAgICAgKiB0aGUgc2hvY2t3YXZlIGFzIGl0IHJpcHBsZXMgb3V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge29iamVjdDxzdHJpbmcsIG51bWJlcj59XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlNob2Nrd2F2ZUZpbHRlciNcclxuICAgICAqL1xyXG4gICAgcGFyYW1zOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucGFyYW1zLnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnBhcmFtcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVsYXBzZWQgdGltZSBvZiB0aGUgc2hvY2t3YXZlLiBUaGlzIGNvbnRyb2xzIHRoZSBzcGVlZCBhdCB3aGljaFxyXG4gICAgICogdGhlIHNob2Nrd2F2ZSByaXBwbGVzIG91dC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlNob2Nrd2F2ZUZpbHRlciNcclxuICAgICAqL1xyXG4gICAgdGltZToge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnRpbWUudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudGltZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xyXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFZpY28gQHZpY29jb3RlYVxyXG4gKiBvcmlnaW5hbCBmaWx0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanMgYnkgRXZhbiBXYWxsYWNlIDogaHR0cDovL21hZGVieWV2YW4uY29tL1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIFRpbHRTaGlmdEF4aXNGaWx0ZXIuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIFRpbHRTaGlmdEF4aXNGaWx0ZXIoKVxyXG57XHJcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gZmxvYXQgYmx1cjtcXHJcXG51bmlmb3JtIGZsb2F0IGdyYWRpZW50Qmx1cjtcXHJcXG51bmlmb3JtIHZlYzIgc3RhcnQ7XFxyXFxudW5pZm9ybSB2ZWMyIGVuZDtcXHJcXG51bmlmb3JtIHZlYzIgZGVsdGE7XFxyXFxudW5pZm9ybSB2ZWMyIHRleFNpemU7XFxyXFxuXFxyXFxuZmxvYXQgcmFuZG9tKHZlYzMgc2NhbGUsIGZsb2F0IHNlZWQpXFxyXFxue1xcclxcbiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChnbF9GcmFnQ29vcmQueHl6ICsgc2VlZCwgc2NhbGUpKSAqIDQzNzU4LjU0NTMgKyBzZWVkKTtcXHJcXG59XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcclxcbiAgICBmbG9hdCB0b3RhbCA9IDAuMDtcXHJcXG5cXHJcXG4gICAgZmxvYXQgb2Zmc2V0ID0gcmFuZG9tKHZlYzMoMTIuOTg5OCwgNzguMjMzLCAxNTEuNzE4MiksIDAuMCk7XFxyXFxuICAgIHZlYzIgbm9ybWFsID0gbm9ybWFsaXplKHZlYzIoc3RhcnQueSAtIGVuZC55LCBlbmQueCAtIHN0YXJ0LngpKTtcXHJcXG4gICAgZmxvYXQgcmFkaXVzID0gc21vb3Roc3RlcCgwLjAsIDEuMCwgYWJzKGRvdCh2VGV4dHVyZUNvb3JkICogdGV4U2l6ZSAtIHN0YXJ0LCBub3JtYWwpKSAvIGdyYWRpZW50Qmx1cikgKiBibHVyO1xcclxcblxcclxcbiAgICBmb3IgKGZsb2F0IHQgPSAtMzAuMDsgdCA8PSAzMC4wOyB0KyspXFxyXFxuICAgIHtcXHJcXG4gICAgICAgIGZsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyAzMC4wO1xcclxcbiAgICAgICAgZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcclxcbiAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyBkZWx0YSAvIHRleFNpemUgKiBwZXJjZW50ICogcmFkaXVzKTtcXHJcXG4gICAgICAgIHNhbXBsZS5yZ2IgKj0gc2FtcGxlLmE7XFxyXFxuICAgICAgICBjb2xvciArPSBzYW1wbGUgKiB3ZWlnaHQ7XFxyXFxuICAgICAgICB0b3RhbCArPSB3ZWlnaHQ7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yLnJnYiAvPSBnbF9GcmFnQ29sb3IuYSArIDAuMDAwMDE7XFxyXFxufVxcclxcblwiLFxyXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmx1cjogICAgICAgICAgIHsgdHlwZTogJzFmJywgdmFsdWU6IDEwMCB9LFxyXG4gICAgICAgICAgICBncmFkaWVudEJsdXI6ICAgeyB0eXBlOiAnMWYnLCB2YWx1ZTogNjAwIH0sXHJcbiAgICAgICAgICAgIHN0YXJ0OiAgICAgICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDAsICAgIHk6IHdpbmRvdy5pbm5lckhlaWdodCAvIDIgfSB9LFxyXG4gICAgICAgICAgICBlbmQ6ICAgICAgICAgICAgeyB0eXBlOiAndjInLCB2YWx1ZTogeyB4OiA2MDAsICB5OiB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIH0gfSxcclxuICAgICAgICAgICAgZGVsdGE6ICAgICAgICAgIHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogMzAsICAgeTogMzAgfSB9LFxyXG4gICAgICAgICAgICB0ZXhTaXplOiAgICAgICAgeyB0eXBlOiAndjInLCB2YWx1ZTogeyB4OiB3aW5kb3cuaW5uZXJXaWR0aCwgeTogd2luZG93LmlubmVySGVpZ2h0IH0gfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVEZWx0YSgpO1xyXG59XHJcblxyXG5UaWx0U2hpZnRBeGlzRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xyXG5UaWx0U2hpZnRBeGlzRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbHRTaGlmdEF4aXNGaWx0ZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gVGlsdFNoaWZ0QXhpc0ZpbHRlcjtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBmaWx0ZXIgZGVsdGEgdmFsdWVzLlxyXG4gKiBUaGlzIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFggYW5kIFkgZmlsdGVycywgZG9lcyBub3RoaW5nIGZvciB0aGlzIGNsYXNzLlxyXG4gKlxyXG4gKi9cclxuVGlsdFNoaWZ0QXhpc0ZpbHRlci5wcm90b3R5cGUudXBkYXRlRGVsdGEgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhLnZhbHVlLnggPSAwO1xyXG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YS52YWx1ZS55ID0gMDtcclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRpbHRTaGlmdEF4aXNGaWx0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlRpbHRTaGlmdEF4aXNGaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIGJsdXI6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5ibHVyLnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBncmFkaWVudCBibHVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuVGlsdFNoaWZ0QXhpc0ZpbHRlciNcclxuICAgICAqL1xyXG4gICAgZ3JhZGllbnRCbHVyOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ3JhZGllbnRCbHVyLnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmdyYWRpZW50Qmx1ci52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgWCB2YWx1ZSB0byBzdGFydCB0aGUgZWZmZWN0IGF0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlRpbHRTaGlmdEF4aXNGaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc3RhcnQudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc3RhcnQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVEZWx0YSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgWCB2YWx1ZSB0byBlbmQgdGhlIGVmZmVjdCBhdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5UaWx0U2hpZnRBeGlzRmlsdGVyI1xyXG4gICAgICovXHJcbiAgICBlbmQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5lbmQudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuZW5kLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGVsdGEoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKSxcclxuICAgIFRpbHRTaGlmdFhGaWx0ZXIgPSByZXF1aXJlKCcuL1RpbHRTaGlmdFhGaWx0ZXInKSxcclxuICAgIFRpbHRTaGlmdFlGaWx0ZXIgPSByZXF1aXJlKCcuL1RpbHRTaGlmdFlGaWx0ZXInKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFZpY28gQHZpY29jb3RlYVxyXG4gKiBvcmlnaW5hbCBmaWx0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanMgYnkgRXZhbiBXYWxsYWNlIDogaHR0cDovL21hZGVieWV2YW4uY29tL1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIFRpbHRTaGlmdCBGaWx0ZXIuIE1hbmFnZXMgdGhlIHBhc3Mgb2YgYm90aCBhIFRpbHRTaGlmdFhGaWx0ZXIgYW5kIFRpbHRTaGlmdFlGaWx0ZXIuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIFRpbHRTaGlmdEZpbHRlcigpXHJcbntcclxuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIgPSBuZXcgVGlsdFNoaWZ0WEZpbHRlcigpO1xyXG4gICAgdGhpcy50aWx0U2hpZnRZRmlsdGVyID0gbmV3IFRpbHRTaGlmdFlGaWx0ZXIoKTtcclxufVxyXG5cclxuVGlsdFNoaWZ0RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xyXG5UaWx0U2hpZnRGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGlsdFNoaWZ0RmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbHRTaGlmdEZpbHRlcjtcclxuXHJcblRpbHRTaGlmdEZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQpXHJcbntcclxuICAgIHZhciByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmdldFJlbmRlclRhcmdldCh0cnVlKTtcclxuXHJcbiAgICB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIGlucHV0LCByZW5kZXJUYXJnZXQpO1xyXG5cclxuICAgIHRoaXMudGlsdFNoaWZ0WUZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQpO1xyXG5cclxuICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWx0U2hpZnRGaWx0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlRpbHRTaGlmdEZpbHRlciNcclxuICAgICAqL1xyXG4gICAgYmx1cjoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuYmx1cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50aWx0U2hpZnRYRmlsdGVyLmJsdXIgPSB0aGlzLnRpbHRTaGlmdFlGaWx0ZXIuYmx1ciA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3RyZW5ndGggb2YgdGhlIGdyYWRpZW50IGJsdXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5UaWx0U2hpZnRGaWx0ZXIjXHJcbiAgICAgKi9cclxuICAgIGdyYWRpZW50Qmx1cjoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuZ3JhZGllbnRCbHVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuZ3JhZGllbnRCbHVyID0gdGhpcy50aWx0U2hpZnRZRmlsdGVyLmdyYWRpZW50Qmx1ciA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgWSB2YWx1ZSB0byBzdGFydCB0aGUgZWZmZWN0IGF0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuVGlsdFNoaWZ0RmlsdGVyI1xyXG4gICAgICovXHJcbiAgICBzdGFydDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuc3RhcnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5zdGFydCA9IHRoaXMudGlsdFNoaWZ0WUZpbHRlci5zdGFydCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgWSB2YWx1ZSB0byBlbmQgdGhlIGVmZmVjdCBhdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlRpbHRTaGlmdEZpbHRlciNcclxuICAgICAqL1xyXG4gICAgZW5kOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5lbmQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5lbmQgPSB0aGlzLnRpbHRTaGlmdFlGaWx0ZXIuZW5kID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIFRpbHRTaGlmdEF4aXNGaWx0ZXIgPSByZXF1aXJlKCcuL1RpbHRTaGlmdEF4aXNGaWx0ZXInKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFZpY28gQHZpY29jb3RlYVxyXG4gKiBvcmlnaW5hbCBmaWx0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanMgYnkgRXZhbiBXYWxsYWNlIDogaHR0cDovL21hZGVieWV2YW4uY29tL1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIFRpbHRTaGlmdFhGaWx0ZXIuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLlRpbHRTaGlmdEF4aXNGaWx0ZXJcclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gVGlsdFNoaWZ0WEZpbHRlcigpXHJcbntcclxuICAgIFRpbHRTaGlmdEF4aXNGaWx0ZXIuY2FsbCh0aGlzKTtcclxufVxyXG5cclxuVGlsdFNoaWZ0WEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRpbHRTaGlmdEF4aXNGaWx0ZXIucHJvdG90eXBlKTtcclxuVGlsdFNoaWZ0WEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWx0U2hpZnRYRmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbHRTaGlmdFhGaWx0ZXI7XHJcblxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgZmlsdGVyIGRlbHRhIHZhbHVlcy5cclxuICpcclxuICovXHJcblRpbHRTaGlmdFhGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZURlbHRhID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIGR4ID0gdGhpcy51bmlmb3Jtcy5lbmQudmFsdWUueCAtIHRoaXMudW5pZm9ybXMuc3RhcnQudmFsdWUueDtcclxuICAgIHZhciBkeSA9IHRoaXMudW5pZm9ybXMuZW5kLnZhbHVlLnkgLSB0aGlzLnVuaWZvcm1zLnN0YXJ0LnZhbHVlLnk7XHJcbiAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcblxyXG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YS52YWx1ZS54ID0gZHggLyBkO1xyXG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YS52YWx1ZS55ID0gZHkgLyBkO1xyXG59O1xyXG4iLCJ2YXIgVGlsdFNoaWZ0QXhpc0ZpbHRlciA9IHJlcXVpcmUoJy4vVGlsdFNoaWZ0QXhpc0ZpbHRlcicpO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgVmljbyBAdmljb2NvdGVhXHJcbiAqIG9yaWdpbmFsIGZpbHRlciBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iL21hc3Rlci9zcmMvZmlsdGVycy9ibHVyL3RpbHRzaGlmdC5qcyBieSBFdmFuIFdhbGxhY2UgOiBodHRwOi8vbWFkZWJ5ZXZhbi5jb20vXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgVGlsdFNoaWZ0WUZpbHRlci5cclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuVGlsdFNoaWZ0QXhpc0ZpbHRlclxyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBUaWx0U2hpZnRZRmlsdGVyKClcclxue1xyXG4gICAgVGlsdFNoaWZ0QXhpc0ZpbHRlci5jYWxsKHRoaXMpO1xyXG59XHJcblxyXG5UaWx0U2hpZnRZRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGlsdFNoaWZ0QXhpc0ZpbHRlci5wcm90b3R5cGUpO1xyXG5UaWx0U2hpZnRZRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbHRTaGlmdFlGaWx0ZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gVGlsdFNoaWZ0WUZpbHRlcjtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBmaWx0ZXIgZGVsdGEgdmFsdWVzLlxyXG4gKlxyXG4gKi9cclxuVGlsdFNoaWZ0WUZpbHRlci5wcm90b3R5cGUudXBkYXRlRGVsdGEgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgZHggPSB0aGlzLnVuaWZvcm1zLmVuZC52YWx1ZS54IC0gdGhpcy51bmlmb3Jtcy5zdGFydC52YWx1ZS54O1xyXG4gICAgdmFyIGR5ID0gdGhpcy51bmlmb3Jtcy5lbmQudmFsdWUueSAtIHRoaXMudW5pZm9ybXMuc3RhcnQudmFsdWUueTtcclxuICAgIHZhciBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuXHJcbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhLnZhbHVlLnggPSAtZHkgLyBkO1xyXG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YS52YWx1ZS55ID0gZHggLyBkO1xyXG59O1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcclxuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcclxuXHJcblxyXG4vKipcclxuICogVGhpcyBmaWx0ZXIgYXBwbGllcyBhIHR3aXN0IGVmZmVjdCBtYWtpbmcgZGlzcGxheSBvYmplY3RzIGFwcGVhciB0d2lzdGVkIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIFR3aXN0RmlsdGVyKClcclxue1xyXG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXHJcXG51bmlmb3JtIGZsb2F0IGFuZ2xlO1xcclxcbnVuaWZvcm0gdmVjMiBvZmZzZXQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgIHZlYzIgY29vcmQgPSB2VGV4dHVyZUNvb3JkIC0gb2Zmc2V0O1xcclxcbiAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoY29vcmQpO1xcclxcblxcclxcbiAgIGlmIChkaXN0IDwgcmFkaXVzKVxcclxcbiAgIHtcXHJcXG4gICAgICAgZmxvYXQgcmF0aW8gPSAocmFkaXVzIC0gZGlzdCkgLyByYWRpdXM7XFxyXFxuICAgICAgIGZsb2F0IGFuZ2xlTW9kID0gcmF0aW8gKiByYXRpbyAqIGFuZ2xlO1xcclxcbiAgICAgICBmbG9hdCBzID0gc2luKGFuZ2xlTW9kKTtcXHJcXG4gICAgICAgZmxvYXQgYyA9IGNvcyhhbmdsZU1vZCk7XFxyXFxuICAgICAgIGNvb3JkID0gdmVjMihjb29yZC54ICogYyAtIGNvb3JkLnkgKiBzLCBjb29yZC54ICogcyArIGNvb3JkLnkgKiBjKTtcXHJcXG4gICB9XFxyXFxuXFxyXFxuICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb29yZCtvZmZzZXQpO1xcclxcbn1cXHJcXG5cIixcclxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJhZGl1czogICAgIHsgdHlwZTogJzFmJywgdmFsdWU6IDAuNSB9LFxyXG4gICAgICAgICAgICBhbmdsZTogICAgICB7IHR5cGU6ICcxZicsIHZhbHVlOiA1IH0sXHJcbiAgICAgICAgICAgIG9mZnNldDogICAgIHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogMC41LCB5OiAwLjUgfSB9XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufVxyXG5cclxuVHdpc3RGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XHJcblR3aXN0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR3aXN0RmlsdGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFR3aXN0RmlsdGVyO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHdpc3RGaWx0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgcG9pbnQgZGVzY3JpYmVzIHRoZSB0aGUgb2Zmc2V0IG9mIHRoZSB0d2lzdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5Ud2lzdEZpbHRlciNcclxuICAgICAqL1xyXG4gICAgb2Zmc2V0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMub2Zmc2V0LnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLm9mZnNldC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHJhZGl1cyBvZiB0aGUgdHdpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5Ud2lzdEZpbHRlciNcclxuICAgICAqL1xyXG4gICAgcmFkaXVzOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucmFkaXVzLnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGFuZ2xlIG9mIHRoZSB0d2lzdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlR3aXN0RmlsdGVyI1xyXG4gICAgICovXHJcbiAgICBhbmdsZToge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmFuZ2xlLnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmFuZ2xlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiLy8gcnVuIHRoZSBwb2x5ZmlsbHNcclxucmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xyXG5cclxudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29yZScpO1xyXG5cclxuLy8gYWRkIGNvcmUgcGx1Z2lucy5cclxuY29yZS5leHRyYXMgICAgICAgICA9IHJlcXVpcmUoJy4vZXh0cmFzJyk7XHJcbmNvcmUuZmlsdGVycyAgICAgICAgPSByZXF1aXJlKCcuL2ZpbHRlcnMnKTtcclxuY29yZS5pbnRlcmFjdGlvbiAgICA9IHJlcXVpcmUoJy4vaW50ZXJhY3Rpb24nKTtcclxuY29yZS5sb2FkZXJzICAgICAgICA9IHJlcXVpcmUoJy4vbG9hZGVycycpO1xyXG5jb3JlLm1lc2ggICAgICAgICAgID0gcmVxdWlyZSgnLi9tZXNoJyk7XHJcbmNvcmUuYWNjZXNzaWJpbGl0eSAgPSByZXF1aXJlKCcuL2FjY2Vzc2liaWxpdHknKTtcclxuXHJcbi8vIGV4cG9ydCBhIHByZW1hZGUgbG9hZGVyIGluc3RhbmNlXHJcbi8qKlxyXG4gKiBBIHByZW1hZGUgaW5zdGFuY2Ugb2YgdGhlIGxvYWRlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGxvYWRlciByZXNvdXJjZXMuXHJcbiAqXHJcbiAqIEBuYW1lIGxvYWRlclxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAcHJvcGVydHkge1BJWEkubG9hZGVycy5Mb2FkZXJ9XHJcbiAqL1xyXG5jb3JlLmxvYWRlciA9IG5ldyBjb3JlLmxvYWRlcnMuTG9hZGVyKCk7XHJcblxyXG4vLyBtaXhpbiB0aGUgZGVwcmVjYXRpb24gZmVhdHVyZXMuXHJcbk9iamVjdC5hc3NpZ24oY29yZSwgcmVxdWlyZSgnLi9kZXByZWNhdGlvbicpKTtcclxuXHJcbi8vIEFsd2F5cyBleHBvcnQgcGl4aSBnbG9iYWxseS5cclxuZ2xvYmFsLlBJWEkgPSBjb3JlO1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcclxuXHJcbi8qKlxyXG4gKiBIb2xkcyBhbGwgaW5mb3JtYXRpb24gcmVsYXRlZCB0byBhbiBJbnRlcmFjdGlvbiBldmVudFxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQG1lbWJlcm9mIFBJWEkuaW50ZXJhY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIEludGVyYWN0aW9uRGF0YSgpXHJcbntcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBwb2ludCBzdG9yZXMgdGhlIGdsb2JhbCBjb29yZHMgb2Ygd2hlcmUgdGhlIHRvdWNoL21vdXNlIGV2ZW50IGhhcHBlbmVkXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5nbG9iYWwgPSBuZXcgY29yZS5Qb2ludCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRhcmdldCBTcHJpdGUgdGhhdCB3YXMgaW50ZXJhY3RlZCB3aXRoXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5TcHJpdGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gcGFzc2VkIHRvIGFuIGV2ZW50IGhhbmRsZXIsIHRoaXMgd2lsbCBiZSB0aGUgb3JpZ2luYWwgRE9NIEV2ZW50IHRoYXQgd2FzIGNhcHR1cmVkXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG51bGw7XHJcbn1cclxuXHJcbkludGVyYWN0aW9uRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnRlcmFjdGlvbkRhdGE7XHJcbm1vZHVsZS5leHBvcnRzID0gSW50ZXJhY3Rpb25EYXRhO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgd2lsbCByZXR1cm4gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBzcGVjaWZpZWQgZGlzcGxheU9iamVjdCBmb3IgdGhpcyBJbnRlcmFjdGlvbkRhdGFcclxuICpcclxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIERpc3BsYXlPYmplY3QgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgbG9jYWwgY29vcmRzIG9mZlxyXG4gKiBAcGFyYW0gW3BvaW50XSB7UElYSS5Qb2ludH0gQSBQb2ludCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHZhbHVlLCBvcHRpb25hbCAob3RoZXJ3aXNlIHdpbGwgY3JlYXRlIGEgbmV3IHBvaW50KVxyXG4gKiBAcGFyYW0gW2dsb2JhbFBvc10ge1BJWEkuUG9pbnR9IEEgUG9pbnQgb2JqZWN0IGNvbnRhaW5pbmcgeW91ciBjdXN0b20gZ2xvYmFsIGNvb3Jkcywgb3B0aW9uYWwgKG90aGVyd2lzZSB3aWxsIHVzZSB0aGUgY3VycmVudCBnbG9iYWwgY29vcmRzKVxyXG4gKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBBIHBvaW50IGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBJbnRlcmFjdGlvbkRhdGEgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIERpc3BsYXlPYmplY3RcclxuICovXHJcbkludGVyYWN0aW9uRGF0YS5wcm90b3R5cGUuZ2V0TG9jYWxQb3NpdGlvbiA9IGZ1bmN0aW9uIChkaXNwbGF5T2JqZWN0LCBwb2ludCwgZ2xvYmFsUG9zKVxyXG57XHJcbiAgICByZXR1cm4gZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UoZ2xvYmFsUG9zIHx8IHRoaXMuZ2xvYmFsLCBwb2ludCk7XHJcbn07XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpLFxyXG4gICAgSW50ZXJhY3Rpb25EYXRhID0gcmVxdWlyZSgnLi9JbnRlcmFjdGlvbkRhdGEnKTtcclxuXHJcbi8vIE1peCBpbnRlcmFjdGl2ZVRhcmdldCBpbnRvIGNvcmUuRGlzcGxheU9iamVjdC5wcm90b3R5cGVcclxuT2JqZWN0LmFzc2lnbihcclxuICAgIGNvcmUuRGlzcGxheU9iamVjdC5wcm90b3R5cGUsXHJcbiAgICByZXF1aXJlKCcuL2ludGVyYWN0aXZlVGFyZ2V0JylcclxuKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgaW50ZXJhY3Rpb24gbWFuYWdlciBkZWFscyB3aXRoIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuIEFueSBEaXNwbGF5T2JqZWN0IGNhbiBiZSBpbnRlcmFjdGl2ZVxyXG4gKiBpZiBpdHMgaW50ZXJhY3RpdmUgcGFyYW1ldGVyIGlzIHNldCB0byB0cnVlXHJcbiAqIFRoaXMgbWFuYWdlciBhbHNvIHN1cHBvcnRzIG11bHRpdG91Y2guXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAbWVtYmVyb2YgUElYSS5pbnRlcmFjdGlvblxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlclxyXG4gKiBAcGFyYW0gW29wdGlvbnNdIHtvYmplY3R9XHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5hdXRvUHJldmVudERlZmF1bHQ9dHJ1ZV0ge2Jvb2xlYW59IFNob3VsZCB0aGUgbWFuYWdlciBhdXRvbWF0aWNhbGx5IHByZXZlbnQgZGVmYXVsdCBicm93c2VyIGFjdGlvbnMuXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5pbnRlcmFjdGlvbkZyZXF1ZW5jeT0xMF0ge251bWJlcn0gRnJlcXVlbmN5IGluY3JlYXNlcyB0aGUgaW50ZXJhY3Rpb24gZXZlbnRzIHdpbGwgYmUgY2hlY2tlZC5cclxuICovXHJcbmZ1bmN0aW9uIEludGVyYWN0aW9uTWFuYWdlcihyZW5kZXJlciwgb3B0aW9ucylcclxue1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVuZGVyZXIgdGhpcyBpbnRlcmFjdGlvbiBtYW5hZ2VyIHdvcmtzIGZvci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlN5c3RlbVJlbmRlcmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG91bGQgZGVmYXVsdCBicm93c2VyIGFjdGlvbnMgYXV0b21hdGljYWxseSBiZSBwcmV2ZW50ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdXRvUHJldmVudERlZmF1bHQgPSBvcHRpb25zLmF1dG9QcmV2ZW50RGVmYXVsdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hdXRvUHJldmVudERlZmF1bHQgOiB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXMgdGhpcyBmcmVxdWVuY3kgaW5jcmVhc2VzIHRoZSBpbnRlcmFjdGlvbiBldmVudHMgd2lsbCBiZSBjaGVja2VkIG1vcmUgb2Z0ZW4uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMTBcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSA9IG9wdGlvbnMuaW50ZXJhY3Rpb25GcmVxdWVuY3kgfHwgMTA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbW91c2UgZGF0YVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25EYXRhfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vdXNlID0gbmV3IEludGVyYWN0aW9uRGF0YSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gZXZlbnQgZGF0YSBvYmplY3QgdG8gaGFuZGxlIGFsbCB0aGUgZXZlbnQgdHJhY2tpbmcvZGlzcGF0Y2hpbmdcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZXZlbnREYXRhID0ge1xyXG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlLFxyXG4gICAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgICB0eXBlOiBudWxsLFxyXG4gICAgICAgIGRhdGE6IHRoaXMubW91c2UsXHJcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpbnkgbGl0dGxlIGludGVyYWN0aXZlRGF0YSBwb29sICFcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRGF0YVtdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmludGVyYWN0aXZlRGF0YVBvb2wgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBET00gZWxlbWVudCB0byBiaW5kIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge0hUTUxFbGVtZW50fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGF2ZSBldmVudHMgYmVlbiBhdHRhY2hlZCB0byB0aGUgZG9tIGVsZW1lbnQ/XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZXZlbnRzQWRkZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvL3RoaXMgd2lsbCBtYWtlIGl0IHNvIHRoYXQgeW91IGRvbid0IGhhdmUgdG8gY2FsbCBiaW5kIGFsbCB0aGUgdGltZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIHRoaXMub25Nb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcclxuICAgIHRoaXMucHJvY2Vzc01vdXNlVXAgPSB0aGlzLnByb2Nlc3NNb3VzZVVwLmJpbmQoIHRoaXMgKTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbk1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcclxuICAgIHRoaXMucHJvY2Vzc01vdXNlRG93biA9IHRoaXMucHJvY2Vzc01vdXNlRG93bi5iaW5kKCB0aGlzICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCggdGhpcyApO1xyXG4gICAgdGhpcy5wcm9jZXNzTW91c2VNb3ZlID0gdGhpcy5wcm9jZXNzTW91c2VNb3ZlLmJpbmQoIHRoaXMgKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uTW91c2VPdXQgPSB0aGlzLm9uTW91c2VPdXQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMucHJvY2Vzc01vdXNlT3Zlck91dCA9IHRoaXMucHJvY2Vzc01vdXNlT3Zlck91dC5iaW5kKCB0aGlzICk7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIHRoaXMub25Ub3VjaFN0YXJ0ID0gdGhpcy5vblRvdWNoU3RhcnQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMucHJvY2Vzc1RvdWNoU3RhcnQgPSB0aGlzLnByb2Nlc3NUb3VjaFN0YXJ0LmJpbmQodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vblRvdWNoRW5kID0gdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnByb2Nlc3NUb3VjaEVuZCA9IHRoaXMucHJvY2Vzc1RvdWNoRW5kLmJpbmQodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vblRvdWNoTW92ZSA9IHRoaXMub25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMucHJvY2Vzc1RvdWNoTW92ZSA9IHRoaXMucHJvY2Vzc1RvdWNoTW92ZS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3QgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNzcyBzdHlsZSBvZiB0aGUgY3Vyc29yIHRoYXQgaXMgYmVpbmcgdXNlZFxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRDdXJzb3JTdHlsZSA9ICdpbmhlcml0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGNhY2hlZCB2YXJcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl90ZW1wUG9pbnQgPSBuZXcgY29yZS5Qb2ludCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgcmVzb2x1dGlvblxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xyXG5cclxuICAgIHRoaXMuc2V0VGFyZ2V0RWxlbWVudCh0aGlzLnJlbmRlcmVyLnZpZXcsIHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbik7XHJcbn1cclxuXHJcbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnRlcmFjdGlvbk1hbmFnZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gSW50ZXJhY3Rpb25NYW5hZ2VyO1xyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIERPTSBlbGVtZW50IHdoaWNoIHdpbGwgcmVjZWl2ZSBtb3VzZS90b3VjaCBldmVudHMuIFRoaXMgaXMgdXNlZnVsIGZvciB3aGVuIHlvdSBoYXZlXHJcbiAqIG90aGVyIERPTSBlbGVtZW50cyBvbiB0b3Agb2YgdGhlIHJlbmRlcmVycyBDYW52YXMgZWxlbWVudC4gV2l0aCB0aGlzIHlvdSdsbCBiZSBiYWxlIHRvIGRlbGV0ZWdhdGVcclxuICogYW5vdGhlciBET00gZWxlbWVudCB0byByZWNlaXZlIHRob3NlIGV2ZW50cy5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnQge0hUTUxFbGVtZW50fSB0aGUgRE9NIGVsZW1lbnQgd2hpY2ggd2lsbCByZWNlaXZlIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuXHJcbiAqIEBwYXJhbSBbcmVzb2x1dGlvbj0xXSB7bnVtYmVyfSBUSGUgcmVzb2x1dGlvbiBvZiB0aGUgbmV3IGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSBjYW52YXMpLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRUYXJnZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHJlc29sdXRpb24pXHJcbntcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRzKCk7XHJcblxyXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBlbGVtZW50O1xyXG5cclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgMTtcclxuXHJcbiAgICB0aGlzLmFkZEV2ZW50cygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhbGwgdGhlIERPTSBldmVudHNcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkRXZlbnRzID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKCF0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29yZS50aWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcyk7XHJcblxyXG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLWNvbnRlbnQtem9vbWluZyddID0gJ25vbmUnO1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsICAgIHRoaXMub25Nb3VzZU1vdmUsIHRydWUpO1xyXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgICAgdGhpcy5vbk1vdXNlRG93biwgdHJ1ZSk7XHJcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsICAgICB0aGlzLm9uTW91c2VPdXQsIHRydWUpO1xyXG5cclxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAgIHRoaXMub25Ub3VjaFN0YXJ0LCB0cnVlKTtcclxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgICAgIHRoaXMub25Ub3VjaEVuZCwgdHJ1ZSk7XHJcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAgICB0aGlzLm9uVG91Y2hNb3ZlLCB0cnVlKTtcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICB0aGlzLm9uTW91c2VVcCwgdHJ1ZSk7XHJcblxyXG4gICAgdGhpcy5ldmVudHNBZGRlZCA9IHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbGwgdGhlIERPTSBldmVudHMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgcmVnaXN0ZXJlZFxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVFdmVudHMgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICBpZiAoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb3JlLnRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlKTtcclxuXHJcbiAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnJztcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLXRvdWNoLWFjdGlvbiddID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUsIHRydWUpO1xyXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93biwgdHJ1ZSk7XHJcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsICB0aGlzLm9uTW91c2VPdXQsIHRydWUpO1xyXG5cclxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCwgdHJ1ZSk7XHJcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICB0aGlzLm9uVG91Y2hFbmQsIHRydWUpO1xyXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgdHJ1ZSk7XHJcblxyXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgIHRoaXMub25Nb3VzZVVwLCB0cnVlKTtcclxuXHJcbiAgICB0aGlzLmV2ZW50c0FkZGVkID0gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgaW50ZXJhY3RpdmUgb2JqZWN0cy5cclxuICogSW52b2tlZCBieSBhIHRocm90dGxlZCB0aWNrZXIgdXBkYXRlIGZyb21cclxuICoge0BsaW5rIFBJWEkudGlja2VyLnNoYXJlZH0uXHJcbiAqXHJcbiAqIEBwYXJhbSBkZWx0YVRpbWUge251bWJlcn1cclxuICovXHJcbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhVGltZSlcclxue1xyXG4gICAgdGhpcy5fZGVsdGFUaW1lICs9IGRlbHRhVGltZTtcclxuXHJcbiAgICBpZiAodGhpcy5fZGVsdGFUaW1lIDwgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcclxuXHJcbiAgICBpZiAoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB0aGUgdXNlciBtb3ZlIHRoZSBtb3VzZSB0aGlzIGNoZWNrIGhhcyBhbHJlYWR5IGJlZW4gZGZvbmUgdXNpbmcgdGhlIG1vdXNlIG1vdmUhXHJcbiAgICBpZih0aGlzLmRpZE1vdmUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kaWRNb3ZlID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY3Vyc29yID0gJ2luaGVyaXQnO1xyXG5cclxuICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKHRoaXMubW91c2UuZ2xvYmFsLCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc01vdXNlT3Zlck91dCwgdHJ1ZSApO1xyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRDdXJzb3JTdHlsZSAhPT0gdGhpcy5jdXJzb3IpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q3Vyc29yU3R5bGUgPSB0aGlzLmN1cnNvcjtcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZS5jdXJzb3IgPSB0aGlzLmN1cnNvcjtcclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE9cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IG9uIHRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyBpbnRlcmFjdGVkIHdpdGhcclxuICpcclxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gdGhlIGRpc3BsYXkgb2JqZWN0IGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSBldmVudFN0cmluZyB7c3RyaW5nfSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGUuZywgbW91c2Vkb3duKVxyXG4gKiBAcGFyYW0gZXZlbnREYXRhIHtvYmplY3R9IHRoZSBldmVudCBkYXRhIG9iamVjdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBldmVudFN0cmluZywgZXZlbnREYXRhIClcclxue1xyXG4gICAgaWYoIWV2ZW50RGF0YS5zdG9wcGVkKVxyXG4gICAge1xyXG4gICAgICAgIGV2ZW50RGF0YS50YXJnZXQgPSBkaXNwbGF5T2JqZWN0O1xyXG4gICAgICAgIGV2ZW50RGF0YS50eXBlID0gZXZlbnRTdHJpbmc7XHJcblxyXG4gICAgICAgIGRpc3BsYXlPYmplY3QuZW1pdCggZXZlbnRTdHJpbmcsIGV2ZW50RGF0YSApO1xyXG5cclxuICAgICAgICBpZiggZGlzcGxheU9iamVjdFtldmVudFN0cmluZ10gKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGlzcGxheU9iamVjdFtldmVudFN0cmluZ10oIGV2ZW50RGF0YSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXBzIHggYW5kIHkgY29vcmRzIGZyb20gYSBET00gb2JqZWN0IGFuZCBtYXBzIHRoZW0gY29ycmVjdGx5IHRvIHRoZSBwaXhpIHZpZXcuIFRoZSByZXN1bHRpbmcgdmFsdWUgaXMgc3RvcmVkIGluIHRoZSBwb2ludC5cclxuICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIGZhY3QgdGhhdCB0aGUgRE9NIGVsZW1lbnQgY291bGQgYmUgc2NhbGVkIGFuZCBwb3NpdGlvbmVkIGFueXdoZXJlIG9uIHRoZSBzY3JlZW4uXHJcbiAqXHJcbiAqIEBwYXJhbSAge1BJWEkuUG9pbnR9IHBvaW50IHRoZSBwb2ludCB0aGF0IHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgaW5cclxuICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICB0aGUgeCBjb29yZCBvZiB0aGUgcG9zaXRpb24gdG8gbWFwXHJcbiAqIEBwYXJhbSAge251bWJlcn0geSAgICAgdGhlIHkgY29vcmQgb2YgdGhlIHBvc2l0aW9uIHRvIG1hcFxyXG4gKi9cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5tYXBQb3NpdGlvblRvUG9pbnQgPSBmdW5jdGlvbiAoIHBvaW50LCB4LCB5IClcclxue1xyXG4gICAgdmFyIHJlY3QgPSB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHBvaW50LnggPSAoICggeCAtIHJlY3QubGVmdCApICogKHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LndpZHRoICAvIHJlY3Qud2lkdGggICkgKSAvIHRoaXMucmVzb2x1dGlvbjtcclxuICAgIHBvaW50LnkgPSAoICggeSAtIHJlY3QudG9wICApICogKHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmhlaWdodCAvIHJlY3QuaGVpZ2h0ICkgKSAvIHRoaXMucmVzb2x1dGlvbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHByb3ZpZGVzIGEgbmVhdCB3YXkgb2YgY3Jhd2xpbmcgdGhyb3VnaCB0aGUgc2NlbmUgZ3JhcGggYW5kIHJ1bm5pbmcgYSBzcGVjaWZpZWQgZnVuY3Rpb24gb24gYWxsIGludGVyYWN0aXZlIG9iamVjdHMgaXQgZmluZHMuXHJcbiAqIEl0IHdpbGwgYWxzbyB0YWtlIGNhcmUgb2YgaGl0IHRlc3RpbmcgdGhlIGludGVyYWN0aXZlIG9iamVjdHMgYW5kIHBhc3NlcyB0aGUgaGl0IGFjcm9zcyBpbiB0aGUgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSAge1BJWEkuUG9pbnR9IHBvaW50IHRoZSBwb2ludCB0aGF0IGlzIHRlc3RlZCBmb3IgY29sbGlzaW9uXHJcbiAqIEBwYXJhbSAge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gZGlzcGxheU9iamVjdCB0aGUgZGlzcGxheU9iamVjdCB0aGF0IHdpbGwgYmUgaGl0IHRlc3QgKHJlY3VyY3Npdmx5IGNyYXdscyBpdHMgY2hpbGRyZW4pXHJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmdW5jIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggaW50ZXJhY3RpdmUgb2JqZWN0LiBUaGUgZGlzcGxheU9iamVjdCBhbmQgaGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvblxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBoaXRUZXN0IHRoaXMgaW5kaWNhdGVzIGlmIHRoZSBvYmplY3RzIGluc2lkZSBzaG91bGQgYmUgaGl0IHRlc3QgYWdhaW5zdCB0aGUgcG9pbnRcclxuICogQHJldHVybiB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBkaXNwbGF5T2JqZWN0IGhpdCB0aGUgcG9pbnRcclxuICovXHJcbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc0ludGVyYWN0aXZlID0gZnVuY3Rpb24gKHBvaW50LCBkaXNwbGF5T2JqZWN0LCBmdW5jLCBoaXRUZXN0LCBpbnRlcmFjdGl2ZSlcclxue1xyXG4gICAgaWYoIWRpc3BsYXlPYmplY3QgfHwgIWRpc3BsYXlPYmplY3QudmlzaWJsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVG9vayBhIGxpdHRsZSB3aGlsZSB0byByZXdvcmsgdGhpcyBmdW5jdGlvbiBjb3JyZWN0bHkhIEJ1dCBub3cgaXQgaXMgZG9uZSBhbmQgbmljZSBhbmQgb3B0aW1pc2VkLiBeX15cclxuICAgIC8vIFxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIG5vdyBsb29wIHRocm91Z2ggYWxsIG9iamVjdHMgYW5kIHRoZW4gb25seSBoaXQgdGVzdCB0aGUgb2JqZWN0cyBpdCBIQVMgdG8sIG5vdCBhbGwgb2YgdGhlbS4gTVVDSCBmYXN0ZXIuLlxyXG4gICAgLy8gQW4gb2JqZWN0IHdpbGwgYmUgaGl0IHRlc3QgaWYgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxyXG4gICAgLy8gXHJcbiAgICAvLyAxOiBJdCBpcyBpbnRlcmFjdGl2ZS5cclxuICAgIC8vIDI6IEl0IGJlbG9uZ3MgdG8gYSBwYXJlbnQgdGhhdCBpcyBpbnRlcmFjdGl2ZSBBTkQgb25lIG9mIHRoZSBwYXJlbnRzIGNoaWxkcmVuIGhhdmUgbm90IGFscmVhZHkgYmVlbiBoaXQuXHJcbiAgICAvLyBcclxuICAgIC8vIEFzIGFub3RoZXIgbGl0dGxlIG9wdGltaXNhdGlvbiBvbmNlIGFuIGludGVyYWN0aXZlIG9iamVjdCBoYXMgYmVlbiBoaXQgd2UgY2FuIGNhcnJ5IG9uIHRocm91Z2ggdGhlIHNjZW5lZ3JhcGgsIGJ1dCB3ZSBrbm93IHRoYXQgdGhlcmUgd2lsbCBiZSBubyBtb3JlIGhpdHMhIFNvIHdlIGNhbiBhdm9pZCBleHRyYSBoaXQgdGVzdHNcclxuICAgIC8vIEEgZmluYWwgb3B0aW1pc2F0aW9uIGlzIHRoYXQgYW4gb2JqZWN0IGlzIG5vdCBoaXQgdGVzdCBkaXJlY3RseSBpZiBhIGNoaWxkIGhhcyBhbHJlYWR5IGJlZW4gaGl0LlxyXG4gICAgXHJcbiAgICB2YXIgaGl0ID0gZmFsc2UsXHJcbiAgICAgICAgaW50ZXJhY3RpdmVQYXJlbnQgPSBpbnRlcmFjdGl2ZSA9IGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUgfHwgaW50ZXJhY3RpdmU7XHJcblxyXG4gICAgLy8gaWYgdGhlIGRpc3BsYXlvYmplY3QgaGFzIGEgaGl0QXJlYSwgdGhlbiBpdCBkb2VzIG5vdCBuZWVkIHRvIGhpdFRlc3QgY2hpbGRyZW4uXHJcbiAgICBpZihkaXNwbGF5T2JqZWN0LmhpdEFyZWEpXHJcbiAgICB7XHJcbiAgICAgICAgaW50ZXJhY3RpdmVQYXJlbnQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAqKiBGUkVFIFRJUCAqKiEgSWYgYW4gb2JqZWN0IGlzIG5vdCBpbnRlcmFjdHRpdmUgb3IgaGFzIG5vIGJ1dHRvbnMgaW4gaXQgKHN1Y2ggYXMgYSBnYW1lIHNjZW5lISkgc2V0IGludGVyYWN0aXZlQ2hpbGRyZW4gdG8gZmFsc2UgZm9yIHRoYXQgZGlzcGxheU9iamVjdC5cclxuICAgIC8vIFRoaXMgd2lsbCBhbGxvdyBwaXhpIHRvIGNvbXBsZXRseSBpZ25vcmUgYW5kIGJ5cGFzcyBjaGVja2luZyB0aGUgZGlzcGxheU9iamVjdHMgY2hpbGRyZW4uXHJcbiAgICBpZihkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlQ2hpbGRyZW4pXHJcbiAgICB7ICAgICAgIFxyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aC0xOyBpID49IDA7IGktLSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIHRpbWUgdG8gZ2V0IHJlY3Vyc2l2ZS4uIGlmIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gaWYgc29tdGhpbmcgaXMgaGl0Li5cclxuICAgICAgICAgICAgaWYoIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKHBvaW50LCBjaGlsZHJlbltpXSwgZnVuYywgaGl0VGVzdCwgaW50ZXJhY3RpdmVQYXJlbnQpIClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaGl0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBubyBsb25nZXIgbmVlZCB0byBoaXQgdGVzdCBhbnkgbW9yZSBvYmplY3RzIGluIHRoaXMgY29udGFpbmVyIGFzIHdlIHdlIG5vdyBrbm93IHRoZSBwYXJlbnQgaGFzIGJlZW4gaGl0XHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZVBhcmVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2hpbGQgaXMgaW50ZXJhY3RpdmUgLCB0aGF0IG1lYW5zIHRoYXQgdGhlIG9iamVjdCBoaXQgd2FzIGFjdHVhbGx5IGludGVyYWN0aXZlIGFuZCBub3QganVzdCB0aGUgY2hpbGQgb2YgYW4gaW50ZXJhY3RpdmUgb2JqZWN0LiBcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gaGl0IHRlc3QgYW55dGhpbmcgZWxzZS4gV2Ugc3RpbGwgbmVlZCB0byBydW4gdGhyb3VnaCBhbGwgb2JqZWN0cywgYnV0IHdlIGRvbid0IG5lZWQgdG8gcGVyZm9ybSBhbnkgaGl0IHRlc3RzLlxyXG4gICAgICAgICAgICAgICAgaWYoY2hpbGRyZW5baV0uaW50ZXJhY3RpdmUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGl0VGVzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIG5vIHBvaW50IHJ1bm5pbmcgdGhpcyBpZiB0aGUgaXRlbSBpcyBub3QgaW50ZXJhY3RpdmUgb3IgZG9lcyBub3QgaGF2ZSBhbiBpbnRlcmFjdGl2ZSBwYXJlbnQuXHJcbiAgICBpZihpbnRlcmFjdGl2ZSlcclxuICAgIHtcclxuICAgICAgICAvLyBpZiB3ZSBhcmUgaGl0IHRlc3RpbmcgKGFzIGluIHdlIGhhdmUgbm8gaGl0IGFueSBvYmplY3RzIHlldClcclxuICAgICAgICAvLyBXZSBhbHNvIGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgaGl0IHRlc3RpbmcgaWYgb25jZSBvZiB0aGUgZGlzcGxheU9iamVjdHMgY2hpbGRyZW4gaGFzIGFscmVhZHkgYmVlbiBoaXQhXHJcbiAgICAgICAgaWYoaGl0VGVzdCAmJiAhaGl0KVxyXG4gICAgICAgIHsgIFxyXG4gICAgICAgICAgICBpZihkaXNwbGF5T2JqZWN0LmhpdEFyZWEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCAgdGhpcy5fdGVtcFBvaW50KTtcclxuICAgICAgICAgICAgICAgIGhpdCA9IGRpc3BsYXlPYmplY3QuaGl0QXJlYS5jb250YWlucyggdGhpcy5fdGVtcFBvaW50LngsIHRoaXMuX3RlbXBQb2ludC55ICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGhpdCA9IGRpc3BsYXlPYmplY3QuY29udGFpbnNQb2ludChwb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmdW5jKGRpc3BsYXlPYmplY3QsIGhpdCk7IFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaGl0O1xyXG4gIFxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgZG93biBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIGEgbW91c2UgYnV0dG9uIGJlaW5nIHByZXNzZWQgZG93blxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudClcclxue1xyXG4gICAgdGhpcy5tb3VzZS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XHJcbiAgICB0aGlzLmV2ZW50RGF0YS5kYXRhID0gdGhpcy5tb3VzZTtcclxuICAgIHRoaXMuZXZlbnREYXRhLnN0b3BwZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBVcGRhdGUgaW50ZXJuYWwgbW91c2UgcmVmZXJlbmNlXHJcbiAgICB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludCggdGhpcy5tb3VzZS5nbG9iYWwsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG5cclxuICAgIGlmICh0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZSh0aGlzLm1vdXNlLmdsb2JhbCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NNb3VzZURvd24sIHRydWUgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQcm9jZXNzZXMgdGhlIHJlc3VsdCBvZiB0aGUgbW91c2UgZG93biBjaGVjayBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgaWYgbmVlZCBiZVxyXG4gKlxyXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7UElYSS5Db250YWluZXJ8UElYSS5TcHJpdGV8UElYSS5leHRyYXMuVGlsaW5nU3ByaXRlfSBUaGUgZGlzcGxheSBvYmplY3QgdGhhdCB3YXMgdGVzdGVkXHJcbiAqIEBwYXJhbSBoaXQge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGhpdCB0ZXN0IG9uIHRoZSBkaXNwYXkgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NNb3VzZURvd24gPSBmdW5jdGlvbiAoIGRpc3BsYXlPYmplY3QsIGhpdCApXHJcbntcclxuICAgIHZhciBlID0gdGhpcy5tb3VzZS5vcmlnaW5hbEV2ZW50O1xyXG4gICAgXHJcbiAgICB2YXIgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyIHx8IGUud2hpY2ggPT09IDM7XHJcblxyXG4gICAgaWYoaGl0KVxyXG4gICAge1xyXG4gICAgICAgIGRpc3BsYXlPYmplY3RbIGlzUmlnaHRCdXR0b24gPyAnX2lzUmlnaHREb3duJyA6ICdfaXNMZWZ0RG93bicgXSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBkaXNwbGF5T2JqZWN0LCBpc1JpZ2h0QnV0dG9uID8gJ3JpZ2h0ZG93bicgOiAnbW91c2Vkb3duJywgdGhpcy5ldmVudERhdGEgKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBidXR0b24gaXMgcmVsZWFzZWQgb24gdGhlIHJlbmRlcmVyIGVsZW1lbnRcclxuICpcclxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIG1vdXNlIGJ1dHRvbiBiZWluZyByZWxlYXNlZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpXHJcbntcclxuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xyXG4gICAgdGhpcy5ldmVudERhdGEuZGF0YSA9IHRoaXMubW91c2U7XHJcbiAgICB0aGlzLmV2ZW50RGF0YS5zdG9wcGVkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gVXBkYXRlIGludGVybmFsIG1vdXNlIHJlZmVyZW5jZVxyXG4gICAgdGhpcy5tYXBQb3NpdGlvblRvUG9pbnQoIHRoaXMubW91c2UuZ2xvYmFsLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZSh0aGlzLm1vdXNlLmdsb2JhbCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NNb3VzZVVwLCB0cnVlICk7XHJcbn07XHJcblxyXG4vKipcclxuICogUHJvY2Vzc2VzIHRoZSByZXN1bHQgb2YgdGhlIG1vdXNlIHVwIGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXHJcbiAqXHJcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcclxuICogQHBhcmFtIGhpdCB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgaGl0IHRlc3Qgb24gdGhlIGRpc3BsYXkgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NNb3VzZVVwID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBoaXQgKVxyXG57XHJcbiAgICB2YXIgZSA9IHRoaXMubW91c2Uub3JpZ2luYWxFdmVudDtcclxuXHJcbiAgICB2YXIgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyIHx8IGUud2hpY2ggPT09IDM7XHJcbiAgICB2YXIgaXNEb3duID0gIGlzUmlnaHRCdXR0b24gPyAnX2lzUmlnaHREb3duJyA6ICdfaXNMZWZ0RG93bic7XHJcblxyXG4gICAgaWYoaGl0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggZGlzcGxheU9iamVjdCwgaXNSaWdodEJ1dHRvbiA/ICdyaWdodHVwJyA6ICdtb3VzZXVwJywgdGhpcy5ldmVudERhdGEgKTtcclxuXHJcbiAgICAgICAgaWYoIGRpc3BsYXlPYmplY3RbIGlzRG93biBdIClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3RbIGlzRG93biBdID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggZGlzcGxheU9iamVjdCwgaXNSaWdodEJ1dHRvbiA/ICdyaWdodGNsaWNrJyA6ICdjbGljaycsIHRoaXMuZXZlbnREYXRhICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmKCBkaXNwbGF5T2JqZWN0WyBpc0Rvd24gXSApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0WyBpc0Rvd24gXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsIGlzUmlnaHRCdXR0b24gPyAncmlnaHR1cG91dHNpZGUnIDogJ21vdXNldXBvdXRzaWRlJywgdGhpcy5ldmVudERhdGEgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBhY3Jvc3MgdGhlIHJlbmRlcmVyIGVsZW1lbnRcclxuICpcclxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiB0aGUgbW91c2UgbW92aW5nXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KVxyXG57XHJcbiAgICB0aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcclxuICAgIHRoaXMuZXZlbnREYXRhLmRhdGEgPSB0aGlzLm1vdXNlO1xyXG4gICAgdGhpcy5ldmVudERhdGEuc3RvcHBlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KCB0aGlzLm1vdXNlLmdsb2JhbCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcblxyXG4gICAgdGhpcy5kaWRNb3ZlID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLmN1cnNvciA9ICdpbmhlcml0JztcclxuXHJcbiAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZSh0aGlzLm1vdXNlLmdsb2JhbCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NNb3VzZU1vdmUsIHRydWUgKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50Q3Vyc29yU3R5bGUgIT09IHRoaXMuY3Vyc29yKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEN1cnNvclN0eWxlID0gdGhpcy5jdXJzb3I7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gdGhpcy5jdXJzb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPIEJVRyBmb3IgcGFyZW50cyBpbmVyYWN0aXZlIG9iamVjdCAoYm9yZGVyIG9yZGVyIGlzc3VlKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3NlcyB0aGUgcmVzdWx0IG9mIHRoZSBtb3VzZSBtb3ZlIGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXHJcbiAqXHJcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcclxuICogQHBhcmFtIGhpdCB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgaGl0IHRlc3Qgb24gdGhlIGRpc3BsYXkgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NNb3VzZU1vdmUgPSBmdW5jdGlvbiAoIGRpc3BsYXlPYmplY3QsIGhpdCApXHJcbntcclxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggZGlzcGxheU9iamVjdCwgJ21vdXNlbW92ZScsIHRoaXMuZXZlbnREYXRhKTtcclxuICAgIHRoaXMucHJvY2Vzc01vdXNlT3Zlck91dChkaXNwbGF5T2JqZWN0LCBoaXQpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgaXMgbW92ZWQgb3V0IG9mIHRoZSByZW5kZXJlciBlbGVtZW50XHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSBtb3VzZSBiZWluZyBtb3ZlZCBvdXRcclxuICogQHByaXZhdGVcclxuICovXHJcbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Nb3VzZU91dCA9IGZ1bmN0aW9uIChldmVudClcclxue1xyXG4gICAgdGhpcy5tb3VzZS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XHJcbiAgICB0aGlzLmV2ZW50RGF0YS5zdG9wcGVkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gVXBkYXRlIGludGVybmFsIG1vdXNlIHJlZmVyZW5jZVxyXG4gICAgdGhpcy5tYXBQb3NpdGlvblRvUG9pbnQoIHRoaXMubW91c2UuZ2xvYmFsLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnaW5oZXJpdCc7XHJcblxyXG4gICAgLy8gVE9ETyBvcHRpbWl6ZSBieSBub3QgY2hlY2sgRVZFUlkgVElNRSEgbWF5YmUgaGFsZiBhcyBvZnRlbj8gLy9cclxuICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KCB0aGlzLm1vdXNlLmdsb2JhbCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cclxuICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKCB0aGlzLm1vdXNlLmdsb2JhbCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NNb3VzZU92ZXJPdXQsIGZhbHNlICk7XHJcbn07XHJcblxyXG4vKipcclxuICogUHJvY2Vzc2VzIHRoZSByZXN1bHQgb2YgdGhlIG1vdXNlIG92ZXIvb3V0IGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXHJcbiAqXHJcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcclxuICogQHBhcmFtIGhpdCB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgaGl0IHRlc3Qgb24gdGhlIGRpc3BsYXkgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NNb3VzZU92ZXJPdXQgPSBmdW5jdGlvbiAoIGRpc3BsYXlPYmplY3QsIGhpdCApXHJcbntcclxuICAgIGlmKGhpdClcclxuICAgIHtcclxuICAgICAgICBpZighZGlzcGxheU9iamVjdC5fb3ZlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuX292ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICdtb3VzZW92ZXInLCB0aGlzLmV2ZW50RGF0YSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuYnV0dG9uTW9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gZGlzcGxheU9iamVjdC5kZWZhdWx0Q3Vyc29yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZihkaXNwbGF5T2JqZWN0Ll9vdmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5fb3ZlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICdtb3VzZW91dCcsIHRoaXMuZXZlbnREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIElzIGNhbGxlZCB3aGVuIGEgdG91Y2ggaXMgc3RhcnRlZCBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIGEgdG91Y2ggc3RhcnRpbmcgb24gdGhlIHJlbmRlcmVyIHZpZXdcclxuICogQHByaXZhdGVcclxuICovXHJcbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KVxyXG57XHJcbiAgICBpZiAodGhpcy5hdXRvUHJldmVudERlZmF1bHQpXHJcbiAgICB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcclxuICAgIHZhciBjTGVuZ3RoID0gY2hhbmdlZFRvdWNoZXMubGVuZ3RoO1xyXG5cclxuICAgIGZvciAodmFyIGk9MDsgaSA8IGNMZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgdG91Y2hFdmVudCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xyXG4gICAgICAgIC8vVE9ETyBQT09MXHJcbiAgICAgICAgdmFyIHRvdWNoRGF0YSA9IHRoaXMuZ2V0VG91Y2hEYXRhKCB0b3VjaEV2ZW50ICk7XHJcblxyXG4gICAgICAgIHRvdWNoRGF0YS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnREYXRhLmRhdGEgPSB0b3VjaERhdGE7XHJcbiAgICAgICAgdGhpcy5ldmVudERhdGEuc3RvcHBlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZSggdG91Y2hEYXRhLmdsb2JhbCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NUb3VjaFN0YXJ0LCB0cnVlICk7XHJcblxyXG4gICAgICAgIHRoaXMucmV0dXJuVG91Y2hEYXRhKCB0b3VjaERhdGEgKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBQcm9jZXNzZXMgdGhlIHJlc3VsdCBvZiBhIHRvdWNoIGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXHJcbiAqXHJcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcclxuICogQHBhcmFtIGhpdCB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgaGl0IHRlc3Qgb24gdGhlIGRpc3BsYXkgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBoaXQgKVxyXG57XHJcbiAgICBpZihoaXQpXHJcbiAgICB7XHJcbiAgICAgICAgZGlzcGxheU9iamVjdC5fdG91Y2hEb3duID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICd0b3VjaHN0YXJ0JywgdGhpcy5ldmVudERhdGEgKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogSXMgY2FsbGVkIHdoZW4gYSB0b3VjaCBlbmRzIG9uIHRoZSByZW5kZXJlciBlbGVtZW50XHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSB0b3VjaCBlbmRpbmcgb24gdGhlIHJlbmRlcmVyIHZpZXdcclxuICovXHJcbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Ub3VjaEVuZCA9IGZ1bmN0aW9uIChldmVudClcclxue1xyXG4gICAgaWYgKHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0KVxyXG4gICAge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XHJcbiAgICB2YXIgY0xlbmd0aCA9IGNoYW5nZWRUb3VjaGVzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjTGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRvdWNoRXZlbnQgPSBjaGFuZ2VkVG91Y2hlc1tpXTtcclxuXHJcbiAgICAgICAgdmFyIHRvdWNoRGF0YSA9IHRoaXMuZ2V0VG91Y2hEYXRhKCB0b3VjaEV2ZW50ICk7XHJcblxyXG4gICAgICAgIHRvdWNoRGF0YS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vVE9ETyB0aGlzIHNob3VsZCBiZSBwYXNzZWQgYWxvbmcuLiBubyBzZXRcclxuICAgICAgICB0aGlzLmV2ZW50RGF0YS5kYXRhID0gdG91Y2hEYXRhO1xyXG4gICAgICAgIHRoaXMuZXZlbnREYXRhLnN0b3BwZWQgPSBmYWxzZTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKCB0b3VjaERhdGEuZ2xvYmFsLCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc1RvdWNoRW5kLCB0cnVlICk7XHJcblxyXG4gICAgICAgIHRoaXMucmV0dXJuVG91Y2hEYXRhKCB0b3VjaERhdGEgKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBQcm9jZXNzZXMgdGhlIHJlc3VsdCBvZiB0aGUgZW5kIG9mIGEgdG91Y2ggYW5kIGRpc3BhdGNoZXMgdGhlIGV2ZW50IGlmIG5lZWQgYmVcclxuICpcclxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gVGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgd2FzIHRlc3RlZFxyXG4gKiBAcGFyYW0gaGl0IHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSBoaXQgdGVzdCBvbiB0aGUgZGlzcGxheSBvYmplY3RcclxuICogQHByaXZhdGVcclxuICovXHJcbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1RvdWNoRW5kID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBoaXQgKVxyXG57XHJcbiAgICBpZihoaXQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBkaXNwbGF5T2JqZWN0LCAndG91Y2hlbmQnLCB0aGlzLmV2ZW50RGF0YSApO1xyXG5cclxuICAgICAgICBpZiggZGlzcGxheU9iamVjdC5fdG91Y2hEb3duIClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuX3RvdWNoRG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICd0YXAnLCB0aGlzLmV2ZW50RGF0YSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZiggZGlzcGxheU9iamVjdC5fdG91Y2hEb3duIClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuX3RvdWNoRG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICd0b3VjaGVuZG91dHNpZGUnLCB0aGlzLmV2ZW50RGF0YSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBJcyBjYWxsZWQgd2hlbiBhIHRvdWNoIGlzIG1vdmVkIGFjcm9zcyB0aGUgcmVuZGVyZXIgZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIGEgdG91Y2ggbW92aW5nIGFjcm9zcyB0aGUgcmVuZGVyZXIgdmlld1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldmVudClcclxue1xyXG4gICAgaWYgKHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0KVxyXG4gICAge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XHJcbiAgICB2YXIgY0xlbmd0aCA9IGNoYW5nZWRUb3VjaGVzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjTGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRvdWNoRXZlbnQgPSBjaGFuZ2VkVG91Y2hlc1tpXTtcclxuXHJcbiAgICAgICAgdmFyIHRvdWNoRGF0YSA9IHRoaXMuZ2V0VG91Y2hEYXRhKCB0b3VjaEV2ZW50ICk7XHJcblxyXG4gICAgICAgIHRvdWNoRGF0YS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnREYXRhLmRhdGEgPSB0b3VjaERhdGE7XHJcbiAgICAgICAgdGhpcy5ldmVudERhdGEuc3RvcHBlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZSggdG91Y2hEYXRhLmdsb2JhbCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NUb3VjaE1vdmUsIHRydWUgKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXR1cm5Ub3VjaERhdGEoIHRvdWNoRGF0YSApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3NlcyB0aGUgcmVzdWx0IG9mIGEgdG91Y2ggbW92ZSBjaGVjayBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgaWYgbmVlZCBiZVxyXG4gKlxyXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7UElYSS5Db250YWluZXJ8UElYSS5TcHJpdGV8UElYSS5leHRyYXMuVGlsaW5nU3ByaXRlfSBUaGUgZGlzcGxheSBvYmplY3QgdGhhdCB3YXMgdGVzdGVkXHJcbiAqIEBwYXJhbSBoaXQge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGhpdCB0ZXN0IG9uIHRoZSBkaXNwbGF5IG9iamVjdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzVG91Y2hNb3ZlID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBoaXQgKVxyXG57XHJcbiAgICBoaXQgPSBoaXQ7XHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICd0b3VjaG1vdmUnLCB0aGlzLmV2ZW50RGF0YSk7XHJcbn07XHJcblxyXG4vKipcclxuICogR3JhYnMgYW4gaW50ZXJhY3Rpb24gZGF0YSBvYmplY3QgZnJvbSB0aGUgaW50ZXJuYWwgcG9vbFxyXG4gKlxyXG4gKiBAcGFyYW0gdG91Y2hFdmVudCB7RXZlbnREYXRhfSBUaGUgdG91Y2ggZXZlbnQgd2UgbmVlZCB0byBwYWlyIHdpdGggYW4gaW50ZXJhY3Rpb25EYXRhIG9iamVjdFxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUb3VjaERhdGEgPSBmdW5jdGlvbiAodG91Y2hFdmVudClcclxue1xyXG4gICAgdmFyIHRvdWNoRGF0YSA9IHRoaXMuaW50ZXJhY3RpdmVEYXRhUG9vbC5wb3AoKTtcclxuXHJcbiAgICBpZighdG91Y2hEYXRhKVxyXG4gICAge1xyXG4gICAgICAgIHRvdWNoRGF0YSA9IG5ldyBJbnRlcmFjdGlvbkRhdGEoKTtcclxuICAgIH1cclxuXHJcbiAgICB0b3VjaERhdGEuaWRlbnRpZmllciA9IHRvdWNoRXZlbnQuaWRlbnRpZmllcjtcclxuICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KCB0b3VjaERhdGEuZ2xvYmFsLCB0b3VjaEV2ZW50LmNsaWVudFgsIHRvdWNoRXZlbnQuY2xpZW50WSApO1xyXG5cclxuICAgIGlmKG5hdmlnYXRvci5pc0NvY29vbkpTKVxyXG4gICAge1xyXG4gICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueCA9IHRvdWNoRGF0YS5nbG9iYWwueCAvIHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICB0b3VjaERhdGEuZ2xvYmFsLnkgPSB0b3VjaERhdGEuZ2xvYmFsLnkgLyB0aGlzLnJlc29sdXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgdG91Y2hFdmVudC5nbG9iYWxYID0gdG91Y2hEYXRhLmdsb2JhbC54O1xyXG4gICAgdG91Y2hFdmVudC5nbG9iYWxZID0gdG91Y2hEYXRhLmdsb2JhbC55O1xyXG5cclxuICAgIHJldHVybiB0b3VjaERhdGE7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBpbnRlcmFjdGlvbiBkYXRhIG9iamVjdCB0byB0aGUgaW50ZXJuYWwgcG9vbFxyXG4gKlxyXG4gKiBAcGFyYW0gdG91Y2hEYXRhIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRGF0YX0gVGhlIHRvdWNoIGRhdGEgb2JqZWN0IHdlIHdhbnQgdG8gcmV0dXJuIHRvIHRoZSBwb29sXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJldHVyblRvdWNoRGF0YSA9IGZ1bmN0aW9uICggdG91Y2hEYXRhIClcclxue1xyXG4gICAgdGhpcy5pbnRlcmFjdGl2ZURhdGFQb29sLnB1c2goIHRvdWNoRGF0YSApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc3Ryb3lzIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyXHJcbiAqXHJcbiAqL1xyXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xyXG5cclxuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMubW91c2UgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuZXZlbnREYXRhID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmludGVyYWN0aXZlRGF0YVBvb2wgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLm9uTW91c2VVcCA9IG51bGw7XHJcbiAgICB0aGlzLnByb2Nlc3NNb3VzZVVwID0gbnVsbDtcclxuXHJcblxyXG4gICAgdGhpcy5vbk1vdXNlRG93biA9IG51bGw7XHJcbiAgICB0aGlzLnByb2Nlc3NNb3VzZURvd24gPSBudWxsO1xyXG5cclxuICAgIHRoaXMub25Nb3VzZU1vdmUgPSBudWxsO1xyXG4gICAgdGhpcy5wcm9jZXNzTW91c2VNb3ZlID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLm9uTW91c2VPdXQgPSBudWxsO1xyXG4gICAgdGhpcy5wcm9jZXNzTW91c2VPdmVyT3V0ID0gbnVsbDtcclxuXHJcblxyXG4gICAgdGhpcy5vblRvdWNoU3RhcnQgPSBudWxsO1xyXG4gICAgdGhpcy5wcm9jZXNzVG91Y2hTdGFydCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5vblRvdWNoRW5kID0gbnVsbDtcclxuICAgIHRoaXMucHJvY2Vzc1RvdWNoRW5kID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLm9uVG91Y2hNb3ZlID0gbnVsbDtcclxuICAgIHRoaXMucHJvY2Vzc1RvdWNoTW92ZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fdGVtcFBvaW50ID0gbnVsbDtcclxufTtcclxuXHJcbmNvcmUuV2ViR0xSZW5kZXJlci5yZWdpc3RlclBsdWdpbignaW50ZXJhY3Rpb24nLCBJbnRlcmFjdGlvbk1hbmFnZXIpO1xyXG5jb3JlLkNhbnZhc1JlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdpbnRlcmFjdGlvbicsIEludGVyYWN0aW9uTWFuYWdlcik7XHJcbiIsIi8qKlxyXG4gKiBAZmlsZSAgICAgICAgTWFpbiBleHBvcnQgb2YgdGhlIFBJWEkgaW50ZXJhY3Rpb25zIGxpYnJhcnlcclxuICogQGF1dGhvciAgICAgIE1hdCBHcm92ZXMgPG1hdEBnb29kYm95ZGlnaXRhbC5jb20+XHJcbiAqIEBjb3B5cmlnaHQgICAyMDEzLTIwMTUgR29vZEJveURpZ2l0YWxcclxuICogQGxpY2Vuc2UgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGkuanMvYmxvYi9tYXN0ZXIvTElDRU5TRXxNSVQgTGljZW5zZX1cclxuICovXHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBQSVhJLmludGVyYWN0aW9uXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEludGVyYWN0aW9uRGF0YTogICAgcmVxdWlyZSgnLi9JbnRlcmFjdGlvbkRhdGEnKSxcclxuICAgIEludGVyYWN0aW9uTWFuYWdlcjogcmVxdWlyZSgnLi9JbnRlcmFjdGlvbk1hbmFnZXInKSxcclxuICAgIGludGVyYWN0aXZlVGFyZ2V0OiAgcmVxdWlyZSgnLi9pbnRlcmFjdGl2ZVRhcmdldCcpXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBEZWZhdWx0IHByb3BlcnR5IHZhbHVlcyBvZiBpbnRlcmFjdGl2ZSBvYmplY3RzXHJcbiAqIHVzZWQgYnkge0BsaW5rIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyfS5cclxuICpcclxuICogQG1peGluXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmludGVyYWN0aW9uXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICAgZnVuY3Rpb24gTXlPYmplY3QoKSB7fVxyXG4gKlxyXG4gKiAgICAgIE9iamVjdC5hc3NpZ24oXHJcbiAqICAgICAgICAgIE15T2JqZWN0LnByb3RvdHlwZSxcclxuICogICAgICAgICAgUElYSS5pbnRlcmFjdGlvbi5pbnRlcmFjdGl2ZVRhcmdldFxyXG4gKiAgICAgICk7XHJcbiAqL1xyXG52YXIgaW50ZXJhY3RpdmVUYXJnZXQgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXHJcbiAgICAgKi9cclxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogQHRvZG8gTmVlZHMgZG9jcy5cclxuICAgICAqL1xyXG4gICAgYnV0dG9uTW9kZTogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXHJcbiAgICAgKi9cclxuICAgIGludGVyYWN0aXZlQ2hpbGRyZW46IHRydWUsXHJcbiAgICAvKipcclxuICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRDdXJzb3I6ICdwb2ludGVyJyxcclxuXHJcbiAgICAvLyBzb21lIGludGVybmFsIGNoZWNrcy4uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX292ZXI6IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3RvdWNoRG93bjogZmFsc2VcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW50ZXJhY3RpdmVUYXJnZXQ7XHJcbiIsInZhciBSZXNvdXJjZSA9IHJlcXVpcmUoJ3Jlc291cmNlLWxvYWRlcicpLlJlc291cmNlLFxyXG4gICAgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKSxcclxuICAgIGV4dHJhcyA9IHJlcXVpcmUoJy4uL2V4dHJhcycpLFxyXG4gICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuXHJcblxyXG5mdW5jdGlvbiBwYXJzZShyZXNvdXJjZSwgdGV4dHVyZSkge1xyXG4gICAgdmFyIGRhdGEgPSB7fTtcclxuICAgIHZhciBpbmZvID0gcmVzb3VyY2UuZGF0YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpWzBdO1xyXG4gICAgdmFyIGNvbW1vbiA9IHJlc291cmNlLmRhdGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NvbW1vbicpWzBdO1xyXG5cclxuICAgIGRhdGEuZm9udCA9IGluZm8uZ2V0QXR0cmlidXRlKCdmYWNlJyk7XHJcbiAgICBkYXRhLnNpemUgPSBwYXJzZUludChpbmZvLmdldEF0dHJpYnV0ZSgnc2l6ZScpLCAxMCk7XHJcbiAgICBkYXRhLmxpbmVIZWlnaHQgPSBwYXJzZUludChjb21tb24uZ2V0QXR0cmlidXRlKCdsaW5lSGVpZ2h0JyksIDEwKTtcclxuICAgIGRhdGEuY2hhcnMgPSB7fTtcclxuXHJcbiAgICAvL3BhcnNlIGxldHRlcnNcclxuICAgIHZhciBsZXR0ZXJzID0gcmVzb3VyY2UuZGF0YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2hhcicpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgY2hhckNvZGUgPSBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgnaWQnKSwgMTApO1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZVJlY3QgPSBuZXcgY29yZS5SZWN0YW5nbGUoXHJcbiAgICAgICAgICAgIHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCd4JyksIDEwKSArIHRleHR1cmUuZnJhbWUueCxcclxuICAgICAgICAgICAgcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3knKSwgMTApICsgdGV4dHVyZS5mcmFtZS55LFxyXG4gICAgICAgICAgICBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSwgMTApLFxyXG4gICAgICAgICAgICBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksIDEwKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGRhdGEuY2hhcnNbY2hhckNvZGVdID0ge1xyXG4gICAgICAgICAgICB4T2Zmc2V0OiBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgneG9mZnNldCcpLCAxMCksXHJcbiAgICAgICAgICAgIHlPZmZzZXQ6IHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCd5b2Zmc2V0JyksIDEwKSxcclxuICAgICAgICAgICAgeEFkdmFuY2U6IHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCd4YWR2YW5jZScpLCAxMCksXHJcbiAgICAgICAgICAgIGtlcm5pbmc6IHt9LFxyXG4gICAgICAgICAgICB0ZXh0dXJlOiBuZXcgY29yZS5UZXh0dXJlKHRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVSZWN0KVxyXG5cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vcGFyc2Uga2VybmluZ3NcclxuICAgIHZhciBrZXJuaW5ncyA9IHJlc291cmNlLmRhdGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2tlcm5pbmcnKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXJuaW5ncy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgZmlyc3QgPSBwYXJzZUludChrZXJuaW5nc1tpXS5nZXRBdHRyaWJ1dGUoJ2ZpcnN0JyksIDEwKTtcclxuICAgICAgICB2YXIgc2Vjb25kID0gcGFyc2VJbnQoa2VybmluZ3NbaV0uZ2V0QXR0cmlidXRlKCdzZWNvbmQnKSwgMTApO1xyXG4gICAgICAgIHZhciBhbW91bnQgPSBwYXJzZUludChrZXJuaW5nc1tpXS5nZXRBdHRyaWJ1dGUoJ2Ftb3VudCcpLCAxMCk7XHJcblxyXG4gICAgICAgIGRhdGEuY2hhcnNbc2Vjb25kXS5rZXJuaW5nW2ZpcnN0XSA9IGFtb3VudDtcclxuICAgIH1cclxuXHJcbiAgICByZXNvdXJjZS5iaXRtYXBGb250ID0gZGF0YTtcclxuXHJcbiAgICAvLyBJJ20gbGVhdmluZyB0aGlzIGFzIGEgdGVtcG9yYXJ5IGZpeCBzbyB3ZSBjYW4gdGVzdCB0aGUgYml0bWFwIGZvbnRzIGluIHYzXHJcbiAgICAvLyBidXQgaXQncyB2ZXJ5IGxpa2VseSB0byBjaGFuZ2VcclxuICAgIGV4dHJhcy5CaXRtYXBUZXh0LmZvbnRzW2RhdGEuZm9udF0gPSBkYXRhO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc291cmNlLCBuZXh0KVxyXG4gICAge1xyXG4gICAgICAgIC8vIHNraXAgaWYgbm8gZGF0YSBvciBub3QgeG1sIGRhdGFcclxuICAgICAgICBpZiAoIXJlc291cmNlLmRhdGEgfHwgIXJlc291cmNlLmlzWG1sKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNraXAgaWYgbm90IGJpdG1hcCBmb250IGRhdGEsIHVzaW5nIHNvbWUgc2lsbHkgZHVjay10eXBpbmdcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHJlc291cmNlLmRhdGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhZ2UnKS5sZW5ndGggPT09IDAgfHxcclxuICAgICAgICAgICAgcmVzb3VyY2UuZGF0YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpLmxlbmd0aCA9PT0gMCB8fFxyXG4gICAgICAgICAgICByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbmZvJylbMF0uZ2V0QXR0cmlidXRlKCdmYWNlJykgPT09IG51bGxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB4bWxVcmwgPSBwYXRoLmRpcm5hbWUocmVzb3VyY2UudXJsKTtcclxuXHJcbiAgICAgICAgaWYgKHhtbFVybCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgIHhtbFVybCA9ICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYmFzZVVybCAmJiB4bWxVcmwpIHtcclxuICAgICAgICAgICAgLy8gaWYgYmFzZXVybCBoYXMgYSB0cmFpbGluZyBzbGFzaCB0aGVuIGFkZCBvbmUgdG8geG1sVXJsIHNvIHRoZSByZXBsYWNlIHdvcmtzIGJlbG93XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJhc2VVcmwuY2hhckF0KHRoaXMuYmFzZVVybC5sZW5ndGggLSAxKSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICB4bWxVcmwgKz0gJy8nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyByZW1vdmUgYmFzZVVybCBmcm9tIHhtbFVybFxyXG4gICAgICAgICAgICB4bWxVcmwgPSB4bWxVcmwucmVwbGFjZSh0aGlzLmJhc2VVcmwsICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIHhtbFVybCBub3csIGl0IG5lZWRzIGEgdHJhaWxpbmcgc2xhc2guIEVuc3VyZSB0aGF0IGl0IGRvZXMgaWYgdGhlIHN0cmluZyBpc24ndCBlbXB0eS5cclxuICAgICAgICBpZiAoeG1sVXJsICYmIHhtbFVybC5jaGFyQXQoeG1sVXJsLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcclxuICAgICAgICAgICAgeG1sVXJsICs9ICcvJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRleHR1cmVVcmwgPSB4bWxVcmwgKyByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYWdlJylbMF0uZ2V0QXR0cmlidXRlKCdmaWxlJyk7XHJcbiAgICAgICAgaWYgKGNvcmUudXRpbHMuVGV4dHVyZUNhY2hlW3RleHR1cmVVcmxdKSB7XHJcbiAgICAgICAgICAgIC8vcmV1c2UgZXhpc3RpbmcgdGV4dHVyZVxyXG4gICAgICAgICAgICBwYXJzZShyZXNvdXJjZSwgY29yZS51dGlscy5UZXh0dXJlQ2FjaGVbdGV4dHVyZVVybF0pO1xyXG4gICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbG9hZE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogcmVzb3VyY2UuY3Jvc3NPcmlnaW4sXHJcbiAgICAgICAgICAgICAgICBsb2FkVHlwZTogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJlc291cmNlLm1ldGFkYXRhLmltYWdlTWV0YWRhdGFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gbG9hZCB0aGUgdGV4dHVyZSBmb3IgdGhlIGZvbnRcclxuICAgICAgICAgICAgdGhpcy5hZGQocmVzb3VyY2UubmFtZSArICdfaW1hZ2UnLCB0ZXh0dXJlVXJsLCBsb2FkT3B0aW9ucywgZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgcGFyc2UocmVzb3VyY2UsIHJlcy50ZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgIG5leHQoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuIiwiLyoqXHJcbiAqIEBmaWxlICAgICAgICBNYWluIGV4cG9ydCBvZiB0aGUgUElYSSBsb2FkZXJzIGxpYnJhcnlcclxuICogQGF1dGhvciAgICAgIE1hdCBHcm92ZXMgPG1hdEBnb29kYm95ZGlnaXRhbC5jb20+XHJcbiAqIEBjb3B5cmlnaHQgICAyMDEzLTIwMTUgR29vZEJveURpZ2l0YWxcclxuICogQGxpY2Vuc2UgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGkuanMvYmxvYi9tYXN0ZXIvTElDRU5TRXxNSVQgTGljZW5zZX1cclxuICovXHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBQSVhJLmxvYWRlcnNcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgTG9hZGVyOiAgICAgICAgICAgICByZXF1aXJlKCcuL2xvYWRlcicpLFxyXG5cclxuICAgIC8vIHBhcnNlcnNcclxuICAgIGJpdG1hcEZvbnRQYXJzZXI6ICAgcmVxdWlyZSgnLi9iaXRtYXBGb250UGFyc2VyJyksXHJcbiAgICBzcHJpdGVzaGVldFBhcnNlcjogIHJlcXVpcmUoJy4vc3ByaXRlc2hlZXRQYXJzZXInKSxcclxuICAgIHRleHR1cmVQYXJzZXI6ICAgICAgcmVxdWlyZSgnLi90ZXh0dXJlUGFyc2VyJyksXHJcbiAgICBSZXNvdXJjZTogICAgICAgICAgIHJlcXVpcmUoJ3Jlc291cmNlLWxvYWRlcicpLlJlc291cmNlXHJcbn07XHJcbiIsInZhciBSZXNvdXJjZUxvYWRlciA9IHJlcXVpcmUoJ3Jlc291cmNlLWxvYWRlcicpLFxyXG4gICAgdGV4dHVyZVBhcnNlciA9IHJlcXVpcmUoJy4vdGV4dHVyZVBhcnNlcicpLFxyXG4gICAgc3ByaXRlc2hlZXRQYXJzZXIgPSByZXF1aXJlKCcuL3Nwcml0ZXNoZWV0UGFyc2VyJyksXHJcbiAgICBiaXRtYXBGb250UGFyc2VyID0gcmVxdWlyZSgnLi9iaXRtYXBGb250UGFyc2VyJyk7XHJcblxyXG4vKipcclxuICpcclxuICogVGhlIG5ldyBsb2FkZXIsIGV4dGVuZHMgUmVzb3VyY2UgTG9hZGVyIGJ5IENoYWQgRW5nbGVyIDogaHR0cHM6Ly9naXRodWIuY29tL2VuZ2xlcmNqL3Jlc291cmNlLWxvYWRlclxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbG9hZGVyID0gUElYSS5sb2FkZXI7IC8vIHBpeGkgZXhwb3NlcyBhIHByZW1hZGUgaW5zdGFuY2UgZm9yIHlvdSB0byB1c2UuXHJcbiAqIC8vb3JcclxuICogdmFyIGxvYWRlciA9IG5ldyBQSVhJLmxvYWRlcnMuTG9hZGVyKCk7IC8vIHlvdSBjYW4gYWxzbyBjcmVhdGUgeW91ciBvd24gaWYgeW91IHdhbnRcclxuICpcclxuICogbG9hZGVyLmFkZCgnYnVubnknLFwiZGF0YS9idW5ueS5wbmdcIik7XHJcbiAqXHJcbiAqIGxvYWRlci5vbmNlKCdjb21wbGV0ZScsb25Bc3NldHNMb2FkZWQpO1xyXG4gKlxyXG4gKiBsb2FkZXIubG9hZCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuUmVzb3VyY2VMb2FkZXJcclxuICogQG1lbWJlcm9mIFBJWEkubG9hZGVyc1xyXG4gKiBAcGFyYW0gW2Jhc2VVcmw9JyddIHtzdHJpbmd9IFRoZSBiYXNlIHVybCBmb3IgYWxsIHJlc291cmNlcyBsb2FkZWQgYnkgdGhpcyBsb2FkZXIuXHJcbiAqIEBwYXJhbSBbY29uY3VycmVuY3k9MTBdIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHRvIGxvYWQgY29uY3VycmVudGx5LlxyXG4gKi9cclxuZnVuY3Rpb24gTG9hZGVyKGJhc2VVcmwsIGNvbmN1cnJlbmN5KVxyXG57XHJcbiAgICBSZXNvdXJjZUxvYWRlci5jYWxsKHRoaXMsIGJhc2VVcmwsIGNvbmN1cnJlbmN5KTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IExvYWRlci5fcGl4aU1pZGRsZXdhcmUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB0aGlzLnVzZShMb2FkZXIuX3BpeGlNaWRkbGV3YXJlW2ldKCkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZXNvdXJjZUxvYWRlci5wcm90b3R5cGUpO1xyXG5Mb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9hZGVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXI7XHJcblxyXG5Mb2FkZXIuX3BpeGlNaWRkbGV3YXJlID0gW1xyXG4gICAgLy8gcGFyc2UgYW55IGJsb2IgaW50byBtb3JlIHVzYWJsZSBvYmplY3RzIChlLmcuIEltYWdlKVxyXG4gICAgUmVzb3VyY2VMb2FkZXIubWlkZGxld2FyZS5wYXJzaW5nLmJsb2IsXHJcbiAgICAvLyBwYXJzZSBhbnkgSW1hZ2Ugb2JqZWN0cyBpbnRvIHRleHR1cmVzXHJcbiAgICB0ZXh0dXJlUGFyc2VyLFxyXG4gICAgLy8gcGFyc2UgYW55IHNwcml0ZXNoZWV0IGRhdGEgaW50byBtdWx0aXBsZSB0ZXh0dXJlc1xyXG4gICAgc3ByaXRlc2hlZXRQYXJzZXIsXHJcbiAgICAvLyBwYXJzZSBhbnkgc3ByaXRlc2hlZXQgZGF0YSBpbnRvIG11bHRpcGxlIHRleHR1cmVzXHJcbiAgICBiaXRtYXBGb250UGFyc2VyXHJcbl07XHJcblxyXG5Mb2FkZXIuYWRkUGl4aU1pZGRsZXdhcmUgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgIExvYWRlci5fcGl4aU1pZGRsZXdhcmUucHVzaChmbik7XHJcbn07XHJcblxyXG4vLyBBZGQgY3VzdG9tIGV4dGVudGlvbnNcclxudmFyIFJlc291cmNlID0gUmVzb3VyY2VMb2FkZXIuUmVzb3VyY2U7XHJcblxyXG5SZXNvdXJjZS5zZXRFeHRlbnNpb25YaHJUeXBlKCdmbnQnLCBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCk7XHJcbiIsInZhciBSZXNvdXJjZSA9IHJlcXVpcmUoJ3Jlc291cmNlLWxvYWRlcicpLlJlc291cmNlLFxyXG4gICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcclxuICAgIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiBmdW5jdGlvbiAocmVzb3VyY2UsIG5leHQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gc2tpcCBpZiBubyBkYXRhLCBpdHMgbm90IGpzb24sIG9yIGl0IGlzbid0IHNwcml0ZXNoZWV0IGRhdGFcclxuICAgICAgICBpZiAoIXJlc291cmNlLmRhdGEgfHwgIXJlc291cmNlLmlzSnNvbiB8fCAhcmVzb3VyY2UuZGF0YS5mcmFtZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxvYWRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBjcm9zc09yaWdpbjogcmVzb3VyY2UuY3Jvc3NPcmlnaW4sXHJcbiAgICAgICAgICAgIGxvYWRUeXBlOiBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0UsXHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiByZXNvdXJjZS5tZXRhZGF0YS5pbWFnZU1ldGFkYXRhXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHJvdXRlID0gcGF0aC5kaXJuYW1lKHJlc291cmNlLnVybC5yZXBsYWNlKHRoaXMuYmFzZVVybCwgJycpKTtcclxuXHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb3JlLnV0aWxzLmdldFJlc29sdXRpb25PZlVybCggcmVzb3VyY2UudXJsICk7XHJcblxyXG4gICAgICAgIC8vIGxvYWQgdGhlIGltYWdlIGZvciB0aGlzIHNoZWV0XHJcbiAgICAgICAgdGhpcy5hZGQocmVzb3VyY2UubmFtZSArICdfaW1hZ2UnLCByb3V0ZSArICcvJyArIHJlc291cmNlLmRhdGEubWV0YS5pbWFnZSwgbG9hZE9wdGlvbnMsIGZ1bmN0aW9uIChyZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXNvdXJjZS50ZXh0dXJlcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHJlc291cmNlLmRhdGEuZnJhbWVzO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBmcmFtZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZnJhbWVzW2ldLmZyYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZWN0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpbSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZXNbaV0ucm90YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gbmV3IGNvcmUuUmVjdGFuZ2xlKHJlY3QueCwgcmVjdC55LCByZWN0LmgsIHJlY3Qudyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gbmV3IGNvcmUuUmVjdGFuZ2xlKHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgQ2hlY2sgdG8gc2VlIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZXNbaV0udHJpbW1lZClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0gPSBuZXcgY29yZS5SZWN0YW5nbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZXNbaV0uc3ByaXRlU291cmNlU2l6ZS54IC8gcmVzb2x1dGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lc1tpXS5zcHJpdGVTb3VyY2VTaXplLnkgLyByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVzW2ldLnNvdXJjZVNpemUudyAvIHJlc29sdXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZXNbaV0uc291cmNlU2l6ZS5oIC8gcmVzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsaXAgdGhlIHdpZHRoIGFuZCBoZWlnaHQhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lc1tpXS5yb3RhdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBzaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplLndpZHRoID0gc2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUuaGVpZ2h0ID0gdGVtcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNpemUueCAvPSByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpemUueSAvPSByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpemUud2lkdGggLz0gcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBzaXplLmhlaWdodCAvPSByZXNvbHV0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS50ZXh0dXJlc1tpXSA9IG5ldyBjb3JlLlRleHR1cmUocmVzLnRleHR1cmUuYmFzZVRleHR1cmUsIHNpemUsIHNpemUuY2xvbmUoKSwgdHJpbSwgZnJhbWVzW2ldLnJvdGF0ZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBsZXRzIGFsc28gYWRkIHRoZSBmcmFtZSB0byBwaXhpJ3MgZ2xvYmFsIGNhY2hlIGZvciBmcm9tRnJhbWUgYW5kIGZyb21JbWFnZSBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLnV0aWxzLlRleHR1cmVDYWNoZVtpXSA9IHJlc291cmNlLnRleHR1cmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59O1xyXG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvdXJjZSwgbmV4dClcclxuICAgIHtcclxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgdGV4dHVyZSBpZiB0aGUgZGF0YSBpcyBhbiBJbWFnZSBvYmplY3RcclxuICAgICAgICBpZiAocmVzb3VyY2UuZGF0YSAmJiByZXNvdXJjZS5pc0ltYWdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gbmV3IGNvcmUuQmFzZVRleHR1cmUocmVzb3VyY2UuZGF0YSwgbnVsbCwgY29yZS51dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwocmVzb3VyY2UudXJsKSk7XHJcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlLmltYWdlVXJsID0gcmVzb3VyY2UudXJsO1xyXG4gICAgICAgICAgICByZXNvdXJjZS50ZXh0dXJlID0gbmV3IGNvcmUuVGV4dHVyZShiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgICAgIC8vIGxldHMgYWxzbyBhZGQgdGhlIGZyYW1lIHRvIHBpeGkncyBnbG9iYWwgY2FjaGUgZm9yIGZyb21GcmFtZSBhbmQgZnJvbUltYWdlIGZ1Y250aW9uc1xyXG4gICAgICAgICAgICBjb3JlLnV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbcmVzb3VyY2UudXJsXSA9IGJhc2VUZXh0dXJlO1xyXG4gICAgICAgICAgICBjb3JlLnV0aWxzLlRleHR1cmVDYWNoZVtyZXNvdXJjZS51cmxdID0gcmVzb3VyY2UudGV4dHVyZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5leHQoKTtcclxuICAgIH07XHJcbn07XHJcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpLFxyXG4gICAgdGVtcFBvaW50ID0gbmV3IGNvcmUuUG9pbnQoKSxcclxuICAgIHRlbXBQb2x5Z29uID0gbmV3IGNvcmUuUG9seWdvbigpO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgbWVzaCBjbGFzc1xyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5Db250YWluZXJcclxuICogQG1lbWJlcm9mIFBJWEkubWVzaFxyXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5UZXh0dXJlfSBUaGUgdGV4dHVyZSB0byB1c2VcclxuICogQHBhcmFtIFt2ZXJ0aWNlc10ge0Zsb2F0MzJBcnJpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSB2ZXJ0aWNlc1xyXG4gKiBAcGFyYW0gW3V2c10ge0Zsb2F0MzJBcnJheX0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgdXZzXHJcbiAqIEBwYXJhbSBbaW5kaWNlc10ge1VpbnQxNkFycmF5fSBpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSBpbmRpY2VzXHJcbiAqIEBwYXJhbSBbZHJhd01vZGVdIHtudW1iZXJ9IHRoZSBkcmF3TW9kZSwgY2FuIGJlIGFueSBvZiB0aGUgTWVzaC5EUkFXX01PREVTIGNvbnN0c1xyXG4gKi9cclxuZnVuY3Rpb24gTWVzaCh0ZXh0dXJlLCB2ZXJ0aWNlcywgdXZzLCBpbmRpY2VzLCBkcmF3TW9kZSlcclxue1xyXG4gICAgY29yZS5Db250YWluZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0dXJlIG9mIHRoZSBNZXNoXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgVXZzIG9mIHRoZSBNZXNoXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnV2cyA9IHV2cyB8fCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLFxyXG4gICAgICAgIDEsIDAsXHJcbiAgICAgICAgMSwgMSxcclxuICAgICAgICAwLCAxXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiB2ZXJ0aWNlc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzIHx8IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsXHJcbiAgICAgICAgMTAwLCAwLFxyXG4gICAgICAgIDEwMCwgMTAwLFxyXG4gICAgICAgIDAsIDEwMF0pO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXNcclxuICAgICAqL1xyXG4gICAgLy8gIFRPRE8gYXV0byBnZW5lcmF0ZSB0aGlzIGJhc2VkIG9uIGRyYXcgbW9kZSFcclxuICAgIHRoaXMuaW5kaWNlcyA9IGluZGljZXMgfHwgbmV3IFVpbnQxNkFycmF5KFswLCAxLCAzLCAyXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBNZXNoIGlzIGRpcnR5IG9yIG5vdFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBTZXQgdG8gYFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMYCB0byByZW1vdmUgYW55IGJsZW5kIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcclxuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xyXG4gICAgICovXHJcbiAgICB0aGlzLmJsZW5kTW9kZSA9IGNvcmUuQkxFTkRfTU9ERVMuTk9STUFMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJpYW5nbGVzIGluIGNhbnZhcyBtb2RlIGFyZSBhdXRvbWF0aWNhbGx5IGFudGlhbGlhc2VkLCB1c2UgdGhpcyB2YWx1ZSB0byBmb3JjZSB0cmlhbmdsZXMgdG8gb3ZlcmxhcCBhIGJpdCB3aXRoIGVhY2ggb3RoZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNhbnZhc1BhZGRpbmcgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdheSB0aGUgTWVzaCBzaG91bGQgYmUgZHJhd24sIGNhbiBiZSBhbnkgb2YgdGhlIHtAbGluayBQSVhJLm1lc2guTWVzaC5EUkFXX01PREVTfSBjb25zdHNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAc2VlIFBJWEkubWVzaC5NZXNoLkRSQVdfTU9ERVNcclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmF3TW9kZSA9IGRyYXdNb2RlIHx8IE1lc2guRFJBV19NT0RFUy5UUklBTkdMRV9NRVNIO1xyXG5cclxuICAgIC8vIHJ1biB0ZXh0dXJlIHNldHRlcjtcclxuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgc2hhZGVyIHRoYXQgaXMgdXNlZCBpZiBhIG1lc2ggZG9lc24ndCBoYXZlIGEgbW9yZSBzcGVjaWZpYyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxufVxyXG5cclxuLy8gY29uc3RydWN0b3JcclxuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQ29udGFpbmVyLnByb3RvdHlwZSk7XHJcbk1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaDtcclxubW9kdWxlLmV4cG9ydHMgPSBNZXNoO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWVzaC5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkubWVzaC5NZXNoI1xyXG4gICAgICovXHJcbiAgICB0ZXh0dXJlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICB0aGlzLl90ZXh0dXJlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgdGV4dHVyZSB0byBsb2FkXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLm9uY2UoJ3VwZGF0ZScsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICpcclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IGEgcmVmZXJlbmNlIHRvIHRoZSBXZWJHTCByZW5kZXJlclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTWVzaC5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxyXG57XHJcbiAgICByZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLm1lc2gpO1xyXG4gICAgcmVuZGVyZXIucGx1Z2lucy5tZXNoLnJlbmRlcih0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxyXG4gKlxyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5NZXNoLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxyXG57XHJcbiAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcblxyXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XHJcblxyXG4gICAgaWYgKHJlbmRlcmVyLnJvdW5kUGl4ZWxzKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hLCB0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmMsIHRyYW5zZm9ybS5kLCB0cmFuc2Zvcm0udHggfCAwLCB0cmFuc2Zvcm0udHkgfCAwKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4LCB0cmFuc2Zvcm0udHkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmRyYXdNb2RlID09PSBNZXNoLkRSQVdfTU9ERVMuVFJJQU5HTEVfTUVTSClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJDYW52YXNUcmlhbmdsZU1lc2goY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2FudmFzVHJpYW5nbGVzKGNvbnRleHQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERyYXdzIHRoZSBvYmplY3QgaW4gVHJpYW5nbGUgTWVzaCBtb2RlIHVzaW5nIGNhbnZhc1xyXG4gKlxyXG4gKiBAcGFyYW0gY29udGV4dCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSB0aGUgY3VycmVudCBkcmF3aW5nIGNvbnRleHRcclxuICogQHByaXZhdGVcclxuICovXHJcbk1lc2gucHJvdG90eXBlLl9yZW5kZXJDYW52YXNUcmlhbmdsZU1lc2ggPSBmdW5jdGlvbiAoY29udGV4dClcclxue1xyXG4gICAgLy8gZHJhdyB0cmlhbmdsZXMhIVxyXG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgIHZhciB1dnMgPSB0aGlzLnV2cztcclxuXHJcbiAgICB2YXIgbGVuZ3RoID0gdmVydGljZXMubGVuZ3RoIC8gMjtcclxuICAgIC8vIHRoaXMuY291bnQrKztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAtIDI7IGkrKylcclxuICAgIHtcclxuICAgICAgICAvLyBkcmF3IHNvbWUgdHJpYW5nbGVzIVxyXG4gICAgICAgIHZhciBpbmRleCA9IGkgKiAyO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckNhbnZhc0RyYXdUcmlhbmdsZShjb250ZXh0LCB2ZXJ0aWNlcywgdXZzLCBpbmRleCwgKGluZGV4ICsgMiksIChpbmRleCArIDQpKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEcmF3cyB0aGUgb2JqZWN0IGluIHRyaWFuZ2xlIG1vZGUgdXNpbmcgY2FudmFzXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250ZXh0IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IHRoZSBjdXJyZW50IGRyYXdpbmcgY29udGV4dFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTWVzaC5wcm90b3R5cGUuX3JlbmRlckNhbnZhc1RyaWFuZ2xlcyA9IGZ1bmN0aW9uIChjb250ZXh0KVxyXG57XHJcbiAgICAvLyBkcmF3IHRyaWFuZ2xlcyEhXHJcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgdmFyIHV2cyA9IHRoaXMudXZzO1xyXG4gICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XHJcblxyXG4gICAgdmFyIGxlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xyXG4gICAgLy8gdGhpcy5jb3VudCsrO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDMpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gZHJhdyBzb21lIHRyaWFuZ2xlcyFcclxuICAgICAgICB2YXIgaW5kZXgwID0gaW5kaWNlc1tpXSAqIDIsIGluZGV4MSA9IGluZGljZXNbaSArIDFdICogMiwgaW5kZXgyID0gaW5kaWNlc1tpICsgMl0gKiAyO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckNhbnZhc0RyYXdUcmlhbmdsZShjb250ZXh0LCB2ZXJ0aWNlcywgdXZzLCBpbmRleDAsIGluZGV4MSwgaW5kZXgyKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEcmF3cyBvbmUgb2YgdGhlIHRyaWFuZ2xlcyB0aGF0IGZvcm0gdGhpcyBNZXNoXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250ZXh0IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IHRoZSBjdXJyZW50IGRyYXdpbmcgY29udGV4dFxyXG4gKiBAcGFyYW0gdmVydGljZXMge0Zsb2F0MzJBcnJheX0gYSByZWZlcmVuY2UgdG8gdGhlIHZlcnRpY2VzIG9mIHRoZSBNZXNoXHJcbiAqIEBwYXJhbSB1dnMge0Zsb2F0MzJBcnJheX0gYSByZWZlcmVuY2UgdG8gdGhlIHV2cyBvZiB0aGUgTWVzaFxyXG4gKiBAcGFyYW0gaW5kZXgwIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdmVydGV4XHJcbiAqIEBwYXJhbSBpbmRleDEge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgdmVydGV4XHJcbiAqIEBwYXJhbSBpbmRleDIge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSB0aGlyZCB2ZXJ0ZXhcclxuICogQHByaXZhdGVcclxuICovXHJcbk1lc2gucHJvdG90eXBlLl9yZW5kZXJDYW52YXNEcmF3VHJpYW5nbGUgPSBmdW5jdGlvbiAoY29udGV4dCwgdmVydGljZXMsIHV2cywgaW5kZXgwLCBpbmRleDEsIGluZGV4Milcclxue1xyXG4gICAgdmFyIHRleHR1cmVTb3VyY2UgPSB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZTtcclxuICAgIHZhciB0ZXh0dXJlV2lkdGggPSB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoO1xyXG4gICAgdmFyIHRleHR1cmVIZWlnaHQgPSB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodDtcclxuXHJcbiAgICB2YXIgeDAgPSB2ZXJ0aWNlc1tpbmRleDBdLCB4MSA9IHZlcnRpY2VzW2luZGV4MV0sIHgyID0gdmVydGljZXNbaW5kZXgyXTtcclxuICAgIHZhciB5MCA9IHZlcnRpY2VzW2luZGV4MCArIDFdLCB5MSA9IHZlcnRpY2VzW2luZGV4MSArIDFdLCB5MiA9IHZlcnRpY2VzW2luZGV4MiArIDFdO1xyXG5cclxuICAgIHZhciB1MCA9IHV2c1tpbmRleDBdICogdGV4dHVyZVdpZHRoLCB1MSA9IHV2c1tpbmRleDFdICogdGV4dHVyZVdpZHRoLCB1MiA9IHV2c1tpbmRleDJdICogdGV4dHVyZVdpZHRoO1xyXG4gICAgdmFyIHYwID0gdXZzW2luZGV4MCArIDFdICogdGV4dHVyZUhlaWdodCwgdjEgPSB1dnNbaW5kZXgxICsgMV0gKiB0ZXh0dXJlSGVpZ2h0LCB2MiA9IHV2c1tpbmRleDIgKyAxXSAqIHRleHR1cmVIZWlnaHQ7XHJcblxyXG4gICAgaWYgKHRoaXMuY2FudmFzUGFkZGluZyA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHBhZGRpbmdYID0gdGhpcy5jYW52YXNQYWRkaW5nIC8gdGhpcy53b3JsZFRyYW5zZm9ybS5hO1xyXG4gICAgICAgIHZhciBwYWRkaW5nWSA9IHRoaXMuY2FudmFzUGFkZGluZyAvIHRoaXMud29ybGRUcmFuc2Zvcm0uZDtcclxuICAgICAgICB2YXIgY2VudGVyWCA9ICh4MCArIHgxICsgeDIpIC8gMztcclxuICAgICAgICB2YXIgY2VudGVyWSA9ICh5MCArIHkxICsgeTIpIC8gMztcclxuXHJcbiAgICAgICAgdmFyIG5vcm1YID0geDAgLSBjZW50ZXJYO1xyXG4gICAgICAgIHZhciBub3JtWSA9IHkwIC0gY2VudGVyWTtcclxuXHJcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQobm9ybVggKiBub3JtWCArIG5vcm1ZICogbm9ybVkpO1xyXG4gICAgICAgIHgwID0gY2VudGVyWCArIChub3JtWCAvIGRpc3QpICogKGRpc3QgKyBwYWRkaW5nWCk7XHJcbiAgICAgICAgeTAgPSBjZW50ZXJZICsgKG5vcm1ZIC8gZGlzdCkgKiAoZGlzdCArIHBhZGRpbmdZKTtcclxuXHJcbiAgICAgICAgLy9cclxuXHJcbiAgICAgICAgbm9ybVggPSB4MSAtIGNlbnRlclg7XHJcbiAgICAgICAgbm9ybVkgPSB5MSAtIGNlbnRlclk7XHJcblxyXG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQobm9ybVggKiBub3JtWCArIG5vcm1ZICogbm9ybVkpO1xyXG4gICAgICAgIHgxID0gY2VudGVyWCArIChub3JtWCAvIGRpc3QpICogKGRpc3QgKyBwYWRkaW5nWCk7XHJcbiAgICAgICAgeTEgPSBjZW50ZXJZICsgKG5vcm1ZIC8gZGlzdCkgKiAoZGlzdCArIHBhZGRpbmdZKTtcclxuXHJcbiAgICAgICAgbm9ybVggPSB4MiAtIGNlbnRlclg7XHJcbiAgICAgICAgbm9ybVkgPSB5MiAtIGNlbnRlclk7XHJcblxyXG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQobm9ybVggKiBub3JtWCArIG5vcm1ZICogbm9ybVkpO1xyXG4gICAgICAgIHgyID0gY2VudGVyWCArIChub3JtWCAvIGRpc3QpICogKGRpc3QgKyBwYWRkaW5nWCk7XHJcbiAgICAgICAgeTIgPSBjZW50ZXJZICsgKG5vcm1ZIC8gZGlzdCkgKiAoZGlzdCArIHBhZGRpbmdZKTtcclxuICAgIH1cclxuXHJcbiAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcblxyXG5cclxuICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xyXG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcclxuXHJcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cclxuICAgIGNvbnRleHQuY2xpcCgpO1xyXG5cclxuICAgIC8vIENvbXB1dGUgbWF0cml4IHRyYW5zZm9ybVxyXG4gICAgdmFyIGRlbHRhID0gICh1MCAqIHYxKSAgICAgICsgKHYwICogdTIpICAgICAgKyAodTEgKiB2MikgICAgICAtICh2MSAqIHUyKSAgICAgIC0gKHYwICogdTEpICAgICAgLSAodTAgKiB2Mik7XHJcbiAgICB2YXIgZGVsdGFBID0gKHgwICogdjEpICAgICAgKyAodjAgKiB4MikgICAgICArICh4MSAqIHYyKSAgICAgIC0gKHYxICogeDIpICAgICAgLSAodjAgKiB4MSkgICAgICAtICh4MCAqIHYyKTtcclxuICAgIHZhciBkZWx0YUIgPSAodTAgKiB4MSkgICAgICArICh4MCAqIHUyKSAgICAgICsgKHUxICogeDIpICAgICAgLSAoeDEgKiB1MikgICAgICAtICh4MCAqIHUxKSAgICAgIC0gKHUwICogeDIpO1xyXG4gICAgdmFyIGRlbHRhQyA9ICh1MCAqIHYxICogeDIpICsgKHYwICogeDEgKiB1MikgKyAoeDAgKiB1MSAqIHYyKSAtICh4MCAqIHYxICogdTIpIC0gKHYwICogdTEgKiB4MikgLSAodTAgKiB4MSAqIHYyKTtcclxuICAgIHZhciBkZWx0YUQgPSAoeTAgKiB2MSkgICAgICArICh2MCAqIHkyKSAgICAgICsgKHkxICogdjIpICAgICAgLSAodjEgKiB5MikgICAgICAtICh2MCAqIHkxKSAgICAgIC0gKHkwICogdjIpO1xyXG4gICAgdmFyIGRlbHRhRSA9ICh1MCAqIHkxKSAgICAgICsgKHkwICogdTIpICAgICAgKyAodTEgKiB5MikgICAgICAtICh5MSAqIHUyKSAgICAgIC0gKHkwICogdTEpICAgICAgLSAodTAgKiB5Mik7XHJcbiAgICB2YXIgZGVsdGFGID0gKHUwICogdjEgKiB5MikgKyAodjAgKiB5MSAqIHUyKSArICh5MCAqIHUxICogdjIpIC0gKHkwICogdjEgKiB1MikgLSAodjAgKiB1MSAqIHkyKSAtICh1MCAqIHkxICogdjIpO1xyXG5cclxuICAgIGNvbnRleHQudHJhbnNmb3JtKGRlbHRhQSAvIGRlbHRhLCBkZWx0YUQgLyBkZWx0YSxcclxuICAgICAgICBkZWx0YUIgLyBkZWx0YSwgZGVsdGFFIC8gZGVsdGEsXHJcbiAgICAgICAgZGVsdGFDIC8gZGVsdGEsIGRlbHRhRiAvIGRlbHRhKTtcclxuXHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlU291cmNlLCAwLCAwKTtcclxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG59O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVuZGVycyBhIGZsYXQgTWVzaFxyXG4gKlxyXG4gKiBAcGFyYW0gTWVzaCB7UElYSS5tZXNoLk1lc2h9IFRoZSBNZXNoIHRvIHJlbmRlclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTWVzaC5wcm90b3R5cGUucmVuZGVyTWVzaEZsYXQgPSBmdW5jdGlvbiAoTWVzaClcclxue1xyXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICB2YXIgdmVydGljZXMgPSBNZXNoLnZlcnRpY2VzO1xyXG5cclxuICAgIHZhciBsZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGgvMjtcclxuICAgIC8vIHRoaXMuY291bnQrKztcclxuXHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgZm9yICh2YXIgaT0xOyBpIDwgbGVuZ3RoLTI7IGkrKylcclxuICAgIHtcclxuICAgICAgICAvLyBkcmF3IHNvbWUgdHJpYW5nbGVzIVxyXG4gICAgICAgIHZhciBpbmRleCA9IGkqMjtcclxuXHJcbiAgICAgICAgdmFyIHgwID0gdmVydGljZXNbaW5kZXhdLCAgIHgxID0gdmVydGljZXNbaW5kZXgrMl0sIHgyID0gdmVydGljZXNbaW5kZXgrNF07XHJcbiAgICAgICAgdmFyIHkwID0gdmVydGljZXNbaW5kZXgrMV0sIHkxID0gdmVydGljZXNbaW5kZXgrM10sIHkyID0gdmVydGljZXNbaW5kZXgrNV07XHJcblxyXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XHJcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcclxuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNGRjAwMDAnO1xyXG4gICAgY29udGV4dC5maWxsKCk7XHJcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdoZW4gdGhlIHRleHR1cmUgaXMgdXBkYXRlZCwgdGhpcyBldmVudCB3aWxsIGZpcmUgdG8gdXBkYXRlIHRoZSBzY2FsZSBhbmQgZnJhbWVcclxuICpcclxuICogQHBhcmFtIGV2ZW50XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5NZXNoLnByb3RvdHlwZS5fb25UZXh0dXJlVXBkYXRlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy51cGRhdGVGcmFtZSA9IHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBtZXNoIGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIHRoZSB3b3JsZFRyYW5zZm9ybSBpbnRvIGFjY291bnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBtYXRyaXgge1BJWEkuTWF0cml4fSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBzcHJpdGVcclxuICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxyXG4gKi9cclxuTWVzaC5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKG1hdHJpeClcclxue1xyXG4gICAgaWYgKCF0aGlzLl9jdXJyZW50Qm91bmRzKSB7XHJcbiAgICAgICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gbWF0cml4IHx8IHRoaXMud29ybGRUcmFuc2Zvcm07XHJcblxyXG4gICAgICAgIHZhciBhID0gd29ybGRUcmFuc2Zvcm0uYTtcclxuICAgICAgICB2YXIgYiA9IHdvcmxkVHJhbnNmb3JtLmI7XHJcbiAgICAgICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5jO1xyXG4gICAgICAgIHZhciBkID0gd29ybGRUcmFuc2Zvcm0uZDtcclxuICAgICAgICB2YXIgdHggPSB3b3JsZFRyYW5zZm9ybS50eDtcclxuICAgICAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTtcclxuXHJcbiAgICAgICAgdmFyIG1heFggPSAtSW5maW5pdHk7XHJcbiAgICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XHJcblxyXG4gICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XHJcbiAgICAgICAgdmFyIG1pblkgPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xyXG4gICAgICAgICAgICB2YXIgcmF3WCA9IHZlcnRpY2VzW2ldLCByYXdZID0gdmVydGljZXNbaSArIDFdO1xyXG4gICAgICAgICAgICB2YXIgeCA9IChhICogcmF3WCkgKyAoYyAqIHJhd1kpICsgdHg7XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGQgKiByYXdZKSArIChiICogcmF3WCkgKyB0eTtcclxuXHJcbiAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xyXG4gICAgICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcclxuXHJcbiAgICAgICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xyXG4gICAgICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtaW5YID09PSAtSW5maW5pdHkgfHwgbWF4WSA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvcmUuUmVjdGFuZ2xlLkVNUFRZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcclxuXHJcbiAgICAgICAgYm91bmRzLnggPSBtaW5YO1xyXG4gICAgICAgIGJvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xyXG5cclxuICAgICAgICBib3VuZHMueSA9IG1pblk7XHJcbiAgICAgICAgYm91bmRzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG5cclxuICAgICAgICAvLyBzdG9yZSBhIHJlZmVyZW5jZSBzbyB0aGF0IGlmIHRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgYWdhaW4gaW4gdGhlIHJlbmRlciBjeWNsZSB3ZSBkbyBub3QgaGF2ZSB0byByZWNhbGN1bGF0ZVxyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBib3VuZHM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCb3VuZHM7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBtZXNoLiBXb3JrcyBvbmx5IGZvciBUUklBTkdMRV9NRVNIXHJcbiAqXHJcbiAqIEBwYXJhbSBwb2ludCB7UElYSS5Qb2ludH0gdGhlIHBvaW50IHRvIHRlc3RcclxuICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxyXG4gKi9cclxuTWVzaC5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKCBwb2ludCApIHtcclxuICAgIGlmICghdGhpcy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludC54LCBwb2ludC55KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCAgdGVtcFBvaW50KTtcclxuXHJcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgdmFyIHBvaW50cyA9IHRlbXBQb2x5Z29uLnBvaW50cztcclxuICAgIHZhciBpLCBsZW47XHJcblxyXG4gICAgaWYgKHRoaXMuZHJhd01vZGUgPT09IE1lc2guRFJBV19NT0RFUy5UUklBTkdMRVMpIHtcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcclxuICAgICAgICBsZW4gPSB0aGlzLmluZGljZXMubGVuZ3RoO1xyXG4gICAgICAgIC8vVE9ETzogaW5saW5lIHRoaXMuXHJcbiAgICAgICAgZm9yIChpPTA7aTxsZW47aSs9Mykge1xyXG4gICAgICAgICAgICB2YXIgaW5kMCA9IGluZGljZXNbaV0qMiwgaW5kMSA9IGluZGljZXNbaSsxXSoyLCBpbmQyID0gaW5kaWNlc1tpKzJdKjI7XHJcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHZlcnRpY2VzW2luZDBdO1xyXG4gICAgICAgICAgICBwb2ludHNbMV0gPSB2ZXJ0aWNlc1tpbmQwKzFdO1xyXG4gICAgICAgICAgICBwb2ludHNbMl0gPSB2ZXJ0aWNlc1tpbmQxXTtcclxuICAgICAgICAgICAgcG9pbnRzWzNdID0gdmVydGljZXNbaW5kMSsxXTtcclxuICAgICAgICAgICAgcG9pbnRzWzRdID0gdmVydGljZXNbaW5kMl07XHJcbiAgICAgICAgICAgIHBvaW50c1s1XSA9IHZlcnRpY2VzW2luZDIrMV07XHJcbiAgICAgICAgICAgIGlmICh0ZW1wUG9seWdvbi5jb250YWlucyh0ZW1wUG9pbnQueCwgdGVtcFBvaW50LnkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGVuID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaT0wO2k8bGVuO2krPTYpIHtcclxuICAgICAgICAgICAgcG9pbnRzWzBdID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIHBvaW50c1sxXSA9IHZlcnRpY2VzW2krMV07XHJcbiAgICAgICAgICAgIHBvaW50c1syXSA9IHZlcnRpY2VzW2krMl07XHJcbiAgICAgICAgICAgIHBvaW50c1szXSA9IHZlcnRpY2VzW2krM107XHJcbiAgICAgICAgICAgIHBvaW50c1s0XSA9IHZlcnRpY2VzW2krNF07XHJcbiAgICAgICAgICAgIHBvaW50c1s1XSA9IHZlcnRpY2VzW2krNV07XHJcbiAgICAgICAgICAgIGlmICh0ZW1wUG9seWdvbi5jb250YWlucyh0ZW1wUG9pbnQueCwgdGVtcFBvaW50LnkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEaWZmZXJlbnQgZHJhd2luZyBidWZmZXIgbW9kZXMgc3VwcG9ydGVkXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQGNvbnN0YW50XHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBEUkFXX01PREVTXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLlRSSUFOR0xFX01FU0hcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IERSQVdfTU9ERVMuVFJJQU5HTEVTXHJcbiAqL1xyXG5NZXNoLkRSQVdfTU9ERVMgPSB7XHJcbiAgICBUUklBTkdMRV9NRVNIOiAwLFxyXG4gICAgVFJJQU5HTEVTOiAxXHJcbn07XHJcbiIsInZhciBNZXNoID0gcmVxdWlyZSgnLi9NZXNoJyk7XHJcblxyXG4vKipcclxuICogVGhlIFBsYW5lIGFsbG93cyB5b3UgdG8gZHJhdyBhIHRleHR1cmUgYWNyb3NzIHNldmVyYWwgcG9pbnRzIGFuZCB0aGVtIG1hbmlwdWxhdGUgdGhlc2UgcG9pbnRzXHJcbiAqXHJcbiAqYGBganNcclxuICogZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XHJcbiAqICAgICBwb2ludHMucHVzaChuZXcgUElYSS5Qb2ludChpICogNTAsIDApKTtcclxuICogfTtcclxuICogdmFyIFBsYW5lID0gbmV3IFBJWEkuUGxhbmUoUElYSS5UZXh0dXJlLmZyb21JbWFnZShcInNuYWtlLnBuZ1wiKSwgcG9pbnRzKTtcclxuICogIGBgYFxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5tZXNoLk1lc2hcclxuICogQG1lbWJlcm9mIFBJWEkubWVzaFxyXG4gKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIHVzZSBvbiB0aGUgUGxhbmUuXHJcbiAqIEBwYXJhbSB7aW50fSBzZWdtZW50c1ggLSBUaGUgbnVtYmVyIG94IHggc2VnbWVudHNcclxuICogQHBhcmFtIHtpbnR9IHNlZ21lbnRzWSAtIFRoZSBudW1iZXIgb2YgeSBzZWdtZW50c1xyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gUGxhbmUodGV4dHVyZSwgc2VnbWVudHNYLCBzZWdtZW50c1kpXHJcbntcclxuICAgIE1lc2guY2FsbCh0aGlzLCB0ZXh0dXJlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYWNrZXIgZm9yIGlmIHRoZSBQbGFuZSBpcyByZWFkeSB0byBiZSBkcmF3bi4gTmVlZGVkIGJlY2F1c2UgTWVzaCBjdG9yIGNhblxyXG4gICAgICogY2FsbCBfb25UZXh0dXJlVXBkYXRlZCB3aGljaCBjb3VsZCBjYWxsIHJlZnJlc2ggdG9vIGVhcmx5LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9yZWFkeSA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5zZWdtZW50c1ggPSAgc2VnbWVudHNYIHx8IDEwO1xyXG4gICAgdGhpcy5zZWdtZW50c1kgPSBzZWdtZW50c1kgfHwgMTA7XHJcblxyXG4gICAgdGhpcy5kcmF3TW9kZSA9IE1lc2guRFJBV19NT0RFUy5UUklBTkdMRVM7XHJcbiAgICB0aGlzLnJlZnJlc2goKTtcclxuXHJcbn1cclxuXHJcblxyXG4vLyBjb25zdHJ1Y3RvclxyXG5QbGFuZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoLnByb3RvdHlwZSApO1xyXG5QbGFuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGFuZTtcclxubW9kdWxlLmV4cG9ydHMgPSBQbGFuZTtcclxuXHJcbi8qKlxyXG4gKiBSZWZyZXNoZXNcclxuICpcclxuICovXHJcblBsYW5lLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKVxyXG57XHJcbiAgICB2YXIgdG90YWwgPSB0aGlzLnNlZ21lbnRzWCAqIHRoaXMuc2VnbWVudHNZO1xyXG4gICAgdmFyIHZlcnRzID0gW107XHJcbiAgICB2YXIgY29sb3JzID0gW107XHJcbiAgICB2YXIgdXZzID0gW107XHJcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XHJcblxyXG4gIC8vICB0ZXh0dXJlLndpZHRoID0gODAwIHRleHR1cmUud2lkdGggfHwgODAwO1xyXG4gLy8gICB0ZXh0dXJlLmhlaWdodCA9IDgwMC8vdGV4dHVyZS5oZWlnaHQgfHwgODAwO1xyXG5cclxuICAgIHZhciBzZWdtZW50c1hTdWIgPSB0aGlzLnNlZ21lbnRzWCAtIDE7XHJcbiAgICB2YXIgc2VnbWVudHNZU3ViID0gdGhpcy5zZWdtZW50c1kgLSAxO1xyXG4gICAgdmFyIGkgPSAwO1xyXG5cclxuICAgIC8vIFRPRE8gTUFQIFVWUy4uXHJcbiAgICB2YXIgc2l6ZVggPSB0ZXh0dXJlLndpZHRoIC8gc2VnbWVudHNYU3ViO1xyXG4gICAgdmFyIHNpemVZID0gdGV4dHVyZS5oZWlnaHQgLyBzZWdtZW50c1lTdWI7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcclxuXHJcbiAgICAgICAgdmFyIHggPSAoaSAlIHRoaXMuc2VnbWVudHNYKTtcclxuICAgICAgICB2YXIgeSA9ICggKGkgLyB0aGlzLnNlZ21lbnRzWCApIHwgMCApO1xyXG5cclxuXHJcbiAgICAgICAgdmVydHMucHVzaCgoeCAqIHNpemVYKSxcclxuICAgICAgICAgICAgICAgICAgICh5ICogc2l6ZVkpKTtcclxuXHJcbiAgICAgICAgdXZzLnB1c2goeCAvICh0aGlzLnNlZ21lbnRzWC0xKSwgeS8gKHRoaXMuc2VnbWVudHNZLTEpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgY29uc1xyXG5cclxuICAgIHZhciB0b3RhbFN1YiA9IHNlZ21lbnRzWFN1YiAqIHNlZ21lbnRzWVN1YjtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxTdWI7IGkrKykge1xyXG5cclxuICAgICAgICB2YXIgeHBvcyA9IGkgJSBzZWdtZW50c1hTdWI7XHJcbiAgICAgICAgdmFyIHlwb3MgPSAoaSAvIHNlZ21lbnRzWFN1YiApIHwgMDtcclxuXHJcblxyXG4gICAgICAgIHZhciAgdmFsdWUgPSAoeXBvcyAqIHRoaXMuc2VnbWVudHNYKSArIHhwb3M7XHJcbiAgICAgICAgdmFyICB2YWx1ZTIgPSAoeXBvcyAqIHRoaXMuc2VnbWVudHNYKSArIHhwb3MgKyAxO1xyXG4gICAgICAgIHZhciAgdmFsdWUzID0gKCh5cG9zKzEpICogdGhpcy5zZWdtZW50c1gpICsgeHBvcztcclxuICAgICAgICB2YXIgIHZhbHVlNCA9ICgoeXBvcysxKSAqIHRoaXMuc2VnbWVudHNYKSArIHhwb3MgKyAxO1xyXG5cclxuICAgICAgICBpbmRpY2VzLnB1c2godmFsdWUsIHZhbHVlMiwgdmFsdWUzKTtcclxuICAgICAgICBpbmRpY2VzLnB1c2godmFsdWUyLCB2YWx1ZTQsIHZhbHVlMyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vY29uc29sZS5sb2coaW5kaWNlcylcclxuICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRzKTtcclxuICAgIHRoaXMudXZzID0gbmV3IEZsb2F0MzJBcnJheSh1dnMpO1xyXG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KGNvbG9ycyk7XHJcbiAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xlYXIgdGV4dHVyZSBVVnMgd2hlbiBuZXcgdGV4dHVyZSBpcyBzZXRcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcblBsYW5lLnByb3RvdHlwZS5fb25UZXh0dXJlVXBkYXRlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgTWVzaC5wcm90b3R5cGUuX29uVGV4dHVyZVVwZGF0ZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8vIHdhaXQgZm9yIHRoZSBQbGFuZSBjdG9yIHRvIGZpbmlzaCBiZWZvcmUgY2FsbGluZyByZWZyZXNoXHJcbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgIH1cclxufTtcclxuIiwidmFyIE1lc2ggPSByZXF1aXJlKCcuL01lc2gnKTtcclxudmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XHJcblxyXG4vKipcclxuICogVGhlIHJvcGUgYWxsb3dzIHlvdSB0byBkcmF3IGEgdGV4dHVyZSBhY3Jvc3Mgc2V2ZXJhbCBwb2ludHMgYW5kIHRoZW0gbWFuaXB1bGF0ZSB0aGVzZSBwb2ludHNcclxuICpcclxuICpgYGBqc1xyXG4gKiBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpKyspIHtcclxuICogICAgIHBvaW50cy5wdXNoKG5ldyBQSVhJLlBvaW50KGkgKiA1MCwgMCkpO1xyXG4gKiB9O1xyXG4gKiB2YXIgcm9wZSA9IG5ldyBQSVhJLlJvcGUoUElYSS5UZXh0dXJlLmZyb21JbWFnZShcInNuYWtlLnBuZ1wiKSwgcG9pbnRzKTtcclxuICogIGBgYFxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgUElYSS5tZXNoLk1lc2hcclxuICogQG1lbWJlcm9mIFBJWEkubWVzaFxyXG4gKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIHVzZSBvbiB0aGUgcm9wZS5cclxuICogQHBhcmFtIHtQSVhJLlBvaW50W119IHBvaW50cyAtIEFuIGFycmF5IG9mIHtAbGluayBQSVhJLlBvaW50fSBvYmplY3RzIHRvIGNvbnN0cnVjdCB0aGlzIHJvcGUuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBSb3BlKHRleHR1cmUsIHBvaW50cylcclxue1xyXG4gICAgTWVzaC5jYWxsKHRoaXMsIHRleHR1cmUpO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50W119IEFuIGFycmF5IG9mIHBvaW50cyB0aGF0IGRldGVybWluZSB0aGUgcm9wZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcclxuXHJcbiAgICAvKlxyXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fSBBbiBhcnJheSBvZiB2ZXJ0aWNlcyB1c2VkIHRvIGNvbnN0cnVjdCB0aGlzIHJvcGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcclxuXHJcbiAgICAvKlxyXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fSBUaGUgV2ViR0wgVXZzIG9mIHRoZSByb3BlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbG9yIGNvbXBvbmVudHNcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcclxuXHJcbiAgICAvKlxyXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShwb2ludHMubGVuZ3RoICogMik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFja2VyIGZvciBpZiB0aGUgcm9wZSBpcyByZWFkeSB0byBiZSBkcmF3bi4gTmVlZGVkIGJlY2F1c2UgTWVzaCBjdG9yIGNhblxyXG4gICAgICogY2FsbCBfb25UZXh0dXJlVXBkYXRlZCB3aGljaCBjb3VsZCBjYWxsIHJlZnJlc2ggdG9vIGVhcmx5LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICAgdGhpcy5fcmVhZHkgPSB0cnVlO1xyXG5cclxuICAgICB0aGlzLnJlZnJlc2goKTtcclxufVxyXG5cclxuXHJcbi8vIGNvbnN0cnVjdG9yXHJcblJvcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNZXNoLnByb3RvdHlwZSk7XHJcblJvcGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm9wZTtcclxubW9kdWxlLmV4cG9ydHMgPSBSb3BlO1xyXG5cclxuLyoqXHJcbiAqIFJlZnJlc2hlc1xyXG4gKlxyXG4gKi9cclxuUm9wZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuXHJcbiAgICAvLyBpZiB0b28gbGl0dGxlIHBvaW50cywgb3IgdGV4dHVyZSBoYXNuJ3QgZ290IFVWcyBzZXQgeWV0IGp1c3QgbW92ZSBvbi5cclxuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMSB8fCAhdGhpcy5fdGV4dHVyZS5fdXZzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdXZzID0gdGhpcy51dnM7XHJcblxyXG4gICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XHJcbiAgICB2YXIgY29sb3JzID0gdGhpcy5jb2xvcnM7XHJcblxyXG4gICAgdmFyIHRleHR1cmVVdnMgPSB0aGlzLl90ZXh0dXJlLl91dnM7XHJcbiAgICB2YXIgb2Zmc2V0ID0gbmV3IGNvcmUuUG9pbnQodGV4dHVyZVV2cy54MCwgdGV4dHVyZVV2cy55MCk7XHJcbiAgICB2YXIgZmFjdG9yID0gbmV3IGNvcmUuUG9pbnQodGV4dHVyZVV2cy54MiAtIHRleHR1cmVVdnMueDAsIHRleHR1cmVVdnMueTIgLSB0ZXh0dXJlVXZzLnkwKTtcclxuXHJcbiAgICB1dnNbMF0gPSAwICsgb2Zmc2V0Lng7XHJcbiAgICB1dnNbMV0gPSAwICsgb2Zmc2V0Lnk7XHJcbiAgICB1dnNbMl0gPSAwICsgb2Zmc2V0Lng7XHJcbiAgICB1dnNbM10gPSAxICogZmFjdG9yLnkgKyBvZmZzZXQueTtcclxuXHJcbiAgICBjb2xvcnNbMF0gPSAxO1xyXG4gICAgY29sb3JzWzFdID0gMTtcclxuXHJcbiAgICBpbmRpY2VzWzBdID0gMDtcclxuICAgIGluZGljZXNbMV0gPSAxO1xyXG5cclxuICAgIHZhciB0b3RhbCA9IHBvaW50cy5sZW5ndGgsXHJcbiAgICAgICAgcG9pbnQsIGluZGV4LCBhbW91bnQ7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0b3RhbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgIGluZGV4ID0gaSAqIDQ7XHJcbiAgICAgICAgLy8gdGltZSB0byBkbyBzb21lIHNtYXJ0IGRyYXdpbmchXHJcbiAgICAgICAgYW1vdW50ID0gaSAvICh0b3RhbC0xKTtcclxuXHJcbiAgICAgICAgdXZzW2luZGV4XSA9IGFtb3VudCAqIGZhY3Rvci54ICsgb2Zmc2V0Lng7XHJcbiAgICAgICAgdXZzW2luZGV4KzFdID0gMCArIG9mZnNldC55O1xyXG5cclxuICAgICAgICB1dnNbaW5kZXgrMl0gPSBhbW91bnQgKiBmYWN0b3IueCArIG9mZnNldC54O1xyXG4gICAgICAgIHV2c1tpbmRleCszXSA9IDEgKiBmYWN0b3IueSArIG9mZnNldC55O1xyXG5cclxuICAgICAgICBpbmRleCA9IGkgKiAyO1xyXG4gICAgICAgIGNvbG9yc1tpbmRleF0gPSAxO1xyXG4gICAgICAgIGNvbG9yc1tpbmRleCsxXSA9IDE7XHJcblxyXG4gICAgICAgIGluZGV4ID0gaSAqIDI7XHJcbiAgICAgICAgaW5kaWNlc1tpbmRleF0gPSBpbmRleDtcclxuICAgICAgICBpbmRpY2VzW2luZGV4ICsgMV0gPSBpbmRleCArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xlYXIgdGV4dHVyZSBVVnMgd2hlbiBuZXcgdGV4dHVyZSBpcyBzZXRcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcblJvcGUucHJvdG90eXBlLl9vblRleHR1cmVVcGRhdGUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICBNZXNoLnByb3RvdHlwZS5fb25UZXh0dXJlVXBkYXRlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLy8gd2FpdCBmb3IgdGhlIFJvcGUgY3RvciB0byBmaW5pc2ggYmVmb3JlIGNhbGxpbmcgcmVmcmVzaFxyXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Sb3BlLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcblxyXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGFzdFBvaW50ID0gcG9pbnRzWzBdO1xyXG4gICAgdmFyIG5leHRQb2ludDtcclxuICAgIHZhciBwZXJwWCA9IDA7XHJcbiAgICB2YXIgcGVycFkgPSAwO1xyXG5cclxuICAgIC8vIHRoaXMuY291bnQgLT0gMC4yO1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcbiAgICB2YXIgdG90YWwgPSBwb2ludHMubGVuZ3RoLFxyXG4gICAgICAgIHBvaW50LCBpbmRleCwgcmF0aW8sIHBlcnBMZW5ndGgsIG51bTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XHJcbiAgICAgICAgaW5kZXggPSBpICogNDtcclxuXHJcbiAgICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwZXJwWSA9IC0obmV4dFBvaW50LnggLSBsYXN0UG9pbnQueCk7XHJcbiAgICAgICAgcGVycFggPSBuZXh0UG9pbnQueSAtIGxhc3RQb2ludC55O1xyXG5cclxuICAgICAgICByYXRpbyA9ICgxIC0gKGkgLyAodG90YWwtMSkpKSAqIDEwO1xyXG5cclxuICAgICAgICBpZiAocmF0aW8gPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmF0aW8gPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGVycExlbmd0aCA9IE1hdGguc3FydChwZXJwWCAqIHBlcnBYICsgcGVycFkgKiBwZXJwWSk7XHJcbiAgICAgICAgbnVtID0gdGhpcy5fdGV4dHVyZS5oZWlnaHQgLyAyOyAvLygyMCArIE1hdGguYWJzKE1hdGguc2luKChpICsgdGhpcy5jb3VudCkgKiAwLjMpICogNTApICkqIHJhdGlvO1xyXG4gICAgICAgIHBlcnBYIC89IHBlcnBMZW5ndGg7XHJcbiAgICAgICAgcGVycFkgLz0gcGVycExlbmd0aDtcclxuXHJcbiAgICAgICAgcGVycFggKj0gbnVtO1xyXG4gICAgICAgIHBlcnBZICo9IG51bTtcclxuXHJcbiAgICAgICAgdmVydGljZXNbaW5kZXhdID0gcG9pbnQueCArIHBlcnBYO1xyXG4gICAgICAgIHZlcnRpY2VzW2luZGV4KzFdID0gcG9pbnQueSArIHBlcnBZO1xyXG4gICAgICAgIHZlcnRpY2VzW2luZGV4KzJdID0gcG9pbnQueCAtIHBlcnBYO1xyXG4gICAgICAgIHZlcnRpY2VzW2luZGV4KzNdID0gcG9pbnQueSAtIHBlcnBZO1xyXG5cclxuICAgICAgICBsYXN0UG9pbnQgPSBwb2ludDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSgpO1xyXG59O1xyXG4iLCIvKipcclxuICogQGZpbGUgICAgICAgIE1haW4gZXhwb3J0IG9mIHRoZSBQSVhJIGV4dHJhcyBsaWJyYXJ5XHJcbiAqIEBhdXRob3IgICAgICBNYXQgR3JvdmVzIDxtYXRAZ29vZGJveWRpZ2l0YWwuY29tPlxyXG4gKiBAY29weXJpZ2h0ICAgMjAxMy0yMDE1IEdvb2RCb3lEaWdpdGFsXHJcbiAqIEBsaWNlbnNlICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUIExpY2Vuc2V9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgUElYSS5tZXNoXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIE1lc2g6ICAgICAgICAgICByZXF1aXJlKCcuL01lc2gnKSxcclxuICAgIFBsYW5lOiAgICAgICAgICAgcmVxdWlyZSgnLi9QbGFuZScpLFxyXG4gICAgUm9wZTogICAgICAgICAgIHJlcXVpcmUoJy4vUm9wZScpLFxyXG4gICAgTWVzaFJlbmRlcmVyOiAgIHJlcXVpcmUoJy4vd2ViZ2wvTWVzaFJlbmRlcmVyJyksXHJcbiAgICBNZXNoU2hhZGVyOiAgICAgcmVxdWlyZSgnLi93ZWJnbC9NZXNoU2hhZGVyJylcclxufTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyksXHJcbiAgICBNZXNoID0gcmVxdWlyZSgnLi4vTWVzaCcpO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xyXG4gKlxyXG4gKiBCaWcgdGhhbmtzIHRvIHRoZSB2ZXJ5IGNsZXZlciBNYXR0IERlc0xhdXJpZXJzIDxtYXR0ZGVzbD4gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL1xyXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcclxuICogQWxzbyBhIHRoYW5rcyB0byBodHRwczovL2dpdGh1Yi5jb20vYmNoZXZhbGllciBmb3IgdHdlYWtpbmcgdGhlIHRpbnQgYW5kIGFscGhhIHNvIHRoYXQgdGhleSBub3cgc2hhcmUgNCBieXRlcyBvbiB0aGUgdmVydGV4IGJ1ZmZlclxyXG4gKlxyXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIE1lc2hSZW5kZXJlcjpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9NZXNoUmVuZGVyZXIuamF2YVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICogQHByaXZhdGVcclxuICogQG1lbWJlcm9mIFBJWEkubWVzaFxyXG4gKiBAZXh0ZW5kcyBQSVhJLk9iamVjdFJlbmRlcmVyXHJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBzcHJpdGUgYmF0Y2ggd29ya3MgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gTWVzaFJlbmRlcmVyKHJlbmRlcmVyKVxyXG57XHJcbiAgICBjb3JlLk9iamVjdFJlbmRlcmVyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIHRoZSBpbmRpY2VzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIFxyXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KDE1MDAwKTtcclxuXHJcbiAgICAvL1RPRE8gdGhpcyBjb3VsZCBiZSBhIHNpbmdsZSBidWZmZXIgc2hhcmVkIGFtb25nc3QgYWxsIHJlbmRlcmVycyBhcyB3ZSByZXVzZSB0aGlzIHNldCB1cCBpbiBtb3N0IHJlbmRlcmVyc1xyXG4gICAgZm9yICh2YXIgaT0wLCBqPTA7IGkgPCAxNTAwMDsgaSArPSA2LCBqICs9IDQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAwXSA9IGogKyAwO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMV0gPSBqICsgMTtcclxuICAgICAgICB0aGlzLmluZGljZXNbaSArIDJdID0gaiArIDI7XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAzXSA9IGogKyAwO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNF0gPSBqICsgMjtcclxuICAgICAgICB0aGlzLmluZGljZXNbaSArIDVdID0gaiArIDM7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50U2hhZGVyID0gbnVsbDtcclxufVxyXG5cclxuTWVzaFJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5PYmplY3RSZW5kZXJlci5wcm90b3R5cGUpO1xyXG5NZXNoUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaFJlbmRlcmVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1lc2hSZW5kZXJlcjtcclxuXHJcbmNvcmUuV2ViR0xSZW5kZXJlci5yZWdpc3RlclBsdWdpbignbWVzaCcsIE1lc2hSZW5kZXJlcik7XHJcblxyXG4vKipcclxuICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcclxuICovXHJcbk1lc2hSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gKClcclxue1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBzcHJpdGUgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gbWVzaCB7UElYSS5tZXNoLk1lc2h9IHRoZSBtZXNoIHRvIHJlbmRlclxyXG4gKi9cclxuTWVzaFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobWVzaClcclxue1xyXG4gICAgaWYoIW1lc2guX3ZlcnRleEJ1ZmZlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9pbml0V2ViR0wobWVzaCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcclxuICAgICAgICBnbCA9IHJlbmRlcmVyLmdsLFxyXG4gICAgICAgIHRleHR1cmUgPSBtZXNoLl90ZXh0dXJlLmJhc2VUZXh0dXJlLFxyXG4gICAgICAgIHNoYWRlciA9IG1lc2guc2hhZGVyOy8vIHx8IHJlbmRlcmVyLnNoYWRlck1hbmFnZXIucGx1Z2lucy5tZXNoU2hhZGVyO1xyXG5cclxuICAgIHZhciBkcmF3TW9kZSA9IG1lc2guZHJhd01vZGUgPT09IE1lc2guRFJBV19NT0RFUy5UUklBTkdMRV9NRVNIID8gZ2wuVFJJQU5HTEVfU1RSSVAgOiBnbC5UUklBTkdMRVM7XHJcblxyXG4gICAgcmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUobWVzaC5ibGVuZE1vZGUpO1xyXG5cclxuICAgIC8vVE9ETyBjYWNoZSBjdXN0b20gc3RhdGUuLlxyXG4gICAgaWYgKCFzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgc2hhZGVyID0gcmVuZGVyZXIuc2hhZGVyTWFuYWdlci5wbHVnaW5zLm1lc2hTaGFkZXI7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgc2hhZGVyID0gc2hhZGVyLnNoYWRlcnNbZ2wuaWRdIHx8IHNoYWRlci5nZXRTaGFkZXIocmVuZGVyZXIpOy8vIDogc2hhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoc2hhZGVyKTtcclxuXHJcbiAgICBzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXgudmFsdWUgPSBtZXNoLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XHJcbiAgICBzaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC52YWx1ZSA9IHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xyXG4gICAgc2hhZGVyLnVuaWZvcm1zLmFscGhhLnZhbHVlID0gbWVzaC53b3JsZEFscGhhO1xyXG5cclxuICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoKTtcclxuXHJcbiAgICBpZiAoIW1lc2guZGlydHkpXHJcbiAgICB7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLl92ZXJ0ZXhCdWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCBtZXNoLnZlcnRpY2VzKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB1dnNcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC5fdXZCdWZmZXIpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYVRleHR1cmVDb29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuXHJcblxyXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xyXG5cclxuICAgICAgIGlmICghdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVRleHR1cmUodGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGN1cnJlbnQgdGV4dHVyZVxyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBtZXNoLl9pbmRleEJ1ZmZlcik7XHJcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgMCwgbWVzaC5pbmRpY2VzKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuXHJcbiAgICAgICAgbWVzaC5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLl92ZXJ0ZXhCdWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLnZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdXZzXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG1lc2guX3V2QnVmZmVyKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC51dnMsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hdHRyaWJ1dGVzLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcblxyXG4gICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuXHJcbiAgICAgICAgaWYgKCF0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlVGV4dHVyZSh0ZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gYmluZCB0aGUgY3VycmVudCB0ZXh0dXJlXHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRvbnQgbmVlZCB0byB1cGxvYWQhXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbWVzaC5faW5kZXhCdWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG1lc2guaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBnbC5kcmF3RWxlbWVudHMoZHJhd01vZGUsIG1lc2guaW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogUHJlcGFyZXMgYWxsIHRoZSBidWZmZXJzIHRvIHJlbmRlciB0aGlzIG1lc2hcclxuICogQHBhcmFtIG1lc2gge1BJWEkubWVzaC5NZXNofSB0aGUgbWVzaCB0byByZW5kZXJcclxuICovXHJcbk1lc2hSZW5kZXJlci5wcm90b3R5cGUuX2luaXRXZWJHTCA9IGZ1bmN0aW9uIChtZXNoKVxyXG57XHJcbiAgICAvLyBidWlsZCB0aGUgc3RyaXAhXHJcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgIG1lc2guX3ZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgbWVzaC5faW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIG1lc2guX3V2QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cclxuXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC5fdmVydGV4QnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLnZlcnRpY2VzLCBnbC5EWU5BTUlDX0RSQVcpO1xyXG5cclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLl91dkJ1ZmZlcik7XHJcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgIG1lc2gudXZzLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgaWYobWVzaC5jb2xvcnMpe1xyXG4gICAgICAgIG1lc2guX2NvbG9yQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG1lc2guX2NvbG9yQnVmZmVyKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC5jb2xvcnMsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIH1cclxuXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBtZXNoLl9pbmRleEJ1ZmZlcik7XHJcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBtZXNoLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRW1wdGllcyB0aGUgY3VycmVudCBiYXRjaC5cclxuICpcclxuICovXHJcbk1lc2hSZW5kZXJlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKVxyXG57XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN0YXJ0cyBhIG5ldyBtZXNoIHJlbmRlcmVyLlxyXG4gKlxyXG4gKi9cclxuTWVzaFJlbmRlcmVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIFxyXG5cclxuICAgIHRoaXMuY3VycmVudFNoYWRlciA9IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVzdHJveXMgdGhlIE1lc2ggcmVuZGVyZXJcclxuICpcclxuICovXHJcbk1lc2hSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIGNvcmUuT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxufTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuU2hhZGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLm1lc2hcclxuICogQHBhcmFtIHNoYWRlck1hbmFnZXIge1BJWEkuU2hhZGVyTWFuYWdlcn0gVGhlIFdlYkdMIHNoYWRlciBtYW5hZ2VyIHRoaXMgc2hhZGVyIHdvcmtzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIE1lc2hTaGFkZXIoc2hhZGVyTWFuYWdlcilcclxue1xyXG4gICAgY29yZS5TaGFkZXIuY2FsbCh0aGlzLFxyXG4gICAgICAgIHNoYWRlck1hbmFnZXIsXHJcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXHJcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcclxuXHJcbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OycsXHJcblxyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcclxuICAgICAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7JyxcclxuICAgICAgICAgICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXHJcbiAgICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcclxuXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYTsnLFxyXG5cclxuICAgICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXHJcblxyXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpeycsXHJcbiAgICAgICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogYWxwaGEgOycsXHJcbiAgICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbHBoYTogIHsgdHlwZTogJzFmJywgdmFsdWU6IDAgfSxcclxuICAgICAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IHsgdHlwZTogJ21hdDMnLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg5KSB9LFxyXG4gICAgICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoOSkgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gY3VzdG9tIGF0dHJpYnV0ZXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFWZXJ0ZXhQb3NpdGlvbjowLFxyXG4gICAgICAgICAgICBhVGV4dHVyZUNvb3JkOjBcclxuICAgICAgICB9XHJcbiAgICApO1xyXG59XHJcblxyXG5NZXNoU2hhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5TaGFkZXIucHJvdG90eXBlKTtcclxuTWVzaFNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoU2hhZGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1lc2hTaGFkZXI7XHJcblxyXG5jb3JlLlNoYWRlck1hbmFnZXIucmVnaXN0ZXJQbHVnaW4oJ21lc2hTaGFkZXInLCBNZXNoU2hhZGVyKTtcclxuIiwiLy8gUmVmZXJlbmNlczpcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXHJcblxyXG5pZiAoIU1hdGguc2lnbilcclxue1xyXG4gICAgTWF0aC5zaWduID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB4ID0gK3g7XHJcbiAgICAgICAgaWYgKHggPT09IDAgfHwgaXNOYU4oeCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHggPiAwID8gMSA6IC0xO1xyXG4gICAgfTtcclxufVxyXG4iLCIvLyBSZWZlcmVuY2VzOlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL29iamVjdC1hc3NpZ25cclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxyXG5cclxuaWYgKCFPYmplY3QuYXNzaWduKVxyXG57XHJcbiAgICBPYmplY3QuYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG59XHJcbiIsInJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xyXG5yZXF1aXJlKCcuL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xyXG5yZXF1aXJlKCcuL01hdGguc2lnbicpO1xyXG4iLCIvLyBSZWZlcmVuY2VzOlxyXG4vLyBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xNTc5NjcxXHJcbi8vIGh0dHA6Ly91cGRhdGVzLmh0bWw1cm9ja3MuY29tLzIwMTIvMDUvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLUFQSS1ub3ctd2l0aC1zdWItbWlsbGlzZWNvbmQtcHJlY2lzaW9uXHJcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3RpbWhhbGwvNDA3ODYxNFxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLXNlcnZpY2UvdHJlZS9tYXN0ZXIvcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZVxyXG5cclxuLy8gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIEJyb3dzZXJmaXlcclxuLy8gQnJvd3NlcmlmeSBhdXRvbWF0aWNhbGx5IGRldGVjdHMgdGhlIHVzZSBvZiBgZ2xvYmFsYCBhbmQgcGFzc2VzIHRoZVxyXG4vLyBjb3JyZWN0IHJlZmVyZW5jZSBvZiBgZ2xvYmFsYCwgYHNlbGZgLCBhbmQgZmluYWxseSBgd2luZG93YFxyXG5cclxuLy8gRGF0ZS5ub3dcclxuaWYgKCEoRGF0ZS5ub3cgJiYgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZSkpIHtcclxuICAgIERhdGUubm93ID0gZnVuY3Rpb24gbm93KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIHBlcmZvcm1hbmNlLm5vd1xyXG5pZiAoIShnbG9iYWwucGVyZm9ybWFuY2UgJiYgZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdykpIHtcclxuICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgaWYgKCFnbG9iYWwucGVyZm9ybWFuY2UpIHtcclxuICAgICAgICBnbG9iYWwucGVyZm9ybWFuY2UgPSB7fTtcclxuICAgIH1cclxuICAgIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBzdGFydFRpbWU7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxudmFyIGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcclxudmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xyXG5cclxuZm9yKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcclxuICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBnbG9iYWxbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcclxuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGdsb2JhbFt2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHxcclxuICAgICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcclxufVxyXG5cclxuaWYgKCFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJ2lzIG5vdCBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICBkZWxheSA9IDE2ICsgbGFzdFRpbWUgLSBjdXJyZW50VGltZTtcclxuXHJcbiAgICAgICAgaWYgKGRlbGF5IDwgMCkge1xyXG4gICAgICAgICAgICBkZWxheSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xyXG5cclxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgY2FsbGJhY2socGVyZm9ybWFuY2Uubm93KCkpO1xyXG4gICAgICAgIH0sIGRlbGF5KTtcclxuICAgIH07XHJcbn1cclxuXHJcbmlmICghZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XHJcbiAgICB9O1xyXG59XHJcbiJdfQ==

//# sourceMappingURL=pixi.js.map
